<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2023-04-02T18:31:00.498Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>14，小米 13 的兩大關鍵亮點，與那些「價值觀層級」的器物們</title>
    <link href="https://blog.kyomind.tw/weekly-review-14/"/>
    <id>https://blog.kyomind.tw/weekly-review-14/</id>
    <published>2023-04-02T12:12:51.000Z</published>
    <updated>2023-04-02T18:31:00.498Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>從 3&#x2F;20 收到貨，隔天開始正式使用<a href="https://www.mi.com/tw/product/xiaomi-13">小米 13 手機</a>，至今也十餘天了，我對它的感想如何？答案是：</p><blockquote><p>多年的追尋與等待，都值得了！</p></blockquote><p>這篇只提 2 個，我選它「<strong>最最最重要</strong>」的理由——你可能也會有興趣。</p><p>小米 13 整體而言，就像大多數 3C 評測 YouTuber（主要是中國）說的：沒有太大的缺點。對此我完全認同，所以我決定留下它。</p><p>標題的另一部分是「『價值觀層級』的器物們」，基於單一幅篇上限考慮，請容我下下篇再行討論，但有必要在本篇先提出！</p><p>好，我們開始吧。</p><span id="more"></span><hr><h2 id="紅米-Note-4X"><a href="#紅米-Note-4X" class="headerlink" title="紅米 Note 4X"></a>紅米 Note 4X</h2><p>在講小米 13 之前，不得不先提一下陪伴了我近 6 年的「<a href="https://www.mi.com/tw/redminote4x/">紅米 Note 4X</a>」。</p><p>我對手機無論從軟體、硬體及產品設計的角度，都有著明確的要求。以致於從 2017 年 6 月買了「紅米 Note 4X」後，足足過了近 6 年，才尋得這下一步的歸宿。</p><p>在我看來，紅米 Note 4X 絕對是一代經典，後續的 56789 代相較之下都差強人意。但它終究是一隻中階手機，在使用約 2 年後，面對日益肥大的現代 app，已經明顯捉襟見肘。</p><p>直到現在 2023 年，我用它開一次 LINE，往往要等上十幾二十秒，這無疑是在自虐。</p><p>講述這一段主要為了表達：為了貫徹我對手機的眾多「價值觀」要求，我寧可忍受如此的不便，也不會輕易換掉它，直到另一隻符合價值觀的手機出現為止。</p><hr><h2 id="小米-13-的兩大亮點"><a href="#小米-13-的兩大亮點" class="headerlink" title="小米 13 的兩大亮點"></a>小米 13 的兩大亮點</h2><p>首先，我得承認我是一個米粉，但別誤會，我可不是非小米 &#x2F; 紅米手機不買。</p><p>畢竟「符合我要求的手機才能是我的手機」這樣的價值觀，其層級與順序，絕對優先於一個米粉的價值觀。</p><p>而且嚴格來說，米粉也只能算是一種「<strong>偏好</strong>」而已。</p><p>最近這幾年，手上的紅米手機愈來愈慢，我也一直在做功課，想要換掉它。從三星到蘋果，甚至還買了一隻 iPhone SE 2 打算作為主力機——可惜失敗了。</p><p>這麼說來，小米 13 究竟有什麼樣的「<strong>魔力</strong>」，讓我決定留下它？我覺得主要有二。</p><h2 id="一、Grip（握感良好）"><a href="#一、Grip（握感良好）" class="headerlink" title="一、Grip（握感良好）"></a>一、Grip（握感良好）</h2><p>我可以非常篤定地告訴你，grip 就是我挑選手機時所考量的「第二」重要因素，其重要性不言而喻。</p><p>什麼是 grip（握感）？講白了就是「握起來舒不舒服、是否適合久握」。</p><p>不要小看這樣一個簡單的訴求，大部分的手機<strong>卻都不及格</strong>。</p><p>最差的設計，就是「很尖的圓弧」造型，對手指壓力甚大。很遺憾，小米後來的大多數手機都是這樣的造型，比如下圖的小米 11：</p><p><img src="https://i.imgur.com/qhU0DRb.jpg" alt="圖片來源：小米官網"><span class="cap">圖片來源：小米官網</span></p><p>至於為什麼要這樣設計？不難理解——從側面看起來手機會「更窄更薄」。</p><p>Apple 和三星則習慣使用比較「鈍」的大圓弧，我覺得手感相對好一些。</p><p>所幸，從 iPhone 12 開始，蘋果讓「直角邊框」設計重新回歸。直角邊的接觸面積較大，對手指的負擔更低，是我個人偏好的做法，而紅米 Note 4X 正是如此！</p><p>而非常善於「致敬」的中國手機廠商們，也開始在這一、兩年的部分新手機採用直角邊框，有的還在背部加了一點 2.5D 圓弧作為過渡，手感上更勝於純直角的 iPhone，小米 13 正是其中之一。</p><h2 id="二、全亮度「類-DC-調光」的護眼-OLED-螢幕"><a href="#二、全亮度「類-DC-調光」的護眼-OLED-螢幕" class="headerlink" title="二、全亮度「類 DC 調光」的護眼 OLED 螢幕"></a>二、全亮度「類 DC 調光」的護眼 OLED 螢幕</h2><p>若 grip 是我挑選手機第二重視的要素，那第一則無疑是「<strong>護眼</strong>」。</p><p>OLED 螢幕使用 PWM 調光造成的「<strong>閃爍</strong>」問題，對於少數眼睛敏感族群——比如我，是一個無法跨越的難關。</p><p>可以看看下面這影片，了解「PWM 調光」的可怕之處：</p><ul><li><a href="https://youtu.be/_eAe_5W9Y6U">【Techris】 iPhone 13 Pro 使用兩週後的心得：我眼睛快瞎了</a></li></ul><p>很遺憾的，現在手機為了<strong>機身更輕薄</strong>（OLED 螢幕相較於 LCD 可以做得更薄）與<strong>顯色更漂亮</strong>，有 9 成以上採用 OLED 面板。</p><p>尤其是<strong>旗鑑機</strong>，基本上「<strong>全部</strong>」都是 OLED。</p><p>如果你從未感受到螢幕閃爍相關的困擾，那麼你是幸運的，無需過多擔心。</p><p>但如果有過上述眼睛不適問題，那麼你可以考慮選擇一款 LCD 面板的手機；或者像我一樣，選擇一款對「PWM 閃爍」問題有所改善的 OLED 螢幕手機。</p><p>基本上，後者幾乎都是來自中國廠商的產品。換句話說，目前只有中國手機製造商願意在「<strong>緩解 PWM 調光閃爍</strong>」這個議題上投入精力與用心。</p><h2 id="防閃爍模式"><a href="#防閃爍模式" class="headerlink" title="防閃爍模式"></a>防閃爍模式</h2><p>想要實現小米 13 最大護眼能力，要先打開它的「<strong>防閃爍模式</strong>」才行，也就是「類 DC 調光」，其代價是<strong>低亮度</strong>時會產生<strong>色彩偏差</strong>。</p><p>從結論上看，小米 13 可做到全亮度的「<strong>SVM</strong>」值（不是機器學習那個支援向量機🤣）都在 <strong>0.06</strong> 左右。</p><p>SVM 值愈低愈好，若低於 0.4 則可視為安全範圍。而小米 13 的全亮度 0.06 無疑是非常出色。</p><p>關於 PWM 調光與 SVM 更多的講解與介紹，可以參考這個影片（影片末段有附上對抗 PWM 調光閃爍的改善對策）：</p><ul><li><a href="https://youtu.be/kfT6GmwTO_k">不止 iPhone 13 的頻閃, 你們之前看到的 OLED 頻閃分析可能都是錯的</a></li></ul><p>我用了十幾天，效果確實很棒！即使在低亮度下，眼睛也沒有感到絲毫的不適。</p><hr><h2 id="何謂「價值觀層級」的器物？"><a href="#何謂「價值觀層級」的器物？" class="headerlink" title="何謂「價值觀層級」的器物？"></a>何謂「價值觀層級」的器物？</h2><p>下下篇會討論「偏好與價值觀」，並闡述那些被賦了價值觀的器物，就<strong>不再只是一般的器物了</strong>。</p><p>對我而言，這些「價值觀層級的器物」又有哪些呢？敬請期待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;從 3&amp;#x2F;20 收到貨，隔天開始正式使用&lt;a href=&quot;https://www.mi.com/tw/product/xiaomi-13&quot;&gt;小米 13 手機&lt;/a&gt;，至今也十餘天了，我對它的感想如何？答案是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多年的追尋與等待，都值得了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這篇只提 2 個，我選它「&lt;strong&gt;最最最重要&lt;/strong&gt;」的理由——你可能也會有興趣。&lt;/p&gt;
&lt;p&gt;小米 13 整體而言，就像大多數 3C 評測 YouTuber（主要是中國）說的：沒有太大的缺點。對此我完全認同，所以我決定留下它。&lt;/p&gt;
&lt;p&gt;標題的另一部分是「『價值觀層級』的器物們」，基於單一幅篇上限考慮，請容我下下篇再行討論，但有必要在本篇先提出！&lt;/p&gt;
&lt;p&gt;好，我們開始吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="產品評論" scheme="https://blog.kyomind.tw/tags/%E7%94%A2%E5%93%81%E8%A9%95%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>13，我買了 Apple Studio Display 與系列心得寫作計畫</title>
    <link href="https://blog.kyomind.tw/weekly-review-13/"/>
    <id>https://blog.kyomind.tw/weekly-review-13/</id>
    <published>2023-03-11T09:33:31.000Z</published>
    <updated>2023-04-02T13:31:20.985Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>上星期買了 <a href="https://www.apple.com/tw/studio-display/">Studio Display</a>，使用上已滿一週。儘管它確實是個好螢幕，但期間仍少不了一定的探索和適應過程。</p><p>結論上，我會留下它。</p><p>之前在<a href="https://www.facebook.com/kyomind/posts/pfbid02R8CpNTfyHcfaLsRpF3TcBMbiKuumrHyDxYgdGKfPqFCm576Skq7J2i63iD4MgJuJl">臉書發文</a>已提過「若最終沒有退貨，再來寫一篇『<strong>必須選它的理由</strong>』」，我想這是很有必要的。</p><p>畢竟，這麼貴的東西，確實值得好好寫一篇選購指南。更別說我為了買 Mac 的外接螢幕，也著實做了不少功課。</p><p>我打算把整個選購螢幕歷程所做的功課、曾經考慮的選項、Studio Display 購買上要特別注意的點，還有入手後我對於大螢幕的不適應所做出的調整與改善。</p><p>尤其是那些「<strong>曾經太過年輕</strong>」的天真想法——買入後發現根本不切實際，當初純粹是多想了……等以上種種，寫成一個「三部曲」系列。</p><p>而本篇，則是這個系列的<strong>導讀</strong>與<strong>輪廓介紹</strong>。</p><span id="more"></span><hr><h2 id="一、所做的功課與曾經考慮過的選項"><a href="#一、所做的功課與曾經考慮過的選項" class="headerlink" title="一、所做的功課與曾經考慮過的選項"></a>一、所做的功課與曾經考慮過的選項</h2><p>為 Mac（Macbook &#x2F; Mac mini）買一台外接顯示器所需要下的功夫，除了選購螢幕本來就必備具體的基本知識之外，macOS 作業系統也有一些不同於 Windows 的「獨特之處」。</p><p>換言之，想要做出好的決定，「螢幕選購」與「Mac 螢幕選購」這兩種先備知識都是不可缺少的。</p><p>所幸 YouTube 上已有好些影片整理了這類內容，有特別出色的，我會在文中介紹並強調我認為的重點（有些影片真的好長……）。</p><p>此外，我會順便介紹曾經心儀的兩款非 Studio Display 螢幕——雖然後來還是捨棄了，講述當時考慮它們的理由與做過的功課，作為不想花大錢買螢幕的替代方案。</p><h2 id="二、Studio-Display-使用心得與採購指南"><a href="#二、Studio-Display-使用心得與採購指南" class="headerlink" title="二、Studio Display 使用心得與採購指南"></a>二、Studio Display 使用心得與採購指南</h2><p>Studio Display 的介紹與評測影片已經非常多，所以它的整體素質、表現如何，並不需要我再重複著墨。</p><p>再說，文字也不比影片更適合表達螢幕的聲音、色彩在呈現上的種種迷人之處。</p><p>所以本篇的著眼點，在於我選購 Studio Display 前，所<strong>慎重考慮過</strong>的部分，與實際購入後遇到的「困難」。</p><p>但還是會提一些它的優點——那些我很喜歡的地方。</p><p>只不過，那些你<strong>不喜歡</strong>或<strong>可能無法接受</strong>的環節，才是做決定時最重要的考量點——<strong>那些「不」才是關鍵</strong>。</p><p>本文會著重在 Studio Display 的哪些特點可能會讓你<strong>想對它說「不」</strong>，或者你可能沒考慮到的<strong>潛在問題</strong>，省得買回來後，還要大費周章退貨——它好重！</p><p>所以，這絕不是「另一篇」開箱評測，而是給潛在購買者的「<strong>買前必讀</strong>」。</p><h2 id="三、我如何使用-Rectangle-app-讓-Studio-Display-變得好用"><a href="#三、我如何使用-Rectangle-app-讓-Studio-Display-變得好用" class="headerlink" title="三、我如何使用 Rectangle app 讓 Studio Display 變得好用"></a>三、我如何使用 Rectangle app 讓 Studio Display 變得好用</h2><p><a href="https://rectangleapp.com/">Rectangle</a> 是 macOS 上的視窗管理工具，可以讓你分割視窗、快速將視窗拖曳至不同區域並對齊，使得<strong>多工作業</strong>更加方便。</p><p>但說真的，我用它的方式並不如你想的那樣——上下分割、左右分割之類的，其實我不太用。</p><p>本文會討論「<strong>為什麼 Rectangle 對我是必要的</strong>」，以及我在 Studio Display 上使用它的主要方式，還有一個比較 Geek 的自定義。</p><p>必須說，我完全不是為了什麼多工，純粹是因為 <strong>27 吋螢幕對我而言太大了</strong>。我必須透過 Rectangle 把視窗縮小，才能好好使用 Studio Display——或其它 27 吋螢幕。</p><p>你可能覺得：「那就縮小視窗就好了啊？有什麼特別之處？」</p><p>對我而言，這其中的「<strong>眉眉角角</strong>」，非 app 不能勝任。</p><p>所以，Rectangle 不止必要，而且是我螢幕選購之路的<strong>最後一塊拼圖</strong>，值得為它留一點篇幅。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上星期買了 &lt;a href=&quot;https://www.apple.com/tw/studio-display/&quot;&gt;Studio Display&lt;/a&gt;，使用上已滿一週。儘管它確實是個好螢幕，但期間仍少不了一定的探索和適應過程。&lt;/p&gt;
&lt;p&gt;結論上，我會留下它。&lt;/p&gt;
&lt;p&gt;之前在&lt;a href=&quot;https://www.facebook.com/kyomind/posts/pfbid02R8CpNTfyHcfaLsRpF3TcBMbiKuumrHyDxYgdGKfPqFCm576Skq7J2i63iD4MgJuJl&quot;&gt;臉書發文&lt;/a&gt;已提過「若最終沒有退貨，再來寫一篇『&lt;strong&gt;必須選它的理由&lt;/strong&gt;』」，我想這是很有必要的。&lt;/p&gt;
&lt;p&gt;畢竟，這麼貴的東西，確實值得好好寫一篇選購指南。更別說我為了買 Mac 的外接螢幕，也著實做了不少功課。&lt;/p&gt;
&lt;p&gt;我打算把整個選購螢幕歷程所做的功課、曾經考慮的選項、Studio Display 購買上要特別注意的點，還有入手後我對於大螢幕的不適應所做出的調整與改善。&lt;/p&gt;
&lt;p&gt;尤其是那些「&lt;strong&gt;曾經太過年輕&lt;/strong&gt;」的天真想法——買入後發現根本不切實際，當初純粹是多想了……等以上種種，寫成一個「三部曲」系列。&lt;/p&gt;
&lt;p&gt;而本篇，則是這個系列的&lt;strong&gt;導讀&lt;/strong&gt;與&lt;strong&gt;輪廓介紹&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="Studio Display" scheme="https://blog.kyomind.tw/tags/Studio-Display/"/>
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="產品評論" scheme="https://blog.kyomind.tw/tags/%E7%94%A2%E5%93%81%E8%A9%95%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>從 Logseq 看清單式筆記的兩大缺點</title>
    <link href="https://blog.kyomind.tw/rusty-bullets/"/>
    <id>https://blog.kyomind.tw/rusty-bullets/</id>
    <published>2023-03-03T18:25:04.000Z</published>
    <updated>2023-03-29T19:40:45.515Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/poxMxfO.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>〈<a href="https://blog.kyomind.tw/silver-bullets/">從 WorkFlowy 到 Logseq——我偏愛「清單式筆記」的四大理由</a>〉中，我們講完了清單式筆記的四項優勢。</p><p>然而，有光就有影，這篇就來說說，<strong>不適合「清單」的場景，</strong>也就是<strong>清單的弱勢</strong>。</p><p>使用 Logseq 至今，我覺得<strong>明顯不適合</strong>清單的場景<strong>主要有二</strong>：</p><ol><li><strong>逐字稿。</strong></li><li><strong>長文本（長篇內容）。</strong></li></ol><p>因為 Logseq 屬於清單式筆記軟體，所以你也可以認為上述兩者算是 <strong>Logseq 的缺點</strong>，只不過它們本來就「<strong>應該要是</strong>」——這部分容後述。</p><p>總之，以上兩種情境，在使用清單式筆記時，最好能有效避開。</p><span id="more"></span><hr><h2 id="一、清單式筆記不適合寫逐字稿"><a href="#一、清單式筆記不適合寫逐字稿" class="headerlink" title="一、清單式筆記不適合寫逐字稿"></a>一、清單式筆記不適合寫逐字稿</h2><p>清單式筆記不適合寫<strong>逐字稿</strong>，比如我的文章創作時的<strong>草稿</strong>，這點可想而知。</p><p>畢竟它在文體上的特性——即清單本身——就和「<strong>以標題、大段落為主軸</strong>」的逐字稿不怎麼相容。而「<a href="https://blog.kyomind.tw/logseq/#%E7%82%BA%E4%BD%95%E9%81%B8%E6%93%87-Logseq%EF%BC%9F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%BC%8F-vs-%E6%B8%85%E5%96%AE%E5%BC%8F">文件式筆記</a>」，比如 <a href="https://www.notion.so/">Notion</a> 或 <a href="https://obsidian.md/">Obsidian</a>，則適合得多。</p><p>尤其，清單式筆記更強調概念、想法上的「<strong>層次與結構</strong>」，而<strong>相對輕忽「具體的文字該如何表述」</strong>。如果拿來寫逐字稿，難免會讓你覺得<strong>少了一味——甚至好幾味</strong>。</p><h3 id="概念條列-VS-逐字稿"><a href="#概念條列-VS-逐字稿" class="headerlink" title="概念條列 VS 逐字稿"></a>概念條列 VS 逐字稿</h3><p>申言之，清單這種「<strong>有意精簡</strong>」的格式，如果拿來寫一段一段的內容，雖然不是不行，但可能在段落之間會給人一種「<strong>不連貫</strong>」的感覺，多少影響創作的效率。</p><p>而且從「<strong>清單的精神</strong>」看來，每一行清單筆記，就是希望你寫得少——<strong>把想法、概念收束起來</strong>——而非寫得鉅細靡遺。</p><p>所以，雖然我大量使用 Logseq，但具體文字內容的創作，還是透過 Notion。</p><h3 id="清單：構思的利器"><a href="#清單：構思的利器" class="headerlink" title="清單：構思的利器"></a>清單：構思的利器</h3><p>不過話說回來，清單式筆記拿來「<strong>構思文章架構、收集寫作材料</strong>」則<strong>非常適合</strong>！</p><p>比如下圖就是本文的 Logseq 創作筆記，雖然看起來這篇記事的內容十分精簡，好像也沒什麼。但我有些長文的材料項目就非常多，而且不斷在補充。</p><p>此時清單在構思時的重要性就會彰顯出來。</p><p><img src="https://i.imgur.com/coufhQN.png"></p><p>總的來說，把寫作的「<strong>準備</strong>」和「<strong>下筆</strong>」兩個階段區分開來，並使用不同的工具，是我目前偏好的方式。</p><h2 id="二、清單式筆記不適合長篇內容"><a href="#二、清單式筆記不適合長篇內容" class="headerlink" title="二、清單式筆記不適合長篇內容"></a>二、清單式筆記不適合長篇內容</h2><p>這點我在使用 <a href="https://workflowy.com/">Workflowy</a> 時期就有隱約感覺到，但始終沒弄明白。</p><p>那時就發現，好像有些內容無論我怎麼整理，就是很難「<strong>內化</strong>」——顯然 Workflowy 並不適合某些場景，但我無法具體說出來。</p><p>我只知道某些筆記的效果很有限，我學得不好。</p><h3 id="Notion-很擅長記錄長篇內容"><a href="#Notion-很擅長記錄長篇內容" class="headerlink" title="Notion 很擅長記錄長篇內容"></a>Notion 很擅長記錄長篇內容</h3><p>後來用了 Notion，有些網路教材的筆記我可以寫上一、兩萬字（當然有不少是複製貼上），十分誇張，且 Notion 豐富的 Markdown 元素，也讓整個文本<strong>即使冗長也不覺得難讀</strong>。</p><p>但<strong>有一好沒兩好</strong>，冗長的筆記或許滿足了「<strong>整理的成就感</strong>」，但誰沒事會想要複習一、兩萬字的內容？——我還真的複習過幾回！</p><p>然而，常常<strong>看到後面忘了前面</strong>，筆記的可讀性不差，但學習的效果仍是普普。</p><h3 id="清單受不了長文本"><a href="#清單受不了長文本" class="headerlink" title="清單受不了長文本"></a>清單受不了長文本</h3><p>後來，為了加強<strong>複習的頻率</strong>，程式類的筆記我全部改用 Logseq 做，且立刻發現一個事實：只要內容一多，我就<strong>完全不想</strong>看這篇筆記了——因為清單受不了長文本。</p><p>如果 Notion 容許一、兩萬字的筆記，那 Logseq 這樣的清單式內容，直觀的上限可能只在兩、三千左右。</p><p>因為長篇內容需要更多段落、標題等元素。而這些元素若透過清單來呈現，反而會讓它顯得<strong>眼花撩亂</strong>，使人放棄思考。</p><p>所以，太長的筆記，我要麼刪到一定字數內，不然就是分拆它們到不同的「<strong>卡片</strong>」，不可能讓一堆內容塞在同一頁。否則就完全違背了<strong>清單的本意</strong>：整理思路、明確想法。</p><p><strong>而更嚴重的後果則是：我根本不想看</strong>。</p><hr><h2 id="清單的使用說明書"><a href="#清單的使用說明書" class="headerlink" title="清單的使用說明書"></a>清單的使用說明書</h2><p>關於清單的<strong>優勢</strong>，我足足寫了四項。而清單的<strong>劣勢</strong>或說<strong>缺點</strong>，卻只提兩項，是否我<strong>偏愛</strong>了清單式筆記？當然！畢竟<a href="https://blog.kyomind.tw/logseq/#%E6%B8%85%E5%96%AE%E7%9A%84%E5%84%AA%E5%8B%A2%E8%88%87%E5%8A%A3%E5%8B%A2">我本來就是這麼說的</a>🤣：</p><blockquote><p>我認為在 80% 的場景中，清單式都優於文件式。</p></blockquote><p>從本文上述的所有內容可以推知，若想用好清單式筆記，我們應該遵守下面兩點：</p><ol><li>清單的<strong>每一行</strong>，內容不要太多、<strong>句子不要太長</strong>——所以它不適合寫逐字稿。因為如果要遵守這原則，一個段落的內容恐怕要拆成很多小點。</li><li>清單的<strong>整體篇幅</strong>也不要太長。這裡的「長」是相對於「文件式筆記」可以接受的上限而言。而清單的上限則要<strong>短得多</strong>。</li></ol><h2 id="清單與卡片筆記的共通點"><a href="#清單與卡片筆記的共通點" class="headerlink" title="清單與卡片筆記的共通點"></a>清單與卡片筆記的共通點</h2><p>仔細觀察這兩點，你是否發現，它們和我在〈<a href="https://blog.kyomind.tw/logseq/">Logseq 使用滿一個月心得：一顆冉冉升起的「卡片筆記」新星</a>〉提到有關<strong>卡片筆記兩大原則</strong>之一的「<a href="https://blog.kyomind.tw/logseq/#%E5%85%83%E7%B4%A0%E5%8C%96%E8%88%87%E9%80%A3%E7%B5%90%E5%B0%8E%E5%90%91">元素化</a>」，似乎有著<strong>異曲同工的核心精神</strong>：</p><blockquote><p>每一則筆記的範圍都不要太大、內容不要太多，且盡可能<strong>都有一個——也「只有」一個——核心論述。</strong></p></blockquote><p>所以我一開始時才會說：「它們（指逐字搞和長文本）本來就『<strong>應該要是</strong>』」Logseq 或其它清單式筆記的缺點——否則<strong>很可能意味著</strong>，你在使用這類筆記工具的時候，<strong>已經「違反」了卡片筆記的原則</strong>。</p><h2 id="Why-Logseq？"><a href="#Why-Logseq？" class="headerlink" title="Why Logseq？"></a>Why Logseq？</h2><p>如此說來，這或許也是<strong>我最終「為何」選擇了清單式的 Logseq</strong>，而非文件式 Obsidian 的一大理由——<strong>因為「清單」本身就蘊含了濃濃的</strong>「<a href="https://blog.kyomind.tw/logseq/#%E5%85%83%E7%B4%A0%E5%8C%96%E8%88%87%E9%80%A3%E7%B5%90%E5%B0%8E%E5%90%91">卡片筆記思維</a>」：</p><blockquote><p><strong>讓你想不貫徹也難☺️</strong></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/poxMxfO.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;https://blog.kyomind.tw/silver-bullets/&quot;&gt;從 WorkFlowy 到 Logseq——我偏愛「清單式筆記」的四大理由&lt;/a&gt;〉中，我們講完了清單式筆記的四項優勢。&lt;/p&gt;
&lt;p&gt;然而，有光就有影，這篇就來說說，&lt;strong&gt;不適合「清單」的場景，&lt;/strong&gt;也就是&lt;strong&gt;清單的弱勢&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用 Logseq 至今，我覺得&lt;strong&gt;明顯不適合&lt;/strong&gt;清單的場景&lt;strong&gt;主要有二&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;逐字稿。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;長文本（長篇內容）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因為 Logseq 屬於清單式筆記軟體，所以你也可以認為上述兩者算是 &lt;strong&gt;Logseq 的缺點&lt;/strong&gt;，只不過它們本來就「&lt;strong&gt;應該要是&lt;/strong&gt;」——這部分容後述。&lt;/p&gt;
&lt;p&gt;總之，以上兩種情境，在使用清單式筆記時，最好能有效避開。&lt;/p&gt;</summary>
    
    
    
    <category term="隨筆雜談" scheme="https://blog.kyomind.tw/categories/%E9%9A%A8%E7%AD%86%E9%9B%9C%E8%AB%87/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="WorkFlowy" scheme="https://blog.kyomind.tw/tags/WorkFlowy/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="清單式筆記" scheme="https://blog.kyomind.tw/tags/%E6%B8%85%E5%96%AE%E5%BC%8F%E7%AD%86%E8%A8%98/"/>
    
    <category term="卡片盒筆記法" scheme="https://blog.kyomind.tw/tags/%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%B3%95/"/>
    
    <category term="Obsidian" scheme="https://blog.kyomind.tw/tags/Obsidian/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
  </entry>
  
  <entry>
    <title>12，blog 新增文章訂閱功能——使用 follow.it——與我的思考</title>
    <link href="https://blog.kyomind.tw/weekly-review-12/"/>
    <id>https://blog.kyomind.tw/weekly-review-12/</id>
    <published>2023-02-25T11:25:27.000Z</published>
    <updated>2023-03-05T18:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>在臉書、YouTube 這類「流量大平台」興起之後，很多創作者雖然因此獲得不少流量甚至一夕爆紅，但對<strong>平台演算法</strong>的心情，仍然是愛恨交加。</p><p>在文字創作領域，為了對抗平台與演算法，古老的<strong>電子報</strong>也迎來了一波「<strong>文藝復興</strong>」，造就了一堆電子報服務提供者，比如 <a href="https://mailchimp.com/">Mailchimp</a>、<a href="https://convertkit.com/">Convertkit</a>。</p><p>它們讓作者可以直接把內容透過 email 發送給讀者，強化了兩者間的直接連繫。</p><p>因此，你可以看到愈來愈多的部落格，都有提供電子報訂閱功能。可能是推送最新文章給你，也可能是更多額外的內容。</p><p>更別說像 <a href="https://substack.com/">Substack</a> 這樣「<strong>部落格、電子報——我全都要</strong>」的數位出版服務。</p><p>說這些主要想表達：「<strong>訂閱功能</strong>」確實是現代部落格的一大需求。</p><span id="more"></span><hr><h2 id="我也為部落格新增了文章訂閱功能——使用-follow-it"><a href="#我也為部落格新增了文章訂閱功能——使用-follow-it" class="headerlink" title="我也為部落格新增了文章訂閱功能——使用 follow.it"></a>我也為部落格新增了文章訂閱功能——使用 follow.it</h2><p>如果你有用過電子報服務，那想必很清楚，它們都有一個共同特色：收費不便宜。</p><p>雖然在一定的訂戶額度、發信量內是不用錢的，但一旦流量提升，隨之而來的費用也相當可觀。</p><p>不同於一些很重視電子報訂閱的 blog，對我來說，我的 email 訂閱主要是方便想收到新文章通知，但又不想用（或沒在用）RSS reader 的讀者。</p><p>所以一般的電子報供應商，對我而言就有點太「重」了——我想要更加簡潔的方案，但心裡一直沒有底。</p><p>直到某天，我在哆啦王的臉書看到<a href="https://www.facebook.com/FfaarrFinance/posts/pfbid0m7TpUSiE3Y2cfFfUpAph4Mq9Gw9pFUfyTbGC3EutxVbhhbdJmhDekRo9jBPD1jS1l">這篇</a>：</p><blockquote><p>雖然我在部落格發文之後，都會也在facebook這邊分享，但之前有讀者覺得因為fb常常觸及不到，所以建議來做一個文章訂閱，因此目前在我部落格的右上角，增設了使用follow.it這個網站的訂閱按鈕，輸入e-mail後按下送出之後，信箱會收到一封follow.it的確認信件，點擊確認之後即完成訂閱文章。</p></blockquote><p>感謝哆啦王！讓我此從知道了 <a href="https://follow.it/">follow.it</a> 這個服務——這不就是我一直在找的嗎！</p><h2 id="follow-it-的優勢與缺點"><a href="#follow-it-的優勢與缺點" class="headerlink" title="follow.it 的優勢與缺點"></a>follow.it 的優勢與缺點</h2><p>follow.it 的主要功能，是幫你把網站的 RSS feed 內容轉成電子報發送。要說它屬於前述 Mailchimp 那種電子報服務，是，但也不完全是。</p><p>它的角色核心比較側重於「<strong>透過 RSS feed 轉 email，輔助並完善網站的內容訂閱</strong>」，而上述的電子報供應商，不一定要你有部落格或 RSS。</p><p>相反的，使用 <a href="http://follow.it/">follow.it</a>，你必須提供 RSS feed 才行。（不然沒有東西可以轉）</p><p><a href="http://follow.it/">follow.it</a> 可以免費使用，而且相比於傳統電子報服務，它的免費方案和 Substack 相同——<strong>沒有訂閱人數限制！</strong>這無疑是免費仔的福音。</p><p>但先別高興得太早，它自然有<strong>別的限制</strong>來促使你付費。比如對電子報而言，舉足輕重的「<strong>email 標題</strong>」和「<strong>寄件者</strong>」欄位，在免費方案裡，都是<strong>無法自訂</strong>的！</p><p>不得不承認這確實有點「<strong>痛</strong>」，難怪可以不限人數，卻不怕你不付費。😂</p><p><img src="https://i.imgur.com/Icrn8xh.png" alt="天下果然沒有白吃的午餐"><span class="cap">天下果然沒有白吃的午餐</span></p><p>透過付費可以得到更多額外的 email 客製化功能，這樣就會愈來愈像真正的電子報了。但老實說，如果要付費，我會選擇<strong>專業的電子報服務</strong>，比如 <a href="https://buttondown.email/">Buttondown</a>。😎</p><hr><h2 id="我對電子報的思考"><a href="#我對電子報的思考" class="headerlink" title="我對電子報的思考"></a>我對電子報的思考</h2><p>就我所知，有些 blog 非常重視透過電子報和讀者互動。比如「<a href="https://pinchlime.com/">Pin 起來</a>」，不僅提供所有文章的電子報訂閱，甚至能讓你<a href="https://pinchlime.com/subscribe/">只訂閱部分內容</a>，可謂非常用心。</p><p>對現階段的我而言，文章訂閱型的電子報僅屬於「<strong>輔助</strong>」地位，基於軟體工程師的簡潔信仰，我一直有意避開上述那些電子報供應商方案。</p><p>本來還想要自己寫（程式），但問過有類似經驗的同事後，才知道土砲（DIY）最難的地方反而是「如何讓 gmail 不把你的電子報歸到垃圾信」——好吧！我放棄XD。</p><p>確定採用 <a href="http://follow.it/">follow.it</a> 後，還有兩個點也讓我掙扎了一番。</p><h2 id="一、是否附上全文？"><a href="#一、是否附上全文？" class="headerlink" title="一、是否附上全文？"></a>一、是否附上全文？</h2><p>我一開始是設定<strong>只顯示文章開頭部分</strong>，然後附上文章連結。心裡打的算盤當然是——「你要看全文就要來站上喔！」這樣瀏覽數會好看一點。</p><p>但仔細想想，這真的很蠢。</p><p>一來是有這類訂閱需求的人就已經很少了，如果還吝於把全文放在 email 裡，實在有些可笑。</p><p>再說，這些 email 內容都是透過 <a href="http://follow.it/">follow.it</a> 從我的 RSS feed 自動轉換過來的，既然 RSS 提供的就是全文，那希望讓讀者<strong>更加方便、好用</strong>的 email 管道，何必再自我閹割？</p><p>追根究柢，到底要在 email 裡讀完，還是到到網站上看，這個「選擇權」應該留給讀者才對。</p><p>所以，後來我就改成全文發送了。</p><h2 id="二、訂閱按鈕放哪好？"><a href="#二、訂閱按鈕放哪好？" class="headerlink" title="二、訂閱按鈕放哪好？"></a>二、訂閱按鈕放哪好？</h2><p>這是另一個有趣且<strong>不可小覷</strong>的議題。</p><p>最常見的方式是放在每一篇文章的<strong>結尾處</strong>，或像<a href="https://finance.ffaarr.com.tw/">哆啦王</a>那樣，放在<strong>側邊欄的 widget</strong>，讓每一篇文章都能看到。</p><p>這樣做無疑能最大化訂戶的數量，因為位置顯眼，讀者想不看到都難，有興趣的人自然就會訂了。</p><p>不過我還是捨棄了上述兩種方案，因為兩者都會一定程度地影響我<strong>文章版面的美感</strong>。</p><p>而且，假設我是讀者，如果我不是很想訂，但願意多看看站上的文章，結果每篇文章結尾都在 push 我訂閱，看著就有點煩。</p><p>或者，我已經訂了，但依舊要繼續看到這些佔空間的訂閱按鈕，也是有點煩。</p><p>所以想了想，我還是把訂閱區塊獨立一個<a href="https://blog.kyomind.tw/subscribe/">分頁</a>，這樣至少它在版面上，只會佔用<strong>兩個字</strong>，把視覺上的妨礙降到最低。</p><p>而且因為分頁已經有點多，為了維持<strong>簡潔的美感</strong>，我同時也拿掉了「首頁」這個連結——其實按左上角的「<a href="https://blog.kyomind.tw/">Code and Me</a>」就能回到首頁。</p><hr><p>看到這裡，不考慮<a href="https://blog.kyomind.tw/subscribe/">訂一下</a>嗎？👀</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在臉書、YouTube 這類「流量大平台」興起之後，很多創作者雖然因此獲得不少流量甚至一夕爆紅，但對&lt;strong&gt;平台演算法&lt;/strong&gt;的心情，仍然是愛恨交加。&lt;/p&gt;
&lt;p&gt;在文字創作領域，為了對抗平台與演算法，古老的&lt;strong&gt;電子報&lt;/strong&gt;也迎來了一波「&lt;strong&gt;文藝復興&lt;/strong&gt;」，造就了一堆電子報服務提供者，比如 &lt;a href=&quot;https://mailchimp.com/&quot;&gt;Mailchimp&lt;/a&gt;、&lt;a href=&quot;https://convertkit.com/&quot;&gt;Convertkit&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;它們讓作者可以直接把內容透過 email 發送給讀者，強化了兩者間的直接連繫。&lt;/p&gt;
&lt;p&gt;因此，你可以看到愈來愈多的部落格，都有提供電子報訂閱功能。可能是推送最新文章給你，也可能是更多額外的內容。&lt;/p&gt;
&lt;p&gt;更別說像 &lt;a href=&quot;https://substack.com/&quot;&gt;Substack&lt;/a&gt; 這樣「&lt;strong&gt;部落格、電子報——我全都要&lt;/strong&gt;」的數位出版服務。&lt;/p&gt;
&lt;p&gt;說這些主要想表達：「&lt;strong&gt;訂閱功能&lt;/strong&gt;」確實是現代部落格的一大需求。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="blog" scheme="https://blog.kyomind.tw/tags/blog/"/>
    
    <category term="電子報" scheme="https://blog.kyomind.tw/tags/%E9%9B%BB%E5%AD%90%E5%A0%B1/"/>
    
  </entry>
  
  <entry>
    <title>Linux 開發環境設定大全：zsh、zinit、pyenv、poetry、docker</title>
    <link href="https://blog.kyomind.tw/linux-dev-setup/"/>
    <id>https://blog.kyomind.tw/linux-dev-setup/</id>
    <published>2023-02-19T13:04:51.000Z</published>
    <updated>2023-03-05T18:42:43.261Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/wuqTPvs.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>最近為了升級 <a href="https://www.ubuntu-tw.org/modules/tinyd0/">Ubuntu</a> 版本，重建了工作上的 Linux VM（直接升級會怕），所以又得重新設定一次開發環境。</p><p>軟體界有一句名言叫「<a href="https://zh.wikipedia.org/zh-tw/%E5%90%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8B%97%E7%B2%AE">吃自己的狗糧</a>」，通常指的是自己開發的工具，自己先使用。而每次重設 Linux 開發環境時，我也都在吃自己的狗糧——看自己寫的教學文章。</p><p>不誇張，就是一篇篇看，把指令複製貼上，一步一步將環境設定到位。</p><p>做了好幾次以後，這次不禁想到：「<strong>咦？我乾脆整理成一篇就好了啊！</strong>」</p><span id="more"></span><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>沒錯！本篇講述的是：當我拿到一個<strong>全新的 Linux VM</strong>，為了開發方便，一定會安裝、設定的工具——主要基於「<strong>Python 後端</strong>」角度。</p><p>內容參考自以往數篇文章，且只關注在<strong>建立開發環境的必要步驟</strong>，並適時給出一些額外的提醒與建議。</p><p>如此一來，我們就不必在文章間穿梭，力求節省時間、一步到位！</p><p>本文是以 <strong>Ubuntu 20.04</strong> 實作，如果你用的是別的 Linux 發行版，肯定會有一些差別，這部分還請留意。</p><p>話不多說，讓我們開始。</p><hr><h2 id="一、設定-SSH-連線"><a href="#一、設定-SSH-連線" class="headerlink" title="一、設定 SSH 連線"></a>一、設定 SSH 連線</h2><p>這部分我並沒有寫成文章，因為網路上的資源已經非常多，而且步驟也不算太複雜。</p><p>對我而言，主要設定下面兩種 SSH 連線：</p><ol><li>本機電腦與遠端 VM 的連線。</li><li>VM 與 GitHub（或其它 Git 服務）的連線。</li></ol><p>至於具體要怎麼做，還請自行 Google。</p><h2 id="二、設定-zsh、zinit、Powerlevel10k"><a href="#二、設定-zsh、zinit、Powerlevel10k" class="headerlink" title="二、設定 zsh、zinit、Powerlevel10k"></a>二、設定 zsh、zinit、Powerlevel10k</h2><blockquote><p>參考原文：</p><ul><li><a href="https://blog.kyomind.tw/ubuntu-zsh-zinit/">Ubuntu 安裝使用 zsh + 輕量級套件管理器 zinit</a></li><li><a href="https://blog.kyomind.tw/powerlevel10k/">zsh 透過 zinit 安裝 Powerlevel10k 佈景主題</a></li></ul></blockquote><h3 id="安裝-zsh"><a href="#安裝-zsh" class="headerlink" title="安裝 zsh"></a>安裝 zsh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update;</span><br><span class="line">sudo apt-get upgrade -y;</span><br><span class="line">sudo apt-get install -y zsh;</span><br></pre></td></tr></table></figure><h3 id="將-zsh-設為登入時的「預設」shell"><a href="#將-zsh-設為登入時的「預設」shell" class="headerlink" title="將 zsh 設為登入時的「預設」shell"></a>將 zsh 設為登入時的「預設」shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -s /bin/zsh <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>提醒：請務必先確認 zsh 本身的安裝、設定沒問題，可以正常使用。否則登入後可能直接卡住，需要透過別的帳號例如 admin 來處理。</p><h3 id="新增-zshrc與-zprofile"><a href="#新增-zshrc與-zprofile" class="headerlink" title="新增.zshrc與.zprofile"></a>新增<code>.zshrc</code>與<code>.zprofile</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> .zshrc</span><br><span class="line"><span class="built_in">touch</span> .zprofile</span><br></pre></td></tr></table></figure><h3 id="安裝-zinit-套件管理器"><a href="#安裝-zinit-套件管理器" class="headerlink" title="安裝 zinit 套件管理器"></a>安裝 zinit 套件管理器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl --fail --show-error --silent --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="設定-zinit-套件"><a href="#設定-zinit-套件" class="headerlink" title="設定 zinit 套件"></a>設定 zinit 套件</h3><p>安裝完後，zinit 已經自動在<code>.zshrc</code>新增部分內容，請接著繼續新增下列內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh 套件四天王</span></span><br><span class="line">zinit light zsh-users/zsh-completions</span><br><span class="line">zinit light zsh-users/zsh-autosuggestions</span><br><span class="line">zinit light zsh-users/zsh-history-substring-search</span><br><span class="line">zinit light zdharma-continuum/fast-syntax-highlighting</span><br><span class="line"></span><br><span class="line"><span class="comment"># Oh My Zsh 功能</span></span><br><span class="line">zinit snippet OMZ::lib/completion.zsh</span><br><span class="line">zinit snippet OMZ::lib/history.zsh</span><br><span class="line">zinit snippet OMZ::lib/key-bindings.zsh</span><br><span class="line">zinit snippet OMZ::lib/theme-and-appearance.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># key binding</span></span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^[[A&#x27;</span> history-substring-search-up</span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^[[B&#x27;</span> history-substring-search-down</span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;,&#x27;</span> autosuggest-accept</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line">zinit load djui/alias-tips</span><br></pre></td></tr></table></figure><p>存檔後，重啟 shell。（如果要一併安裝 Powerlevel10k，可先不用重啟。）</p><h3 id="安裝-Powerlevel10k-佈景主題"><a href="#安裝-Powerlevel10k-佈景主題" class="headerlink" title="安裝 Powerlevel10k 佈景主題"></a>安裝 Powerlevel10k 佈景主題</h3><p>非常簡單，只要在 zinit 的設定內容後面，再加上這行即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Powerlevel10k</span></span><br><span class="line">zinit ice depth=1; zinit light romkatv/powerlevel10k</span><br></pre></td></tr></table></figure><p>存檔，重啟 shell，此時就會開始安裝 Powerlevel10k，隨即會進入「<strong>外觀樣式選擇與設定</strong>」畫面。</p><p>之後如果要重新設定，可使用指令<code>p10k configure</code>。</p><hr><h2 id="三、設定-pyenv"><a href="#三、設定-pyenv" class="headerlink" title="三、設定 pyenv"></a>三、設定 pyenv</h2><blockquote><p>參考原文：<a href="https://blog.kyomind.tw/ubuntu-pyenv/">Ubuntu 安裝使用 pyenv + pyenv-virtualenv</a></p></blockquote><h3 id="安裝-dependency"><a href="#安裝-dependency" class="headerlink" title="安裝 dependency"></a>安裝 dependency</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update;</span><br><span class="line">sudo apt-get install -y --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev</span><br></pre></td></tr></table></figure><h3 id="安裝-pyenv"><a href="#安裝-pyenv" class="headerlink" title="安裝 pyenv"></a>安裝 pyenv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pyenv/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure><h3 id="設定-pyenv"><a href="#設定-pyenv" class="headerlink" title="設定 pyenv"></a>設定 pyenv</h3><p>這裡只講 zsh 的設定，bash 請參見原文。</p><h4 id="zprofile新增內容，使用echo指令，或自行貼上"><a href="#zprofile新增內容，使用echo指令，或自行貼上" class="headerlink" title=".zprofile新增內容，使用echo指令，或自行貼上"></a><code>.zprofile</code>新增內容，使用<code>echo</code>指令，或自行貼上</h4><p>直接使用<code>echo</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init --path)&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br></pre></td></tr></table></figure><p>或自行貼上<code>.zprofile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PYENV_ROOT=<span class="string">&quot;<span class="variable">$HOME</span>/.pyenv&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PYENV_ROOT</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init --path)</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="zshrc新增，一樣使用echo指令，或自行貼上"><a href="#zshrc新增，一樣使用echo指令，或自行貼上" class="headerlink" title=".zshrc新增，一樣使用echo指令，或自行貼上"></a><code>.zshrc</code>新增，一樣使用<code>echo</code>指令，或自行貼上</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init -)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="pyenv-安裝-Python-3-10-10-並設為全域"><a href="#pyenv-安裝-Python-3-10-10-並設為全域" class="headerlink" title="pyenv 安裝 Python 3.10.10 並設為全域"></a>pyenv 安裝 Python 3.10.10 並設為全域</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.10.10</span><br></pre></td></tr></table></figure><p>通常需要等待好一段時間，安裝才會完成。🐸</p><p>接著透過 pyenv，將系統全域的 Python 設定為 <a href="https://www.python.org/downloads/release/python-31010/">3.10.10</a>（或其他版本）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global 3.10.10</span><br></pre></td></tr></table></figure><h3 id="不再安裝-pyenv-virtualenv"><a href="#不再安裝-pyenv-virtualenv" class="headerlink" title="不再安裝 pyenv-virtualenv"></a>不再安裝 pyenv-virtualenv</h3><p>因為 Poetry 自帶了虛擬環境管理功能，容易和 pyenv-virtualenv <strong>疊床架屋</strong>，徒增<strong>管理上的混淆</strong>，所以我現在<strong>一律只使用 Poetry + venv 來管理 Python 虛擬環境</strong>。</p><p>這也是我目前覺得<strong>最簡潔</strong>的做法。</p><hr><h2 id="四、設定-Poetry"><a href="#四、設定-Poetry" class="headerlink" title="四、設定 Poetry"></a>四、設定 Poetry</h2><blockquote><p>參考原文：<a href="https://blog.kyomind.tw/python-poetry/">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a></p></blockquote><h3 id="安裝-Poetry"><a href="#安裝-Poetry" class="headerlink" title="安裝 Poetry"></a>安裝 Poetry</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://install.python-poetry.org | python3 -</span><br></pre></td></tr></table></figure><h3 id="新增poetry指令至-PATH"><a href="#新增poetry指令至-PATH" class="headerlink" title="新增poetry指令至 PATH"></a>新增<code>poetry</code>指令至 PATH</h3><p>在<code>.zshrc</code>新增以下內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/.local/bin</span><br></pre></td></tr></table></figure><h3 id="修改config，改用專案內的-venv虛擬環境"><a href="#修改config，改用專案內的-venv虛擬環境" class="headerlink" title="修改config，改用專案內的.venv虛擬環境"></a>修改<code>config</code>，改用專案內的<code>.venv</code>虛擬環境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry config virtualenvs.in-project <span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><h2 id="五、安裝-Docker"><a href="#五、安裝-Docker" class="headerlink" title="五、安裝 Docker"></a>五、安裝 Docker</h2><p>安裝細節常常隨著 Docker 版本的更新而有所變動，建議直接看<a href="https://docs.docker.com/engine/install/ubuntu/">官方文件</a>即可。</p><p>這次安裝有兩個發現：</p><ol><li>最新版似乎已經<strong>不需要將使用者加入 Docker 群組了</strong>。</li><li><code>docker compose</code>改以 plugin 的形式安裝，變成 Docker client 的<strong>子命令</strong>，而不再採用舊版的<code>docker-compose</code>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wuqTPvs.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近為了升級 &lt;a href=&quot;https://www.ubuntu-tw.org/modules/tinyd0/&quot;&gt;Ubuntu&lt;/a&gt; 版本，重建了工作上的 Linux VM（直接升級會怕），所以又得重新設定一次開發環境。&lt;/p&gt;
&lt;p&gt;軟體界有一句名言叫「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%90%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8B%97%E7%B2%AE&quot;&gt;吃自己的狗糧&lt;/a&gt;」，通常指的是自己開發的工具，自己先使用。而每次重設 Linux 開發環境時，我也都在吃自己的狗糧——看自己寫的教學文章。&lt;/p&gt;
&lt;p&gt;不誇張，就是一篇篇看，把指令複製貼上，一步一步將環境設定到位。&lt;/p&gt;
&lt;p&gt;做了好幾次以後，這次不禁想到：「&lt;strong&gt;咦？我乾脆整理成一篇就好了啊！&lt;/strong&gt;」&lt;/p&gt;</summary>
    
    
    
    <category term="開發筆記" scheme="https://blog.kyomind.tw/categories/%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.kyomind.tw/tags/Ubuntu/"/>
    
    <category term="zsh" scheme="https://blog.kyomind.tw/tags/zsh/"/>
    
    <category term="zinit" scheme="https://blog.kyomind.tw/tags/zinit/"/>
    
    <category term="Powerlevel10k" scheme="https://blog.kyomind.tw/tags/Powerlevel10k/"/>
    
    <category term="pyenv" scheme="https://blog.kyomind.tw/tags/pyenv/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>11，我絕不當資訊的聚合者</title>
    <link href="https://blog.kyomind.tw/weekly-review-11/"/>
    <id>https://blog.kyomind.tw/weekly-review-11/</id>
    <published>2023-02-18T14:58:07.000Z</published>
    <updated>2023-03-05T18:42:43.263Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>你一定用過 <a href="https://getpocket.com/">Pocket</a> 這類可以幫你把文章、網址存下來，以供日後再讀的服務。現在很多瀏覽器也內建了類似功能。</p><p>可以說，這樣的「<strong>稍後再讀</strong>」服務，幾乎是現代人獲取和管理網路上資訊的起手式。畢竟資訊量實在太大，不可能一看到什麼就讀什麼。</p><p>如果要再進一步，將這些資訊歸納、整合，那可就<strong>非常複雜</strong>了！</p><p>聽聽星箭廣播這期〈<a href="https://blog.starrocket.io/posts/star-rocket-podcast-ep107-statementdog-marketing-manager-wei-yu-lin-talks-about-his-productivity-tools-and-the-system-for-learning/">107: 希望我們的第二大腦都不會太遲緩：聊聊學習生產力工具（ft. 財報狗林威宇）</a>〉，我們可以得知，有一種人，特別熱衷於整理、消化網路上的各種資訊。</p><p>通常，他 &#x2F; 她們也都挺厲害的，比如上述財報狗的<a href="https://wylin.tw/">林威宇</a>。</p><p>而我想說的是——我絕對不要成為這樣的人。</p><span id="more"></span><p><img src="https://i.imgur.com/drRrybF.png" alt="純屬博君一笑"><span class="cap">純屬博君一笑</span></p><h2 id="這樣是哪樣？"><a href="#這樣是哪樣？" class="headerlink" title="這樣是哪樣？"></a>這樣是哪樣？</h2><p>為避免誤解，我們還是要定義一下，所謂的「這樣」，到底是哪樣？</p><p>首先「資訊」一詞你也可以理解為「知識」，這裡請容我混用，因為它們並非重點。</p><p>在部落格「<a href="https://blog.kyomind.tw/about/">關於我</a>」中，我已經表明自己是一個不折不扣的「<strong>筆記控</strong>」，更有多篇文章討論或提及了筆記軟體如 <a href="https://blog.kyomind.tw/tags/Notion/">Notion</a> 與 <a href="https://blog.kyomind.tw/tags/Logseq/">Logseq</a>。</p><p>毫無疑問，我是一個<strong>很愛整理知識</strong>（尤其是<strong>程式相關的知識</strong>）的人，而且也深深信仰著「<a href="https://blog.kyomind.tw/a-mind-for-blogs/#%E6%9C%80%E5%A4%A7%E5%A5%BD%E8%99%95%EF%BC%9A%E5%AF%AB%E4%BD%9C%E5%8D%B3%E6%80%9D%E8%80%83">不寫下來就無法思考</a>」的價值觀。</p><h2 id="善於收集、整理、消化零碎資訊的人"><a href="#善於收集、整理、消化零碎資訊的人" class="headerlink" title="善於收集、整理、消化零碎資訊的人"></a>善於收集、整理、消化零碎資訊的人</h2><p>所以，我不想成為的，是「<strong>零碎資訊的有效聚合者</strong>」，請注意這裡有<strong>兩個重點</strong>：</p><ol><li><strong>零碎</strong>：意味資訊來源眾多，主要可能是網路文章、YouTube 影片、Podcast，甚至臉書、推特發文。</li><li><strong>有效</strong>：有一整套系統（或稱「工作流」），有辦法大量收集眾多來源資訊，並且還能相當程度地進行處理、整合，甚至<strong>內化與輸出</strong>。</li></ol><p>該怎麼形容這樣的人？聽聽上面的那集 Podcast 就能知曉。可想而知，這類人也通常都非常善用工具，有著過人的生產力。</p><p>我就知道好幾個！</p><hr><h2 id="為什麼我不想？"><a href="#為什麼我不想？" class="headerlink" title="為什麼我不想？"></a>為什麼我不想？</h2><p>如果你以為我會說：「我不想是因為，他們把自己限縮成一個資訊收集機器，就算是把資訊收集得很好，但最終沒有把它們轉化為有用的知識……等等等」那你就猜錯了🤣</p><p>不可否認有些人或許是純收集而忽略創造價值，但至少就我所知道的這些人，是真能夠一定程度運用起大量聚合後的資訊，比如上述的林威宇。</p><p>因此，我不想，不是因為沒用，而是因為我個人的因素，主要有二：</p><ol><li>能量不足。</li><li>收集讓人滿足，但也讓我煩躁。</li></ol><p>從這兩個角度看，與其說我不想，不如說「<strong>我辦不到</strong>」，或許更為貼切。</p><h2 id="一、我的能量不足"><a href="#一、我的能量不足" class="headerlink" title="一、我的能量不足"></a>一、我的能量不足</h2><p>說真的，我並不（特別）羨慕那些<a href="https://blog.kyomind.tw/simple-notion/#%E7%AC%AC%E4%B8%80%E7%A8%AE%E4%BA%BA%EF%BC%9A%E7%94%9F%E7%94%A2%E5%8A%9B%E7%8B%82%E9%AD%94">生產力過人的人</a>，因為我知道自己<strong>沒有那麼多能量</strong>。對此，我也不氣餒，只怪自己仍無法將大部分的<strong>專注力</strong>，都盡可能用在刀口上，還是常常在看 <a href="https://youtu.be/MqPj1X_uRME">YouTube 廢片解說</a>🙈。</p><p>而且我知道，即使將時間精力全都用在刀口上了，那依舊是<strong>有限</strong>的。面對有限的資源，我始終不能太貪心，最好集中在少部分關鍵知識材料——比如書本——才是正途。</p><h2 id="二、收集讓人滿足，也讓我煩躁"><a href="#二、收集讓人滿足，也讓我煩躁" class="headerlink" title="二、收集讓人滿足，也讓我煩躁"></a>二、收集讓人滿足，也讓我煩躁</h2><p>收集資訊肯定能帶來一些成就感，因為「<strong>掌控力</strong>」與「<strong>收集欲</strong>」被一定程度滿足了——那種<strong>井然有序</strong>的感覺，我懂！</p><p>然而，知識的 <a href="https://zh.wikipedia.org/zh-tw/%E9%94%99%E5%A4%B1%E6%81%90%E6%83%A7%E7%97%87">FOMO</a>（即<strong>知識焦慮</strong>）是所有軟體工程師的<strong>宿命</strong>，看看胡立這篇〈<a href="https://hulitw.medium.com/what-to-learn-b85ee24c3e8">來談談工程師的知識焦慮</a>〉就能明白。</p><p>真的很焦慮捏！</p><p>程式之海就已一望無際，再看看邊界外的眾多資訊，實在讓人絕望。資訊處理工作流？不可能——能寫好每天的 <a href="https://blog.kyomind.tw/logseq/#%E6%97%A5%E8%AA%8C%EF%BC%88Journal%EF%BC%89%E7%B3%BB%E7%B5%B1">Logseq 日誌</a>和 <a href="https://www.facebook.com/kyomind/posts/pfbid03X7knbcajedDqET2s4xYBGxdD6abpTGzusVb7CXisihbGksHGv2PXzUacpXxcdtdl">Google Sheets 記錄</a>，我已該知足。</p><h2 id="稍後再讀——你真的會讀？"><a href="#稍後再讀——你真的會讀？" class="headerlink" title="稍後再讀——你真的會讀？"></a>稍後再讀——你真的會讀？</h2><p>常見的答案是：「應該會。」</p><p>而你我都知道，真實的答案往往是：「<strong>當然不會</strong>。」</p><p>但我想說的是，絕大部分的時候，<strong>存了不讀才是正確的XD！</strong></p><hr><h2 id="小結：靠別人去聚合"><a href="#小結：靠別人去聚合" class="headerlink" title="小結：靠別人去聚合"></a>小結：靠別人去聚合</h2><blockquote><p>可是，不收集，我會很容易資訊焦慮耶！怕跟不上時代。</p></blockquote><p>真的會！我也會，那要怎麼辦？</p><p>當然是把事情<strong>交給專業的人去做</strong>，然後我再關注這些人就好了，比如追縱臉書或訂閱電子報。</p><p>沒錯，我自己不聚合，我就關注幾個很會聚合的人足矣——這些人自然會幫我們去聚合一大堆已經在大量聚合的人事物（好繞口）。</p><p>但如此一來，你可能又不免擔心，那資訊豈不是已經經過了 N 手後，才被我看到？是的，確實如此。</p><p>然而，對於零碎資訊（相較於完整、有體系的內容），我覺得可以了。</p><p>誤導？沒關係，只要我們保持著一顆<strong>持續思考的心</strong>，你總能嗅到其中的<strong>不對勁</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;你一定用過 &lt;a href=&quot;https://getpocket.com/&quot;&gt;Pocket&lt;/a&gt; 這類可以幫你把文章、網址存下來，以供日後再讀的服務。現在很多瀏覽器也內建了類似功能。&lt;/p&gt;
&lt;p&gt;可以說，這樣的「&lt;strong&gt;稍後再讀&lt;/strong&gt;」服務，幾乎是現代人獲取和管理網路上資訊的起手式。畢竟資訊量實在太大，不可能一看到什麼就讀什麼。&lt;/p&gt;
&lt;p&gt;如果要再進一步，將這些資訊歸納、整合，那可就&lt;strong&gt;非常複雜&lt;/strong&gt;了！&lt;/p&gt;
&lt;p&gt;聽聽星箭廣播這期〈&lt;a href=&quot;https://blog.starrocket.io/posts/star-rocket-podcast-ep107-statementdog-marketing-manager-wei-yu-lin-talks-about-his-productivity-tools-and-the-system-for-learning/&quot;&gt;107: 希望我們的第二大腦都不會太遲緩：聊聊學習生產力工具（ft. 財報狗林威宇）&lt;/a&gt;〉，我們可以得知，有一種人，特別熱衷於整理、消化網路上的各種資訊。&lt;/p&gt;
&lt;p&gt;通常，他 &amp;#x2F; 她們也都挺厲害的，比如上述財報狗的&lt;a href=&quot;https://wylin.tw/&quot;&gt;林威宇&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;而我想說的是——我絕對不要成為這樣的人。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="簡潔主義" scheme="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="知識焦慮" scheme="https://blog.kyomind.tw/tags/%E7%9F%A5%E8%AD%98%E7%84%A6%E6%85%AE/"/>
    
    <category term="學習" scheme="https://blog.kyomind.tw/tags/%E5%AD%B8%E7%BF%92/"/>
    
  </entry>
  
  <entry>
    <title>10，Weekly Review 寫滿 10 回——我的心得與改進</title>
    <link href="https://blog.kyomind.tw/weekly-review-10/"/>
    <id>https://blog.kyomind.tw/weekly-review-10/</id>
    <published>2023-02-12T11:40:51.000Z</published>
    <updated>2023-03-05T18:42:43.263Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>從 2022 年 11 月 6 日的〈<a href="https://blog.kyomind.tw/weekly-review-01/">01，為何他們可以，但我不行</a>〉到今天，Weekly Review 剛好滿 10 回了！</p><p>如果是整個 blog 是我在寫作方面的「產品」，那「Weekly Reivew」可以視為產品中的一個重要 feature 與嘗試。</p><p>而一個成長中的 feature，必然經過一次次的迭代與更新。本期就來看看，從第一篇到現在，期間我有哪些感受與發現，以及做了哪些調整。</p><p>以下是我的心得（突然覺得這句話好 GPT🤣）。</p><span id="more"></span><hr><h2 id="一、關於「定期」與「不定期」的取捨"><a href="#一、關於「定期」與「不定期」的取捨" class="headerlink" title="一、關於「定期」與「不定期」的取捨"></a>一、關於「定期」與「不定期」的取捨</h2><p>大部分的電子報都是每週更新一期甚至兩期，除了逢年過節或作者要務纏身不克更新之外，訂閱的讀者們對於出刊規律，有著一定的期待。</p><p>若輕易辜負，難免會給人一種「三天曬網，兩天捕魚」的感覺。</p><p>因此，考慮到我的內容屬性（不易量產）與寫作紀律（毫無紀律），我在一開始就選擇了「<strong>不定期</strong>」的更新模式，藉此逃避週更責任！</p><p>整體而言，我覺得這個選擇還是比較適合我的——因為我確實沒辦法每週都寫出自己覺得有趣的內容。</p><p>但它的<strong>代價</strong>也很明顯：有時候我已經有了想法，只要願意下筆，幾乎一定能成篇。而正因為可以偷懶，所以就真的先偷懶了！拖到下一期甚至下下期才發，這顯然就算不上什麼好事。</p><p>兩者的取捨沒有明確分界可言，端視你<strong>最在乎什麼</strong>。我希望不要勉強自己硬產內容，所以容忍了伴隨的怠惰。</p><p>可是，我也明白，有時候適度的強迫確實就能成事。甚至，很多時候，就是需要你強迫自己「開始」下筆——而輕易的寬容，會因此而失去不少。</p><p>唉，只能說，做人真難，尤難在取捨。</p><h2 id="二、篇幅上限？忘了吧！"><a href="#二、篇幅上限？忘了吧！" class="headerlink" title="二、篇幅上限？忘了吧！"></a>二、篇幅上限？忘了吧！</h2><p>第一期我就為這個系列設定了<a href="https://blog.kyomind.tw/weekly-review-01/#%E4%B8%89%E5%80%8B%E4%B8%BB%E8%A6%81%E9%99%90%E5%88%B6">三個主要限制</a>。現在看來只有「不定期」這個限制，被穩穩地維持了。</p><p>關於篇幅的上限，原則為 1000 字，但從〈<a href="https://blog.kyomind.tw/weekly-review-07/">07，年末特輯上：2022 寫作反省與明年目標</a>〉開始，我連 3 期都超過。（本期也超過）</p><p>這部分失守了，因為有時候一個完整的主題，如果要控制篇幅，需要花費 3、5 成的額外心力去刪減，但這樣做就不符合「<strong>降底寫作摩擦力</strong>」這個上位原則。</p><p>算了吧！這也不是特別重要的限制，但還是會克制一下啦！</p><h2 id="三、我不喜歡「收集型」的創作模式"><a href="#三、我不喜歡「收集型」的創作模式" class="headerlink" title="三、我不喜歡「收集型」的創作模式"></a>三、我不喜歡「收集型」的創作模式</h2><p>這個就非常有趣了！</p><p>如第一期所言：</p><blockquote><p>目前中文創作者中，常見電子報內容架構主流之一是仿效 James Clear 的 《3–2–1 Thursday newsletter》這種。</p></blockquote><p>所以一開始我也從善如流，依樣畫葫蘆——決定每期寫 1 到 3 個主題。</p><p>這裡的重點在於「多個主題」的收集。</p><p>但寫了幾期後發現，我還<strong>真不習慣</strong>這種「<strong>點子收集型</strong>」的內容創作模式，身為作者我會有很強烈的「<strong>拼湊感</strong>」。</p><p>這和我為了不要硬產內容，而選擇了不定期發文，形成「<strong>潛在的價值矛盾</strong>」。</p><p>當然，收集並不等於拼湊，更不等於硬產，只是我自己會有拼湊感而已。</p><p>我常常心中<strong>只有一個主題</strong>，但為了貫徹「<strong>主題的多元</strong>」，卻還得另想一個副主題出來——難怪我幾乎沒寫過 3 個主題的內容🐸，因為兩個就已經讓感到混身不適。</p><p>顯然，這個常見的「3-2-1」框架，並不適合我，我一次還是只寫一個主題就好了。</p><h2 id="四、反省可以，但不必太過言重"><a href="#四、反省可以，但不必太過言重" class="headerlink" title="四、反省可以，但不必太過言重"></a>四、反省可以，但不必太過言重</h2><p>在〈<a href="https://blog.kyomind.tw/weekly-review-05/">05，終於寫了「關於我」頁面</a>〉提到了「Weekly Review 的核心主軸是『<strong>反省』</strong>」，我想，這樣的立意是好的。</p><p>但是！我也不禁發現，反省常常跟「<strong>嚴肅</strong>」產生連結，而嚴肅又和「<strong>沉重</strong>」掛勾。</p><p>長此以往，容易影響寫作的情緒，讓你的筆鋒變得愈來愈重，感覺自己若沒什麼深刻的反省，都不好意思下筆了——這無疑是一種寫作上的摩擦力。</p><p>所以，不反省了啦！</p><h2 id="五、Weekly-Review-只是一個名字而已"><a href="#五、Weekly-Review-只是一個名字而已" class="headerlink" title="五、Weekly Review 只是一個名字而已"></a>五、Weekly Review 只是一個名字而已</h2><p>一開始是說，取材內容會是當週 Logseq 筆記中的思考，但其實很難真的做到，每次都是「當週」才有的想法——「非當週」才是常態。</p><p>真實往往是，很多事，已經翻來覆去想了好幾週了。所以，請不用介意，它就只是一個名字而已。</p><p>但我可以保證，這些思考都是真的。</p><h2 id="六、輕快才是持續寫作的王道"><a href="#六、輕快才是持續寫作的王道" class="headerlink" title="六、輕快才是持續寫作的王道"></a>六、輕快才是持續寫作的王道</h2><p>最後，我想說，寫作務必輕快，既不必太過言重，也不必要求自己太多。</p><p>可以先寫出來，要刪要改，都是以後的事，來日方長，還可以慢慢來。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;從 2022 年 11 月 6 日的〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-01/&quot;&gt;01，為何他們可以，但我不行&lt;/a&gt;〉到今天，Weekly Review 剛好滿 10 回了！&lt;/p&gt;
&lt;p&gt;如果是整個 blog 是我在寫作方面的「產品」，那「Weekly Reivew」可以視為產品中的一個重要 feature 與嘗試。&lt;/p&gt;
&lt;p&gt;而一個成長中的 feature，必然經過一次次的迭代與更新。本期就來看看，從第一篇到現在，期間我有哪些感受與發現，以及做了哪些調整。&lt;/p&gt;
&lt;p&gt;以下是我的心得（突然覺得這句話好 GPT🤣）。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 正確設定 PYTHONPATH 教學</title>
    <link href="https://blog.kyomind.tw/vscode-pythonpath/"/>
    <id>https://blog.kyomind.tw/vscode-pythonpath/</id>
    <published>2023-02-11T06:54:50.000Z</published>
    <updated>2023-03-05T18:42:43.263Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/VHCKtxW.jpg"></p><p>前幾天，同事為專案的局部元件寫了一個偵錯小程式，我們姑且稱為<code>debugger.py</code>。該程式中會使用到整個專案的共同設定，這些設定則放在專案下的<code>configs</code>模組（資料夾）裡，所以需要另外 import：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> configs.config <span class="keyword">import</span> TestMode  <span class="comment"># import 本地的 configs 模組</span></span><br></pre></td></tr></table></figure><p>而專案的結構則是（這裡只凸顯兩者的「<strong>相對層級關係</strong>」，其餘細節省略）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 元件</span><br><span class="line">│   ├── debugger.py</span><br><span class="line">│</span><br><span class="line">├── configs</span><br><span class="line">│   ├── config.py</span><br><span class="line">│</span><br></pre></td></tr></table></figure><p>有經驗的你可能不用執行這個小程式就能預料——它找不到<code>configs</code>！</p><p>不出所料，直接執行之後，會出現錯誤訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;configs&#x27;</span></span><br></pre></td></tr></table></figure><p>這就牽涉到，Python 直譯器在 import 時，究竟「<strong>如何尋找 import 路徑</strong>」議題。</p><span id="more"></span><hr><h2 id="Python-import-基礎"><a href="#Python-import-基礎" class="headerlink" title="Python import 基礎"></a>Python import 基礎</h2><p>可先參考下列三篇文章，建立關於 import 的基礎世界觀：</p><ul><li><a href="https://ithelp.ithome.com.tw/articles/10195501">import雜談之一———import路徑的相對論</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10196775">import雜談之二———export機制以及namespace package</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10196901">import雜談之三———sys.path的洪荒之時</a></li></ul><p>從上述引用內容可知，<code>debugger.py</code>所以會出現<code>ModuleNotFoundError</code>，正是因為<code>from configs.config import TestMode</code>這段程式碼，是希望從「專案根目錄」的角度出發去 import。</p><p>但在沒有額外設定的情況下，專案根目錄並不在<code>sys.path</code>裡——除非<code>debugger.py</code>就在專案根目錄底下（容後述）。所以自然就找不到<code>configs</code>模組。</p><h2 id="兩個幫sys-path「加料」的方法"><a href="#兩個幫sys-path「加料」的方法" class="headerlink" title="兩個幫sys.path「加料」的方法"></a>兩個幫<code>sys.path</code>「加料」的方法</h2><p>因此，若想要正確執行<code>debugger.py</code>，我們需要把「專案根目錄」的路徑，加入到<code>sys.path</code>，此時有兩個常見方法。</p><h3 id="一、在程式碼中手動加入sys-path"><a href="#一、在程式碼中手動加入sys-path" class="headerlink" title="一、在程式碼中手動加入sys.path"></a>一、在程式碼中手動加入<code>sys.path</code></h3><p>也就是在<code>from configs.config...</code>之前，先手動加入這段<code>sys.path.append(&#39;專案根目錄&#39;)</code>。</p><p>這樣的好處是，別人不需要額外設定<code>PYTHONPATH</code>，因為程式已經幫我們做完了。</p><p>而缺點則是——對我來說是一個缺點🐸——太醜了。不僅會降低程式碼的可讀性，且<code>Flake8</code>也會給出<a href="https://www.flake8rules.com/rules/E402.html">錯誤訊息（E402）</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module level import not at top of file</span><br></pre></td></tr></table></figure><p>不過，在團隊協作時，這樣的做法可以減少大家在「設定未同步」時的潛在問題，所以還是要依不同情境考量，究竟要用哪種方式。</p><p>基於協作一致性考慮，本文的案例我仍建議同事採用這個做法。</p><h3 id="二、使用PYTHONPATH"><a href="#二、使用PYTHONPATH" class="headerlink" title="二、使用PYTHONPATH"></a>二、使用<code>PYTHONPATH</code></h3><p>儘管如此，有時候我們只是個人開發，或不想在程式碼中直接修改<code>sys.path</code>，則設定<code>PYTHONPATH</code>是更常見的做法。</p><h2 id="VS-Code-設定PYTHONPATH"><a href="#VS-Code-設定PYTHONPATH" class="headerlink" title="VS Code 設定PYTHONPATH"></a>VS Code 設定<code>PYTHONPATH</code></h2><p>首先要說明的是，<code>PYTHONPATH</code>在不同情境會被不同的工具使用，比如 <a href="https://stackoverflow.com/questions/49631146/how-do-you-add-a-path-to-pythonpath-in-a-dockerfile">Dockerfile</a>。</p><p>而本文只集中在「<strong>使用 VS Code</strong>」的情境下——究竟要怎麼設定，才能讓 VS Code 取得正確的路徑？</p><p>嚴格說，是指 VS Code 的<strong>整合命令列</strong>中，如何正確套用<code>PYTHONPATH</code>。好讓 VS Code 在以整合命令列執行程式時，可以正確 import，而不會出現<code>ModuleNotFoundError</code>。</p><p>通常這段設定會放在「專案」下的<code>settings.json</code>，也就是「<code>專案/.vscode/settings.json</code>」，你要使用「使用者」設定（全域的<code>settings.json</code>）也是可以，只是要留意<strong>不同專案是否會因此而有不一致的結果</strong>。</p><hr><h2 id="設定PYTHONPATH的三種方式"><a href="#設定PYTHONPATH的三種方式" class="headerlink" title="設定PYTHONPATH的三種方式"></a>設定<code>PYTHONPATH</code>的三種方式</h2><p>關於 VS Code 加入<code>PYTHONPATH</code>的<code>settings.json</code>設定，從以前（至少是 3 年前）到現在，有過方式變遷，我們只需要知道：舊的方法已經不管用。</p><h2 id="第一種方式：直接設定-settings-json（已廢棄）"><a href="#第一種方式：直接設定-settings-json（已廢棄）" class="headerlink" title="第一種方式：直接設定 settings.json（已廢棄）"></a>第一種方式：直接設定 settings.json（已廢棄）</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;python.pythonPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;專案根目錄&quot;</span></span><br></pre></td></tr></table></figure><p>簡單暴力，透過<code>python.pythonPath</code>這個 token，直接幫 VS Code 直接指定<code>PYTHONPATH</code>，但此 token 已經作古（被移除）了，可以不必理會。</p><h2 id="第二種方式：透過-env-檔"><a href="#第二種方式：透過-env-檔" class="headerlink" title="第二種方式：透過 env 檔"></a>第二種方式：透過 env 檔</h2><p>你先建立 env 檔，讓 VS Code 去讀取它。不用說，env 裡面必須要有<code>PYTHONPATH</code>這個 key 才行。</p><p>通常我們會這樣設定 env 內容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYTHONPATH=$(pwd)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYTHONPATH=.</span><br></pre></td></tr></table></figure><p>可以看出，使用的是「<strong>相對路徑</strong>」或「<strong>環境變數</strong>」，兩者異曲同工，實際想指向的，都是專案根目錄。不用絕對路徑，則是為了「<strong>方便在不同專案之間套用</strong>」。</p><p>要特別注意，無論是<code>.</code>還是<code>$(pwd)</code>，都是「<strong>相對於該 env 檔所在的資料夾</strong>」而言。</p><p>換句話說，如果你的 env「<strong>沒有</strong>」放在專案根目錄底下，這個設定就可能會出錯。此時為了避免過度複雜，改用絕對路徑也是可以的。</p><h3 id="重要：sys-path-的第一順位值"><a href="#重要：sys-path-的第一順位值" class="headerlink" title="重要：sys.path 的第一順位值"></a>重要：sys.path 的第一順位值</h3><p>需要補充說明的是，執行任意 Python 檔案時，Python 直譯器會依序嘗試<code>sys.path</code>裡的每個值，直到找到你要 import 的模組。而<code>sys.path</code>的「<strong>第一順位值</strong>」就是<a href="https://www.geeksforgeeks.org/sys-path-in-python/">執行檔所在的路徑（資料夾）</a>：</p><blockquote><p><strong>By default, the interpreter looks for a module within the current directory.</strong> To make the interpreter search in some other directory you just simply have to change the current directory.</p></blockquote><p>換句話說，如果<code>debugger.py</code>「正好」就在專案根目錄下，那就不需要額外的設定。因此，本文案例之所以會出現<code>ModuleNotFoundError</code>，也正因<code>debugger.py</code>不在專案的根目錄裡。</p><p>可想而知，把<code>debugger.py</code>改放在專案根目錄下，就不會有問題了。但這並不是解決問題的<strong>根本方法</strong>，因為會讓專案結構變得「<strong>不整齊、缺乏一致性</strong>」。</p><h3 id="settings-json-設定-env-讀取路徑"><a href="#settings-json-設定-env-讀取路徑" class="headerlink" title="settings.json 設定 env 讀取路徑"></a>settings.json 設定 env 讀取路徑</h3><p>有了 env 檔案，接著就是要讓 VS Code 去讀取它，<code>settings.json</code>要加入下列內容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;python.envFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/.env&quot;</span></span><br></pre></td></tr></table></figure><p><code>$&#123;workspaceFolder&#125;</code>的意思是「VS Code 當前開啟的專案根目錄」。</p><p>你可以把 env 檔放在更深層的資料夾，只要<code>python.envFile</code>的路徑正確，VS Code 仍然能夠正確讀取它。</p><p>但如前所述，env 中<code>PYTHONOPATH</code>的值若為<code>$(pwd)</code>或<code>.</code>，那它的「<strong>實際路徑</strong>」就會隨著 env 所在的路徑而變動，有著不確定性。</p><p>所以，我們往往<strong>就是</strong>把 env 放在<strong>專案根目錄</strong>。當然，它通常叫「<code>.env</code>」。</p><h2 id="第三種方式：「整合-terminal」設定"><a href="#第三種方式：「整合-terminal」設定" class="headerlink" title="第三種方式：「整合 terminal」設定"></a>第三種方式：「整合 terminal」設定</h2><p>一開始看到<code>ModuleNotFoundError</code>時，我立刻想到的就是第二種設定，趕緊翻出筆記，依樣畫葫蘆。</p><p>沒想到，它不 work！</p><p>我開啟 VS Code 的整合命令列去執行<code>debugger.py</code>，發現它依舊找不到<code>configs</code>的路徑。這就奇了，我之前都是這樣做的啊？</p><p>後來想了一下，以前發生問題，主要是 VS Code 在對程式進行<strong>靜態分析</strong>時，會直接提示找不到路徑，所以我才透過<code>python.envFile</code>和 env 檔來解決。</p><p>而且這次是<strong>整合命令列的執行問題</strong>，兩者不盡相同。</p><p>但無妨，反正問題的本質不變，我們知道其中關鍵，就是<code>PYTHONPATH</code>設定，所以關鍵字打下去，不意外的——答案就在文件裡！</p><h3 id="官方文件"><a href="#官方文件" class="headerlink" title="官方文件"></a>官方文件</h3><p>使用「vscode pythonpath」關鍵字，你將輕易找到這篇「<a href="https://code.visualstudio.com/docs/python/environments">Using Python environments in VS Code</a>」。</p><p>其中，和本文議題直接相關的，就是最下方的「<a href="https://code.visualstudio.com/docs/python/environments#_use-of-the-pythonpath-variable">Use of the PYTHONPATH variable</a>」部分：</p><blockquote><p>The <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH">PYTHONPATH</a> environment variable specifies additional locations where the Python interpreter should look for modules. In VS Code, <strong>PYTHONPATH can be set through the terminal settings</strong> (<code>terminal.integrated.env.*</code>) and&#x2F;or within an <code>.env</code> file.</p></blockquote><p>本段的最大重點就是：<code>PYTHONPATH</code>環境變數除了使用 env 檔外，也可以直接由<code>terminal.integrated</code>這個 token 設定。</p><p>看到這裡，整個「故事背景」我們已經了解得差不多了，直接來看設定吧！</p><h3 id="為-VS-Code-的整合命令列設定PYTHONPATH"><a href="#為-VS-Code-的整合命令列設定PYTHONPATH" class="headerlink" title="為 VS Code 的整合命令列設定PYTHONPATH"></a>為 VS Code 的整合命令列設定<code>PYTHONPATH</code></h3><p>設定內容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;terminal.integrated.env.linux&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;PYTHONPATH&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>這個設定允許你，為「VS Code 整合命令列」<strong>額外新增環境變數</strong>，方便你在命令列中執行程式。</p><p>上述的<code>env.linux</code>可以改為<code>.osx</code>或<code>.windows</code>，讓你依不同作業系統，分別設定不同變數內容。如果其實都一致，就可以像文件中那樣，使用萬字元<code>*</code>即可。</p><p>因為我只在 Linux VM 上執行，所以只設定了<code>.linux</code>。</p><p>雖然文件表明，你也可以透過 env 設定<code>PYTHONPATH</code>，但 env 中的<code>PYTHONPATH</code>，<strong>應該只對 linter、formatter 等工具有效</strong>，而不會影響 VS Code 的整合命令列。至少我無法透過 env 來解決命令列的執行問題。</p><hr><h2 id="特別提醒"><a href="#特別提醒" class="headerlink" title="特別提醒"></a>特別提醒</h2><p><code>terminal.integrated</code>如它的名稱所述，<strong>只對</strong> VS Code 的整合命令列有效：</p><blockquote><p>However, in this case when the extension is performing an action that <strong>isn’t routed through the terminal</strong>, such as the use of a linter or formatter, then this setting <strong>won’t have an effect on module look-up.</strong></p></blockquote><p>舉例而言，如果你自行開一個 terminal 去執行<code>debugger.py</code>，則還是一樣會出現<code>ModuleNotFoundError</code>。</p><p>如果這對你造成困擾，那麼採用「在程式碼加入<code>sys.path</code>」的方式，或許才是適合的選擇。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VHCKtxW.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;前幾天，同事為專案的局部元件寫了一個偵錯小程式，我們姑且稱為&lt;code&gt;debugger.py&lt;/code&gt;。該程式中會使用到整個專案的共同設定，這些設定則放在專案下的&lt;code&gt;configs&lt;/code&gt;模組（資料夾）裡，所以需要另外 import：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; configs.config &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; TestMode  &lt;span class=&quot;comment&quot;&gt;# import 本地的 configs 模組&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而專案的結構則是（這裡只凸顯兩者的「&lt;strong&gt;相對層級關係&lt;/strong&gt;」，其餘細節省略）：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── 元件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── debugger.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── configs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── config.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;有經驗的你可能不用執行這個小程式就能預料——它找不到&lt;code&gt;configs&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;不出所料，直接執行之後，會出現錯誤訊息：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ModuleNotFoundError: No module named &lt;span class=&quot;string&quot;&gt;&amp;#x27;configs&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;這就牽涉到，Python 直譯器在 import 時，究竟「&lt;strong&gt;如何尋找 import 路徑&lt;/strong&gt;」議題。&lt;/p&gt;</summary>
    
    
    
    <category term="VS Code" scheme="https://blog.kyomind.tw/categories/VS-Code/"/>
    
    
    <category term="VS Code" scheme="https://blog.kyomind.tw/tags/VS-Code/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="PYTHONPATH" scheme="https://blog.kyomind.tw/tags/PYTHONPATH/"/>
    
  </entry>
  
  <entry>
    <title>09，我的 Macbook 之旅 + 新的野心</title>
    <link href="https://blog.kyomind.tw/weekly-review-09/"/>
    <id>https://blog.kyomind.tw/weekly-review-09/</id>
    <published>2023-02-05T12:10:37.000Z</published>
    <updated>2023-04-02T12:15:23.660Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>過年期間，什麼正事都沒做，天天睡到中午，非常愜意。</p><p>唯一勉強和「正事」沾得上邊的，就是花了一堆時間在 YouTube 上，觀看最新發表的 M2 Pro&#x2F;Max Macbook Pro 與 2021 版的差異介紹、評測影片。</p><p>因為我想要幫自己換電腦了！</p><span id="more"></span><hr><h2 id="我的第一台-Macbook"><a href="#我的第一台-Macbook" class="headerlink" title="我的第一台 Macbook"></a>我的第一台 Macbook</h2><p>說起來，我的第一台蘋果電腦，是 2016 年底時買的 <a href="https://www.apple.com/tw/shop/product/FRQN2TA/A/12-%E5%90%8B-MacBook-12GHz-%E9%9B%99%E6%A0%B8%E5%BF%83-Intel-Core-m3-%E6%95%B4%E4%BF%AE%E5%93%81-%E9%87%91%E8%89%B2">12 吋 Macbook 整修品</a>。（但我的是銀色的）</p><p>之所以可以接受這樣的規格，是因為當時沒有想到自己，竟然會需要用它來寫程式！那時還在執行分署當書記官，所以只視它為普通的下班休閒文書機。</p><p>當時買它，是看上了 Macbook 系列的螢幕品質，事後證明，確實令人滿意。</p><p>彼時的 Macbook 都還很貴，不像現在的入門款，便宜且效能強大。所以，哪怕是整修品，也要 35400 新台幣。</p><p>轉職以後，我竟然還用它寫了足足 2 年程式，回想 12 吋 Macbook 視野之狹窄、效能之孱弱——打開 VS Code 時，我都可以先去倒杯水了。</p><h2 id="我的第二台-Macbook：Macbook-Air-2020-Intel-版"><a href="#我的第二台-Macbook：Macbook-Air-2020-Intel-版" class="headerlink" title="我的第二台 Macbook：Macbook Air 2020 Intel 版"></a>我的第二台 Macbook：Macbook Air 2020 Intel 版</h2><p>有了前車之鑑，我心想：「下一台一定要告別小螢幕與低效能！」，2020 年 8 月，我入手了 Macbook Air。</p><p>這台 Air，相比於前一代，各方面的規格都有大幅提升。CPU 從雙核升級到 4 核，而且不再是 Intel 14nm+++++，而是初代的 10 奈米產品（Ice Lake），RAM 也從萬年的 DDR3 2133 升級成 DDR4 3733。</p><p>那時我還很得意，心想：「等了這麼久，忍過了幾乎沒啥提升的前一代，這下子總算苦盡甘來了！😎」</p><p>結果 2020 年 11 月，Apple 就發表了 M1。</p><p>Apple 要為旗下的 Macbook 改用 ARM 架構處理器，這是我們早就知道的，我們唯一不知道的是：<strong>M1 的效能竟是如此的變態！</strong></p><p>頓時讓我的 Intel 版 Macbook 變成一個笑話。我只好安慰自己：「至少它可以 Boot Camp 灌 Windows！」</p><h2 id="令人失望的-M2-Pro-x2F-Max-Macbook-Pro"><a href="#令人失望的-M2-Pro-x2F-Max-Macbook-Pro" class="headerlink" title="令人失望的 M2 Pro&#x2F;Max Macbook Pro"></a>令人失望的 M2 Pro&#x2F;Max Macbook Pro</h2><p>轉眼間，這台 Macbook Air 也服役了兩年半了，它的效能果然是——<strong>真的不太行 XD。</strong></p><p>儘管當初已幫它加到了 16 GB RAM 和 1 TB SSD，也救不了弱弱的 CPU。所以我一直期待著這次的 M2 Pro&#x2F;Max 系列。</p><p>一經推出，知道不是採用台積電 3 奈米製程，心就先涼了半截——效能的提升幅度已完全可以預料，並不會有太誇張的升幅。</p><blockquote><p><code>2023/02/25</code>：後來看了<a href="https://youtu.be/BGQUtTBnhzI">這個影片</a>，才知道其實 N3 製程也有許多版本，所以即便後續採用，提升也未必如想像中巨大——那我就放心了🤣</p></blockquote><p>沒有 3 奈米，也罷！然而在看了一堆評測影片以後（我主要看 <a href="https://www.youtube.com/c/MaxTechOfficial/videos">Max Tech</a> 和<a href="https://www.youtube.com/@Petersun/videos">彼得森</a>），又發現新版的 Macbook Pro，竟還伴隨著一些「<strong>降級</strong>」：</p><ul><li><a href="https://youtu.be/kaGGyXzBG2M">散熱片的面積變小</a>，對於我想買的 14 吋的影響比 16 吋更大。</li><li><a href="https://www.youtube.com/watch?v=20eIt1XGNGA&t=548s">入門款的 SSD 變慢</a>，這個相信大家已經熟知了。在定價 1999 美元的產品上還這樣省成本，令我難以苟同。雖然我不太可能真的選擇入門款的大小，但還是覺得十足反胃。</li><li>變貴了！好啦，這不算降級，而且美元定價是沒變的，但因為匯率變貴了，台幣定價硬生生漲了 5000，不可謂不痛。</li></ul><p>上面的變動可能不算什麼，但考慮到整體的升級幅度確實不大，我頓時就不想買新版的  Macbook Pro 了。</p><h2 id="我買了-14-吋-Macbook-Pro-2021-整修品"><a href="#我買了-14-吋-Macbook-Pro-2021-整修品" class="headerlink" title="我買了 14 吋 Macbook Pro 2021 整修品"></a>我買了 14 吋 Macbook Pro 2021 整修品</h2><p>相較於新的 Macbook Pro，舊版的 2021 版整修品，CP 值真的爆炸高！</p><p>Apple 的整修品我基本上當新品看待，而且我的第一台 Macbook 就是。只是要等新品上市半年後才會開始有，所以沒事也不會特別等。</p><p>入手這台只要 57600，全新版的定價為 74900（現已下架），其規格如下：</p><ul><li>M1 Pro 高階版：10 核 CPU + 16 核 GPU</li><li>16 GB RAM</li><li>1 TB SSD</li></ul><p>看起來很不錯，本來整修品的定價是 67400，在新 Macbook Pro 發表後，再度降價為 57600，這價格真的太殺了！</p><p>做了許多功課，我知道它不止比新 Macbook Pro 更便宜（新版類似規格要 79900），而且效能還相去不遠，認真思考了一天後就下標了。</p><h2 id="我來，我見，我退貨"><a href="#我來，我見，我退貨" class="headerlink" title="我來，我見，我退貨"></a>我來，我見，我退貨</h2><p>收到後，用了幾個小時，我突然意識一件非常重要的事：</p><blockquote><p>我其實並不需要一台 Macbook Pro。</p></blockquote><p>仔細想想，其原因有二：</p><ol><li>除了過年回家，我幾乎很少帶筆電出門使用。</li><li>即使要帶出門，14 吋這個大小與重量，實在不是我喜歡帶著移動的份量。外出我只能接受 Air。</li></ol><p>加上同時也打算為自己入手人生的第一台螢幕（不誇張，這輩子還沒買過螢幕🙈），Macbook Pro 那精美的 Mini LED 螢幕對我也變得無關緊要。</p><p>這時我才<strong>恍然大悟</strong>：原來我需要的不是 Macbook Pro，而是配備了 M2 Pro 處理器的 <a href="https://www.apple.com/tw/mac-mini/">Mac mini</a>！——YouTuber Marques Brownlee <a href="https://youtu.be/cneoANZKBGk">稱它是一台「Game Changer」</a>。</p><p>這個認知讓我<strong>豁然開朗</strong>，而且我知道，如果不是「<strong>真的</strong>」買了一台 Macbook Pro，我是很難產生<strong>這麼清晰的想法與好惡。</strong></p><p>換句話說，<strong>有些事，往往只有試了才能知曉。</strong></p><p>所以我選擇了退貨，繼續等待台灣新 Mac mini 上市。</p><hr><h2 id="小結：新的野心"><a href="#小結：新的野心" class="headerlink" title="小結：新的野心"></a>小結：新的野心</h2><p>這次我不止打算買新電腦而已，沒錯，如前所言，我還打算買新螢幕與相關道具（螢幕掛燈、支架）。</p><p>經過無數爬文與爬影片，預計會入手貴鬆鬆的 <a href="https://www.apple.com/tw/studio-display/">Studio Display</a>。</p><p>對於螢幕，我也做了相當大量的功課（過個年真是不輕鬆），從機型選擇的變遷，到 macOS 在渲染不同解析度 HiDPI 的做法差異與對效能的影響，都足以再另成篇章了。</p><p>總之，新的一年，讓我們一起快快樂樂地寫程式吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;過年期間，什麼正事都沒做，天天睡到中午，非常愜意。&lt;/p&gt;
&lt;p&gt;唯一勉強和「正事」沾得上邊的，就是花了一堆時間在 YouTube 上，觀看最新發表的 M2 Pro&amp;#x2F;Max Macbook Pro 與 2021 版的差異介紹、評測影片。&lt;/p&gt;
&lt;p&gt;因為我想要幫自己換電腦了！&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="產品評論" scheme="https://blog.kyomind.tw/tags/%E7%94%A2%E5%93%81%E8%A9%95%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>08，年末特輯下：2022 工作與程式學習總結</title>
    <link href="https://blog.kyomind.tw/weekly-review-08/"/>
    <id>https://blog.kyomind.tw/weekly-review-08/</id>
    <published>2023-01-29T08:28:52.000Z</published>
    <updated>2023-03-14T08:43:25.125Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-07/">07，年末特輯上：2022 寫作反省與明年目標</a></p></blockquote><p>「今天是公司尾牙，也是我進公司剛滿一年半。」——本來要用這兩句作為開頭的🤣。結果年假放起來，一轉眼兩星期過去，驀然回首，2023 年 1 月都快結束了！</p><p>不得不說，2022 才是我身為軟體工程師，覺得自己比較有進步的第一年。儘管不特別勤奮，但對細節還是相當講究的，尤其是「團隊文件文化」的建立，與程式碼可讀性的落實。</p><p>個人部分，寫程式的能力，要說提升多少，可能也沒有——code review 功力倒是明顯提升了，主還是在於一些重要工具的熟悉、應用上。</p><p>這些工具是在 Python 開發工作上佔據一定重要性，有著「應用廣、可延續」的特性，並擔當「讓團隊開發更加高效且健全」的角色。</p><p>可以說，作為一個稱職的 Python 開發者，就應該要使用這些東東！</p><p>其中的一部分，去年已經寫成教學文章。剩下的還沒動筆的，今年也要寫出來。接下來就來盤點一下，它們具體是哪些。</p><span id="more"></span><hr><h2 id="一、使用-Poetry-管理專案的-Python-虛擬環境"><a href="#一、使用-Poetry-管理專案的-Python-虛擬環境" class="headerlink" title="一、使用 Poetry 管理專案的 Python 虛擬環境"></a>一、使用 Poetry 管理專案的 Python 虛擬環境</h2><p>在〈<a href="https://blog.kyomind.tw/python-poetry/">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a>〉中，我並沒有具體提及團隊改採用 Poetry 的理由，但在<a href="https://www.facebook.com/groups/pythontw/permalink/10162017819458438/">臉書社團的宣傳文</a>中則有這段發言：</p><blockquote><p>前陣子工作專案在新增一個簡單的 feature 後，我赫然發現明明專案規模還不算大，Python 虛擬環境所安裝的套件數量竟然堂堂突破了 200 大關（拜 Azure SDK 所賜），產生的 Docker image 也超過 2 GB，真是太誇張了！</p></blockquote><p>這是不能接受的！</p><p>不過即便用了一段時間，還是難免覺得，Poetry 真的「不算」是個容易上手的工具。有時候我還是會回頭看自己的文章，才能想起來某件事要怎麼下指令。</p><p>但整體而言，絕對值得啦！而且它的套件管理機制，也不像 <a href="https://blog.marsen.me/2022/09/08/2022/how_to_npm_update_more_smoothly/">npm 那樣，容易過度肥大，甚至會形成黑洞（一個迷因）</a>。</p><h2 id="二、使用-pytest-撰寫-API-單元測試"><a href="#二、使用-pytest-撰寫-API-單元測試" class="headerlink" title="二、使用 pytest 撰寫 API 單元測試"></a>二、使用 pytest 撰寫 API 單元測試</h2><p>可能是去年「第二重要」的事！</p><p>我想，單元測試，或者說寫測試，是「<strong>最有效</strong>」改善一個工程師平時寫程式的「不良習慣」的一種手段——因為它要求你對自己寫下的程式碼的品質，負起責任。</p><p>而且光單元測試本身就很多學問——還真的非常多，比如這篇〈<a href="https://www.marclittlemore.com/how-to-write-high-quality-unit-tests/">How To Write High Quality Unit Tests</a>〉。不過對剛接觸測試的我們，用一個好工具如 pytest，把基本的測試寫出來，就已經有 60 分了！</p><p>用過 pytest 就能感受到它是如此的<strong>強大而優雅</strong>，優雅的點在於，它能讓測試程式碼本身就盡可能「<strong>有秩序、好讀好維護</strong>」（當然這需要一定深思熟慮的設計與落實），尤其在<strong>專案與測試規模愈來愈大</strong>的時候，pytest 的優勢將會更加突顯。</p><p>難怪 pytest 能在軟體 QA 等各種測試領域都佔據一定地位，更別說對一般的開發者了——不用說，我們要善用它。</p><h2 id="三、MongoEngine-ORM-存取-MongoDB"><a href="#三、MongoEngine-ORM-存取-MongoDB" class="headerlink" title="三、MongoEngine ORM 存取 MongoDB"></a>三、MongoEngine ORM 存取 MongoDB</h2><p>ORM 這東西到底是否必要，<a href="https://ionutbalosin.com/2021/12/do-we-really-need-an-orm/">向來都有爭論</a>。在存取需求不複雜的情況下，我還是偏好 ORM，這裡就是很好的例子。</p><p>我們只是想把 gateway 的 config（多層且不固定的資料結構）透過 MongoDB 儲存，有了 MongoEngine 這樣的 ORM 工具，就不需要知曉太多 MongoDB 細節，可以減輕一開始的實作負擔。</p><p>不過不可否認，工具本身也需要學習🐸，而學習就是成本！這部分可參考〈<a href="https://blog.kyomind.tw/django-mongoengine/">Django 專案 ORM 存取 MongoDB：MongoEngine 設定教學</a>〉。後續預計會再寫一、兩篇操作教學文。</p><h2 id="四、Linter、Formatter、pyproject-toml、pre-commit"><a href="#四、Linter、Formatter、pyproject-toml、pre-commit" class="headerlink" title="四、Linter、Formatter、pyproject.toml、pre-commit"></a>四、Linter、Formatter、pyproject.toml、pre-commit</h2><p>如果測試是第二重要，那什麼才是最重要的事？——確保程式碼的<strong>規範與一致性</strong>。</p><p>「一致性」在團隊協作的重要程度，容易被輕忽。</p><p>對於相同功能與目標，卻有著（截然）不同的寫法，其中造成的<strong>思考停頓、理解混淆、bug 滋生</strong>等，這些額外的隱性成本，並不容易計算，但確確實實存在。</p><p>你我都知道，這就是一種「<strong>程式碼的不衛生</strong>」。</p><p>本段標題的工具們就是為了落實規範與一致性，降低「程式碼不衛生」的可能，我視它們為程式開發基石，所以自然是第一重要的事。</p><hr><h2 id="小結：2023-上半年目標"><a href="#小結：2023-上半年目標" class="headerlink" title="小結：2023 上半年目標"></a>小結：2023 上半年目標</h2><p>我在今年上半年（除日常開發外）的自訂工作績效，列了下面幾個小目標，供參：</p><ol><li>為全部專案實作完整的 logging。</li><li>大量導入 type hints 與相關工具如 <a href="https://github.com/python/mypy">mypy</a>。</li><li>增進單元測試品質（增加測試覆蓋率與降低外部耦合）。</li></ol><p>儘管每個目標都不算大，但透過一步步累積與向外擴展，我們應該都能過上踏實的開發人生。🐧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-07/&quot;&gt;07，年末特輯上：2022 寫作反省與明年目標&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;「今天是公司尾牙，也是我進公司剛滿一年半。」——本來要用這兩句作為開頭的🤣。結果年假放起來，一轉眼兩星期過去，驀然回首，2023 年 1 月都快結束了！&lt;/p&gt;
&lt;p&gt;不得不說，2022 才是我身為軟體工程師，覺得自己比較有進步的第一年。儘管不特別勤奮，但對細節還是相當講究的，尤其是「團隊文件文化」的建立，與程式碼可讀性的落實。&lt;/p&gt;
&lt;p&gt;個人部分，寫程式的能力，要說提升多少，可能也沒有——code review 功力倒是明顯提升了，主還是在於一些重要工具的熟悉、應用上。&lt;/p&gt;
&lt;p&gt;這些工具是在 Python 開發工作上佔據一定重要性，有著「應用廣、可延續」的特性，並擔當「讓團隊開發更加高效且健全」的角色。&lt;/p&gt;
&lt;p&gt;可以說，作為一個稱職的 Python 開發者，就應該要使用這些東東！&lt;/p&gt;
&lt;p&gt;其中的一部分，去年已經寫成教學文章。剩下的還沒動筆的，今年也要寫出來。接下來就來盤點一下，它們具體是哪些。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
    <category term="MongoEngine" scheme="https://blog.kyomind.tw/tags/MongoEngine/"/>
    
    <category term="pytest" scheme="https://blog.kyomind.tw/tags/pytest/"/>
    
  </entry>
  
</feed>
