<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2023-10-04T18:11:01.153Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>別依賴「試誤法」寫程式</title>
    <link href="https://blog.kyomind.tw/stop-trial-and-error/"/>
    <id>https://blog.kyomind.tw/stop-trial-and-error/</id>
    <published>2023-10-04T17:42:55.000Z</published>
    <updated>2023-10-04T18:11:01.153Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>這個情況真的太普遍，尤其是知識不夠紮實（指<strong>為開發所做的功課太少</strong>）的開發者。但如下所述，其實這是一個「<strong>開發習慣</strong>」議題。</p><p>無論如何，我不得不為此發聲：「<strong>請停止用『試誤法』來寫程式</strong>！」</p><p>我們先看看維基百科對於「<a href="https://zh.wikipedia.org/zh-tw/%E5%B0%9D%E8%AF%95%E9%94%99%E8%AF%AF%E6%B3%95">試誤法</a>」的闡述：</p><blockquote><p><strong>嘗試錯誤法</strong>，又稱<strong>試誤法</strong>（英語：trial and error），簡稱<strong>試錯</strong>，是用來解決問題、獲取知識。此種方法可以視為簡易解決問題的方法中的一種，與使用洞察力／直覺或理論推理的方法正好相反。</p></blockquote><p>就像這句「此種方法可以視為簡易解決問題的方法中的一種」說的，在我看來，試誤法常常會得到 workaround（雖不能根本解決，但能<strong>避開問題</strong>的替代方法）等級的答案——這肯定不是好事。</p><p>首先我得說，「試誤」在軟體開發中，是一個常見且實用的手段。</p><p>我自己寫一些邏輯時，也常常在 jupyter notebook 先執行嘗試執行一下程式碼片段，看看結果，以確保我的想法沒錯。<strong>但，這只是一種輔助。</strong></p><p>本文想強調的是：<strong>不要以「試誤」作為開發的基調，或解決問題的主要方式</strong>。換言之就是，<strong>不要濫用試誤</strong>。</p><p>否則那將是一場災難。</p><p>無數次 trial and error，看起來勤勤懇懇，實際上是<strong>最低效的開發手段</strong>。我覺得，試個兩、三次行不通，就應該<strong>重新思考問題的本質——而非繼續嘗試。</strong></p><span id="more"></span><p>以下我們從除錯（debug）與開發（develop）兩個角度，來看看「濫用試誤法」帶來的悲劇。</p><hr><h2 id="Debug-時的濫用試誤"><a href="#Debug-時的濫用試誤" class="headerlink" title="Debug 時的濫用試誤"></a>Debug 時的濫用試誤</h2><p>Debug 和試誤法似乎挺搭的，不是嗎？一步一步嘗試，直接全都正確了為止。</p><p>看似如此，但實際上<strong>正好相反</strong>。</p><p><strong>把試誤心態用在 debug，恰恰是讓 bug 不斷滋生的主要原因。</strong></p><p>試誤的基本心態是「結果好，一切好」，但我們 debug 往往不僅是為了把當下的錯誤消除掉而已。</p><p>更多時候，<strong>我們想要知曉錯誤發生的「原因」為何</strong>，以及是否存在會引發相關錯誤的其它原由——這些都是試誤法不關心的。</p><p>所以，debug 時，試誤只能作一種<strong>很次要的輔助手段</strong>，我們的目標應該是「<strong>找出錯誤的原因，並想辦法防止同類型錯誤的發生</strong>」。</p><p>只要找不到問題的本源，那後續可有的「試」了。</p><h2 id="開發時的濫用試誤"><a href="#開發時的濫用試誤" class="headerlink" title="開發時的濫用試誤"></a>開發時的濫用試誤</h2><p>別想說只有 debug 才容易讓人陷入試誤的濫用。以「試誤心態」進行開發，我認為也非常普遍！</p><p>這樣的開發者的什麼樣的<strong>習性</strong>？以開發一個新功能為例，常常有以下流程：</p><ul><li>想到什麼就寫什麼——單純把自然語言的需求，翻譯成程式碼，我稱之為「<strong>機器翻譯</strong>」</li><li>從頭到尾寫完，然後看看程式運行會不會出錯（寫完也不重構一下，就像文章草稿完成後，直接發表）</li><li>發現執行結果有錯，看一下錯誤訊息，調整一下程式碼</li><li>可以了！好，下一個功能</li></ul><p>這樣的開發方式有什麼問題？看起來好像也不算太差呀？</p><p>確實，在簡單的需求時，這種開發方式（或說心態、習性）可能是「效率最高」的做法！——姑且不論程式碼品質。</p><h2 id="試誤處理不了複雜"><a href="#試誤處理不了複雜" class="headerlink" title="試誤處理不了複雜"></a>試誤處理不了複雜</h2><p>但只要需求變化、複雜化，包括後續的擴充，這樣的開發方式就不太妙了。</p><p>因為缺乏全局觀與開發工具（套件、框架）重要知識——講白了就是文件看太少，畢竟之前的開發成果主要是靠「試」出來的。</p><p>此時「試誤型開發者」會陷入一個迴圈：</p><ol><li>發現程式執行結果不如預期（未必是無法執行，但就是不如預期）</li><li>不確定原因為何（因為常常都是靠「試誤」在解決問題）</li><li>不斷調整寫法、不斷觀察程式執行結果</li><li>回到前述 1</li></ol><p>隨著專案愈來愈複雜，程式碼行數不斷擴張，這種情況也將隨之增加。</p><p>一言以蔽之，試誤無法有效處理複雜。處理複雜，需要你有系統地思考、更全面的知識——最好多看文件、多問 ChatGPT。而非簡單的試誤。</p><p>但在簡單的需求下，試誤卻是一個<strong>快速完成開發的誘人捷徑</strong>。總是依賴試誤法開發，在複雜的情況就容易原形畢露。</p><hr><h2 id="試誤依賴的根本問題"><a href="#試誤依賴的根本問題" class="headerlink" title="試誤依賴的根本問題"></a>試誤依賴的根本問題</h2><p>現在有了 ChatGPT 這個強力工具，理論上我們的開發水準都在相應提升。</p><p>但是，我必須說，對於依賴試誤開發的人而言，ChatGPT 對他們帶來的提升，<strong>可能是最小的——why</strong>？</p><p>因為這類人很容易把試誤心態帶入 ChatGPT 的使用習慣，所以就變成了「向 ChatGPT 要答案」：</p><ul><li>可以了！→下一題</li><li>不行耶！→修改問題再問一次、補充內容</li></ul><p>反正我要的就是答案，至於原理是什麼，暫且不論。</p><p>沒錯，這只是<strong>另一種方式的試誤</strong>而已。（或許我們可以稱之為「<strong>AI 輔助試誤法</strong>」）</p><p>這樣做絕對可以讓開發變得更快，卻未必能變得「更好」。</p><hr><h2 id="小結：試誤是機器的事"><a href="#小結：試誤是機器的事" class="headerlink" title="小結：試誤是機器的事"></a>小結：試誤是機器的事</h2><p>試誤是機器的事，因為機器擅長此道。沒有人能夠在 1 秒內發出 1000 個請求，但機器卻能輕鬆辦到。</p><p>直白地說，如果軟體工程師終有一天會被 AI 取代，那我相信第一波肯定最先取代這些「把 AI 當作試誤工具」的人。</p><p>因為他們把自己當「試誤機器」在操作——但人終究不是機器。</p><p>在快速試誤的競賽中，人和機器誰更有勝算呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;這個情況真的太普遍，尤其是知識不夠紮實（指&lt;strong&gt;為開發所做的功課太少&lt;/strong&gt;）的開發者。但如下所述，其實這是一個「&lt;strong&gt;開發習慣&lt;/strong&gt;」議題。&lt;/p&gt;
&lt;p&gt;無論如何，我不得不為此發聲：「&lt;strong&gt;請停止用『試誤法』來寫程式&lt;/strong&gt;！」&lt;/p&gt;
&lt;p&gt;我們先看看維基百科對於「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%B0%9D%E8%AF%95%E9%94%99%E8%AF%AF%E6%B3%95&quot;&gt;試誤法&lt;/a&gt;」的闡述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;嘗試錯誤法&lt;/strong&gt;，又稱&lt;strong&gt;試誤法&lt;/strong&gt;（英語：trial and error），簡稱&lt;strong&gt;試錯&lt;/strong&gt;，是用來解決問題、獲取知識。此種方法可以視為簡易解決問題的方法中的一種，與使用洞察力／直覺或理論推理的方法正好相反。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就像這句「此種方法可以視為簡易解決問題的方法中的一種」說的，在我看來，試誤法常常會得到 workaround（雖不能根本解決，但能&lt;strong&gt;避開問題&lt;/strong&gt;的替代方法）等級的答案——這肯定不是好事。&lt;/p&gt;
&lt;p&gt;首先我得說，「試誤」在軟體開發中，是一個常見且實用的手段。&lt;/p&gt;
&lt;p&gt;我自己寫一些邏輯時，也常常在 jupyter notebook 先執行嘗試執行一下程式碼片段，看看結果，以確保我的想法沒錯。&lt;strong&gt;但，這只是一種輔助。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文想強調的是：&lt;strong&gt;不要以「試誤」作為開發的基調，或解決問題的主要方式&lt;/strong&gt;。換言之就是，&lt;strong&gt;不要濫用試誤&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;否則那將是一場災難。&lt;/p&gt;
&lt;p&gt;無數次 trial and error，看起來勤勤懇懇，實際上是&lt;strong&gt;最低效的開發手段&lt;/strong&gt;。我覺得，試個兩、三次行不通，就應該&lt;strong&gt;重新思考問題的本質——而非繼續嘗試。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>Kyo&#39;s Django Tutorial：系列介紹與導讀</title>
    <link href="https://blog.kyomind.tw/django-tutorial/"/>
    <id>https://blog.kyomind.tw/django-tutorial/</id>
    <published>2023-09-30T08:48:35.000Z</published>
    <updated>2023-10-03T02:05:57.737Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="github.com/kyomind/Django-Tutorial"><span class="cap">github.com/kyomind/Django-Tutorial</span></p><p>這是「<a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a>」系列文章的第「0」篇，也就是序言。</p><p>主要說明整個系列的寫作動機、文章規劃，並介紹 GitHub 倉庫的使用方式。</p><p>嘗試寫作這樣「單一主題長系列連載」的靈感，源於下列二者：</p><ul><li><a href="https://www.maxlist.xyz/2020/01/01/author/">Max 行銷誌</a>的 <a href="https://www.maxlist.xyz/2020/05/01/flask-list/">2023 Flask 入門指南</a></li><li><a href="https://blog.aotoki.me/">蒼時弦也</a>的<a href="https://blog.aotoki.me/series/">系列連載</a></li></ul><p>兩位都是「<strong>既能做又能寫</strong>」的優秀開發者，值得我們學習。</p><hr><h2 id="系列寫作動機"><a href="#系列寫作動機" class="headerlink" title="系列寫作動機"></a>系列寫作動機</h2><p>雖然 blog 上本來就有少數被我歸類為「系列」的文章，比如 <a href="https://blog.kyomind.tw/simple-notion/#%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion%E2%80%94%E2%80%94%E6%88%91%E7%9A%84-Notion-%E7%B0%A1%E6%BD%94%E4%B9%8B%E9%81%93">Simple Notion 系列</a>。但最多就是 3-4 篇，這是我有意控制的結果，希望整個創作週期不要拉得太長。</p><p>而且用 3-4 篇呈現、表達一個我認為重要的主題，通常也足夠了。</p><p>後來想到自己雖然在工作上寫了 2 年 Django，對 Django 的文章介紹卻非常少。讓我不免覺得，自己有違作為一個 Django 開發者的「義務」。</p><p>所以起心動念，想說至少寫個「Django Models」三部曲，也就是目前整個系列中，在時間軸上第一篇發表的文章〈<a href="https://blog.kyomind.tw/django-models/">Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</a>〉。</p><p>寫完後又沉寂了好一段時間，才有了這篇序言。</p><span id="more"></span><h2 id="從-Django-Models-到-Django-API"><a href="#從-Django-Models-到-Django-API" class="headerlink" title="從 Django Models 到 Django API"></a>從 Django Models 到 Django API</h2><p>Django models 可以說是 Django 最常見的議題（它確實非常重要），網路上的介紹文章已經不少。</p><p>所以即使寫完這三部曲，我覺得恐怕對讀者的助益仍是有限，想到這裡難免有點動搖，於是遲遲不見第二篇。</p><p>後來又思考了一番，既然如此，那我乾脆把工作中常見的 Django 實作加入這個系列，無疑會更有價值、更完整。</p><p>尤其繁體中文世界對於 Django 的介紹，大多停留在<strong>製作整個網站</strong>（主要介紹模板、Form、View、Model），而不是開發 API——用 Django 開發 API 的相關教材太少了。</p><p>這個現象不難理解，因為在台灣使用 Django 作為產品主要後端的公司相對有限，所以文章分享自然就不是那麼多。</p><p>但工作中你幾乎不太可能直接用 Django 來開發整個網站，畢竟這是個前後端分離的年代。</p><p>想到這裡，寫作 Django 系列教學的動力又回升了！這或許就是我的使命。</p><h2 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h2><p>因此，這系列文章主要針對那些已有 Python 基礎，但想要進一步了解 Django 網頁開發，尤其是「<strong>用 Django 開發 Web API</strong>」的讀者。</p><p>畢竟開發 API 才是我的 Django 日常。</p><p>所以我不得不遺憾地表示，這個系列將不會有任何關於「Django 模板、表單」元件等介紹，也不會討論上述元件與 Django View 的整合議題。</p><p>而是完全以「API」為核心。</p><hr><h2 id="文章規劃"><a href="#文章規劃" class="headerlink" title="文章規劃"></a>文章規劃</h2><p>目前計畫分成三大部分。</p><h3 id="一、Django-ORM"><a href="#一、Django-ORM" class="headerlink" title="一、Django ORM"></a>一、Django ORM</h3><p>無論全端還是前後端分離，<strong>Django ORM 的重要性與地位都不會有任何影響</strong>，所以 ORM 三部曲自然還是要一一介紹。</p><p>而且會放在整個系列的最靠前部分。</p><p>目前規劃的文章為：</p><ol><li>Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</li><li>Django ORM：一對一、一對多外鍵教學（中）反向關聯</li><li>Django ORM：一對一、一對多外鍵教學（下）查詢篇</li></ol><p>而且，整個 Django 框架中，我最愛的部分就是 Django ORM——它<strong>強大而優雅</strong>。</p><h3 id="二、pytest-單元測試"><a href="#二、pytest-單元測試" class="headerlink" title="二、pytest 單元測試"></a>二、pytest 單元測試</h3><p>我相信，沒有單元測試的開發，是「不健全」的開發。</p><p>自己的程式自己測，優秀的開發者不會把「低級錯誤」留給 QA，讓 QA 當保姆。</p><p>哪怕只是最基本的，為每一個 API 加上 200 回傳值的單元測試，都遠比沒有來得強。有了測試，再來就是覆蓋率報告。</p><p>文章預計有下：</p><ol><li>Django 測試指南：用 pytest 撰寫 API 單元測試——環境設定篇</li><li>Django 測試指南：用 pytest 撰寫 API 單元測試——Fixtures 篇</li><li>Django 測試指南：使用 pytest + pytest-cov 計算 Test Coverage</li></ol><h3 id="三、Django-API"><a href="#三、Django-API" class="headerlink" title="三、Django API"></a>三、Django API</h3><p>講到 Django API，就不得不提 <a href="https://www.django-rest-framework.org/">Django REST framework</a>（下稱 DRF），尤其是它提供的 <a href="https://www.django-rest-framework.org/api-guide/views/">API view</a>（無論 <a href="https://ithelp.ithome.com.tw/articles/10205779">CBV 或 FBV</a>）與<a href="https://www.django-rest-framework.org/api-guide/serializers/">序列化器</a>。</p><p>當然，時代在變遷，如今開發 Django API 並非只能選擇 DRF，後起之秀 <a href="https://django-ninja.rest-framework.com/">Django Ninja</a> 也值得一試。</p><p>尤其它支援 <a href="https://docs.pydantic.dev/latest/">Pydantic</a>，可以<strong>依程式碼自動生成 API 文件</strong>。你可以簡單想成，它就像是「Django 版的 FastAPI」。</p><p>不過我們的教學還是會以 DRF 為主。</p><p>預計主題有下，目前文章標題皆未定：</p><ul><li>用 DRF 開發 Django API</li><li>DRF 序列化器</li><li>檔案上傳</li><li>國際化（i18n）</li><li>DRF 分頁（Pagination）</li><li>logging</li></ul><p>如你所見，<strong>這並不是一個「大而全」的 Django 教學</strong>，而是<strong>以我自己的實務經驗為主</strong>，介紹我認為最重要且相對熟悉的部分。</p><p>主要的目標是讓讀者可以<strong>快速上手</strong>，並了解 Django API 開發的基本概念。</p><h3 id="非屬系列的-Django-教學"><a href="#非屬系列的-Django-教學" class="headerlink" title="非屬系列的 Django 教學"></a>非屬系列的 Django 教學</h3><p>Blog 的 <a href="https://blog.kyomind.tw/categories/Django/">Django 分類</a>，還是會寫一些和 Django 相關的文章，但不屬於這個大主題的一部分，所以沒有納入系列文章中。</p><p>比如現有的：</p><ul><li><a href="https://blog.kyomind.tw/django-request-headers/">Django：以 request.headers 而非 META 獲取 HTTP header 資訊</a></li><li><a href="https://blog.kyomind.tw/django-mongoengine/">Django 專案 ORM 存取 MongoDB：MongoEngine 設定教學</a></li></ul><hr><h2 id="GitHub-專案介紹"><a href="#GitHub-專案介紹" class="headerlink" title="GitHub 專案介紹"></a>GitHub 專案介紹</h2><p>最後，介紹與整個系列教學直接相關的 GitHub repository——<a href="https://github.com/kyomind/Django-Tutorial">Django Tutorial</a> 專案。</p><p>這個專案的核心定位是「讓有讀者實際程式碼可以參考」。所以基本上是拿來「看」的。</p><p>但實際上我會讓它也能夠真正運行，以方便想要自己動手嘗試的讀者。</p><p>所以會為你準備相對應的 db 資料（使用 Django fixtures）。讓你可以在運行起這個專案後，使用 Postman 等 api client，直接呼叫該 api 親身驗證結果。</p><p>我相信這對學習大有幫助。</p><h3 id="分支的功能"><a href="#分支的功能" class="headerlink" title="分支的功能"></a>分支的功能</h3><p>專案中會有許多分支，採<code>&lt;流水號-文章slug&gt;</code>的模式命名，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01-django-models</span><br></pre></td></tr></table></figure><p>分支主要是作為歷史記錄之用，以及快速查看該分支所對應的<strong>程式碼修改</strong>。</p><p>每個分支所在的 commit 與上一個分支的結束，基本就是整個分支的變更內容（除了我直接在<code>main</code>分支進行修改，比如更新 <code>README</code>）。也就是文章教學中，對專案程式碼新增的部分。</p><p>附帶一提，<strong>分支記錄並非只限 Django Tutorial 系列文章</strong>，別的相關文章可能也會有！</p><p>比如我某篇文章要講解「專案容器化」，用現有的專案來進行示範無疑再好不過，所以也會變動專案程式碼並留下分支記錄。</p><h2 id="為何需要「教學用專案」"><a href="#為何需要「教學用專案」" class="headerlink" title="為何需要「教學用專案」"></a>為何需要「教學用專案」</h2><p>如前所述，<strong>讓系列中的每篇文章，有相應的程式碼可供參考，而且可以實際運行，是我為何特地建立這個專案的核心理由。</strong></p><p>不得不說，維護這樣的專案比單純寫文章來得辛苦。因為如此一來，這些文章中的程式碼舉例，都需要<strong>圍繞著專案而設計</strong>——不能隨意為之，且須有一定的「連貫性」。</p><p>但這麼做的價值是顯而易見的，專案讓這些教學更有<strong>整體感</strong>，與<strong>真實感</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;github.com/kyomind/Django-Tutorial&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是「&lt;a href=&quot;https://blog.kyomind.tw/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt;」系列文章的第「0」篇，也就是序言。&lt;/p&gt;
&lt;p&gt;主要說明整個系列的寫作動機、文章規劃，並介紹 GitHub 倉庫的使用方式。&lt;/p&gt;
&lt;p&gt;嘗試寫作這樣「單一主題長系列連載」的靈感，源於下列二者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.maxlist.xyz/2020/01/01/author/&quot;&gt;Max 行銷誌&lt;/a&gt;的 &lt;a href=&quot;https://www.maxlist.xyz/2020/05/01/flask-list/&quot;&gt;2023 Flask 入門指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.aotoki.me/&quot;&gt;蒼時弦也&lt;/a&gt;的&lt;a href=&quot;https://blog.aotoki.me/series/&quot;&gt;系列連載&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;兩位都是「&lt;strong&gt;既能做又能寫&lt;/strong&gt;」的優秀開發者，值得我們學習。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;系列寫作動機&quot;&gt;&lt;a href=&quot;#系列寫作動機&quot; class=&quot;headerlink&quot; title=&quot;系列寫作動機&quot;&gt;&lt;/a&gt;系列寫作動機&lt;/h2&gt;&lt;p&gt;雖然 blog 上本來就有少數被我歸類為「系列」的文章，比如 &lt;a href=&quot;https://blog.kyomind.tw/simple-notion/#%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion%E2%80%94%E2%80%94%E6%88%91%E7%9A%84-Notion-%E7%B0%A1%E6%BD%94%E4%B9%8B%E9%81%93&quot;&gt;Simple Notion 系列&lt;/a&gt;。但最多就是 3-4 篇，這是我有意控制的結果，希望整個創作週期不要拉得太長。&lt;/p&gt;
&lt;p&gt;而且用 3-4 篇呈現、表達一個我認為重要的主題，通常也足夠了。&lt;/p&gt;
&lt;p&gt;後來想到自己雖然在工作上寫了 2 年 Django，對 Django 的文章介紹卻非常少。讓我不免覺得，自己有違作為一個 Django 開發者的「義務」。&lt;/p&gt;
&lt;p&gt;所以起心動念，想說至少寫個「Django Models」三部曲，也就是目前整個系列中，在時間軸上第一篇發表的文章〈&lt;a href=&quot;https://blog.kyomind.tw/django-models/&quot;&gt;Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定&lt;/a&gt;〉。&lt;/p&gt;
&lt;p&gt;寫完後又沉寂了好一段時間，才有了這篇序言。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>重啟了 Twitter 與我的理由</title>
    <link href="https://blog.kyomind.tw/return-to-twitter/"/>
    <id>https://blog.kyomind.tw/return-to-twitter/</id>
    <published>2023-09-27T17:15:14.000Z</published>
    <updated>2023-09-30T08:25:00.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>上個月重新登入了塵封一段時間的 Twitter（下稱推特）帳戶。也開始在上面發一些零星的推文——幾乎都是程式相關。</p><p>一直以來我都稱不上推特的重度用戶，如果有一個社群平台是我獲取資訊的來源，那主要還是臉書。</p><p>但我們知道，臉書在幾波隱私相關的大事件後，演算法有了較為明顯的改動。很多人——包括我在內——都覺得臉書的推薦內容不再像過去那般有趣、實用。</p><p>於是在轉職後的這幾年，我也開始看推特。</p><hr><h2 id="Cal-Newport-對推特的看法"><a href="#Cal-Newport-對推特的看法" class="headerlink" title="Cal Newport 對推特的看法"></a>Cal Newport 對推特的看法</h2><p>如果你看比較多 Cal Newport 的內容（主要是 Podcast），你會發現，他雖然沒有任何社群平台帳戶，但他對推特的討論與關注，遠遠超過對其它平台的討論，比如臉書、Substack。</p><p>〈<a href="https://www.thedeeplife.com/podcasts/episodes/ep-241-the-virality-trap/">EP. 241: The Virality Trap</a>〉這集有一定的代表性。</p><span id="more"></span><p>他的基本論調是「推特的影響力被高估了」，大概用詞則是（ChatGPT 整理）：</p><blockquote><p>這是虛榮的販賣機——卻不一定能帶來真實價值。</p></blockquote><blockquote><p>他認為，這些社交媒體平台<strong>只是在吸收用戶的注意力</strong>，並將其轉化為收益，而不是真正的為用戶提供有價值的內容。</p></blockquote><blockquote><p>最後，他強調了一個觀點，那就是最好的策略是遠離這些社交媒體平台，並將注意力集中在更深入、更有價值的事情上。</p></blockquote><p>哈哈，Cal Newport 最後的結論總是「遠離這些平台」。</p><h2 id="我對推特的看法"><a href="#我對推特的看法" class="headerlink" title="我對推特的看法"></a>我對推特的看法</h2><p>我基本認同上述 Cal Newport 觀點，只不過，因為推特並非我的主要舞台，所以我可能不太容易掉入這個「陷阱」中。</p><p>儘管如此，推特還是有一些我不喜歡（或說不適應）的特色。</p><h3 id="一、快速表達帶來的喧囂"><a href="#一、快速表達帶來的喧囂" class="headerlink" title="一、快速表達帶來的喧囂"></a>一、快速表達帶來的喧囂</h3><p>因為每一則都很短，所以用戶常常是想到什麼都趕緊發一推，這讓我感覺有點太喧囂。不過說真的，連我自己都不禁受到平台的影響，也變成類似的發文模式。</p><p>而我對抗這個「引力」的簡單做法就是，限制可以存取的時間。</p><h3 id="二、政治元素太多"><a href="#二、政治元素太多" class="headerlink" title="二、政治元素太多"></a>二、政治元素太多</h3><p>政治味最重的平台，無人能出其右。你也可以說，意識形態非常濃厚。</p><p>我使用推特主要是為了看程式相關的內容，所以總是盡可能把這些聲音 mute 掉。</p><p>並非我不關心政治，只是我「不想在這裡關心」——這裡有我更感興趣的主題。</p><h2 id="離開推特的原因"><a href="#離開推特的原因" class="headerlink" title="離開推特的原因"></a>離開推特的原因</h2><p>我不登入推特超過了半年時間，那時覺得不想再使用它，主要還是因為——成癮性。</p><p>我覺得推特的成癮力比臉書更甚，所以我比較難穩健控制。哪怕給自己訂了一些規則，它也都有足夠的力量，讓我打破規則。</p><p>而且這些社交平台的手機 app 使用體驗都設計得非常棒（用起來非常流暢），讓你動不動就想要打開。</p><p>很難想像我還只是一個中輕度用戶，成癮性就如此之強。</p><p>就在我某次搭公車，公車搖來搖去但我仍不斷忍著暈眩刷推時，我終於受夠了，刪除了 app。</p><hr><h2 id="重啟了-Twitter-與我的理由"><a href="#重啟了-Twitter-與我的理由" class="headerlink" title="重啟了 Twitter 與我的理由"></a>重啟了 Twitter 與我的理由</h2><p>理由主要有兩個。</p><h3 id="一、需要一個發表程式類內容的地方"><a href="#一、需要一個發表程式類內容的地方" class="headerlink" title="一、需要一個發表程式類內容的地方"></a>一、需要一個發表程式類內容的地方</h3><p>程式相關內容，發在個人臉書，總讓我覺得猶豫，畢竟我的臉友普遍不是軟體產業的人。</p><p>之前有期待過 <a href="https://www.threads.net/">Threads</a>，但因為要綁 Instagram 帳戶，而且沒有網頁版，讓我意興闌珊。</p><p>重啟了推特後，我發現，過去這些追尋都是多餘的，推特就是最適合的舞台！</p><h3 id="二、我想要看更多有趣的開發資訊"><a href="#二、我想要看更多有趣的開發資訊" class="headerlink" title="二、我想要看更多有趣的開發資訊"></a>二、我想要看更多有趣的開發資訊</h3><p>這點臉書就真的遠遠比不上，只有少數軟體工程師會經營臉書的粉專，但很多軟體工程師都有推特帳戶！且樂於分享開發相關的資訊。</p><p>比起單純的教學文章，這些推文往往帶有更多「經驗與價值偏好」，我覺得這也是推特最吸引我的地方。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上個月重新登入了塵封一段時間的 Twitter（下稱推特）帳戶。也開始在上面發一些零星的推文——幾乎都是程式相關。&lt;/p&gt;
&lt;p&gt;一直以來我都稱不上推特的重度用戶，如果有一個社群平台是我獲取資訊的來源，那主要還是臉書。&lt;/p&gt;
&lt;p&gt;但我們知道，臉書在幾波隱私相關的大事件後，演算法有了較為明顯的改動。很多人——包括我在內——都覺得臉書的推薦內容不再像過去那般有趣、實用。&lt;/p&gt;
&lt;p&gt;於是在轉職後的這幾年，我也開始看推特。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Cal-Newport-對推特的看法&quot;&gt;&lt;a href=&quot;#Cal-Newport-對推特的看法&quot; class=&quot;headerlink&quot; title=&quot;Cal Newport 對推特的看法&quot;&gt;&lt;/a&gt;Cal Newport 對推特的看法&lt;/h2&gt;&lt;p&gt;如果你看比較多 Cal Newport 的內容（主要是 Podcast），你會發現，他雖然沒有任何社群平台帳戶，但他對推特的討論與關注，遠遠超過對其它平台的討論，比如臉書、Substack。&lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;https://www.thedeeplife.com/podcasts/episodes/ep-241-the-virality-trap/&quot;&gt;EP. 241: The Virality Trap&lt;/a&gt;〉這集有一定的代表性。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="隨筆雜談" scheme="https://blog.kyomind.tw/categories/%E9%9A%A8%E7%AD%86%E9%9B%9C%E8%AB%87/"/>
    
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
    <category term="數位斷捨離" scheme="https://blog.kyomind.tw/tags/%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
    <category term="Twitter" scheme="https://blog.kyomind.tw/tags/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>23，Blog 新增「發文計畫」與我的思路</title>
    <link href="https://blog.kyomind.tw/weekly-review-23/"/>
    <id>https://blog.kyomind.tw/weekly-review-23/</id>
    <published>2023-09-24T15:48:29.000Z</published>
    <updated>2023-09-26T16:16:42.384Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/anwWHRH.png"></p><p>前幾天躺在床上，突發奇想，想到一個可以改善我「發文紀律」的有效手段！</p><p>從以前到現在，雖然習慣把想寫的主題事先收集起來，但實際上它們<strong>究竟會以什麼樣的順序被創作</strong>，則非常依賴我當下的心情與喜好。</p><p>我並不喜歡這種「<strong>今天想到寫什麼才寫什麼</strong>」的模式，儘管多數主題都不是臨時起意，<strong>但創作本身卻存在很大的不確定性</strong>。</p><p>這是一種<strong>不穩定的狀態</strong>。</p><p>怎麼改善？沒錯，我想到用 Notion 建立我的<strong>發文行事曆</strong>，我稱之為「<a href="https://kyomind.notion.site/0c953c8bedb94bc5905a6257b836a8b8?v=7360496f14e64d47a8e7d781b0dd5a5d">發文計畫</a>」。</p><p>現在，你可以在 blog 左上角的選單找到它。</p><p>這篇來就介紹我的思路、為什麼選擇 Notion，以及如何規劃版面呈現等議題。</p><span id="more"></span><hr><h2 id="兩大訴求"><a href="#兩大訴求" class="headerlink" title="兩大訴求"></a>兩大訴求</h2><p>設計這樣的發文計畫，主要想透過下列<strong>兩個面向</strong>來有效提升我的寫作紀律。</p><h2 id="一、可預見"><a href="#一、可預見" class="headerlink" title="一、可預見"></a>一、可預見</h2><p>這裡的「可預見」包括對讀者和我自己，先說說讀者。</p><h3 id="對讀者而言"><a href="#對讀者而言" class="headerlink" title="對讀者而言"></a>對讀者而言</h3><p>我的 blog 創作方向，大致可以分成三類：</p><ol><li>程式。</li><li>筆記軟體與筆記方法。</li><li>寫作與各種心得。</li></ol><p>而這三者的關係——可以說<strong>沒有太大關係</strong>。</p><p>這會帶來一個「<strong>困境</strong>」：<strong>讀者不知道你下一篇寫的，會是哪個方向的主題</strong>，但讀者可能只對其中之一有興趣。</p><p>這樣的不確定，也會導致讀者<a href="https://blog.kyomind.tw/subscribe/">訂閱本站文章</a>的意願下降。就像<a href="https://www.inside.com.tw/article/8011-yowureport">當初《有物報告》停刊</a>的主要理由：</p><blockquote><p>周欽華表示，因為會員成長停滯，反應了<strong>產品有根本性的問題，最主要的問題是讀者的產品體驗不一致</strong>，造成「有物報告」的品牌不清晰，因此該停就停。</p></blockquote><blockquote><p>在訪談讀者的時候，讀者的回饋是<strong>內容主題太過發散、風格不統一，以至於讀者根本無法確定，今天所收到的電子報到底內容會是什麼？</strong>更不知道內容是不是自己想要的？而這種體驗上的不確定，就成了訂閱制的媒體想要成長所會面臨的瓶頸。</p></blockquote><p>雖然訂閱數並非我的主要追求，<strong>但我仍希望提高讀者的可預見性，讓讀者更容易知曉我接下來會寫什麼。</strong></p><h3 id="對我而言"><a href="#對我而言" class="headerlink" title="對我而言"></a>對我而言</h3><p>誠如前述，我對於什麼時候要創作哪個主題，太過隨機與憑藉個人喜好。這對我自己，也是一種不確定。</p><p>這樣的不確定帶來的<strong>最大困擾</strong>是：我可能會因為不清楚「<strong>現在</strong>」要寫什麼而拖延。</p><p>這十分諷刺，畢竟我早已累積了一大堆主題，<strong>但我卻不知道要從哪個開始。</strong></p><p>有了「發文計畫」，這些不確定有機會被大幅消除，讓我更有效率地進行創作。</p><h2 id="二、公開承諾"><a href="#二、公開承諾" class="headerlink" title="二、公開承諾"></a>二、公開承諾</h2><p>這點比較容易理解。</p><p>以往，在我還沒發文之前，你根本不知道我正在寫什麼，是不是有如期發表——這些都只有我自己知道而已。</p><p><strong>好處就是我可以一拖再拖，而壞處往往也是一拖再拖。</strong></p><p>公開承諾會<strong>強化其中的痛苦</strong>，讓我對這樣的拖延感到壓力。</p><hr><h2 id="為什麼選擇-Notion"><a href="#為什麼選擇-Notion" class="headerlink" title="為什麼選擇 Notion"></a>為什麼選擇 Notion</h2><p>我幾乎第一時間就決定用 Notion。</p><p>我知道，這樣的頁面，想要透過目前採用的「靜態部落格」來呈現，非常困難。</p><p>我當然可以做一個<strong>超級簡易版</strong>：只是列一個清單，第一個項目就是最近會發表的文章，然第二個就是再接下來會發表的……等等，以此類推。</p><p>但這樣的效果並不好，而且我在編輯上也不順手。同時，可以想見這會是比較需要頻繁變動的內容，對<strong>工具的流暢度</strong>有一定要求，單純的靜態網頁並不適合。</p><p>這種需求你會想到什麼？沒錯——Notion database！</p><h2 id="善用-Notion-database"><a href="#善用-Notion-database" class="headerlink" title="善用 Notion database"></a>善用 Notion database</h2><p>顯然，Notion database 非常符合這類情境，更別說它還有多種 view 可以呈現，修改一次資料後，所有的 view 都會跟著變動。</p><blockquote><p>真的太適合了！</p></blockquote><p>雖然它有一個缺點，那就是必須「開新視窗」，讓人有一種離開網站的感覺。但考慮到 Notion database 的強大易用，我還是接受了這個折衷之道。</p><p>此外，我也有考慮過 <a href="https://www.airtable.com/">Airtable</a>，因為它可以把 database 嵌入網頁中，不必開新視窗，整體感更好。</p><p>但仔細想想，我平常根本沒在用 Airtable！這會需要我「特地」去操作這個工具，徒增使用上的「摩擦力」。但 Notion 不同，它依舊是我的日常。</p><hr><h2 id="版面介紹"><a href="#版面介紹" class="headerlink" title="版面介紹"></a>版面介紹</h2><p>介紹一下「發文計畫」這個 database。</p><p>首先必須強調，database 的整體設計，盡可能遵循了我在〈<a href="https://blog.kyomind.tw/notion-database/">剛剛好：Notion database「反複雜」使用指南</a>〉中提到的「<a href="https://blog.kyomind.tw/notion-database/#%E6%88%91%E7%9A%84-database-%E6%B8%9B%E6%B3%95">我的 Notion 減法</a>」原則：</p><ol><li>能少則少的欄位——記錄不要太面面俱到，以免淪為「填表機器」。</li><li>最大程度善用不同的 view——這非常重要。</li><li>固定架構、不使用進階功能。</li></ol><p>這個 database 總共有三個 view，功能各不相同，一一介紹如下。</p><h3 id="即將發表"><a href="#即將發表" class="headerlink" title="即將發表"></a>即將發表</h3><p>只包括「<strong>未發表</strong>」的文章。也是整個發文計畫的核心。</p><p>使用經典的 table view，記載近期將發表的文章標題、分類，以及<strong>預計完成日</strong>（也就是 deadline）。</p><p>其中最最重要的，當然就是「預計完成日」。</p><p>雖然不一定能 100% 遵守——也可能會延後。但原則上，它就是一個 deadline。</p><p>我對這個「既定日期」的尊重，將決定我的發文紀律可以得到多大程度的提升。</p><hr><p>附帶一提，我以前做 Notion 筆記時，其實很少用 table view，幾乎都是用 list view。但 list view 沒有欄位名稱，不利於公開展示，因此這裡我選用了 table。</p><p>此外，為了防止我無止境地往這裡狂塞想到的標題，造成<strong>發文池氾濫</strong>（畢竟我寫的再快，也沒有「想到文章標題」的速度快），所以這裡最多只會有 10 筆資料。</p><h3 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h3><p>只包括「已發表」的文章。</p><p>這裡選用了 gallery view，秀出封面圖片，並附上文章連結。</p><h3 id="發文行事曆"><a href="#發文行事曆" class="headerlink" title="發文行事曆"></a>發文行事曆</h3><p><strong>包括已發表和未發表的文章。</strong></p><p>我原本把它放在最左邊第一分頁（也就是打開這個頁面後的預設分頁），因為它在視覺上最直觀。但想想有點佔版面，還是移到了最右邊。</p><p>使用 <strong>calendar view</strong>，這對我來說很關鍵，我必須透過觀察發文日期之間的<strong>間隔日數</strong>，來確認發文的壓力是否過大、是否過於密集。包括發文日當天、前後一天是否還有別的安排等等。</p><p>如果是，就要進行調整，這也是我無法 100% 遵守發文日的原因之一，因為它們可能會有所變動。</p><p>整體而言，calendar view 完美地做到了「管理發文行程」這個任務，更不用說還可以<strong>透過拖曳來直接移動發文日期</strong>，太讚了！</p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>我有預感，這個「發文計畫」的建立，對我來說會是一個重要的里程碑。</p><p>原因無它，<strong>我屬於「非常排斥」對要做的事進行規劃的人</strong>（現在仍是如此），更不喜歡所謂的「時間管理」。</p><p>我常常強調自己對「<strong>記錄→觀察→反思→調整</strong>」的偏好，甚至引以為豪。</p><p>但我也不得不承認，<strong>記錄有其極限</strong>，不是什麼問題都能夠透過記錄來改善。（雖然很多問題都可以！比如天天量體重來節制自己進食的欲望）</p><p>所以，「發文計畫」或許將成為我對「記錄」與「規劃」看法的轉捩點。</p><p>且讓我們拭目以待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/anwWHRH.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;前幾天躺在床上，突發奇想，想到一個可以改善我「發文紀律」的有效手段！&lt;/p&gt;
&lt;p&gt;從以前到現在，雖然習慣把想寫的主題事先收集起來，但實際上它們&lt;strong&gt;究竟會以什麼樣的順序被創作&lt;/strong&gt;，則非常依賴我當下的心情與喜好。&lt;/p&gt;
&lt;p&gt;我並不喜歡這種「&lt;strong&gt;今天想到寫什麼才寫什麼&lt;/strong&gt;」的模式，儘管多數主題都不是臨時起意，&lt;strong&gt;但創作本身卻存在很大的不確定性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這是一種&lt;strong&gt;不穩定的狀態&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;怎麼改善？沒錯，我想到用 Notion 建立我的&lt;strong&gt;發文行事曆&lt;/strong&gt;，我稱之為「&lt;a href=&quot;https://kyomind.notion.site/0c953c8bedb94bc5905a6257b836a8b8?v=7360496f14e64d47a8e7d781b0dd5a5d&quot;&gt;發文計畫&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;現在，你可以在 blog 左上角的選單找到它。&lt;/p&gt;
&lt;p&gt;這篇來就介紹我的思路、為什麼選擇 Notion，以及如何規劃版面呈現等議題。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/anwWHRH.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="Airtable" scheme="https://blog.kyomind.tw/tags/Airtable/"/>
    
  </entry>
  
  <entry>
    <title>22，我還是預購了瓦基的《卡片盒筆記實戰課》</title>
    <link href="https://blog.kyomind.tw/weekly-review-22/"/>
    <id>https://blog.kyomind.tw/weekly-review-22/</id>
    <published>2023-09-16T15:06:12.000Z</published>
    <updated>2023-09-22T14:51:58.642Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/nltkimY.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>這標題乍看有點像廣告XD，不過你看下去就知道。😎</p><p>「還是」二字代表了我對「購買課程」這個決定的<strong>猶豫與觀望</strong>。</p><p>事情是這樣的，如果你也是<a href="https://readingoutpost.com/about/">瓦基</a>（應該不用再特別介紹）的<a href="https://readingoutpost.com/book-picking-subscriber/">電子報</a>訂戶，他在前兩天的新信中，公布了他的全新募資線上課程《<a href="https://www.pressplay.cc/project/148B74E70523C7A7E260484F9B6825CB/">卡片盒筆記實戰課</a>》。</p><p>這讓我不禁陷入一陣掙扎，究竟是買還是不買呢？</p><span id="more"></span><hr><h2 id="線上課的盛宴已過"><a href="#線上課的盛宴已過" class="headerlink" title="線上課的盛宴已過"></a>線上課的盛宴已過</h2><p>如果是「三年前」的我，肯定是當下就直接入手了。因為那時還處於台灣線上課程平台的全盛時期，很多用戶願意買單，包括我，在 Hahow 也買了超過 30 堂課。</p><p>那時是怎麼想的？當然是希望買了課、上了課以後，自己會有所不同。</p><p>然而從經驗與結果來看，顯然的，這個期望並不容易兌現。即便買了很多課，到頭來也是<strong>失望居多</strong>——我還是以前的那個我。</p><p>其中原因不一而足，有些課確實品質不佳，感覺就是東拼西湊；更多時候則是「買很簡單，卻沒有真的花時間看」。</p><p>實踐的動力不足，本質上往往是因為「<strong>想要大於需要</strong>」，有時候甚至是「<strong>被迫想要</strong>」，也就是所謂的「<strong>資訊焦慮</strong>」。</p><p>無論如何，這裡想表達，大部分人買課時，那些對於自己在購買後能夠「因此而成長」的期待，多數時候是無法兌現的。</p><blockquote><p>畢竟現實如此骨感。</p></blockquote><h2 id="變得精明的消費者"><a href="#變得精明的消費者" class="headerlink" title="變得精明的消費者"></a>變得精明的消費者</h2><p>因此，就算我感覺課的品質不錯，三年後的我，也不會像那時一樣，僅憑著一腔的熱血與期待，就貿然出手。</p><p>因為我知道，買了課以後，很大可能是「<strong>然後就沒有然後了</strong>」。</p><p>用時間——與金錢——理解了上述現實後，我現在也很少再買台灣的線上課，畢竟它們通常都不便宜。</p><h2 id="只買-Udemy"><a href="#只買-Udemy" class="headerlink" title="只買 Udemy"></a>只買 Udemy</h2><p>不過 <strong>Udemy 的程式類課程</strong>我還是很常買，一來是工作與學習需要，二來是便宜，就像逛超市一樣，買了不看我也不心痛。</p><p>相反的，Udemy 課程的最大「問題」，往往是內容太過豐富XD。</p><p>很多都是超大碗、時數長（但特價時基本上都只要台幣 360 元——應該沒人在買原價的），認真看完也不切實際。能完成 6 成就功德圓滿了。</p><p>附帶一提，<a href="https://www.udemy.com/user/academind/">Academind</a> 的課真的都還不錯，我已經看完 <a href="https://www.udemy.com/course/python-django-the-practical-guide/">Django</a> 和 <a href="https://www.udemy.com/course/writing-clean-code/">Clean Code</a> ，目前正在學習 <a href="https://www.udemy.com/course/github-actions-the-complete-guide/">GitHub Actions</a>，十分推薦。</p><hr><h2 id="我的卡片筆記之道"><a href="#我的卡片筆記之道" class="headerlink" title="我的卡片筆記之道"></a>我的卡片筆記之道</h2><p>除了購買線上課程的熱情已經大不如前，還有另一個<strong>更關鍵的原因</strong>，讓我對於購入瓦基的新課感到躊躇。</p><p>那就是「<strong>我有我的卡片筆記之道</strong>」。</p><p>你可以說這是一種「<a href="https://dict.idioms.moe.edu.tw/idiomView.jsp?ID=124&webMd=1&la=0">敝帚自珍</a>」，但可以確信的是，有了自己習慣的方式後，要接受新的做法肯定比「還是一張白紙」時困難。</p><p>且我在〈<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a>〉提過，要用好卡片筆記，其實也不需要看書。尤其書中的那套「<strong>永久筆記、文獻筆記、靈感筆記</strong>」等分類，個人不是特別欣賞。</p><p>簡單來說，我對《<a href="https://www.books.com.tw/products/0010922143">卡片盒筆記</a>》一書的評價是：<strong>普通</strong>。這與<a href="https://readingoutpost.com/smart-notes-foreword/">瓦基對本書的看法</a>可謂<strong>大相徑庭，截然不同。</strong></p><p>而目前台灣卡片筆記的兩大推廣者——瓦基（使用 <a href="https://heptabase.com/">Hetpabase</a>）、<a href="https://www.chichu.co/">朱騏</a>（使用 <a href="https://obsidian.md/">Obsidian</a>）——還是都比較有書中架構的影子。</p><p>這讓我產生一種<strong>本能上的排斥</strong>。</p><hr><h2 id="卡片筆記與我的軟肋"><a href="#卡片筆記與我的軟肋" class="headerlink" title="卡片筆記與我的軟肋"></a>卡片筆記與我的軟肋</h2><p>使用卡片筆記滿一年，我無疑是它的愛好者，它對我在程式學習上的幫助，尤其是<strong>複習</strong>的效果，比起「Notion 時期」明顯提高了一個檔次。</p><p>當然，任何工具都有其優缺點，卡片筆記或 Logseq 也稱不上神乎其神的筆記方法論，只能說它<strong>特別適合我</strong>而已。</p><p>可以說，我這輩子的「歸屬」，就是卡片筆記了。</p><p>然而，儘管有了卡片筆記這把利劍，卻還是存在一根<strong>軟肋</strong>——我創作速度依舊不快。</p><p>從發文的頻率就能看出，我顯然稱不上是一個高產者。</p><p>但「<strong>輔助寫作、讓寫作變簡單</strong>」卻是《卡片盒筆記》這本書的一個宣傳重點，並暗示著「善用卡片筆記」正是其發明者魯曼教授一生能夠<strong>在著作上如此多產</strong>的主要理由。</p><h2 id="卡片筆記真的能讓寫作變輕鬆？"><a href="#卡片筆記真的能讓寫作變輕鬆？" class="headerlink" title="卡片筆記真的能讓寫作變輕鬆？"></a>卡片筆記真的能讓寫作變輕鬆？</h2><p>我確信，卡片筆記對寫作<strong>肯定有幫助</strong>。畢竟我在〈<a href="https://blog.kyomind.tw/rusty-bullets/">從 Logseq 看清單式筆記的兩大缺點</a>〉就提過，<a href="https://blog.kyomind.tw/rusty-bullets/#%E6%B8%85%E5%96%AE%EF%BC%9A%E6%A7%8B%E6%80%9D%E7%9A%84%E5%88%A9%E5%99%A8">清單是構思的利器</a>。而作為清單式卡片筆記軟體的 Logseq，在收集素材與架構文章的作用上，比 Notion 更為稱職。</p><p>我確實可以透過串連一張張已完成的筆記（卡片），讓寫作的「<strong>起手式</strong>」變得較為輕鬆——<strong>但我的感受也僅止於此</strong>，明顯還達不到「組織既有卡片就能快速完成一篇高品質文章」的程度。</p><p>我寫一篇 2000-3000 字的文章，通常還是需要 3-5 小時。</p><p>這是不是因為我的創作能力不足？也許不是，畢竟我還是寫出了〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉這般，連自己都非常滿意的作品。</p><p>所以，僅靠一張張卡片與它們之間的連結，真的就能讓寫作變得輕鬆？</p><p>我對此仍持保留態度。</p><hr><h2 id="最後一塊拼圖"><a href="#最後一塊拼圖" class="headerlink" title="最後一塊拼圖"></a>最後一塊拼圖</h2><p>無論是瓦基還是朱騏，他們的創作能量都是非常豐沛的，我深表佩服。</p><p>我的「創作手速」確實不如他們，但這究竟是因為<strong>我沒有善用卡片筆記</strong>，還是<strong>他們本來就比較認真</strong>呢？這是我心中最大的疑問。</p><p>換句話說，有時候看到別人特別推崇哪個方法時，我不免心生疑問：「<strong>這究竟是方法管用，還是這個人本來就很厲害？</strong>」畢竟能夠自信地提出所謂方法論的人，往往也不是什麼小咖。但如果是基於後者，那整件事對一般人而言就沒有<strong>可複製性</strong>。</p><p>帶著這個疑問，我還是決定買下這堂課——正因為我相信（或者是<strong>想要相信</strong>）「自己還沒有善用」的可能性或許高一些。</p><p>我希望尋找這最後一塊拼圖。</p><p>到時候，再來寫一篇心得吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nltkimY.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;這標題乍看有點像廣告XD，不過你看下去就知道。😎&lt;/p&gt;
&lt;p&gt;「還是」二字代表了我對「購買課程」這個決定的&lt;strong&gt;猶豫與觀望&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;事情是這樣的，如果你也是&lt;a href=&quot;https://readingoutpost.com/about/&quot;&gt;瓦基&lt;/a&gt;（應該不用再特別介紹）的&lt;a href=&quot;https://readingoutpost.com/book-picking-subscriber/&quot;&gt;電子報&lt;/a&gt;訂戶，他在前兩天的新信中，公布了他的全新募資線上課程《&lt;a href=&quot;https://www.pressplay.cc/project/148B74E70523C7A7E260484F9B6825CB/&quot;&gt;卡片盒筆記實戰課&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;這讓我不禁陷入一陣掙扎，究竟是買還是不買呢？&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/xPAR5a7.jpg" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="卡片盒筆記法" scheme="https://blog.kyomind.tw/tags/%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%B3%95/"/>
    
    <category term="Obsidian" scheme="https://blog.kyomind.tw/tags/Obsidian/"/>
    
    <category term="Hetpabase" scheme="https://blog.kyomind.tw/tags/Hetpabase/"/>
    
    <category term="線上課" scheme="https://blog.kyomind.tw/tags/%E7%B7%9A%E4%B8%8A%E8%AA%B2/"/>
    
    <category term="Udemy" scheme="https://blog.kyomind.tw/tags/Udemy/"/>
    
  </entry>
  
  <entry>
    <title>Cal Newport 與我的河濱思考</title>
    <link href="https://blog.kyomind.tw/think-riverside/"/>
    <id>https://blog.kyomind.tw/think-riverside/</id>
    <published>2023-09-14T15:15:04.000Z</published>
    <updated>2023-09-20T08:42:26.082Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>從〈<a href="https://blog.kyomind.tw/weekly-review-19/">19，AI 時代的生存指南（二）數位斷捨離</a>〉發表後，又過了兩個月的時間，就像文中說的，要持續數位斷捨離，可一點也不簡單。</p><p>不過沒關係，我還是會繼續嘗試與實踐下去。只不過，數位斷捨離跟許多好習慣的養成一樣，多多少少都會消耗你的意志力，以達成一定的<strong>慣性</strong>。（當然如果你並不真的喜歡這件事，那最終依舊不會形成慣性）</p><p>如果同時還有其它目標追求，確實不宜對自己太過嚴苛，以免「全軍覆沒」。</p><p>不過其中一種數位斷捨離實踐，我倒是持續了好幾個月，效果不錯，而且我也推薦你這麼做——那就是「<strong>散步時，不要用手機</strong>」。</p><h2 id="Cal-Newport-為什麼沒有社交媒體帳號"><a href="#Cal-Newport-為什麼沒有社交媒體帳號" class="headerlink" title="Cal Newport 為什麼沒有社交媒體帳號"></a>Cal Newport 為什麼沒有社交媒體帳號</h2><p>Cal Newport 在這則〈<a href="https://youtu.be/m6AF_aFuD8w?si=KRXvJroDMkhB7JkJ">The Perks of Living Without Social Media | Cal Newport</a>〉影片中，講述了他<strong>不用任何社交媒體</strong>的理由。</p><p>一言以蔽之就是：為了<strong>保持無聊</strong>。</p><span id="more"></span><p>對，就是無聊，就是你所認知的那個無聊。</p><p>Cal Newport 對於無聊有著自己獨到的看法，我引用影片中的一些論點（由 ChatGPT 整理）：</p><blockquote><ul><li>當你在手機上安裝了這些容易上癮的應用程式後，手機成為了你<strong>分心的默認方式</strong></li><li>只要<strong>稍微感到無聊</strong>，你就會拿起手機並開始滑動社交媒體</li><li>當你感到無聊，本能會驅使你做一些有生產力的活動，<strong>但手機會中斷這種驅使</strong>，使你只看著那片發光的玻璃</li><li>當你不使用社交媒體，手機上沒有太多有趣的內容可以查看，這將使你<strong>更多地專注於周圍的世界和你的思考</strong></li><li>這是你<strong>反思自己</strong>，了解自己的好與壞，以及<strong>你在生活中所關心的事物</strong>的時候</li></ul></blockquote><p>如果你已拜讀過他的《<a href="https://www.books.com.tw/products/0010843512">深度數位大掃除</a>》，上述這些論點可能不會讓你感到太新奇。</p><p>但是，經過這幾個月的不帶手機散步體驗，<strong>我覺得我還是大大低估了「無聊的力量」</strong>。</p><h2 id="無聊的力量"><a href="#無聊的力量" class="headerlink" title="無聊的力量"></a>無聊的力量</h2><p>我不妨先問問自己：「以前帶手機去散步時，都在做些什麼？」</p><p>其實在「<a href="https://blog.kyomind.tw/riverside/#%E6%B2%B3%E6%BF%B1%E4%B9%8B%E6%96%BC%E6%88%91">河濱之於我</a>」有提過，就是聽 Podcast。除了 Podcast，還有<a href="https://time.geekbang.org/">極客時間</a>的一些程式課程。</p><p>這些行為看似充實，但如果讓現在的我來評論，我認為還是有點「不健康」。</p><blockquote><p>為什麼？</p></blockquote><p>就像上面提到 Cal Newport 的看法，這些行為都有「<strong>為了讓自己不無聊</strong>」的成份在。因此，<strong>我始終得不到無聊的力量</strong>。聽這些東西，只能算是一種<strong>廉價的自我滿足</strong>。</p><p>那，什麼是「<strong>無聊的力量</strong>」？</p><h2 id="反思與發想"><a href="#反思與發想" class="headerlink" title="反思與發想"></a>反思與發想</h2><p>無聊的力量，就是<strong>創造</strong>。</p><p>一直 input，沒什麼了不起。在這人手一機的時代，搭配無線耳機，除了睡覺，你可以無時無刻都在 input。</p><p>但這些資訊中的絕大多數，對於我們整個人生，又能有多少影響呢？<strong>我高度懷疑</strong>。</p><p>並不是說這些資訊無益，它們可能是製作精良的「知識大禮包」。但一直輸入，會讓人沒有足夠時間思考，停留在<strong>淺薄的層次</strong>，這就是我前面說的「廉價的自我滿足」。</p><p><strong>持續輸入反而稀釋了那些最重要的事物。</strong></p><p>這毋寧是現代生活的常態——好的東西，總是被平庸的東西，分散了注意力。</p><h2 id="我的河濱思考"><a href="#我的河濱思考" class="headerlink" title="我的河濱思考"></a>我的河濱思考</h2><p>好的河濱散步體驗，就是要無聊，真的無聊！</p><p>我只能<strong>「徒手」思考</strong>。</p><p>這幾天的經驗是這樣：走到河濱後，腦子不禁開始飛速運轉，因為沒有手機干擾，我只能想想<strong>最近有哪些想做的事</strong>，然後就<strong>一發不可收拾</strong>——我有好多想做的事。</p><p>腦海中開始一一盤點、發想怎麼做比較好。</p><p>你會驚訝地發現，<strong>其實自己的大腦擁有很高「轉速」，是手機和各種雜訊拖累了它！</strong></p><p>不過這種高速狀態不會持續很久，大概 15-30 分鐘吧！大腦也會是累的。</p><p>剩下的時候就放空即可，因為已經心滿意足了。</p><p>不想散步時還要思考？<strong>單純放空</strong>我也是非常推薦的！再怎麼樣都比聽手機內容強得多，不誇張。</p><h2 id="寫下來"><a href="#寫下來" class="headerlink" title="寫下來"></a>寫下來</h2><p>最後一步，就是寫下來。剛剛散步有著各種發想與創造，有些是點子，有些是具體行動方針，不妨在回來後，打鐵趁熱，儘速將它們寫下來。</p><p>下面這篇隨手筆記，就是我今晚在河濱走完路後想到的重要事項，回來後立刻寫下來，你看，我這不就完成了第一項了嗎？（不久後<a href="https://blog.kyomind.tw/weekly-review-22/">第二項</a>也完成了，偉哉河濱！🫡）</p><p><img src="https://i.imgur.com/a6xQn6C.png" alt="Logseq app"><span class="cap">Logseq app</span></p><p>附帶一提，寫下來內容只要<strong>大概即可，剛好能看懂就夠了</strong>，而且只要列個幾項重點，就已經功德圓滿。</p><p>這種簡單、清爽的感覺，又不禁讓我感受到「<strong>清單式筆記</strong>」的美妙了。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/silver-bullets/">從 WorkFlowy 到 Logseq——我偏愛「清單式筆記」的四大理由</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;從〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-19/&quot;&gt;19，AI 時代的生存指南（二）數位斷捨離&lt;/a&gt;〉發表後，又過了兩個月的時間，就像文中說的，要持續數位斷捨離，可一點也不簡單。&lt;/p&gt;
&lt;p&gt;不過沒關係，我還是會繼續嘗試與實踐下去。只不過，數位斷捨離跟許多好習慣的養成一樣，多多少少都會消耗你的意志力，以達成一定的&lt;strong&gt;慣性&lt;/strong&gt;。（當然如果你並不真的喜歡這件事，那最終依舊不會形成慣性）&lt;/p&gt;
&lt;p&gt;如果同時還有其它目標追求，確實不宜對自己太過嚴苛，以免「全軍覆沒」。&lt;/p&gt;
&lt;p&gt;不過其中一種數位斷捨離實踐，我倒是持續了好幾個月，效果不錯，而且我也推薦你這麼做——那就是「&lt;strong&gt;散步時，不要用手機&lt;/strong&gt;」。&lt;/p&gt;
&lt;h2 id=&quot;Cal-Newport-為什麼沒有社交媒體帳號&quot;&gt;&lt;a href=&quot;#Cal-Newport-為什麼沒有社交媒體帳號&quot; class=&quot;headerlink&quot; title=&quot;Cal Newport 為什麼沒有社交媒體帳號&quot;&gt;&lt;/a&gt;Cal Newport 為什麼沒有社交媒體帳號&lt;/h2&gt;&lt;p&gt;Cal Newport 在這則〈&lt;a href=&quot;https://youtu.be/m6AF_aFuD8w?si=KRXvJroDMkhB7JkJ&quot;&gt;The Perks of Living Without Social Media | Cal Newport&lt;/a&gt;〉影片中，講述了他&lt;strong&gt;不用任何社交媒體&lt;/strong&gt;的理由。&lt;/p&gt;
&lt;p&gt;一言以蔽之就是：為了&lt;strong&gt;保持無聊&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="隨筆雜談" scheme="https://blog.kyomind.tw/categories/%E9%9A%A8%E7%AD%86%E9%9B%9C%E8%AB%87/"/>
    
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
    <category term="河濱" scheme="https://blog.kyomind.tw/tags/%E6%B2%B3%E6%BF%B1/"/>
    
    <category term="數位斷捨離" scheme="https://blog.kyomind.tw/tags/%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
  </entry>
  
  <entry>
    <title>21，在 VM 上部署 GA 的開源替代品——Umami</title>
    <link href="https://blog.kyomind.tw/weekly-review-21/"/>
    <id>https://blog.kyomind.tw/weekly-review-21/</id>
    <published>2023-09-10T17:03:55.000Z</published>
    <updated>2023-09-16T15:06:51.397Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/fBvzAN2.png" alt="Umami dashboard"><span class="cap">Umami dashboard</span></p><p><a href="https://github.com/umami-software/umami">Umami</a> 是一款類似 Google Analytics 的<strong>網站訪客數據收集、統計與分析</strong>工具，只是它是<a href="https://zh.wikipedia.org/zh-tw/%E5%BC%80%E6%BA%90%E5%AE%9A%E4%B9%89">開源</a>的，而且強調對隱私的保護，不會收集你的個人資訊。</p><p>當初會知道它，主要基於這兩篇文章：</p><ul><li><a href="https://willliu.blot.im/umami/">免費的網站流量統計系統 Umami</a></li><li><a href="https://pinchlime.com/snapshots/why/why-do-i-want-to-try-umami/">為什麼我想嘗試 umami ？</a></li></ul><p>可以看出，兩位作者採用 Umami 的動機大致相同：主要考慮用戶的<strong>隱私權保護</strong>，其次則著眼工具本身對網站效能的影響。</p><p>我呢？既然知道了這個服務，顯然我也有我的需求。</p><span id="more"></span><hr><h2 id="我也不喜歡-GA4"><a href="#我也不喜歡-GA4" class="headerlink" title="我也不喜歡 GA4"></a>我也不喜歡 GA4</h2><p>我雖然不太喜歡 Google Analytics，但倒是沒有那般厭惡。然而！隨著舊版 GA 的停用與 <a href="https://support.google.com/analytics/answer/10089681?hl=zh-Hant">GA4</a> 的到來，必須說：「我真的很不喜歡 GA4！」</p><p>對於商業用戶，它可能是利多，畢竟對網站訪客的蒐集行為更細緻了——這也是它招人恨的理由。這意味著商家對「潛在客戶」的了解又增加了幾分。</p><p>但對於我這種不營利的普通部落客而言，則新增的功能主要偏向商業不說，舊的、有意義的指標也拿掉了不少。</p><p>後台網站的操作界面與和 Looker Studio（Google 自家的 dashboard 服務）的串接體驗都更糟了。</p><p>對我來說，GA4 就是個災難。</p><h2 id="GA-替代品"><a href="#GA-替代品" class="headerlink" title="GA 替代品"></a>GA 替代品</h2><p>如果你也是一個不靠網站盈利的站長，那就未必要選擇 GA 作為數據分析工具。</p><p>雖然我們不得不承認，GA 確實強大——而且免費。</p><p>免費這可是很大的誘因，而它之所以能夠免費，顯然是因為服務提供者——Google——能夠在別的地方賺到錢！</p><p>如果不想用 GA，可選擇的替代品也很多，但大部分需要你付費或有一定成本。這也是為何 GA 依舊是最常見的分析工具，哪怕你不靠網站賺錢。</p><p>因為它使用上簡單且免費。</p><h2 id="我選擇-Umami-的理由"><a href="#我選擇-Umami-的理由" class="headerlink" title="我選擇 Umami 的理由"></a>我選擇 Umami 的理由</h2><p>GA4 的界面讓我很不想用，至少不想常用。雖然我並沒有把它拔除，但我想找一個供平時使用，更簡單、好讀的網站流量儀表版服務。</p><p>Google 一下關鍵字「ga alternative」你可以找到一大堆，而我強力推薦 Umami——畢竟我自己也用了！類似的選項還有 <a href="https://usefathom.com/">Fathom</a>、<a href="https://matomo.org/">Matomo</a>、<a href="https://plausible.io/">Plausible</a> 等等。</p><p>我選擇 Umami 的主要理由只有一個：因為它簡潔且美觀。</p><p>Dashboard 這種東西，顏值肯定是第一指標。至於 Umami 的其它賣點，例如對隱私的保護，雖然我也認同，但不是考量上的重點。</p><p>總之，如果你不想用 GA，又不知道該選哪個作為替代，就先選 Umami 吧！</p><hr><h2 id="部署-Umami-的幾種方式"><a href="#部署-Umami-的幾種方式" class="headerlink" title="部署 Umami 的幾種方式"></a>部署 Umami 的幾種方式</h2><p>Umami 雖然是開源的，但和很多開源軟體的一樣，採用類似 WordPress 的 <a href="https://zh.wikipedia.org/zh-tw/%E5%85%8D%E8%B2%BB%E5%A2%9E%E5%80%BC">Freemium</a> 模式。</p><p>意思是，你可以自行部署在自己的硬體上，比如本機電腦或租來的 <a href="https://www.gigabyte.com/tw/Glossary/virtual-machine">VM</a>。也可以直接申請一個付費帳戶，由 Umami 公司幫你託管，即 <a href="https://cloud.umami.is/">Umami Cloud</a> 服務。</p><p>說真的，如果你稍為研究過，這些付費服務可不算便宜，像 Umami Cloud 一個月就要 9 美元起跳。一個月花 9 美元只為了看看網站數據，你願意？</p><p>反正我不願意。</p><p>所幸，除了直接付錢，自行部署才是開源的常態。此時你依舊有兩種選擇：</p><ol><li>直接弄個自己的 VM 部署——當然租 VM 是要錢的。</li><li>使用 <a href="https://railway.app/">Railway</a> 這種有一定免費額度的托管平台來進行部署。</li></ol><p>從本文標題的可知，我選擇了第一種部署方式：我把 Umami 部署在 DigitalOcean 的 VM 上，並設定好了子域名與 SSL。</p><h2 id="免費部署的常見隱憂"><a href="#免費部署的常見隱憂" class="headerlink" title="免費部署的常見隱憂"></a>免費部署的常見隱憂</h2><p>我認為，如果你只是打算「試用」一下 Umami，那麼選擇什麼方式都可以，甚至直接付費 Umami Cloud 一個月。</p><p>但是，如果用了覺得喜歡，想要長期部署，那我強烈建議不要選擇上述第二種方式。理由有下：</p><ol><li>帶有免費額度的平台通常伴隨著<strong>各種限制</strong>，而且容易受到<strong>政策變更</strong>的影響，最有名的例子莫過於 <a href="https://www.ithome.com.tw/news/152729">Heroku</a>。</li><li>被平台與服務綁定，不利於未來<strong>資料的遷移</strong>。當然平台理論上也會有備份方案，但就是沒有直接 own 一台 Linux VM 那麼簡單、通用。</li></ol><p>簡言之，部署這類服務，<strong>長期可持續性</strong>是最重要的。而免費額度平台可能會讓你在未來遇到各種麻煩。</p><p>當然，如果只是小試水溫，則沒有這麼多顧慮。</p><h2 id="選擇-VM-部署的理由"><a href="#選擇-VM-部署的理由" class="headerlink" title="選擇 VM 部署的理由"></a>選擇 VM 部署的理由</h2><p>為何選擇 VM？除了前述原因，我再補充一下我的理由。</p><p>第一，VM 的環境都是一樣的，足夠通用。不用因為 A 平台要收費了，我又要學習 B 平台怎麼用。資料的備份和遷移也是如此。</p><p>其次，對有技術基礎的人而言，用 VM 部署往往更簡單，尤其 Umami 的專案中直接給你一個<code>docker-compose.yml</code>。Docker 用戶都知道，這意味著部署起來會很方便且無腦，比設定什麼免費 db 都要簡單得多。</p><p>不過話說回來，如果只是為了部署這單一個服務，特地租一台 VM 還是太過浪費了，錢也沒有省多少——還不如直接付費 Umami Cloud。</p><p>換句話說，能讓 VM 有多種用途，會比較划算。</p><p>此外，如果選擇用這個方式<strong>長期部署</strong>，那「<strong>自己的域名</strong>」和「<strong>SSL 憑證</strong>」都是必要的。如此才能確保<strong>安全性</strong>。</p><p>好吧我承認這真的有點麻煩😅，但我認為這是值得的。</p><hr><h2 id="使用-VM-部署-Umami"><a href="#使用-VM-部署-Umami" class="headerlink" title="使用 VM 部署 Umami"></a>使用 VM 部署 Umami</h2><p>關於部署 Umami，網路上可以找到比較多上述第二種部署方式，包括教你怎麼註冊、使用那些平台等等。我想不必再贅述。</p><p>而如果你想用 VM 部署，那麼一定要參考 DigitalOcean 上的這篇手把手教學：</p><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-umami-web-analytics-software-on-ubuntu-20-04">How To Install Umami Web Analytics Software on Ubuntu 20.04</a></li></ul><p>整個流程大概分成三部分：</p><ol><li><strong>透過 Docker Compose 在 VM 的 localhost 部署 Umami 服務</strong></li><li><strong>設定 Nginx 反向代理，將 3000 port 對應到 80（HTTP）</strong></li><li><strong>透過 Certbot 申請 SSL 憑證（需要有自己的域名）</strong></li></ol><p>我基本上就是照著它完成的，順利的話應該不出 1 小時——如果你已經有一台 VM。</p><p>雖然我實際花費的時間比 1 小時要多得多，但主要是為了了解整個流程用到的相關知識——主要是 Nginx 和 Docker，所以和 ChatGPT 進行了大量交流、做了很多筆記。</p><p>這過程讓我學到不少，包括現學現賣的 <a href="https://zh.wikipedia.org/zh-tw/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA">virtual hosting</a>（用單一台主機部署多個域名與服務），和複習 Docker 概念。</p><p>這無疑是很具體且<strong>目標導向</strong>的學習。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fBvzAN2.png&quot; alt=&quot;Umami dashboard&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/umami-software/umami&quot;&gt;Umami&lt;/a&gt; 是一款類似 Google Analytics 的&lt;strong&gt;網站訪客數據收集、統計與分析&lt;/strong&gt;工具，只是它是&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%BC%80%E6%BA%90%E5%AE%9A%E4%B9%89&quot;&gt;開源&lt;/a&gt;的，而且強調對隱私的保護，不會收集你的個人資訊。&lt;/p&gt;
&lt;p&gt;當初會知道它，主要基於這兩篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://willliu.blot.im/umami/&quot;&gt;免費的網站流量統計系統 Umami&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pinchlime.com/snapshots/why/why-do-i-want-to-try-umami/&quot;&gt;為什麼我想嘗試 umami ？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，兩位作者採用 Umami 的動機大致相同：主要考慮用戶的&lt;strong&gt;隱私權保護&lt;/strong&gt;，其次則著眼工具本身對網站效能的影響。&lt;/p&gt;
&lt;p&gt;我呢？既然知道了這個服務，顯然我也有我的需求。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/fBvzAN2.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
    <category term="Umami" scheme="https://blog.kyomind.tw/tags/Umami/"/>
    
    <category term="DigitalOcean" scheme="https://blog.kyomind.tw/tags/DigitalOcean/"/>
    
  </entry>
  
  <entry>
    <title>剛剛好：Notion database「反複雜」使用指南</title>
    <link href="https://blog.kyomind.tw/notion-database/"/>
    <id>https://blog.kyomind.tw/notion-database/</id>
    <published>2023-08-28T17:29:31.000Z</published>
    <updated>2023-09-24T16:28:27.954Z</updated>
    
    <content type="html"><![CDATA[<!-- ![by Tom Clohosy Cole](https://i.imgur.com/KF3B43y.jpg) --><!-- ![by Daria Kolesnikova](https://i.imgur.com/zJRTnei.jpg) --><p><img src="https://i.imgur.com/TJQDGmr.jpg" alt="by Daria Kolesnikova"><span class="cap">by Daria Kolesnikova</span></p><p>讓我們進入「Simple Notion」系列的第三篇，同時也是最後一篇。這次我們要聊聊，<strong>最能夠代表 Notion 的關鍵元素</strong>。</p><p>提到 Notion 你會想到什麼？沒錯，<strong>database</strong>！</p><p>Notion 在 2016 年就誕生了（你也可以說是 2013年，請參考維基百科關於 <a href="https://zh.wikipedia.org/zh-tw/Notion">Notion 的「歷史與發展」</a>），但直到 2018 年才大紅，為什麼？——因為加入了 database。</p><p>儘管在 UI 加入類似 SQL table 元素與互動操作，並非 Notion 獨創。畢竟，在此之前，<a href="https://www.airtable.com/">Airtable</a> 已經是這方面的佼佼者。但我們不得不承認，<strong>Notion 確確實實把 database 玩出了新的高度</strong>。</p><h3 id="系列：Simple-Notion——我的-Notion-簡潔之道"><a href="#系列：Simple-Notion——我的-Notion-簡潔之道" class="headerlink" title="系列：Simple Notion——我的 Notion 簡潔之道"></a><strong>系列：Simple Notion——我的 Notion 簡潔之道</strong></h3><blockquote><ol><li><a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a></li><li><a href="https://blog.kyomind.tw/stumbling-on-notion/">少則得，多則惑：使用 Notion 時的兩個常見陷阱</a></li><li><strong>剛剛好：Notion database「反複雜」使用指南</strong></li></ol></blockquote><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>我希望不落俗套地，討論 Notion 的 database——它的美麗與哀愁。</p><p>既然是「Simple Notion」系列文章，主軸仍會聚焦在「簡潔」二字。而講到簡潔使用 Notion，database 絕對是<strong>一個無法繞過的主要議題</strong>。</p><span id="more"></span><h3 id="何謂不落俗套？"><a href="#何謂不落俗套？" class="headerlink" title="何謂不落俗套？"></a>何謂不落俗套？</h3><p>看過前兩篇的讀者或許能預見，我又要來說一說 database 的缺點了。嚴格而言，應該稱之為「濫用 database 的困境」。</p><p>Notion database 是如此的強大，以至於能夠讓 Notion 在眾多筆記軟體中脫穎而出。甚至，有了 database，你簡直不能說 Notion 只是一個筆記軟體了。</p><p>說它是一個資料平台也不為過。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>這篇文章是為了「已使用過 Notion database 但<strong>覺得太複雜或心累</strong>」的讀者而寫。</p><p>因為我就是其中一員！至少曾經是。</p><p>雖然現在已經較少使用 Notion database（只拿來管理文章草稿和工作會議記錄），但我覺得這個「利器」，適度使用還是非常方便的。</p><h2 id="本文架構與主軸"><a href="#本文架構與主軸" class="headerlink" title="本文架構與主軸"></a>本文架構與主軸</h2><p>我們要先講 Notion database 為什麼強大，然後再討論與之相關的「困境」，最後則是我對這些困境的解法與心得。</p><p>本文的主軸是「<strong>Notion database 使用之道</strong>」。因此，如同前兩篇，文中不會有任何關於 Notion database 的詳細操作教學——這些是「術」。</p><p>想知道各種 database 使用技巧，可以上 YouTube，那裡有著海量的學習資源。</p><hr><p>讓我們進入正題。</p><h2 id="Notion-的核心——database"><a href="#Notion-的核心——database" class="headerlink" title="Notion 的核心——database"></a>Notion 的核心——database</h2><p>Notion database 真的很強大。可以說，光是 database 和六種 <a href="https://www.notion.so/help/guides/when-to-use-each-type-of-database-view">database view</a>，就佔據了 Notion 一半以上的重要功能——以及複雜度。</p><p>雖然 Notion database 有借鑑 Airtable 之嫌，但 <strong>view 與 view 之間的自由切換、資料的靈活呈現</strong>，則是任何剛接觸的人，都不得不讚嘆的強大應用模式。</p><h3 id="Notion-的本體就是-database"><a href="#Notion-的本體就是-database" class="headerlink" title="Notion 的本體就是 database"></a>Notion 的本體就是 database</h3><p>換句話說，我認為要用 Notion，絕對是因為它強大的 database。</p><p>這東西大大滿足了喜歡收集資料，和把它們整理得井然有序而且美觀的筆記控！我也曾經是這一份子啦☺️</p><p>不過就像前一篇說的，不建議花太多時間在「美觀」上，這會沒完沒了：</p><blockquote><p>這些元素可以讓你<strong>在視覺上感到富足</strong>，但從<strong>筆記效率</strong>與<strong>學習、實用角度</strong>來看，恐怕沒有多少幫助。光挑選這些「<strong>樣式</strong>」，就能花掉你不少時間，甚至讓人<strong>樂此不疲</strong>。</p></blockquote><h3 id="Craft——沒有-database-的-Notion？"><a href="#Craft——沒有-database-的-Notion？" class="headerlink" title="Craft——沒有 database 的 Notion？"></a>Craft——沒有 database 的 Notion？</h3><p>第一篇我們曾討論過「<a href="https://blog.kyomind.tw/simple-notion/#Notion-%E6%9B%BF%E4%BB%A3%E5%93%81%EF%BC%9F">Notion 替代品？</a>」這個議題，並提到了這篇文章〈<a href="https://matters.town/@willliu/169743-%E6%88%91%E7%94%A8%E4%BE%86%E5%8F%96%E4%BB%A3-notion-%E7%9A%84%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94-craft-bafyreibxtqjrt6yiwto5jqpogd27j6wcloj3xvq6z5w5nyhafqzpq33ydy">我用來取代 Notion 的筆記軟體：Craft</a>〉。</p><p><a href="https://www.craft.do/">Craft</a> 被部分人稱之為「<strong>沒有 database 的 Notion</strong>」，意味著它省去了 database 的複雜，但保留了其它吸引人的功能。</p><p>我自己因為有訂閱 <a href="https://setapp.com/">Setapp</a>（Craft 有收錄其中），所以有短暫嘗試過一下，但體驗不是很好。</p><p>主要是中文排版讓我覺得頗為零亂，而且字太小又沒有調整機制，這違背了我對筆記軟體的「<a href="https://blog.kyomind.tw/bear/#%E4%BA%8C%E3%80%81%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E7%9A%84%E9%81%B8%E9%A0%85%E5%A4%AA%E5%B0%91">三大基本要求</a>」。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/bear/">Evernote 最佳替代方案——筆記軟體 Bear 2 升級心得</a></p></blockquote><p>但扣除這些，我也不禁在想：「沒有 database 的 Notion，我會想用嗎？」——我深表懷疑。</p><p>簡言之，database 無庸置疑是 Notion 的一大利器。我認為，想要充分感受 Notion 的魅力，學習 database 是不可或缺的一環。</p><p>但是！<strong>怎麼用，才算是「剛剛好」</strong>？</p><p>我歸納了學習使用 Notion database 常見的三大困境。先了解它們，才好對症下藥。</p><hr><h2 id="困境一：學習門檻"><a href="#困境一：學習門檻" class="headerlink" title="困境一：學習門檻"></a>困境一：學習門檻</h2><p>如前所述，database 佔據了 Notion 一半以上的功能與<strong>複雜度</strong>。對於沒有太多時間深入研究的人而言，學習如何有效使用 database 可能是一個挑戰，甚至是一種焦慮。</p><p>而網路上的很多教學，進一步加劇了這個困境。</p><p>部分文章或 YouTube 影片，為了讓讀者、觀看者印象深刻，往往使用相對複雜或進階的技巧，藉以展現 Notion  database 的強大功能。</p><p>這些 database 技巧印證了 Notion 的強大，但也可能間接增加了<strong>學習時的心理負擔</strong>，讓部分新手感到困惑與沮喪，覺得自己無法有效應用 Notion。</p><p>這也是為什麼我會寫下〈<a href="https://blog.kyomind.tw/notion-markdown/">Notion 教學：10 個我最常用的 Markdown 語法與快捷鍵介紹</a>〉這樣的文章，讓 Notion 操作回歸基本。</p><p>毫無疑問，我認為 database 的使用，也應該回歸基本——但並不容易。</p><h2 id="困境二：不必要的複雜"><a href="#困境二：不必要的複雜" class="headerlink" title="困境二：不必要的複雜"></a>困境二：不必要的複雜</h2><p>說起「不必要的複雜」，軟體工程師可能頗有經驗，在開發上我們稱為「過度設計」。</p><p>複雜不一定是問題，少數情況就是要「複雜且有系統地處理」。但是，我們也常看到，很多時候的複雜，真的不是那麼必要。</p><p>這裡所謂的「複雜」，可以指使用 database 欄位各種進階技巧，比如把「公式」欄位玩出各種花樣，或巧妙建立 database 間的關聯（對應欄位是 Relation 和 Rollup）。或任何你看了會不禁發出「wow！」讚嘆的用法。</p><p>誠然，Notion databse 可以做很多事，但這也可能讓你不知不覺掉入了前一篇提到的「<a href="https://blog.kyomind.tw/stumbling-on-notion/#%E9%81%8E%E5%BA%A6%E8%A8%AD%E8%A8%88%EF%BC%9A%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E7%AD%86%E8%A8%98%E6%9E%B6%E6%A7%8B%E5%B8%AB">筆記架構師陷阱</a>」：</p><blockquote><p>這是一個逐漸「<strong>上癮</strong>」的過程，因為 Notion 創建新頁面與層級是<strong>如此地簡單</strong>，導致遇到<strong>新需求</strong>時，我就想要用「<strong>增加 Notion 元素、擴張筆記架構</strong>」的方式來應對，結果它愈長愈大，直到脫離了我的控制。</p></blockquote><p>「擴張筆記架構」最<strong>典型</strong>的情況，就是增加 database 的<strong>數量和欄位</strong>！甚至是它們之間的<strong>關聯</strong>。</p><p>這也就是下面要講的——過度使用。</p><hr><h2 id="困境三：過度使用"><a href="#困境三：過度使用" class="headerlink" title="困境三：過度使用"></a>困境三：過度使用</h2><blockquote><p>一有新的筆記整理、分類需求，就立刻想到新增一個 database；或為既有的 database 新增一個甚至多個欄位。</p></blockquote><p>這幾乎是所有 Notion 新手<strong>不可避免的困境</strong>，當然包括我。</p><p>這樣做有什麼問題？相信過來人都懂，讓我講講自身的經驗。</p><h3 id="使用-Notion-做程式筆記"><a href="#使用-Notion-做程式筆記" class="headerlink" title="使用 Notion 做程式筆記"></a>使用 Notion 做程式筆記</h3><p>以前大量使用 Notion，主要就是為了學程式，所以有很多程式相關的筆記。這些筆記本來只有兩個 database：</p><ol><li>學習筆記：技術類書籍、線上課程、文章的整理。</li><li>實作筆記：開發過程中遇到的問題與我的踩坑記錄。</li></ol><p>這感覺不錯，但你可能已經猜到——兩個根本不夠用！至少對我而言不夠用。</p><p>光學習，可能要區分成「程式類」和「非程式類」。而不同素材如書、線上課、文章等等，我不希望它們<strong>歸納時</strong>沒有任何區別，因為這樣找起來或複習很麻煩。</p><p>於是，為了新的「子分類」，要麻再多開一個 database，不然就是多增加一些欄位作為區別。我甚至想把程式主題再進一步細分，比 Django、Docker、Python 等等。</p><p>如此反覆，我的學習筆記類 database 在數量上增加到了 6-8 個，其中有的欄位多、有的欄位少。</p><h2 id="Database-太多了！"><a href="#Database-太多了！" class="headerlink" title="Database 太多了！"></a>Database 太多了！</h2><blockquote><p>後來，看著一堆 database，覺得自己好累，尤其在新增一則筆記時，不得不先思考：「呃……它應該放到哪個 db？」——好像已經太多了。</p></blockquote><p>如果你有很多個 database 要維護，那你對它們得有一個<strong>相對清晰的概念與操作體系</strong>，才不容易作繭自縛。</p><p>但我必須說，至少在「學習」這一塊，要透過清晰的體系來架構 database，恐怕相對困難。</p><p>為什麼？因為隨著學習的進展，<strong>知識體系往往也會不斷調整</strong>。以往的分類可能不再適用或滿足你，需要做出一定改變。</p><p>然而，<strong>database 是很「重」的</strong>，增加欄位可以，但想要把一部分的資料遷移到新的 database 或分配到不同層級，則麻煩很多。不僅需要你<strong>手動搬運</strong>（使用<code>Move to</code>），還需要處理搬運後<strong>新舊欄位不相容的問題</strong>。</p><p>此外，每新增一筆記錄，就要為欄位選擇各項值，也是一件「看起來有條理，但實際對學習沒有直接助益」的苦力活。</p><p>這些當然可以用模板等功能來簡化，但，你不累嗎？</p><h3 id="無解的「分類」難題"><a href="#無解的「分類」難題" class="headerlink" title="無解的「分類」難題"></a>無解的「分類」難題</h3><p>我認為<strong>分類難題</strong>（為各種事物、概念等筆記找到分類上的明確歸屬）可以說是無解的——尤其當這些分類會<strong>隨著時間不斷變動</strong>的情況下。</p><p>而大量的 database，<strong>本質上就是一層又一層的分類</strong>，容易累死自己。</p><p>還是要再強調一下，這裡我類比的情境是「學習筆記」，一個在分類上<strong>容易不斷變動</strong>的主題。但我覺得，其實現實中大部分情況都是如此——分類就是會一直變動。</p><p>當然，也有例外，比如年、月、週等計畫的 database，概念之間是相對分明的。</p><p>無論如何，只要 database 一多，新增筆記時你難免就要先思考「我要新增到哪個 db？」，複習或搜尋時也要想著「這件事應該是記在哪個 db？」</p><p>腦力成本高昂。</p><hr><h2 id="我的-database-減法"><a href="#我的-database-減法" class="headerlink" title="我的 database 減法"></a>我的 database 減法</h2><p>簡單使用 Notion database 比簡單使用 Notion 要來得容易，我個人會貫徹下列原則。</p><p>不過這些原則<strong>多少都會限制 database 的發揮</strong>，所以是「原則」，作為<strong>需要時的指引</strong>。</p><h3 id="一、能透過「新增欄位」達成的，就不新增-db"><a href="#一、能透過「新增欄位」達成的，就不新增-db" class="headerlink" title="一、能透過「新增欄位」達成的，就不新增 db"></a>一、能透過「新增欄位」達成的，就不新增 db</h3><p>雖然欄位管理也是一個難題，但怎麼說都比新增一個獨立 database 來得<strong>輕量</strong>。</p><p>換句話說，當筆記架構變得複雜，需要更多手段來<strong>有效分類</strong>不同筆記時，建議優先選擇建立欄位而非新增 database。</p><h3 id="二、欄位不要過多"><a href="#二、欄位不要過多" class="headerlink" title="二、欄位不要過多"></a>二、欄位不要過多</h3><p>雖然說能用欄位處理的就不要透過 db，但欄位的增加也必須適合可止，盡可能讓每一個欄位<strong>都是必要的</strong>，而不是為了「<strong>看起來井然有序</strong>」或「<strong>看起來更完整</strong>」。</p><p>畢竟填寫欄位的人是自己。即使有模板，要應付各種複雜的欄位與情況，模板可能也要很多樣，這些都不利於筆記。</p><p>就我的經驗看來，<strong>閱讀類的 database，最容易出現欄位過多的問題</strong>。</p><p>因為一本書有<strong>很多種屬性</strong>，<strong>非常適合</strong>透過 database 歸納與整理！比如封面、作者、出版社、出版年度、書籍分類、個人評價、名言摘錄等等，簡直沒完沒了。</p><p>但閱讀一本書，最重要的往往只有一件事——獲得最大程度滿足與改變自身行動。</p><h3 id="三、減少進階功能的使用"><a href="#三、減少進階功能的使用" class="headerlink" title="三、減少進階功能的使用"></a>三、減少進階功能的使用</h3><p>db 關聯、公式欄位等等比較進階的功能，讓人感覺很厲害，有時候也確有妙用。但我覺得，<strong>少知道一點或許會比較好。</strong></p><p>重劍無鋒，大巧不工。雖然不是最高竿的使用，卻可能會更加高效。</p><h3 id="四、善用-view-與-linked-database"><a href="#四、善用-view-與-linked-database" class="headerlink" title="四、善用 view 與 linked database"></a>四、善用 view 與 linked database</h3><p>過濾、排序、view 等功能分頁，我覺得它們是「必要之惡」——這是讚美☺️</p><p><img src="https://i.imgur.com/DLNmoEx.png" alt="view 分頁"><span class="cap">view 分頁</span></p><p>雖然太多分頁也會造成困擾，但透過分頁選擇不同 view、過濾條件、排序方式等，<strong>確實能讓 db 資料更加有效呈現，充分發揮看資料的視角</strong>，我認為非常值得善用。</p><p>如果分頁太多了，推薦再開一個 <a href="https://www.notion.so/help/guides/using-linked-databases">linked database</a>，這下又多了一個呈現資料的分身。</p><p>總之，<strong>我認為善用 view 分頁與 linked database，就是用好 Notion database 的一大關鍵！</strong></p><p>在新增 db 或新增欄位之前，我們不妨先想想：「是不是新增一個 view 就能解決？」</p><h3 id="五、固定架構"><a href="#五、固定架構" class="headerlink" title="五、固定架構"></a>五、固定架構</h3><p>我覺得 Notion database 最適合的，是那些<strong>「筆記架構相對固定」的場景</strong>，比如前面提到的年、月、週計畫這類的記錄。</p><p>年、月、週、天就是典型的時間劃分，你很難再生出一種全新的時間劃分方式。所以，database 的欄位設計與架構相對穩定。</p><p>而我們要做的，就是不斷增加筆記的「量」。這種場景，特別能發揮 database 在體系與分類上的優勢。</p><h3 id="六、架構常變動的場景，我使用卡片筆記"><a href="#六、架構常變動的場景，我使用卡片筆記" class="headerlink" title="六、架構常變動的場景，我使用卡片筆記"></a>六、架構常變動的場景，我使用卡片筆記</h3><p>前面已提及，學習筆記的架構很容易依不同階段而變動，採用 database 常常會讓我覺得過於笨重、趕不上變化。</p><p>此外，database 還有一個「複習不便」的致命傷。</p><p>所以我後來才狠心放棄了寫了 2 年的 Notion，改用 Logseq 來做我的程式學習筆記，以適應快速變動的學習，並達到更有效的複習。</p><p>畢竟卡片筆記更像是「<a href="https://blog.kyomind.tw/logseq/#%E7%84%A1%E5%9B%BA%E5%AE%9A%E4%B8%AD%E5%BF%83%E7%9A%84%E6%B8%B8%E6%93%8A%E9%9A%8A">無固定中心的游擊隊</a>」，有著更強的機動性。</p><p>關於「為什麼我改用 Logseq 做程式筆記」，我們會再另篇討論。這裡只要提醒自己：「<strong>database 不適合太過頻繁的架構遷移。</strong>」</p><hr><h2 id="題外話：Notion-並不適合做卡片筆記"><a href="#題外話：Notion-並不適合做卡片筆記" class="headerlink" title="題外話：Notion 並不適合做卡片筆記"></a>題外話：Notion 並不適合做卡片筆記</h2><p>正文已結束，我們來聊個題外話。</p><p>這部分跟本文主軸雖然沒有直接關係（但和 database 有關），我還是忍不住想說——Notion 真的不適合做卡片筆記。</p><p>我們先回顧一下〈<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a>〉提到卡片筆記的<a href="https://blog.kyomind.tw/logseq/#%E5%85%83%E7%B4%A0%E5%8C%96%E8%88%87%E9%80%A3%E7%B5%90%E5%B0%8E%E5%90%91">兩大原則</a>：</p><ol><li>元素化。</li><li>連結導向。</li></ol><p>關鍵是第二個：<strong>連結</strong>。</p><p>我知道，Notion database 有 Relation 欄位可以進行簡單的 db 間關聯，頁面開頭也有本頁的 <a href="https://www.playpcesor.com/2020/09/notion.html">backlinks</a> 可供參考。</p><p>但這些功能，相比於「<strong>原生支援雙向連結</strong>」的卡片筆記軟體如 Logseq、Obsidian，在「<strong>有效實踐卡片之間的連結</strong>」這件事上，效果相去甚遠。</p><p>用 Notion 絕對可以做卡片筆記，但很難做得好。</p><p>只要試想一下，當 Relation 欄位有著 <strong>100 個關聯</strong>的時候，這個欄位看起來會是如何？</p><p>而 100 個關聯對於 Logseq 等卡片筆記 app 而言，僅僅只是開始而已。</p>]]></content>
    
    
    <summary type="html">&lt;!-- ![by Tom Clohosy Cole](https://i.imgur.com/KF3B43y.jpg) --&gt;
&lt;!-- ![by Daria Kolesnikova](https://i.imgur.com/zJRTnei.jpg) --&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TJQDGmr.jpg&quot; alt=&quot;by Daria Kolesnikova&quot;&gt;&lt;/p&gt;
&lt;p&gt;讓我們進入「Simple Notion」系列的第三篇，同時也是最後一篇。這次我們要聊聊，&lt;strong&gt;最能夠代表 Notion 的關鍵元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;提到 Notion 你會想到什麼？沒錯，&lt;strong&gt;database&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;Notion 在 2016 年就誕生了（你也可以說是 2013年，請參考維基百科關於 &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/Notion&quot;&gt;Notion 的「歷史與發展」&lt;/a&gt;），但直到 2018 年才大紅，為什麼？——因為加入了 database。&lt;/p&gt;
&lt;p&gt;儘管在 UI 加入類似 SQL table 元素與互動操作，並非 Notion 獨創。畢竟，在此之前，&lt;a href=&quot;https://www.airtable.com/&quot;&gt;Airtable&lt;/a&gt; 已經是這方面的佼佼者。但我們不得不承認，&lt;strong&gt;Notion 確確實實把 database 玩出了新的高度&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;系列：Simple-Notion——我的-Notion-簡潔之道&quot;&gt;&lt;a href=&quot;#系列：Simple-Notion——我的-Notion-簡潔之道&quot; class=&quot;headerlink&quot; title=&quot;系列：Simple Notion——我的 Notion 簡潔之道&quot;&gt;&lt;/a&gt;&lt;strong&gt;系列：Simple Notion——我的 Notion 簡潔之道&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/stumbling-on-notion/&quot;&gt;少則得，多則惑：使用 Notion 時的兩個常見陷阱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;剛剛好：Notion database「反複雜」使用指南&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;我希望不落俗套地，討論 Notion 的 database——它的美麗與哀愁。&lt;/p&gt;
&lt;p&gt;既然是「Simple Notion」系列文章，主軸仍會聚焦在「簡潔」二字。而講到簡潔使用 Notion，database 絕對是&lt;strong&gt;一個無法繞過的主要議題&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Bear" scheme="https://blog.kyomind.tw/tags/Bear/"/>
    
    <category term="Evernote" scheme="https://blog.kyomind.tw/tags/Evernote/"/>
    
    <category term="卡片盒筆記法" scheme="https://blog.kyomind.tw/tags/%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%B3%95/"/>
    
    <category term="Obsidian" scheme="https://blog.kyomind.tw/tags/Obsidian/"/>
    
    <category term="Airtable" scheme="https://blog.kyomind.tw/tags/Airtable/"/>
    
  </entry>
  
  <entry>
    <title>《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱</title>
    <link href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-02/"/>
    <id>https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-02/</id>
    <published>2023-08-19T05:14:26.000Z</published>
    <updated>2023-09-05T16:23:55.443Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/tS78Ke0.png" alt="Python 功力提升的樂趣"><span class="cap">Python 功力提升的樂趣</span></p><p>我們繼續《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務</a>》閱讀筆記，這是第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><h3 id="系列：Python-功力提升的樂趣"><a href="#系列：Python-功力提升的樂趣" class="headerlink" title="系列：Python 功力提升的樂趣"></a>系列：Python 功力提升的樂趣</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a></li><li><strong>《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱</strong></li></ol></blockquote><hr><h2 id="第-6-章：寫出-Pythonic-風格的程式碼"><a href="#第-6-章：寫出-Pythonic-風格的程式碼" class="headerlink" title="第 6 章：寫出 Pythonic 風格的程式碼"></a>第 6 章：寫出 Pythonic 風格的程式碼</h2><p>我們常常聽到 Pythonic，但如果問起它究竟意味著什麼，可能一時之間也不容易回答，畢竟它沒有一個公認的標準或定義。</p><p>不過，<strong>充利分用 Python 獨有的特性、寫作風格、語法，尤其是善用標準函式庫</strong>（不重複造輪子——因為你自己造的輪子往往<strong>不會</strong>更好、更方便、更有效），顯然是大家都認同的部分。</p><p>至於遵守上篇提到的 <a href="https://peps.python.org/pep-0008/">PEP 8</a>，自然不在話下。如果你的變數命名使用了小駝峰式命名法（lower camel case），那麼在「形式上」就已經不太 Pythonic 了。</p><p>話說回來，本書雖然是一本優秀的 Clean Code in Python 入門書，但不知為何，書中的函式命名皆是採用小駝峰，讓我不甚理解。</p><p>但我們要知道：好孩子不要學。至於為什麼，不用問，問就是 PEP 8。</p><span id="more"></span><h2 id="使用enumerate-而不要用range"><a href="#使用enumerate-而不要用range" class="headerlink" title="使用enumerate()而不要用range()"></a>使用<code>enumerate()</code>而不要用<code>range()</code></h2><p>這真的很重要！當我 review 到下面這類 code 時，我會<strong>強烈要求</strong>必須改用<code>enumerate</code><strong>重構</strong>。</p><p>設想你有一個 Python list 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;moose&#x27;</span>]</span><br></pre></td></tr></table></figure><p>你想同時知道每一個元素是 list 中的<strong>第幾個</strong>與<strong>內容為何</strong>，直觀上可能會這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;moose&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(animals)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i + <span class="number">1</span>, animals[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> cat</span><br><span class="line"><span class="number">2</span> dog</span><br><span class="line"><span class="number">3</span> moose</span><br></pre></td></tr></table></figure><p>這種「<strong>手刻邏輯</strong>式的寫作風格」——要什麼就寫什麼，寫完也不重構——你是否已經屢見不鮮？我們來評論一下，這段程式碼有兩個很醜（難讀）的地方。</p><ol><li><code>i + 1</code>。這寫法顯然是為了讓<strong>計數</strong>從 1 開始——而不是預設的 0。</li><li><code>range(len(animals))</code>寫法非常不直觀，多層的<strong>嵌套式呼叫</strong>讓人看了昏昏欲睡。</li></ol><p>這兩個地方充滿了「<strong>手刻</strong>」的<strong>僵化感</strong>，只是為了<strong>最快速達到開發者「當下目的」而強行採用的一種粗糙手段</strong>——但顯然不是最好的那個。</p><p>雖然兩者都不難理解與推測，但除了寫這段程式的人，<strong>誰也無法 100% 確信作者的「意圖」</strong>——這是<a href="https://ithelp.ithome.com.tw/users/20107637/ironman/1927">糙 code</a> 的特色，它存在著<strong>大量且不必要的誤解空間</strong>。</p><p>這些<strong>不明確的誤解空間</strong>會造成別人閱讀本段程式碼時的「<strong>思考停頓</strong>」，更別說後續滋生 bug 的可能。所幸，它們是有可能被消除的。比如使用以下的<code>enumerate</code>。</p><p>一言以蔽之，你只要<strong>在<code>for</code>迴圈內</strong>，看到以下這樣的寫作模式，那就是典型的 Python <a href="https://blog.darkthread.net/blog/refactoring-notes-2-bad-smell/">壞味道</a>：</p><blockquote><p><code>iterable[index]</code>（<code>可迭代物件[物件元素的索引值]</code>）</p></blockquote><p>迭代任何<code>iterable</code>同時，又需要知道每一個元素的索引值，這毋寧是很常見的需求。</p><p>因為太常見了，所以 Python 早就幫你準備好了——就是為了這種情況而存在的——<code>enumerate</code>。</p><p>同樣的需求，我們應該要這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;moose&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals, start=<span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, animal)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> cat</span><br><span class="line"><span class="number">2</span> dog</span><br><span class="line"><span class="number">3</span> moose</span><br></pre></td></tr></table></figure><p><code>start=1</code>讓你不用再<code>i+1</code>，也不再需要<code>range</code>和<code>len</code>的疊床架屋。</p><p>兩種寫法的結果是一樣的，但後者更加善用 Python 的內建特性，<strong>且優雅</strong>。</p><p><strong>善用 Python 的自身的特性寫出優雅而簡潔的程式碼——這就是 Pythonic。</strong></p><hr><h3 id="使用with陳述式而不要手動close"><a href="#使用with陳述式而不要手動close" class="headerlink" title="使用with陳述式而不要手動close()"></a>使用<code>with</code>陳述式而不要手動<code>close()</code></h3><p>因為你很可能會忘記 close！</p><p><code>with</code>（<strong>context manager，上下文管理器</strong>）在資源管理上很有用，比如文件讀寫或資料庫連接等，可以確保即使有錯誤發生，也能正確地關閉、釋放資源。</p><p>但對於不熟悉或不常見的物件，<strong>則要注意物件是否實作了所謂的「上下文管理協定」</strong>。</p><p>這個協定要求物件必須實作以下兩個方法：<code>__enter__</code> 和 <code>__exit__</code>。這樣物件搭配<code>with</code>使用時，才能正常運作。</p><h3 id="使用is比較是否為None，而不用"><a href="#使用is比較是否為None，而不用" class="headerlink" title="使用is比較是否為None，而不用=="></a>使用<code>is</code>比較是否為<code>None</code>，而不用<code>==</code></h3><p>細節請參考書中的詳盡說明，所幸現代 linter 都會提醒你：在比較<code>None</code>、<code>True</code>、<code>False</code>這 3 種值時，請使用<code>is</code>而非<code>==</code>。</p><h3 id="以-Pythonic-風格來運用字典"><a href="#以-Pythonic-風格來運用字典" class="headerlink" title="以 Pythonic 風格來運用字典"></a>以 Pythonic 風格來運用字典</h3><ol><li>使用<code>get()</code>來處理沒有 key 值而出現<code>KeyError</code>的情況。（不過有時候缺少 key 是一個警訊，此時不宜透過 get 讓這個警訊被忽略）</li><li>使用<code>setdefault()</code>來處理沒有 key 值就要<strong>新增該 key 並給定一個預設值</strong>的情況。</li><li>使用<code>collections.defaultdict</code>來更細緻地處理預設值。</li></ol><p>前兩者你可能已經熟悉，而第 3 種在特定情境真的很好用！以前當資料工程師，進行資料清洗時，我就很喜歡用<code>defaultdict</code>。</p><p>關於<code>defaultdict</code>的用法與介紹，可直接參考這篇〈<a href="https://ithelp.ithome.com.tw/articles/10193094">collections雜談之一 ——— dict的key值存不存在乾我屁事</a>〉。</p><hr><p>上面舉的種種例子，都是常見的 <strong>Python 寫作慣例</strong>，這些慣例是 Python 在設計功能時就已經詳細考慮到的常見情況。換句話說，它們也往往是<strong>最佳實踐</strong>。</p><p>這樣寫，我們不敢說是必要的。只是你真的這麼做的話，熟悉 Python 的人會知道，你就是一個「<strong>內行人</strong>」。</p><p>還是那句〈<a href="https://zh.wikipedia.org/zh-tw/Python%E4%B9%8B%E7%A6%85">Zen of Python</a>〉中的名言：</p><blockquote><p>任何問題應有一種，且<strong>最好只有一種</strong>顯而易見的解決方法。（There should be one– and preferably only one –obvious way to do it.）</p></blockquote><p>說到內行人，下一章我們就來看看，內行人還需要知道哪些事情。</p><h2 id="第-7-章：程式設計的行話"><a href="#第-7-章：程式設計的行話" class="headerlink" title="第 7 章：程式設計的行話"></a>第 7 章：程式設計的行話</h2><p>行話，在本章的情境中，指的是程式設計中的「術語」——包括不限於 Python。</p><p>本章應該算是這些重要基礎的再次強調，有一定經驗的人，可以直接跳過。但我還是介紹一些值得重新溫習的內容。</p><h3 id="物件、值、型別、識別碼"><a href="#物件、值、型別、識別碼" class="headerlink" title="物件、值、型別、識別碼"></a>物件、值、型別、識別<strong>碼</strong></h3><p>物件（object）是<strong>資料的表示形式</strong>，例如數字、字串，或更複雜的資料結構，比如 list 或 set。</p><blockquote><p>所有的物件都具有<strong>值</strong>、<strong>識別碼</strong>（id）和<strong>資料型別</strong>。</p></blockquote><p>這句話很重要。因為我們很常把物件的「值」（比如數字 12、字串<code>&quot;hello&quot;</code>）視為物件「本身」，但實際上那只能說是物件的一個<strong>重要屬性</strong>。</p><p>而物件的其它兩個重要屬性，就是 id（代表物件在<strong>當前的程式執行期間</strong>在<strong>記憶體中的地址</strong>）和型別。</p><p>id 屬性的內容可以透過內建的<code>id</code>函式取得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(<span class="number">12345</span>)</span><br><span class="line"><span class="number">4603344144</span></span><br></pre></td></tr></table></figure><p>而型別則是透過<code>type()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">12345</span>)</span><br><span class="line"><span class="built_in">int</span></span><br></pre></td></tr></table></figure><p>了解這些細節的重要理由是，每次執行程式時，物件的 id 與型別不會改變，但物件的值是可以變動的！這是可變與不可變物件的基石。</p><p>此外，如果兩個物件的 id 相同，那麼它們就是<strong>同一個物件</strong>。這將有助於你理解關於「物件的參照」與「<a href="https://blog.kyomind.tw/the-quick-python-book/#%E4%B8%80%E3%80%81Python-%E4%B8%AD%E7%9A%84%E8%AE%8A%E6%95%B8%EF%BC%9A%E6%98%AF%E6%B0%B4%E6%A1%B6%E9%82%84%E6%98%AF%E6%A8%99%E7%B1%A4%EF%BC%9F">一、Python 中的變數：是水桶還是標籤？</a>」等議題。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/the-quick-python-book/">最佳 Python 入門書——《Python 技術者們 - 練功！》心得與導讀</a></p></blockquote><h3 id="可變與不可變"><a href="#可變與不可變" class="headerlink" title="可變與不可變"></a>可變與不可變</h3><p>剛剛提到，物件中只有「值」是可以（有可能）改變的。所以依照物件的<strong>值是否可以改變</strong>，物件也分為兩大類：</p><ol><li>可變物件。</li><li>不可變物件。</li></ol><p>這無疑是一大經典議題，但這裡就不展開了。只要知道物件的可變與不可變，對於變數的「參照」有著巨大的影響。有興趣可以再看看「<a href="https://blog.kyomind.tw/the-quick-python-book/#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6%E4%BD%9C%E7%82%BA%E5%BC%95%E6%95%B8%E6%99%82%E8%A6%81%E5%B0%8F%E5%BF%83">二、使用可變物件作為引數時要小心</a>」部分。</p><hr><p>本章還有很多術語的定義介紹，比如陳述式（statement）與表達式（expression）、iterable 與 iterator、參數與引數……等等，就請讀者自行參照書中介紹囉！</p><h2 id="第-8-章：常見的-Python-誤解和陷阱"><a href="#第-8-章：常見的-Python-誤解和陷阱" class="headerlink" title="第 8 章：常見的 Python 誤解和陷阱"></a>第 8 章：常見的 Python 誤解和陷阱</h2><p>本章介紹基於 Python 特性的一些常見錯誤——我們一定都踩過。在此只提「為什麼這樣不好」以及如何避免這些不佳實作的<strong>核心思路</strong>。</p><h3 id="不要在迴圈中新增或刪除「被迭代物件（比如-list）」中的元素"><a href="#不要在迴圈中新增或刪除「被迭代物件（比如-list）」中的元素" class="headerlink" title="不要在迴圈中新增或刪除「被迭代物件（比如 list）」中的元素"></a>不要在迴圈中新增或刪除「被迭代物件（比如 list）」中的元素</h3><p>只要遇過一、兩次就會知道這個坑，但一段時間後，很可能會一錯再錯XD。</p><p>新增可能會造成無限迴圈（因為迭代不完），而且刪除則很可能會造成<strong>索引值與你預期內容產生錯亂的問題</strong>。</p><p>大原則就是「不要在迴圈中<strong>編輯</strong>（修改）當前被迭代的<strong>可變物件</strong>」，如果必須這麼麼做，就為它們建立一個「副本」吧！</p><h3 id="一定要用copy-copy-和copy-deepcopy-來複製「可變值」"><a href="#一定要用copy-copy-和copy-deepcopy-來複製「可變值」" class="headerlink" title="一定要用copy.copy()和copy.deepcopy()來複製「可變值」"></a>一定要用<code>copy.copy()</code>和<code>copy.deepcopy()</code>來複製「可變值」</h3><p>承上，既然要建立複本，就要採用穩妥的方式，而穩妥方式就是使用內建方法。</p><p>這又又又是一個「物件參照」的相關議題。下一個也是。</p><h2 id="不要使用「可變物件」作為「預設參數」"><a href="#不要使用「可變物件」作為「預設參數」" class="headerlink" title="不要使用「可變物件」作為「預設參數」"></a>不要使用「可變物件」作為「預設參數」</h2><p>這點你可能已經很熟悉了，因為幾乎每一本書都會強調。</p><p>我們用簡單的一段話來再次回顧，<strong>為什麼不能這麼做</strong>，by ChatGPT：</p><blockquote><p>在Python 中，不應該用可變物件做預設參數（引數），因為這個可變物件在函式第一次<strong>被定義的時候</strong>就已經「<strong>固定</strong>」了。（<strong>只會建立一次</strong>）</p></blockquote><blockquote><p>以後每次呼叫這個函式但<strong>沒有提供這個引數</strong>的話，都會<strong>共用同一個物件</strong>。如果你在函式裡改變了這個物件，那麼下次呼叫時，<strong>這個改變就被保留下來了</strong>。這會讓程式的行為變得很難預測和控制。</p></blockquote><p>看一下程式碼，這個函式正常使用時，希望你帶入一個<code>fruit_list</code>作為引數——當然，從上面的「<a href="https://blog.kyomind.tw/the-quick-python-book/#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6%E4%BD%9C%E7%82%BA%E5%BC%95%E6%95%B8%E6%99%82%E8%A6%81%E5%B0%8F%E5%BF%83">二、使用可變物件作為引數時要小心</a>」我們知道，這也是一個不太健康的做法！</p><p>關於使用可變物件為引數，我們先不論，下面的呼叫我們都不給第二個引數，讓它<strong>只使用預設值</strong>。</p><p>我們預期的行為是：每次給定不同的水果，且不給<code>fruit_list</code>引數，則產出應該都要是「以該水果為單一元素的」的 list——<strong>但事實完全不是如此</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_fruit_to_list</span>(<span class="params">fruit, fruit_list=[]</span>):</span><br><span class="line">    fruit_list.append(fruit)</span><br><span class="line">    <span class="keyword">return</span> fruit_list</span><br><span class="line"></span><br><span class="line">apple_list = add_fruit_to_list(<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(apple_list)  <span class="comment"># 輸出: [&#x27;apple&#x27;]</span></span><br><span class="line"></span><br><span class="line">banana_list = add_fruit_to_list(<span class="string">&#x27;banana&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(banana_list)  <span class="comment"># 輸出: [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(apple_list)  <span class="comment"># 輸出: [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure><p>當「第二次」呼叫函式時，情況就<strong>不是我們要的</strong>了：</p><ol><li>banana_list 竟然包含了 apple！</li><li>apple_list 竟然也被改變了！</li></ol><h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>而替代方案想必你也知曉，那就是把預設值改設為<code>None</code>，然後在函式中加上一個判斷式，比如下面的<code>if fruit_list is None:</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_fruit_to_list</span>(<span class="params">fruit, fruit_list=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> fruit_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        fruit_list = []</span><br><span class="line">    fruit_list.append(fruit)</span><br><span class="line">    <span class="keyword">return</span> fruit_list</span><br><span class="line"></span><br><span class="line">apple_list = add_fruit_to_list(<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line">banana_list = add_fruit_to_list(<span class="string">&#x27;banana&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(apple_list)  <span class="comment"># 輸出: [&#x27;apple&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(banana_list)  <span class="comment"># 輸出: [&#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure><p>當沒有提供<code>fruit_list</code>參數（引數）時，<code>if fruit_list is None:</code>判斷式會成立，判斷式內通常會<strong>建立一個全新的可變物件</strong>，讓每一次呼叫都會有不同的<code>fruit_list</code>可變物件，避免前述的「狀態殘留」與意料之外的錯誤。</p><hr><h3 id="不要以字串連接來製作字串"><a href="#不要以字串連接來製作字串" class="headerlink" title="不要以字串連接來製作字串"></a>不要以字串連接來製作字串</h3><p>所謂的字串連接，就是使用<code>+</code>運算子來合併多個字串。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greeting = <span class="string">&#x27;Hello&#x27;</span> + <span class="string">&#x27;World!&#x27;</span></span><br></pre></td></tr></table></figure><p>連接兩個字串無傷大傷，但如果是這樣的話：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greeting = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    greeting += <span class="string">&#x27;one more&#x27;</span></span><br></pre></td></tr></table></figure><p>就會造成效能上的低落——和下列替代方案相比，慢了近 10 倍。</p><p>因為 Python 的<strong>字串</strong>是<strong>不可變</strong>的，所以這種拼接實際上是用舊的字串<strong>建立新的字串</strong>，for 迴圈中的每一次迭代，都會建立一個新字串。</p><p>替代方案當然就是經典的 list +<code>join</code>字串方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greeting_parts = [<span class="string">&#x27;Hello World!&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    greeting_parts.append(<span class="string">&#x27;one more&#x27;</span>)</span><br><span class="line"></span><br><span class="line">greeting = <span class="string">&#x27;&#x27;</span>.join(greeting_parts)</span><br></pre></td></tr></table></figure><h2 id="tuple-中即使只有一個元素，也不要忘記加逗號"><a href="#tuple-中即使只有一個元素，也不要忘記加逗號" class="headerlink" title="tuple 中即使只有一個元素，也不要忘記加逗號"></a>tuple 中即使只有一個元素，也不要忘記加逗號</h2><p>這個例子非常經典！因為不少人可能寫了超過一年的 Python，都未必知道這個特性，而在某些「意料之外」的事發生後，才赫然發現這個事實。</p><p>好，我承認第一次知道時我也很吃驚，還好我是看書知道的。</p><p>照標題的意思，單元素 tuple 應該要長這樣：<code>(&quot;cat&quot;,)</code>，而不是這樣<code>(&quot;cat&quot;)</code>。</p><p>為什麼？</p><p>我們先看一下 ChatGPT 怎麼說：</p><blockquote><p>這是因為在 Python 中，括號（這裡指的是「小」括號）被用於<strong>多個目的</strong>，例如分組表達式。當你寫<code>(&quot;cat&quot;)</code>時，括號會<strong>被解釋為分組符號</strong>，所以這個表達式的值<strong>就是字串</strong><code>&quot;cat&quot;</code>，而<strong>不是</strong>包含一個元素的元組（tuple）。</p></blockquote><blockquote><p>如果你想要創建一個只有一個元素的元組，你需要在那個元素後面加上逗號。所以<code>(&quot;cat&quot;,)</code><strong>才是</strong>包含一個元素的元組。逗號告訴Python你想要創建一個元組，而不僅僅是使用括號進行分組。</p></blockquote><p>非常經典的講解！</p><p>就像《<a href="https://www.tenlong.com.tw/products/9789863479116">流暢的 Python</a>》中說的，逗點才是 tuple 的本體XD。</p><p>這也是為什麼我們在函式中 return 複數值時，不需要為它們加上小括號，只要使用逗點分隔，return 自然就是一個 tuple。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiple_values</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="number">42</span></span><br><span class="line"></span><br><span class="line">result = multiple_values()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 輸出: (&#x27;apple&#x27;, &#x27;banana&#x27;, 42)</span></span><br></pre></td></tr></table></figure><p>足見，逗點確實是定義 tuple 的關鍵。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tS78Ke0.png&quot; alt=&quot;Python 功力提升的樂趣&quot;&gt;&lt;/p&gt;
&lt;p&gt;我們繼續《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務&lt;/a&gt;》閱讀筆記，這是第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;h3 id=&quot;系列：Python-功力提升的樂趣&quot;&gt;&lt;a href=&quot;#系列：Python-功力提升的樂趣&quot; class=&quot;headerlink&quot; title=&quot;系列：Python 功力提升的樂趣&quot;&gt;&lt;/a&gt;系列：Python 功力提升的樂趣&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/&quot;&gt;《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第-6-章：寫出-Pythonic-風格的程式碼&quot;&gt;&lt;a href=&quot;#第-6-章：寫出-Pythonic-風格的程式碼&quot; class=&quot;headerlink&quot; title=&quot;第 6 章：寫出 Pythonic 風格的程式碼&quot;&gt;&lt;/a&gt;第 6 章：寫出 Pythonic 風格的程式碼&lt;/h2&gt;&lt;p&gt;我們常常聽到 Pythonic，但如果問起它究竟意味著什麼，可能一時之間也不容易回答，畢竟它沒有一個公認的標準或定義。&lt;/p&gt;
&lt;p&gt;不過，&lt;strong&gt;充利分用 Python 獨有的特性、寫作風格、語法，尤其是善用標準函式庫&lt;/strong&gt;（不重複造輪子——因為你自己造的輪子往往&lt;strong&gt;不會&lt;/strong&gt;更好、更方便、更有效），顯然是大家都認同的部分。&lt;/p&gt;
&lt;p&gt;至於遵守上篇提到的 &lt;a href=&quot;https://peps.python.org/pep-0008/&quot;&gt;PEP 8&lt;/a&gt;，自然不在話下。如果你的變數命名使用了小駝峰式命名法（lower camel case），那麼在「形式上」就已經不太 Pythonic 了。&lt;/p&gt;
&lt;p&gt;話說回來，本書雖然是一本優秀的 Clean Code in Python 入門書，但不知為何，書中的函式命名皆是採用小駝峰，讓我不甚理解。&lt;/p&gt;
&lt;p&gt;但我們要知道：好孩子不要學。至於為什麼，不用問，問就是 PEP 8。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="筆記" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="閱讀心得" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>Apple Studio Display 適合你嗎？——我的心得與選購指南</title>
    <link href="https://blog.kyomind.tw/apple-studio-display/"/>
    <id>https://blog.kyomind.tw/apple-studio-display/</id>
    <published>2023-08-16T16:06:24.000Z</published>
    <updated>2023-08-26T05:19:00.432Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/H6W14Kj.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p><a href="https://www.apple.com/tw/shop/buy-mac/apple-studio-display">Apple Studio Display</a> 無疑是今年內，我所有新購入的<a href="https://blog.kyomind.tw/weekly-review-16/#%E4%BD%95%E8%AC%82%E5%83%B9%E5%80%BC%E8%A7%80%E5%B1%A4%E7%B4%9A%E7%9A%84%E3%80%8C%E5%99%A8%E7%89%A9%E3%80%8D%EF%BC%9F">器物</a>之中，<strong>最值得的選擇</strong>，且沒有之一。</p><p>但它不一定適合你，也可能不適合多數人。</p><blockquote><p>相關文章：</p><ul><li><a href="https://blog.kyomind.tw/mac-mini/">M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南</a></li><li><a href="https://blog.kyomind.tw/weekly-review-16/">16，我的「價值觀層級」器物清單</a></li></ul></blockquote><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>作為一個使用它近半年的真實用戶，我撰寫本文的目標，就是為了協助你判斷：<strong>是不是真的值得為自己購買一台 Studio Display。</strong></p><p>你也可以當作這是一篇 <strong>Studio Display 開箱文</strong>。</p><p>我們會提到它的優點——我最喜歡的部分。不過，作為一台昂貴的螢幕，在購入之前，你可能更關心「它究竟適不適合自己、值不值得？」</p><p>就像我在〈<a href="https://blog.kyomind.tw/weekly-review-13/">13，我買了 Apple Studio Display 與系列心得寫作計畫</a>〉說的：</p><blockquote><p>那些你<strong>不喜歡</strong>或<strong>可能無法接受</strong>的環節，才是做決定時最重要的考量點——<strong>那些「不」才是關鍵</strong>。</p></blockquote><span id="more"></span><h2 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h2><p>Studio Display 是 Apple 公司專為 Mac 推出的專業顯示器。</p><p>雖然 Windows 電腦也可以連接並使用 Studio Display，但存在一些限制，而且可能還有其它意料之外的問題。</p><p>所以，<strong>本文是寫給 Mac 用戶的選購指南。</strong></p><p>Windows 用戶如果真心想買，建議先參考下列兩篇文章：</p><ul><li><a href="https://www.techbang.com/posts/95066-using-the-apple-studio-display-display-on-a-windows-pc-is">網友實戰在 PC上使用蘋果Studio Display顯示器：不但功能半殘，而且接線可能會把你搞瘋</a></li><li><a href="https://applefans.today/2022-03-how-to-use-apple-studio-display-with-windows-pc/">如何在 Windows 上使用 Apple Studio Display?</a></li></ul><h2 id="兩部影片推薦"><a href="#兩部影片推薦" class="headerlink" title="兩部影片推薦"></a>兩部影片推薦</h2><p>一般的文章，參考材料肯定是放在文末，甚至直接省略。</p><p>但是像「顯示器開箱、評論」這樣的內容，我們從直觀上想像，無疑透過「<strong>影片</strong>」是最適合的，畢竟是它顯示器嘛！——我們想要看顏色、聽聲音。</p><p>因此，我在購入 Studio Display 之前，也不可免地看了大量評測影片。</p><p>但我覺得「少則得，多則惑」，大部分影片講的不夠深入，或者面向的受眾群體更廣，參考價值相對有限。</p><p>我推薦以下這兩部 Studio Display 評測影片，對我頗有幫助。而且我覺得看完文本加上這些影片，已經很足夠：</p><ul><li><a href="https://youtu.be/kdMIw9R7XrQ">最後，我還是怒刷！Apple Studio Display 開箱 &amp; 三個月真實使用心得：蘋果終究是蘋果，連螢幕也有最強生態圈體驗</a></li><li><a href="https://youtu.be/ai7Qc3hV1Xw">「黑貓」Apple Studio Display 開箱 + 評測 + 連接PC</a></li></ul><hr><p>正文開始，我們先講它的優點，再論選購前注意事項，最後給出我對 Studio Display 的總體評價。</p><h2 id="我最喜歡-Studio-Display-的部分"><a href="#我最喜歡-Studio-Display-的部分" class="headerlink" title="我最喜歡 Studio Display 的部分"></a>我最喜歡 Studio Display 的部分</h2><p>以下這幾點是我個人最喜歡 Studio Display 的地方。大部分與主流觀點相同，而最後一項則是我個人的偏好。</p><p>關於優秀的畫質，這對 Studio Display 無疑是基本，且無法用簡單文字呈現，直接參考上述影片即可。以下講述<strong>顏色之外</strong>的細節。</p><h3 id="一、出色的揚聲器"><a href="#一、出色的揚聲器" class="headerlink" title="一、出色的揚聲器"></a>一、出色的揚聲器</h3><p>誰也沒想到，一台螢幕竟然在揚聲器（喇叭）部分引發了熱烈的討論。</p><p>原因無它，如果 Studio Display 的揚聲器音質是 100 分，那其餘「螢幕附帶」的揚聲器，應該沒有一款可以得到 50 分。</p><p>和很多人一樣，買了這台螢幕後，我就把桌上型 2.0 喇叭（兩件式喇叭）丟掉了。電腦桌面空出了原先喇叭與線材佔用的空間，讓人感覺無比清爽！</p><p>無論是音質還是省下的空間，都出乎了我的意料，對此大大加分！</p><p>Studio Display 揚聲器的音質大概可以比美台幣 1500-3000 價位的桌上型 2.0 喇叭。對我而言，已然足夠。</p><p>除此之外，螢幕內建的麥克風和前鏡頭也都有一定水準，對非專業人士而言，堪稱綽綽有餘。</p><h3 id="二、5K-與-4K"><a href="#二、5K-與-4K" class="headerlink" title="二、5K 與 4K"></a>二、<strong>5K 與 4K</strong></h3><p>Studio Display 5K 解析度的 1474 萬總像素量， 比一般常見 27吋 4K 的 829 萬的像素量，<strong>足足多了 77.7%。</strong></p><p>用 PPI 比較，則是 218（5K）VS 163（4K）——差距不可謂不小。而 Studio Display  的 218 PPI，顯然是比照 Macbook 的 PPI 標準。</p><p>不過，使用 27 吋螢幕的視線距離，肯定大於使用筆電型電腦，所以對 PPI 的要求或許不需要達到 Macbook 等級。</p><p>但可以想見，兩者的<strong>細膩度</strong>，在視覺上仍會有一定落差，從文字的「毛邊」就能體現。對於常盯著程式碼與文字稿的我，依舊會很在意。</p><p>所以，5K 解析度對我而言，有其價值與必要性。</p><h3 id="三、抗反射鍍膜"><a href="#三、抗反射鍍膜" class="headerlink" title="三、抗反射鍍膜"></a>三、抗反射鍍膜</h3><p>Macbook 或非平價版 iPad 的用戶，對 Apple 這項科技肯定不陌生。</p><p>不僅保留了鏡面螢幕在觀看時的<strong>通透感</strong>（如下圖），又大幅降低了一般鏡面螢幕的最大問題——反光。</p><p>下圖截取自<a href="https://youtu.be/yiRIfoEqGxw">這部影片</a>，比較<strong>鏡面版</strong>（右，有抗反射鍍膜）和 <strong>Nano-texture 版</strong>（可以類比於一般常見的霧面螢幕，只是 Nano-texture 更高級）的視覺差距。</p><p>擁有抗反射鍍膜的 Studio Display 鏡面版，其視覺效果，無疑是肉眼可見的好。</p><p><img src="https://i.imgur.com/KE1nUaD.png" alt="來源：YouTube 鍾文澤"><span class="cap">來源：YouTube 鍾文澤</span></p><p>這也是為什麼我<strong>非買 Studio Display 不可</strong>的另一大理由。畢竟市面上絕大部分的螢幕都是<strong>霧面</strong>，即使畫質再好，實際顯示效果也會<strong>大打折扣</strong>。</p><p>附帶一提，如影片中所言，除非你<strong>很清楚自身需求</strong>，否則不建議買 Nano-texture 版，而上圖就是理由。</p><h3 id="四、4-邊等寬的螢幕邊框"><a href="#四、4-邊等寬的螢幕邊框" class="headerlink" title="四、4 邊等寬的螢幕邊框"></a>四、4 邊等寬的螢幕邊框</h3><p>這屬於我個人偏好，我非常喜歡 Studio Display 的 4 邊等寬設計。可能有人嫌它還不夠窄（相較於 <a href="https://www.apple.com/tw/pro-display-xdr/">Pro Display XDR</a>），但我覺得很可以了。</p><p>與之相對的，我非常不喜歡各式「下巴型」設計——下邊框很寬，而其餘 3 邊很窄。比如 LG 的<a href="https://www.lg.com/tw/monitors/lg-27up850n-w">很多機型</a>都是如此。</p><p>這類「<strong>不對稱</strong>」設計，其中的審美，恕我難以苟同。</p><hr><h2 id="購買前的注意事項"><a href="#購買前的注意事項" class="headerlink" title="購買前的注意事項"></a>購買前的注意事項</h2><p>前面關於 Studio Display 的優點，你可能未必有感或並不在意。不過以下的注意事項，則是作為消費者的我們，不得不事先考慮的環節。部分取自我實際使用經驗。</p><h3 id="一、固定支架的高度太低"><a href="#一、固定支架的高度太低" class="headerlink" title="一、固定支架的高度太低"></a>一、固定支架的高度太低</h3><p>Studio Display 有「<strong>固定</strong>」和「<strong>可調整高度</strong>」兩種支架——後者要多付 12000。</p><p>對大部分人來說這應該有點難以接受，畢竟我們買一般螢幕時，螢幕底座本來就可以伸縮並調整高低，如今我竟然要多花 12000 才能辦到，豈有此理？</p><p>確實！而且我相信正常人不會想花這個錢——那問題就來了。</p><p>固定支架的<strong>高度有限</strong>，我在買之前就不禁懷疑：「這高度真的夠嗎？」</p><p>仔細看了很多影片（有些影片評的是「可升降」版本，這部分沒有參考價值），並沒有哪一部對此有特別著墨。</p><p>想想我還是不放心，最後選擇了 VESA 版，再另外買了<a href="https://www.dell.com/zh-tw/shop/dell-%E5%96%AE%E4%B8%80%E9%A1%AF%E7%A4%BA%E5%99%A8%E8%87%82%E6%9E%B6-msa20/apd/482-bbdj/%E9%A1%AF%E7%A4%BA%E5%99%A8%E5%92%8C%E9%A1%AF%E7%A4%BA%E5%99%A8%E9%85%8D%E4%BB%B6">螢幕支架</a>。</p><p>事實證明，買 VESA 版是對的！至少就我而言，固定支架的高度是遠遠不夠的——因為我的桌子比較低啦😅</p><p>不過你不一定需要買 VESA 版，但可能要考慮是否具備下列兩項條件之一：</p><ol><li>相對高的桌子。</li><li>螢幕增高架。</li></ol><h3 id="二、VSEA-或支架版？"><a href="#二、VSEA-或支架版？" class="headerlink" title="二、VSEA 或支架版？"></a>二、VSEA 或支架版？</h3><p>VESA 版和其餘兩種支架只能三選一，所以這一步得謹慎，我們繼續此話題。</p><p>絕大部分的螢幕根本沒有這個問題，因為現代螢幕都是底座拆掉就是一個標準的 VESA 接口槽，而 Studio Display 的底座卻無法拆卸，需要你在選購時就決定好。</p><p>這樣的設計著實令人討厭。</p><p>對於已經有獨立螢幕支架的人來說，或許不是太大的問題，直接買 VESA 版即可。不過這裡還有一個考量點，就是萬一要賣掉螢幕，VESA 版可能比較不好賣。</p><p>我自己的思路則是：不考慮轉手問題（應該不會賣掉），但我也不想用螢幕增高架，因為高度固定，萬一使用後的高度看不習慣，又得換一個架子。</p><p>所以我選擇獨立支架 + VESA 版。而從結果看來——我很滿意。</p><h3 id="三、Windows-用戶不建議購買"><a href="#三、Windows-用戶不建議購買" class="headerlink" title="三、Windows 用戶不建議購買"></a>三、Windows 用戶不建議購買</h3><p>如前所述，Studio Display 是為 Mac 開發的螢幕，Windows 電腦可用但問題較多。</p><p>即使這些問題都能一一克服，花這麼多錢卻無法享受完整版的功能，難免讓人心理不平衡。所以我不建議購買。</p><p>當然，如果你真的很喜歡它的畫質（與音質），則另當別論。</p><h3 id="四、Intel-Mac-用戶也要三思"><a href="#四、Intel-Mac-用戶也要三思" class="headerlink" title="四、Intel Mac 用戶也要三思"></a>四、Intel Mac 用戶也要三思</h3><p>即使是 Mac，如果 CPU 是 Intel 版，而且沒有獨立顯卡，只有內顯——尤其是早期的內顯，我強烈建議不要買。</p><p>我自己的 <a href="https://blog.kyomind.tw/weekly-review-09/#%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%8F%B0-Macbook%EF%BC%9AMacbook-Air-2020-Intel-%E7%89%88">2020 Intel 版 Macbook Air</a>，接上這台螢幕，基本上<strong>跑太不動</strong>，可見 5K 解析度對於顯示晶片還是有一定要求。（也可能是硬體不夠相容）</p><p>而 Intel CPU 早期的內顯，只能說是雞肋，有跟沒有差不多！</p><p>所以，如果手上只有 Intel CPU 版的 Mac，可能不一定能夠稱心如意。</p><p>如果是 M 系列晶片，則絕對沒問題。</p><h3 id="五、要不要購買-AppleCare-？"><a href="#五、要不要購買-AppleCare-？" class="headerlink" title="五、要不要購買 AppleCare+？"></a>五、要不要購買 AppleCare+？</h3><p>像 Mac mini、Studio Display 這種「使用場景比較固定」的機器，AppleCare+ 的費用相對低廉，畢竟出保的機率也比較低。</p><p>但 Studio Display 的 AppleCare+ 還是要價 4290！怎麼也稱不上便宜。買不買依舊是一個大問題。</p><p>我最後還是買了。我的考量是，萬一螢幕真的有問題要送修，AppleCare+ 提供到府收送服務，對我比較省事。</p><p>對於沒有車的人而言，這是一個重要的考量——當然你也可以叫計程車😎</p><hr><h2 id="結語：事前功課麻煩，但值得"><a href="#結語：事前功課麻煩，但值得" class="headerlink" title="結語：事前功課麻煩，但值得"></a>結語：事前功課麻煩，但值得</h2><p>為了買這台 Studio Display，我花費了不少心思。好在從結果來看，一切是值得的。</p><p>其實，不想做功課也無妨，畢竟從 Apple 官網購買的產品都有 14 天的鑑賞期，即使完全沒做功課，也可以在使用後覺得不適合時斷然退貨。</p><p>但退貨對我來說（心理上）更麻煩！所以我寧願在事前花時間。</p><p>如果你問我給 Studio Display 的使用滿意度打幾分，我會說 100 分。縱然它真的不便宜，但它的整體表現，完全值得這個價錢，甚至可以說沒有缺點（對我而言）。</p><p>更重要的是，相比也是今年購入的 M2 Pro Mac mini，即使少了 Mac mini，我仍有其他  Macbook 可供選擇。</p><p>而 Studio Display 就這一台了！我完全想不到在同樣的價格下，有其它螢幕選項可以作為「相同滿足感」的替代選項——真的沒有。</p><p>所以在我心中，Studio Display 的地位高於 Mac mini，這也是為什麼它能得到 100 分的根本原因。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/H6W14Kj.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.apple.com/tw/shop/buy-mac/apple-studio-display&quot;&gt;Apple Studio Display&lt;/a&gt; 無疑是今年內，我所有新購入的&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-16/#%E4%BD%95%E8%AC%82%E5%83%B9%E5%80%BC%E8%A7%80%E5%B1%A4%E7%B4%9A%E7%9A%84%E3%80%8C%E5%99%A8%E7%89%A9%E3%80%8D%EF%BC%9F&quot;&gt;器物&lt;/a&gt;之中，&lt;strong&gt;最值得的選擇&lt;/strong&gt;，且沒有之一。&lt;/p&gt;
&lt;p&gt;但它不一定適合你，也可能不適合多數人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/mac-mini/&quot;&gt;M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-16/&quot;&gt;16，我的「價值觀層級」器物清單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;作為一個使用它近半年的真實用戶，我撰寫本文的目標，就是為了協助你判斷：&lt;strong&gt;是不是真的值得為自己購買一台 Studio Display。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你也可以當作這是一篇 &lt;strong&gt;Studio Display 開箱文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們會提到它的優點——我最喜歡的部分。不過，作為一台昂貴的螢幕，在購入之前，你可能更關心「它究竟適不適合自己、值不值得？」&lt;/p&gt;
&lt;p&gt;就像我在〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-13/&quot;&gt;13，我買了 Apple Studio Display 與系列心得寫作計畫&lt;/a&gt;〉說的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那些你&lt;strong&gt;不喜歡&lt;/strong&gt;或&lt;strong&gt;可能無法接受&lt;/strong&gt;的環節，才是做決定時最重要的考量點——&lt;strong&gt;那些「不」才是關鍵&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="開箱評論" scheme="https://blog.kyomind.tw/tags/%E9%96%8B%E7%AE%B1%E8%A9%95%E8%AB%96/"/>
    
    <category term="Studio Display" scheme="https://blog.kyomind.tw/tags/Studio-Display/"/>
    
  </entry>
  
</feed>
