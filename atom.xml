<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-05-16T09:43:05.310Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我寫「AI 對話筆記」的方法與思考</title>
    <link href="https://blog.kyomind.tw/my-ai-dialogue-notes/"/>
    <id>https://blog.kyomind.tw/my-ai-dialogue-notes/</id>
    <published>2024-05-14T17:47:41.000Z</published>
    <updated>2024-05-16T09:43:05.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/YmlPRz1.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>你會把「和 ChatGPT 的對話、問答」寫成筆記嗎？<a href="https://twitter.com/kyomind/status/1790032744598188070">顯然我會，而且很大量！</a></p><p>其中有 8 成以上都是程式相關，來自每天和 ChatGPT 的日常開發問答。</p><p>應該說，與 ChatGPT 對話<strong>早已成為我工作、學習的重要環節</strong>。在〈<a href="https://blog.kyomind.tw/stop-trial-and-error/">別依賴「試誤法」寫程式</a>〉中我也<a href="https://blog.kyomind.tw/stop-trial-and-error/#%E8%A9%A6%E8%AA%A4%E4%BE%9D%E8%B3%B4%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%95%8F%E9%A1%8C">強調過</a>，像 ChatGPT 這樣的工具，如果僅僅用來「獲得答案」，<strong>未免也太可惜。</strong></p><p>因此，我幾乎每天都會有新的「AI 對話筆記」。</p><p>話說回來，把 AI 的回答寫成筆記，並作為主要的知識來源，<strong>這是一個好的實踐嗎？</strong></p><p>本文無法回答這個問題XD，但我可以分享一下，做了一年 AI 對話筆記後，我的看法與注意事項。</p><span id="more"></span><p>附帶一提，我的筆記是 Logseq 閃卡（Flash card），大致做法可參考「<a href="https://blog.kyomind.tw/less-is-more/#%E6%88%91%E5%9C%A8-Logseq-%E7%9A%84%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE">我在 Logseq 的局部實現</a>」或這篇<a href="https://www.facebook.com/fomo.kyo/posts/pfbid0KMyv8WAyMJSQBz8kvVQsmhXmHRspVknx3wwCcdjwvNJrH22bpZKZPMxcEZHECVJVl">臉書</a>。更多閃卡實作細節，我們另篇再談。</p><hr><h2 id="事實、觀點與幻覺"><a href="#事實、觀點與幻覺" class="headerlink" title="事實、觀點與幻覺"></a>事實、觀點與幻覺</h2><p>事實、觀點的定義與區別，這裡不多作闡述。只要能大概區分這兩者，就可以繼續往下閱讀。</p><p>筆記內容，往往是事實與觀點兼具，而我們常說 AI 有「<a href="https://zh.wikipedia.org/zh-tw/%E5%B9%BB%E8%A7%89_(%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD)">幻覺</a>」，主要著眼於它對事實的瞎掰胡扯。</p><p>如果你跟我一樣，把 AI 回答做成筆記並複習，而且為的是「專業技術養成」，那 AI 對於事實的幻覺，當然會是一個重要議題。</p><p>殘酷的是，幻覺目前還很難完全避免。</p><p>因此，把 AI 的回答寫成筆記，還是要有一些方法與準則才好。</p><h2 id="加上標籤"><a href="#加上標籤" class="headerlink" title="加上標籤"></a>加上標籤</h2><p>基於這個擔憂，所有對 AI 的回答整理，我會加上一個標籤，我自己是用 #Session，代表我和 AI 的對話內容。</p><p>貼上標籤只是一個提醒：告訴自己，這些內容是 AI 產生的，只能作為「參考」。雖然嚴格來說，我們所知道的一切，都是參考。</p><h2 id="預設相信八成"><a href="#預設相信八成" class="headerlink" title="預設相信八成"></a>預設相信八成</h2><p>我的看法是，在「<strong>一般情況</strong>（下面會討論「非一般」情況）」下，AI 的回答我會給予 80% 的相信程度。（這只是一種量化的表達方式，不必太認真）</p><p>所謂的「一般情況」，就是<strong>你大概能相信它不會講錯</strong>的情況，這好像是廢話XD。舉例而言，好比我問 ChatGPT 關於 Python 的議題。</p><p>而 Python 是一個很「<strong>一般（general）</strong>」的主題，意謂<strong>網路、文獻資料極多</strong>，我幾乎不擔心它會說謊（有幻覺）——除非是太新的功能。</p><p>對，我只會這樣分XD！所以很依賴個人判斷，但有這個「<strong>場景意識（知曉討論主題的一般與特殊程度）</strong>」確實很重要。</p><p>其實我覺得，加上標籤就很有幫助了！至少是對大腦的一種<strong>提醒</strong>。</p><p>此外，如果不是和 AI 的對話，但是我問了 AI 並用它的回答作為補充，也會上個標籤，此時我用 #GPT——但不限於 ChatGPT 的回答。</p><hr><h2 id="非一般情況——我半信半疑"><a href="#非一般情況——我半信半疑" class="headerlink" title="非一般情況——我半信半疑"></a>非一般情況——我半信半疑</h2><p>上述的「一般」議題我不怕它說謊，但<strong>只要討論主題稍為「特殊」一點，我對它可信度的把握，也隨之下降。</strong></p><p>比如，我工作中很常遇到的 Django 議題。Django 算是「一般」還是「特殊」議題，取決於你問的<strong>具體內容（子議題）</strong>是什麼。</p><p>Django 的<strong>基本概念</strong>，問 ChatGPT 沒問題，這些屬於一般議題。</p><p>但<strong>複雜的 ORM 查詢語法</strong>，就<strong>很不一般</strong>（相關資料少得多），你問 ChatGPT，它也都能說出個所以然，但我對它的回答就會半信半疑。</p><p>這時，我需要一些手段來確認。不然乾脆不要記錄，或者記錄時寫下「待驗證」之類的短語。</p><h2 id="降低不確定性的手段"><a href="#降低不確定性的手段" class="headerlink" title="降低不確定性的手段"></a>降低不確定性的手段</h2><p>遇到半信半疑的時候，有三種方法降低我的不確定性。</p><h3 id="一、看文件"><a href="#一、看文件" class="headerlink" title="一、看文件"></a>一、看文件</h3><p>看文件，這肯定是最重要的，文件說了算！——雖然文件有時候也會描述不清楚，讓人愈看愈糊塗。</p><p>但看文件是作為開發者的義務，可以罵文件沒寫好，但自己沒查，總是說不過去。</p><h3 id="二、Google"><a href="#二、Google" class="headerlink" title="二、Google"></a>二、Google</h3><p>老方法，其中 Stack Overflow 的回答還有 GitHub 上的 issue 討論，往往特別有幫助。</p><h3 id="二、問其它-AI-工具"><a href="#二、問其它-AI-工具" class="headerlink" title="二、問其它 AI 工具"></a>二、問其它 AI 工具</h3><p>除了 ChatGPT（GPT-4），是我的絕對開發主力，我使用的其它工具如下：（都沒有付費）</p><ol><li><a href="https://www.phind.com/">Phind</a></li><li><a href="https://claude.ai/">Claude</a></li><li><a href="https://devv.ai/">Devv AI</a></li></ol><p>上述順序恰恰也是我詢問的順序。不過通常問完 Phind 我就收手了，除非我非常想知道答案。（其實這個時候不會有答案，只有更多的疑問和不確定）</p><p>然而，如果我真問完一輪上述的 AI，那這個問題肯定是沒有讓我滿意的回答，<strong>我全部的回答都不信</strong>，只是想知道這些模型怎麼說而已😷</p><hr><h2 id="小結：就算正確，也可能是暫時的"><a href="#小結：就算正確，也可能是暫時的" class="headerlink" title="小結：就算正確，也可能是暫時的"></a>小結：就算正確，也可能是暫時的</h2><p>總的來說，我做筆記的基本態度是：所有的筆記，都只能算「<strong>我暫時相信的事</strong>」，後面有了新的事實、觀點，就要<strong>繼續修改或廢棄內容。</strong></p><p>當然，如果這些筆記參雜太多 AI 幻覺，也是挺困擾的！</p><p>所以我們<strong>需要一些 sense</strong>，知道什麼情況下，對它的回答<strong>不能認真</strong>。加上適時查證，我相信幻覺問題會大大減少。</p><p>而且，無論資訊是否來自 AI，筆記終歸是筆記，我們還是得保持一顆<strong>懷疑的心</strong>，即使是書中的內容，也不能盡信。</p><p>畢竟書的內容即使正確，也可能<strong>被我誤解地記錄下來</strong>。退萬步言，就算是正確的，這樣的正確，<strong>也可能只是暫時的。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YmlPRz1.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;你會把「和 ChatGPT 的對話、問答」寫成筆記嗎？&lt;a href=&quot;https://twitter.com/kyomind/status/1790032744598188070&quot;&gt;顯然我會，而且很大量！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中有 8 成以上都是程式相關，來自每天和 ChatGPT 的日常開發問答。&lt;/p&gt;
&lt;p&gt;應該說，與 ChatGPT 對話&lt;strong&gt;早已成為我工作、學習的重要環節&lt;/strong&gt;。在〈&lt;a href=&quot;https://blog.kyomind.tw/stop-trial-and-error/&quot;&gt;別依賴「試誤法」寫程式&lt;/a&gt;〉中我也&lt;a href=&quot;https://blog.kyomind.tw/stop-trial-and-error/#%E8%A9%A6%E8%AA%A4%E4%BE%9D%E8%B3%B4%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%95%8F%E9%A1%8C&quot;&gt;強調過&lt;/a&gt;，像 ChatGPT 這樣的工具，如果僅僅用來「獲得答案」，&lt;strong&gt;未免也太可惜。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此，我幾乎每天都會有新的「AI 對話筆記」。&lt;/p&gt;
&lt;p&gt;話說回來，把 AI 的回答寫成筆記，並作為主要的知識來源，&lt;strong&gt;這是一個好的實踐嗎？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文無法回答這個問題XD，但我可以分享一下，做了一年 AI 對話筆記後，我的看法與注意事項。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/YmlPRz1.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="學習" scheme="https://blog.kyomind.tw/tags/%E5%AD%B8%E7%BF%92/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>Django REST framework 教學（一）前言篇</title>
    <link href="https://blog.kyomind.tw/django-rest-framework-01/"/>
    <id>https://blog.kyomind.tw/django-rest-framework-01/</id>
    <published>2024-05-11T17:15:37.000Z</published>
    <updated>2024-05-14T03:36:09.559Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 的第 4 篇。</p><p>範例程式碼可參考我的 <a href="https://github.com/kyomind/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="/django/">Django 文章總覽</a>」。</p><hr><p>終於要進入 Django API 的世界了！</p><p>不過，在開始 DRF 教學之前，我要先介紹 Django、DRF 兩者間的<strong>關係</strong>。</p><p>為什麼 Django 不乾脆自己實作 API 功能就好？而是把這個任務交給第三方套件，比如本文的 Django REST framework。</p><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>因此，本文的主要目標是：<strong>為讀者建立一個「high level」的世界觀</strong>。讓你了解為何在 Django 之外，我們還需要 Django REST framework。</p><p>了解兩者的關係，更能體會<strong>它們所扮演的不同角色。</strong></p><p>簡言之，這一篇還沒有要開始寫 API。</p><h3 id="系列：Django-REST-framework-教學"><a href="#系列：Django-REST-framework-教學" class="headerlink" title="系列：Django REST framework 教學"></a>系列：Django REST framework 教學</h3><ul><li><a href="/series/#Django-REST-framework-%E6%95%99%E5%AD%B8">系列文章清單（連載中）</a></li></ul><span id="more"></span><hr><h2 id="Django-介紹"><a href="#Django-介紹" class="headerlink" title="Django 介紹"></a>Django 介紹</h2><p>Django 是一個<strong>全端框架</strong>（其實是附有<strong>前端模板</strong>的<strong>後端框架</strong>），它強大而靈活，能處理從模板渲染、表單生成、後台管理、資料庫模型等，幾乎所有事情。</p><p>我們常說 Python 是「<a href="https://en.wikipedia.org/wiki/Batteries_Included">Batteries Included</a>」（意味有豐富的標準函式庫），<strong>而 Django 也是如此——它大而全。</strong></p><p>在這個設計理念下，Django 關心的是「<strong>整個網站的建構</strong>」，所以它必須要從前端包到後端，而不會只專注在後端 API。</p><h2 id="Django-REST-framework-介紹"><a href="#Django-REST-framework-介紹" class="headerlink" title="Django REST framework 介紹"></a>Django REST framework 介紹</h2><p>當涉及到現代 Web 開發，尤其是與前端框架如 React、Vue 的配合，我們需要<strong>更專注於 API 的開發方式</strong>。畢竟「<strong>前後端分離</strong>」是當前 Web 開發主流。</p><p>於是我們有了 <a href="https://www.django-rest-framework.org/">Django REST framework</a>。</p><blockquote><p>我仔細看，<strong>f 真的是小寫，而 REST 要全大寫</strong>，這是官方的寫法。為了表述方便，以下簡稱為 DRF。</p></blockquote><p>DRF 引入了專門針對 API 的功能，如強大的序列化器、權限管理、通用 API 視圖。</p><p>這些功能使得 DRF 不僅能夠擴充 Django 的原有能力，而且提供了對 RESTful API 開發的專門支持。</p><p>不得不承認，在「前後端分離」已成顯學的今日，有了 DRF 這樣的框架，能有效維持 Django 作為一個開源後端框架的<strong>整體競爭力</strong>。</p><hr><h2 id="為何需要-DRF"><a href="#為何需要-DRF" class="headerlink" title="為何需要 DRF"></a>為何需要 DRF</h2><p>但又話說回來，為何 Django 不自己強化 API 功能，而是交給 DRF 這類套件呢？</p><p>我們可以從以下兩個方向考慮：</p><h3 id="一、專注與專業分工"><a href="#一、專注與專業分工" class="headerlink" title="一、專注與專業分工"></a>一、專注與專業分工</h3><ul><li>Django 的核心團隊專注於框架的<strong>基礎功能</strong>——比如 ORM、Middleware，這些是所有使用 Django 的開發者都需要的核心功能。</li><li>API 開發則是一個<strong>專業領域</strong>，涉及不同的需求和專業知識，如資料驗證與序列化。DRF 對建構 REST API 功能進行擴充，提供了<strong>一整套工具與實踐。</strong></li></ul><h3 id="二、模組化與彈性"><a href="#二、模組化與彈性" class="headerlink" title="二、模組化與彈性"></a>二、模組化與彈性</h3><ul><li>通過將 API 功能外包給如 DRF 這樣的套件，Django <strong>保持了核心的簡潔</strong>，同時提供了一定<strong>彈性</strong>。讓開發者可以<strong>根據需求</strong>，選擇合適自己的工具。</li><li>換句話說，Django 專注在核心功能而不是 API，可以讓它<strong>更全面、更靈活。</strong></li><li>這意味著你可以<strong>只在需要時</strong>引入 DRF，進而保持專案的<strong>輕量</strong>。畢竟，Django 本身已經非常豐富。</li></ul><h2 id="Django-與-DRF-比較"><a href="#Django-與-DRF-比較" class="headerlink" title="Django 與 DRF 比較"></a>Django 與 DRF 比較</h2><p>綜上所述，我們直接用表格來比較兩者的功能與角色差異：</p><table><thead><tr><th></th><th>Django</th><th>DRF</th></tr></thead><tbody><tr><td>主要目的</td><td>全面的 Web 框架，提供完整的 Web 應用開發支持。</td><td>專注於 Web API 的建立，特別是 RESTful API。</td></tr><tr><td>設計哲學</td><td>提供高度可重用性和快速開發元件，比如 Django ORM。</td><td>API 優先：提供 API 特定的工具和功能，比如序列化器。</td></tr><tr><td>核心功能</td><td>模板渲染、表單生成、管理界面、資料庫模型。</td><td>序列化、權限控制、API View。</td></tr><tr><td>目標用戶</td><td>面向所有類型的 Web 開發者，包括初學者和專業人士。</td><td>面向需要建立複雜 API 的開發者。</td></tr></tbody></table><hr><p>了解 Django 與 DRF 的差異後，還有一個議題也很重要——CBV 與 FBV。</p><h2 id="CBV-vs-FBV"><a href="#CBV-vs-FBV" class="headerlink" title="CBV vs FBV"></a>CBV vs FBV</h2><p>Class-based view 與 function-based view，兩者都是實現 Django 中 view 的手段，各有適合的場景。</p><p>CBV 有著<strong>重用程式碼</strong>優勢，適合大型專案。而 FBV 則以<strong>簡單、直接</strong>為賣點，方便快速開發中小型專案。</p><p>老實說，我只寫過 FBV，而且我也更愛 FBV。</p><h3 id="DRF-更擅長-CBV"><a href="#DRF-更擅長-CBV" class="headerlink" title="DRF 更擅長 CBV"></a>DRF 更擅長 CBV</h3><p>不過，DRF 本身對於 CBV 有著「<strong>更完整的支援</strong>」。</p><p>所以如果你想要將 DRF 發揮到極致，那它提供的 <a href="https://www.django-rest-framework.org/api-guide/generic-views/#genericapiview">GenericAPIView</a> 值得了解一下。並且和 DRF 其它元件有著<strong>高度整合。</strong></p><h3 id="本系列只會使用-FBV"><a href="#本系列只會使用-FBV" class="headerlink" title="本系列只會使用 FBV"></a>本系列只會使用 FBV</h3><p>不過因為我沒真正大量使用過 CBV，而且 DRF 系列只是入門教學，所以我只會用 FBV 進行示範。</p><p>另一方面，Django Ninja、FastAPI、Flask 都是以 FBV 為主，或許對大部分人而言，能善用 FBV 已然足夠。</p><hr><h2 id="DRF-vs-Django-Ninja"><a href="#DRF-vs-Django-Ninja" class="headerlink" title="DRF vs Django Ninja"></a>DRF vs Django Ninja</h2><p>長期以來，DRF 一直是開發 Django API 的主要甚至唯一選擇——直到 <a href="https://django-ninja.dev/">Django Ninja</a> 的出現。</p><p>Django Ninja 是烏克蘭開發者 <a href="https://github.com/vitalik">Vitaliy Kucheryaviy</a> 的力作，可以想成是「<strong>Django 版 FastAPI</strong>」。</p><p>它提供不同於傳統寫法的 FBV，高度整合了 Python type hints。並使用 Pydantic 進行資料的驗證與序列化，還有最重要的——自動產生 API 文件。</p><p>關於 Django Ninja，以及它和 DRF 的比較，我會放到 Django Ninja 系列，再行介紹。</p><hr><h2 id="小結：入門者的選擇"><a href="#小結：入門者的選擇" class="headerlink" title="小結：入門者的選擇"></a>小結：入門者的選擇</h2><p>本文講述了 Django 與 DRF 在現代開發中扮演的角色，與它們之間相輔相成的關係。</p><p>如果你是剛開始接觸 Django API 的開發者，我相信 DRF 仍是第一選擇。因為它更加成熟，而且累積了大量的歷史資料，可作為開發時的參考。</p><p>在熟悉了基本的 Django API 開發流程與常見元素後，再學習 Django Ninja 也不遲。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 的第 4 篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;終於要進入 Django API 的世界了！&lt;/p&gt;
&lt;p&gt;不過，在開始 DRF 教學之前，我要先介紹 Django、DRF 兩者間的&lt;strong&gt;關係&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;為什麼 Django 不乾脆自己實作 API 功能就好？而是把這個任務交給第三方套件，比如本文的 Django REST framework。&lt;/p&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;因此，本文的主要目標是：&lt;strong&gt;為讀者建立一個「high level」的世界觀&lt;/strong&gt;。讓你了解為何在 Django 之外，我們還需要 Django REST framework。&lt;/p&gt;
&lt;p&gt;了解兩者的關係，更能體會&lt;strong&gt;它們所扮演的不同角色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;簡言之，這一篇還沒有要開始寫 API。&lt;/p&gt;
&lt;h3 id=&quot;系列：Django-REST-framework-教學&quot;&gt;&lt;a href=&quot;#系列：Django-REST-framework-教學&quot; class=&quot;headerlink&quot; title=&quot;系列：Django REST framework 教學&quot;&gt;&lt;/a&gt;系列：Django REST framework 教學&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/series/#Django-REST-framework-%E6%95%99%E5%AD%B8&quot;&gt;系列文章清單（連載中）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Django REST framework" scheme="https://blog.kyomind.tw/tags/Django-REST-framework/"/>
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>我絕不用 result 作為變數名稱</title>
    <link href="https://blog.kyomind.tw/no-result/"/>
    <id>https://blog.kyomind.tw/no-result/</id>
    <published>2024-05-04T07:28:56.000Z</published>
    <updated>2024-05-21T04:21:43.789Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/YmlPRz1.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>在〈<a href="/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a>〉中，我們提到了「<a href="/beyond-the-basic-stuff-with-python-01/#%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%B3%9F%E7%9A%84%E8%AE%8A%E6%95%B8%E5%90%8D%E7%A8%B1%E2%80%94%E2%80%94data">data</a>」這個不佳的變數名稱。</p><p>以及應該要用<strong>什麼樣的名稱</strong>取代它，與<strong>例外可以使用</strong> data 的情況。</p><p>看過那段後，你可以發現，data 雖爛，但還是<strong>偶有派上用場</strong>的時候。雖然絕大部分的情況，我依舊會避免使用。</p><p>然而有一個變數名稱，<strong>我絕對不會用</strong>。</p><h2 id="比-data-更糟的變數名稱——result"><a href="#比-data-更糟的變數名稱——result" class="headerlink" title="比 data 更糟的變數名稱——result"></a>比 data 更糟的變數名稱——result</h2><p>當我遵守了好習慣，盡可能避免在程式碼中使用 data 命名後，本以為能從此過上幸福快樂的生活，<strong>但我錯了！</strong></p><p>因為沒多久後我就發現，還有一個比 data 更<strong>駭人聽聞</strong>的變數名稱——<code>result</code>。</p><p>和 data 相比，其<strong>糟糕的程度</strong>，簡直<strong>有過之而無不及</strong>。畢竟<strong>萬事萬物都有「result」</strong>，因果循環、生生不息，而且這個命名<strong>更加抽象</strong>，令人不禁想問：</p><blockquote><p><strong>到底是什麼結果？</strong></p></blockquote><p>result 命名的濫用，在「儲存呼叫函式的<strong>結果</strong>」時最為常見，<strong>難怪到處都是 result。</strong></p><span id="more"></span><hr><h2 id="3-個代表性案例"><a href="#3-個代表性案例" class="headerlink" title="3 個代表性案例"></a>3 個代表性案例</h2><p>不誇張地說，code review 時我看到 result 這個變數名稱，<strong>幾乎都會建議改掉</strong>。因為它<strong>太過籠統</strong>，讓人無法立刻了解這個變數的內容與用途。</p><p><strong>甚至有一種噁心感。</strong>（內心 OS：就這麼懶得想名字？）</p><p>不過，若細看後發現，眼前的情況<strong>真的不容易命名</strong>，我可能會選擇睜一隻眼閉一隻眼，暫時就先算了吧！😷</p><p>但平心而論，這<strong>真的是少數</strong>。我遇到大部分使用 result 的情況，都是<strong>懶得想名字XD</strong>。無論如何，我自己寫程式時，不會考慮使用 result，<strong>而且我認為這並不難。</strong></p><p>下面我們就舉 3 個代表性案例，來看看 result 到底有多糟糕。以及應該要用什麼名稱來取代它——基本上就是<strong>更直接、具體、精確</strong>的名稱。</p><h2 id="一、從資料庫查詢訂單"><a href="#一、從資料庫查詢訂單" class="headerlink" title="一、從資料庫查詢訂單"></a>一、從資料庫查詢訂單</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不好的寫法</span></span><br><span class="line">result = query_orders_from_database(customer_id)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更好的寫法</span></span><br><span class="line">orders = query_orders_from_database(customer_id)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一種典型的情況是，<strong>明明有更具體的名稱可以使用</strong>，卻偏偏用了籠統的 result。</p><p>這樣的寫法，讓人看了一頭霧水，不確定 result 到底是指什麼。</p><p>類似的例子還有求平均值、性別、數量等等，太多了，都有一個 result，但明顯都可以用更具體的名稱來取代。</p><p>事實上，如前所述，會把變數命名為 result，<strong>往往不是真的遇到什麼難以命名的情境</strong>，而是因為懶XD。可是這份懶惰，<strong>會讓你的程式碼變得難讀</strong>。</p><p>其中的代價，不可謂不大。</p><hr><h2 id="二、檢查用戶是否有管理員權限"><a href="#二、檢查用戶是否有管理員權限" class="headerlink" title="二、檢查用戶是否有管理員權限"></a>二、檢查用戶是否有管理員權限</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不好的寫法</span></span><br><span class="line">result = check_user_is_admin(user_id)</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更好的寫法</span></span><br><span class="line">is_admin = check_user_is_admin(user_id)</span><br><span class="line"><span class="keyword">if</span> is_admin:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>這是我認為<strong>最重要</strong>的一條守則，簡言之：<strong>你不應該使用 result 來表示「狀態」</strong>。</p><p>尤其當這個狀態是一個<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97_(%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B)">布林值</a>時，代表「操作成功與否」或「特定條件是否符合」等等情況，你更應該使用<strong>具體的名稱</strong>。</p><p>這個時候，我們可以考慮使用充滿了「<strong>布林味</strong>」的變數名稱，比如<code>has_permission</code>、<code>is_valid</code>、<code>is_success</code>等等——而不是<code>result</code>。</p><h3 id="為什麼布林值最不適合用-result？"><a href="#為什麼布林值最不適合用-result？" class="headerlink" title="為什麼布林值最不適合用 result？"></a>為什麼布林值最不適合用 result？</h3><p>回傳內容如果由<strong>很多部分組成，此時確實不容易概括成一個名稱</strong>。</p><p>要命名好這類的回傳結果，<strong>需要花一定時間思考、評估其合適性，並不輕鬆</strong>。所以有些開發者乾脆用 result 來表示，姑且算是一種 <strong>workaround</strong> 吧！情有可原。</p><p>但如果回傳只是一個布林值，那就沒有「<strong>內涵太複雜以至於不易命名</strong>」問題。因為布林就只有兩種可能性：<strong>True 或 False</strong>。</p><p>此時再偷懶用 result，恐怕就說不太過去了。</p><hr><h2 id="三、使用-requests-發出-HTTP-請求"><a href="#三、使用-requests-發出-HTTP-請求" class="headerlink" title="三、使用 requests 發出 HTTP 請求"></a>三、使用 requests 發出 HTTP 請求</h2><p>終於來你最常見到的情境了，使用<code>requests</code>（或<code>httpx</code>）發出 HTTP 請求，並將回傳的結果存入 result。</p><p>雖然大部分人都會將這個變數命名為 response，但<strong>還是有人會用 result</strong>——而且覺得兩者「<strong>其實也沒什麼不同</strong>」啊！</p><p>（這種「我覺得都差不多啊！」的思維才是真正嚇人的，你懂的。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不好的寫法</span></span><br><span class="line">result = requests.get(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> result.status_code == <span class="number">200</span>:</span><br><span class="line">    process_data(result.json())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更好的寫法</span></span><br><span class="line">response = requests.get(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    process_data(response.json())</span><br></pre></td></tr></table></figure><p>在這個例子中，使用 response 作為變數名稱會比使用 result <strong>更加清晰和具描述性。</strong></p><p>當其他開發者看到這段程式碼時，會立即明白這個變數存儲的是一個 HTTP response（通常就是<code>requests</code>的<code>response</code>物件），而不是某個抽象的「結果」。</p><p>如果隨意地命名為 result，後續使用該變數時，result <strong>預期</strong>會有什麼屬性？什麼方法？<strong>一切都不明朗</strong>，因為它有<strong>無限可能</strong>。</p><p>往往要回去看變數的<strong>定義</strong>部分，才能知曉 result 究竟代表什麼。</p><p><strong>當這變數的生命週期愈長、呼叫的次數愈多，使用 result 名稱造成的「可讀性問題」就愈嚴重。</strong></p><p>這個例子還有一個常見的「<strong>變形</strong>」——<code>res</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = requests.get(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">    process_data(res.json())</span><br></pre></td></tr></table></figure><p>這麼巧！response 和 result 兩者恰好都是以 res 為前綴，只要命名為<code>res</code>就天下太平了——才怪。</p><p>有什麼比 result 更讓人想握緊拳頭的變數名稱嗎？<strong>恐怕就是 res 了。</strong></p><hr><h2 id="小結：No-result"><a href="#小結：No-result" class="headerlink" title="小結：No result"></a>小結：No result</h2><p>總的來說，data 至少還有適用的例外情況，但 result，<strong>我真的想不到。</strong></p><p>我非常確信，打從我轉職後工作的第二年起（第一年還懵懂無知），再就也沒有使用過 result 這個變數名稱。</p><p><strong>一次也沒有。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YmlPRz1.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;/beyond-the-basic-stuff-with-python-01/&quot;&gt;《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道&lt;/a&gt;〉中，我們提到了「&lt;a href=&quot;/beyond-the-basic-stuff-with-python-01/#%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%B3%9F%E7%9A%84%E8%AE%8A%E6%95%B8%E5%90%8D%E7%A8%B1%E2%80%94%E2%80%94data&quot;&gt;data&lt;/a&gt;」這個不佳的變數名稱。&lt;/p&gt;
&lt;p&gt;以及應該要用&lt;strong&gt;什麼樣的名稱&lt;/strong&gt;取代它，與&lt;strong&gt;例外可以使用&lt;/strong&gt; data 的情況。&lt;/p&gt;
&lt;p&gt;看過那段後，你可以發現，data 雖爛，但還是&lt;strong&gt;偶有派上用場&lt;/strong&gt;的時候。雖然絕大部分的情況，我依舊會避免使用。&lt;/p&gt;
&lt;p&gt;然而有一個變數名稱，&lt;strong&gt;我絕對不會用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;比-data-更糟的變數名稱——result&quot;&gt;&lt;a href=&quot;#比-data-更糟的變數名稱——result&quot; class=&quot;headerlink&quot; title=&quot;比 data 更糟的變數名稱——result&quot;&gt;&lt;/a&gt;比 data 更糟的變數名稱——result&lt;/h2&gt;&lt;p&gt;當我遵守了好習慣，盡可能避免在程式碼中使用 data 命名後，本以為能從此過上幸福快樂的生活，&lt;strong&gt;但我錯了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因為沒多久後我就發現，還有一個比 data 更&lt;strong&gt;駭人聽聞&lt;/strong&gt;的變數名稱——&lt;code&gt;result&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;和 data 相比，其&lt;strong&gt;糟糕的程度&lt;/strong&gt;，簡直&lt;strong&gt;有過之而無不及&lt;/strong&gt;。畢竟&lt;strong&gt;萬事萬物都有「result」&lt;/strong&gt;，因果循環、生生不息，而且這個命名&lt;strong&gt;更加抽象&lt;/strong&gt;，令人不禁想問：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;到底是什麼結果？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;result 命名的濫用，在「儲存呼叫函式的&lt;strong&gt;結果&lt;/strong&gt;」時最為常見，&lt;strong&gt;難怪到處都是 result。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/YmlPRz1.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="程式設計" scheme="https://blog.kyomind.tw/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"/>
    
    <category term="壞味道（Bad Smell）" scheme="https://blog.kyomind.tw/tags/%E5%A3%9E%E5%91%B3%E9%81%93%EF%BC%88Bad-Smell%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>29，我編輯舊文的三個理由</title>
    <link href="https://blog.kyomind.tw/weekly-review-29/"/>
    <id>https://blog.kyomind.tw/weekly-review-29/</id>
    <published>2024-04-30T18:50:09.000Z</published>
    <updated>2024-05-01T16:49:49.825Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>作為一個 blog 創作者，我算是比較常<strong>編輯、翻修舊文</strong>的人。</p><p>編輯舊文往往需要花費不少時間，而且讀者也未必看得出有哪裡不同——所以我一定會在文章開頭備註、提醒☺️</p><p>部分文章，編輯過不止一次，比如〈<a href="https://blog.kyomind.tw/python-poetry/">Python 套件管理器——Poetry 完全入門指南</a>〉，我將它視為代表作之一，編輯的次數應該是全站之最。</p><p>這樣的行為，雖然源於<strong>對文字與表達的追求</strong>，但其中也有<strong>實際的理由</strong>。</p><p>這篇來就分享一下，我考慮編輯舊文的<strong>三個實際理由。</strong></p><span id="more"></span><hr><h2 id="一、流量起來了"><a href="#一、流量起來了" class="headerlink" title="一、流量起來了"></a>一、流量起來了</h2><p>這應該不用解釋，當一篇文章看的人變多時，你會有<strong>兩種感受</strong>：</p><ol><li><strong>虛榮感</strong>——受歡迎的感覺真好！</li><li><strong>責任感</strong>——我應該沒有哪邊寫錯了吧？👀</li></ol><p>即使不考慮上述感受，我認為「流量」仍可作為編輯舊文的<strong>首要理由</strong>。</p><p>如果該文章<strong>突顯你的個人風格或價值觀</strong>，花費心思去增進文字的精確度與表達的流暢，確實更加值得——因為它會被更多人看到。</p><p>儘管這不是一個高大上的理由，但我覺得它是<strong>最實際</strong>的理由。</p><p>倘若你身處於部落格寫作的第一年，建議以這個指標作為編輯舊文的主要依據。</p><h2 id="二、內容過時了"><a href="#二、內容過時了" class="headerlink" title="二、內容過時了"></a>二、內容過時了</h2><p>文章內容是否會過時，和主題的<strong>性質</strong>有很大關係。</p><p>個人情感抒發或價值觀表述，即使<strong>現在已經不這麼想了</strong>，也稱不上「過時」，因為那就是當時的想法。</p><p>相對的，技術類文章就比較容易遇到過時問題——尤其是工具教學！</p><p>面對這種「技術上的過時」，你有三種處理方式：</p><ol><li>不理它，反正有發文日期，雖然現在已經過時了，至少它曾經是對的！這屬於最簡單的做法——<strong>什麼都不做</strong>。說真的，通常讀者也不會苛責啦！</li><li>在文中（通常是開頭）表示：「本文部分內容已經過時，請讀者留意或自行查閱官方文件。」這已經算不錯的了，<strong>至少願意提醒讀者。</strong></li><li>依照新的事實，更新文章內容！雖然很累，<strong>但我願意為你喝采！</strong></li></ol><p>〈<a href="https://blog.kyomind.tw/ubuntu-pyenv/">Ubuntu 安裝使用 pyenv + pyenv-virtualenv</a>〉就是很好的例子，以下是文章在重新編輯後新增的段落：</p><blockquote><p><code>2023/04/07</code>重要更新：pyenv 2.3.0 以後，已經大幅簡化了設定操作，本段內容在新版仍可適用，但建議直接升級最新版 pyenv 並直接改用以下設定：（我把指令改成新版）</p></blockquote><p>而且，上述例子也不是單純更新指令就好。我往往還得判斷：哪些內容過時了，要直接刪除。哪些要留下，以及是否需要改寫等等。</p><p><strong>這通常不是一件有趣的事。但你的用心，讀者會看到。</strong></p><h2 id="三、廢話太多了"><a href="#三、廢話太多了" class="headerlink" title="三、廢話太多了"></a>三、廢話太多了</h2><p>為這個理由而編輯舊文，顯示出你<strong>身為作者的自我追求。</strong></p><p>容我解釋一下，所謂的「廢話太多」指的是，你發現文中有一些段落，和主軸<strong>沒有那麼大的關聯</strong>，或可能<strong>增加讀者閱讀上的負擔</strong>——讀者不明白你為什麼要寫這一段。</p><p>然而，作者對自己的內容，肯定都是有<strong>盲點</strong>的——否則就不需要編輯了。想要<strong>自行發現這類問題，說真的，著實不易</strong>！</p><p>畢竟，一字一句都是我的嘔心瀝血之作啊！</p><blockquote><p>那我要怎麼發現這些「廢話」呢？</p></blockquote><p>有一個簡單的判斷方式（雖然未必準確），那就是明明文章篇幅不短，但從後台數據的「平均閱讀時間」看，卻偏短。</p><p>這可能意味著，你的內容，讀者<strong>並不買帳</strong>！你覺得很棒的東西，<strong>他們只覺得很煩</strong>。所以選擇匆匆略過。</p><p>這時我會把<strong>編輯重心</strong>放在「<strong>閱讀流暢度</strong>」上，而提升閱讀流暢度的一個<strong>有效方法</strong>，就是<strong>刪掉那些冗餘的段落</strong>！（要注意刪除後的落段銜接，必要時甚至得增補）</p><p>這真的很不容易——都是自己的孩子啊啊啊！</p><p>但通常這類編輯，<strong>效果特別好，成就感也特別高。</strong></p><p>以下 3 篇是我認為「<strong>刪減後更佳</strong>」的適例（雖然還是很長XD），供讀者參考：</p><ol><li><a href="https://blog.kyomind.tw/the-quick-python-book/">最佳 Python 入門書——《Python 技術者們 - 練功！》心得與導讀</a></li><li><a href="https://blog.kyomind.tw/pyproject-toml/">Python 開發：pyproject.toml 介紹 + 使用教學</a></li><li><a href="https://blog.kyomind.tw/poetry-pyenv-practical-tips/">Poetry + pyenv 教學：常用指令與注意事項</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;作為一個 blog 創作者，我算是比較常&lt;strong&gt;編輯、翻修舊文&lt;/strong&gt;的人。&lt;/p&gt;
&lt;p&gt;編輯舊文往往需要花費不少時間，而且讀者也未必看得出有哪裡不同——所以我一定會在文章開頭備註、提醒☺️&lt;/p&gt;
&lt;p&gt;部分文章，編輯過不止一次，比如〈&lt;a href=&quot;https://blog.kyomind.tw/python-poetry/&quot;&gt;Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;〉，我將它視為代表作之一，編輯的次數應該是全站之最。&lt;/p&gt;
&lt;p&gt;這樣的行為，雖然源於&lt;strong&gt;對文字與表達的追求&lt;/strong&gt;，但其中也有&lt;strong&gt;實際的理由&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這篇來就分享一下，我考慮編輯舊文的&lt;strong&gt;三個實際理由。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="blog" scheme="https://blog.kyomind.tw/tags/blog/"/>
    
    <category term="重構" scheme="https://blog.kyomind.tw/tags/%E9%87%8D%E6%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>Django HttpRequest 常用屬性介紹</title>
    <link href="https://blog.kyomind.tw/django-request/"/>
    <id>https://blog.kyomind.tw/django-request/</id>
    <published>2024-04-28T07:08:53.000Z</published>
    <updated>2024-04-29T05:17:53.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 系列連載的第 3 篇。</p><p>範例程式碼可參考我的 <a href="https://github.com/kyomind/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="https://blog.kyomind.tw/django/">Django 文章總覽</a>」。</p><hr><p>如〈<a href="https://blog.kyomind.tw/django-tutorial/">Django Tutorial：系列介紹與導讀</a>〉所言，這個系列主要是圍繞著「Django API」教學展開的。</p><p>但無論是用 Django 建立全端網站，還是開發 API，Django 的 <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/">HttpRequest</a>——也就是我們熟悉的<code>request</code>參數——都是必不可少的元素。</p><p><code>HttpRequest</code>封裝了來自前端的 HTTP 請求，而 Django 會將<code>HttpRequest</code>物件自動帶入 view 函式的<strong>第一位置參數</strong>（通常就叫<code>request</code>），讓我們可以直接使用。</p><h2 id="為何需要了解-HttpRequest-物件"><a href="#為何需要了解-HttpRequest-物件" class="headerlink" title="為何需要了解 HttpRequest 物件"></a>為何需要了解 <code>HttpRequest</code> 物件</h2><p>在我剛開始寫 Django 的時候，根本不太清楚<code>HttpRequest</code>具體有哪些屬性。</p><p>通常是看教學或為了實作某個功能而 Google 的時候，看到範例程式碼使用某個屬性，然後才知道這個屬性的存在。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">    do_something_else()</span><br></pre></td></tr></table></figure><p>看到這段，才知道<code>request</code>有一個<code>method</code>屬性。</p><p>這樣學當然可以，但如果一開始就對常用的<code>HttpRequest</code>屬性有<strong>基本了解</strong>，會讓你在學習 Django 的路上<strong>更加踏實</strong>。</p><span id="more"></span><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>基於上述考量，我覺得還是有必要整理一下，對於 Django 初學者而言，最常用或需要了解的<code>HttpRequest</code>屬性。</p><p>不求多深，或知悉所有屬性的具體用法。面對<code>HttpRequest</code>這樣內容豐富的物件，我們掌握 80&#x2F;20 法則，了解其中<strong>最重要的幾個</strong>，往往就能很有收獲。</p><p>至少，如果讓我重來，我會希望自己一開始就對這些屬性有一定認識。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文的目標讀者，是 <strong>Django 初學者</strong>。</p><p>無論想寫 Django 全端網站（也就是會用到 <a href="https://docs.djangoproject.com/en/5.0/topics/forms/">Django Form</a> 與 <a href="https://docs.djangoproject.com/en/5.0/ref/templates/language/">Template</a>），還是開發 API。這些屬性都相對重要，或至少要知道它有何「替代品」。</p><p>因此，我還會適時補充，使用框架（DRF、Django Ninja）開發 API 時，這些屬性是否被框架提供的新屬性取代。</p><h3 id="開始前的小提醒"><a href="#開始前的小提醒" class="headerlink" title="開始前的小提醒"></a>開始前的小提醒</h3><p>本文對<code>HttpRequest</code>屬性與介紹內容，主要整理自<a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#httprequest-objects">官方文件</a>，<strong>我會適度引用原文，並加上我的經驗、看法。</strong></p><p>提醒你：</p><ol><li>看完之後，如果<strong>依舊覺得不熟悉</strong>這些屬性，那也無妨，<strong>有基本的認識就很好了！</strong></li><li>所有的例示以 FBV（function-based view）為主，這是 Django 初學者最常接觸的 view 寫法。</li></ol><hr><p>以下依各個屬性在文件中出現的順序，一一介紹。</p><h2 id="一、HttpRequest-method"><a href="#一、HttpRequest-method" class="headerlink" title="一、HttpRequest.method"></a>一、HttpRequest.method</h2><blockquote><p>A string representing the HTTP method used in the request. This is guaranteed to be uppercase.</p></blockquote><p>表示請求所使用的 HTTP 方法，有兩個重點：</p><ol><li>型別為字串。</li><li>而且字串值一定是全大寫。比如<code>&quot;GET&quot;</code>、<code>&quot;POST&quot;</code>等。</li></ol><p>這或許是新手一開始最常呼叫的屬性XD。當然，前提是你寫的是 FBV（function-based view）。</p><p>在 view 函式中的用法前面已經提過：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">    do_something_else()</span><br></pre></td></tr></table></figure><hr><h2 id="二、HttpRequest-GET"><a href="#二、HttpRequest-GET" class="headerlink" title="二、HttpRequest.GET"></a>二、HttpRequest.GET</h2><blockquote><p>A dictionary-like object containing all given HTTP GET parameters. See the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.QueryDict"><code>QueryDict</code></a> documentation below.</p></blockquote><p>用來獲得 HTTP request 的「<strong>URL 參數</strong>」內容，比如你透過 GET 方法存取下列網址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.books.com/search?category=novel&amp;author=Asimov</span><br></pre></td></tr></table></figure><p>這個屬性可取得<code>?</code>後面的「<code>category=novel&amp;author=Asimov</code>」這段資訊。</p><p>而且屬性值的資料型別，是一個<code>QueryDict</code>。</p><p>關於<code>QueryDict</code>，你目前只需要知道，它是一個類似字典的物件，而<strong>值</strong>主要是<strong>字串</strong>，或<strong>元素為字串的 Python list</strong>——如果一個 key 有多個值。</p><p>以下是用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_books</span>(<span class="params">request</span>):</span><br><span class="line">    category = request.GET.get(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">    author = request.GET.get(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="不限於-GET-方法"><a href="#不限於-GET-方法" class="headerlink" title="不限於 GET 方法"></a>不限於 GET 方法</h3><p>雖然叫做<code>GET</code>，但實際上這個屬性不限於 GET 方法，只要是 URL 參數，都可以透過這個屬性取得。</p><p>畢竟除了 GET 方法，還有 DELETE、PATCH 等方法，也都可以透過 URL 參數傳遞資訊。只是因為 GET 方法最常見，所以這個屬性叫做<code>GET</code>。</p><p>我覺得這個命名<strong>多少有點誤導性</strong>，但不算是大問題。</p><h3 id="使用-DRF-框架"><a href="#使用-DRF-框架" class="headerlink" title="使用 DRF 框架"></a>使用 DRF 框架</h3><p>在 DRF（<a href="https://www.django-rest-framework.org/">Django REST framework</a>）的 <a href="https://www.django-rest-framework.org/api-guide/requests/#request-parsing">request</a> 中，官方推薦你使用 <a href="https://www.django-rest-framework.org/api-guide/requests/#query_params">query_params</a> 屬性代替<code>GET</code>屬性：</p><blockquote><p>For clarity inside your code, we recommend using <code>request.query_params</code> instead of the Django’s standard <code>request.GET</code>.</p></blockquote><p>如前所述，<code>GET</code>屬性名稱有點誤導性，而 DRF 的<code>query_params</code>確實比較合理。</p><p>至於是不是要遵守這個建議，我覺得最大的重點是「整個專案的<strong>一致性</strong>」——不要有人寫<code>query_params</code>、有人寫<code>GET</code>。</p><p>而 <a href="https://django-ninja.dev/">Django Ninja</a> 則沒有這個問題（不需要用到<code>GET</code>屬性），以後介紹 Django Ninja 再詳談。</p><hr><h2 id="三、HttpRequest-POST"><a href="#三、HttpRequest-POST" class="headerlink" title="三、HttpRequest.POST"></a>三、HttpRequest.POST</h2><blockquote><p>A dictionary-like object containing all given HTTP <strong>POST</strong> parameters, providing that the request contains <strong>form data</strong>.</p></blockquote><blockquote><p>See the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.QueryDict"><code>QueryDict</code></a> documentation below.</p></blockquote><blockquote><p>If you need to access raw or non-form data posted in the request, access this through the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.body"><code>HttpRequest.body</code></a> attribute instead.</p></blockquote><blockquote><p><code>POST</code> does <strong>not</strong> include file-upload information. See <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.FILES"><code>FILES</code></a>.</p></blockquote><p>我故意把一段原文分 4 段引用，因為它有下列重點：</p><ol><li>這個<code>POST</code>屬性，必須你的 HTTP 請求是 POST 方法。（對應第一段）</li><li>內容是 POST 請求中附帶的「表單資訊（form data）」。（對應第一段，這是最重要的一點！）</li><li>值的型別也是<code>QueryDict</code>。如前所述，值必為字串。（對應第二段）</li><li>如果想取得 form data 以外的內容，要使用<code>HttpRequest.body</code>。（對應第三段）</li><li>不包含上傳的檔案。因為已經有<code>FILES</code>屬性。（對應第四段）</li></ol><h3 id="只限-form-data"><a href="#只限-form-data" class="headerlink" title="只限 form data"></a>只限 form data</h3><p>簡單來說，這個屬性值對應 POST 請求中的 body，但 header 的<code>Content-Type</code>必須為<code>application/x-www-form-urlencoded</code>才行。</p><p>即 body <strong>必須是 form data</strong>，否則<code>POST</code>屬性不會有值。</p><p>不得不說，這屬性名稱也一樣<strong>有點誤導</strong>，因為它<strong>只限於 form data。</strong></p><p>當<code>Content-Type</code>是<code>application/json</code>或其他非表單的類型時，<code>HttpRequest.POST</code> 將會是<strong>空的</strong>，因為 Django 不會自動解析這些類型的資訊到 <code>POST</code> 屬性中。</p><h3 id="只限-POST-方法"><a href="#只限-POST-方法" class="headerlink" title="只限 POST 方法"></a>只限 POST 方法</h3><p>和<code>GET</code>屬性不同，<code>POST</code>屬性「<strong>只限</strong>」使用 POST 方法，這點要特別注意。</p><p>可是，其餘帶有 body 的方法，比如 PUT、PATCH、DELETE，<strong>也可能有 form data</strong>，但 Django 也不會自動解析到<code>POST</code>屬性中。此時該怎麼辦？</p><p>答案是：使用<code>request.body</code>屬性，自行解析。</p><h3 id="HttpRequest-body"><a href="#HttpRequest-body" class="headerlink" title="HttpRequest.body"></a>HttpRequest.body</h3><p>上述的<code>request.POST</code>有一定的限制，而<code>body</code>屬性更加全面。它也是代表 HTTP 請求 body 資料，不限於 POST 方法，且不限於 form data。</p><p>不過，<strong>它的屬性值型別是 bytestring：</strong></p><blockquote><p>The raw HTTP request body as a bytestring.</p></blockquote><p>你需要<strong>手動處理</strong>這個 bytestring，比如使用<code>json.loads()</code>解析 JSON 格式 body。</p><p>所以，實際上我們比較少用到<code>request.body</code>，而是用 DRF 的 <a href="https://www.django-rest-framework.org/api-guide/requests/#data">request.data</a> 屬性，或 Django Ninja 的 <a href="https://django-ninja.dev/guides/input/body/">Schema</a>。</p><p>它們會自動解析 body 資料，並轉換成 Python 物件。</p><h3 id="程式碼實例"><a href="#程式碼實例" class="headerlink" title="程式碼實例"></a>程式碼實例</h3><p>想像一個申請表單：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">submit_form</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        email = request.POST.get(<span class="string">&#x27;email&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其中要注意的是，HTTP POST 方法才會有<code>request.POST</code>屬性值，所以一定要先檢查方法：<code>if request.method == &#39;POST&#39;</code>。</p><p>並且如上所述，即使是 POST 方法，如果請求 body 不是 form data，<code>request.POST</code>依舊是空的。</p><h3 id="實務使用建議"><a href="#實務使用建議" class="headerlink" title="實務使用建議"></a>實務使用建議</h3><p>上述細節可能會新手有點眼花撩亂，不過別擔心，我們從一個更 high level 的角度看。</p><p>如果你寫的是「全端」Django，也就是包括了 Django Form 和模板，那這個<code>POST</code>屬性應該會<strong>很常用</strong>。因為前端（也就是 Django 模板）會傳來大量的 form data。</p><p>但如果你是寫 API，則這個屬性基本上不會用到。因為 API 的前端請求，往往是 JSON 格式，即<code>Content-Type</code>為<code>application/json</code>，而不會是 form data。</p><p>簡言之：</p><ul><li>寫全端 Django 用<code>request.POST</code>屬性。</li><li>寫 API 則是用<strong>別的屬性</strong>，比如 DRF 的<code>request.data</code>。</li></ul><hr><h2 id="四、HttpRequest-FILES"><a href="#四、HttpRequest-FILES" class="headerlink" title="四、HttpRequest.FILES"></a>四、HttpRequest.FILES</h2><blockquote><p>A dictionary-like object containing all uploaded files. Each key in <code>FILES</code> is the <code>name</code> from the <code>&lt;input type=&quot;file&quot; name=&quot;&quot;&gt;</code>. Each value in <code>FILES</code> is an <a href="https://docs.djangoproject.com/en/5.0/ref/files/uploads/#django.core.files.uploadedfile.UploadedFile"><code>UploadedFile</code></a>.</p></blockquote><p>上傳檔案必備！</p><p>注意，這個<code>FILES</code>只是一個類字典，字典的每一個 key 的<strong>值</strong>才是你上傳的檔案。</p><blockquote><p><code>FILES</code> will only contain data if the request method was POST and the <code>&lt;form&gt;</code> that posted to the request had <code>enctype=&quot;multipart/form-data&quot;</code>. Otherwise, <code>FILES</code> will be a blank dictionary-like object.</p></blockquote><p>重點：</p><ol><li>必須使用 POST 方法。</li><li>而且<code>Content-Type</code>為<code>multipart/form-data</code>。</li></ol><p>至於在 view 函式中的操作與使用，較為複雜（牽涉到 <a href="https://docs.djangoproject.com/en/5.0/ref/models/fields/#filefield">FileField</a>），可自行參考<a href="https://docs.djangoproject.com/en/5.0/topics/files/">文件</a>，在此先略不介紹。</p><hr><h2 id="五、關於-Headers"><a href="#五、關於-Headers" class="headerlink" title="五、關於 Headers"></a>五、關於 Headers</h2><p><code>HttpRequest.META</code><a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.META">¶</a></p><blockquote><p>A dictionary containing all available HTTP headers.</p></blockquote><p><code>HttpRequest.headers</code><a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.headers">¶</a></p><blockquote><p>A case insensitive, dict-like object that provides access to all HTTP-prefixed headers (plus <code>Content-Length</code> and <code>Content-Type</code>) from the request.</p></blockquote><p>這部分我們已經有過專文介紹，可直接參考：</p><ul><li><a href="https://blog.kyomind.tw/django-request-headers/">Django：以 request.headers 而非 META 獲取 HTTP header 資訊</a></li></ul><h2 id="六、Attributes-set-by-middleware"><a href="#六、Attributes-set-by-middleware" class="headerlink" title="六、Attributes set by middleware"></a>六、Attributes set by middleware</h2><p>從 Django 的 middleware 整合而獲得的屬性，這些屬性的值「不屬於」HTTP 請求中的資料，而是 Django 基於方便開發，自動幫你加上去的。</p><p>比較重要且常用的是這兩個：</p><ul><li><code>HttpRequest.session</code></li><li><code>HttpRequest.user</code></li></ul><p>這些可以等用到相關 Django 模組時，再深入了解即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 系列連載的第 3 篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;https://blog.kyomind.tw/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如〈&lt;a href=&quot;https://blog.kyomind.tw/django-tutorial/&quot;&gt;Django Tutorial：系列介紹與導讀&lt;/a&gt;〉所言，這個系列主要是圍繞著「Django API」教學展開的。&lt;/p&gt;
&lt;p&gt;但無論是用 Django 建立全端網站，還是開發 API，Django 的 &lt;a href=&quot;https://docs.djangoproject.com/en/5.0/ref/request-response/&quot;&gt;HttpRequest&lt;/a&gt;——也就是我們熟悉的&lt;code&gt;request&lt;/code&gt;參數——都是必不可少的元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HttpRequest&lt;/code&gt;封裝了來自前端的 HTTP 請求，而 Django 會將&lt;code&gt;HttpRequest&lt;/code&gt;物件自動帶入 view 函式的&lt;strong&gt;第一位置參數&lt;/strong&gt;（通常就叫&lt;code&gt;request&lt;/code&gt;），讓我們可以直接使用。&lt;/p&gt;
&lt;h2 id=&quot;為何需要了解-HttpRequest-物件&quot;&gt;&lt;a href=&quot;#為何需要了解-HttpRequest-物件&quot; class=&quot;headerlink&quot; title=&quot;為何需要了解 HttpRequest 物件&quot;&gt;&lt;/a&gt;為何需要了解 &lt;code&gt;HttpRequest&lt;/code&gt; 物件&lt;/h2&gt;&lt;p&gt;在我剛開始寫 Django 的時候，根本不太清楚&lt;code&gt;HttpRequest&lt;/code&gt;具體有哪些屬性。&lt;/p&gt;
&lt;p&gt;通常是看教學或為了實作某個功能而 Google 的時候，看到範例程式碼使用某個屬性，然後才知道這個屬性的存在。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; request.method == &lt;span class=&quot;string&quot;&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do_something()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; request.method == &lt;span class=&quot;string&quot;&gt;&amp;quot;POST&amp;quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do_something_else()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;看到這段，才知道&lt;code&gt;request&lt;/code&gt;有一個&lt;code&gt;method&lt;/code&gt;屬性。&lt;/p&gt;
&lt;p&gt;這樣學當然可以，但如果一開始就對常用的&lt;code&gt;HttpRequest&lt;/code&gt;屬性有&lt;strong&gt;基本了解&lt;/strong&gt;，會讓你在學習 Django 的路上&lt;strong&gt;更加踏實&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="HTTP" scheme="https://blog.kyomind.tw/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>28，去了 2 個月圖書館之後</title>
    <link href="https://blog.kyomind.tw/weekly-review-28/"/>
    <id>https://blog.kyomind.tw/weekly-review-28/</id>
    <published>2024-04-24T09:26:27.000Z</published>
    <updated>2024-04-25T07:00:47.740Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>今年 2 月下旬，我決定晚上（下班後）去圖書館讀書！</p><p>原因很簡單，我在家不好讀書，主要有兩點：</p><ol><li>如你所知，房間誘惑較多。不過這點其實還好，畢竟我工作、學習都是在家，所以不是主因。</li><li>這才是主因，因為目前升降桌的燈光、螢幕都是為了「<strong>使用電腦</strong>」而設計，並不適合用來讀書。</li></ol><p>以前我有兩張桌子，直接切換，一張專門用來讀書，那樣比較合乎實際。但換了升降桌後，小小的租屋空間就不夠了，不得不把「書桌」丟棄。</p><p>一直都有勉強試著讀書，但效果真的好差！</p><p>因為過程很麻煩，要先移開鍵盤，如果滑鼠沒放好，螢幕不時會被喚醒。檯燈我用的是 BenQ 的 ScreenBar，看螢幕很棒，但讀書的話，光源距離桌面又有點太遠了！而且角度也需要再調整。</p><p>讀個書猶如<strong>愚公移山</strong>，最後，我決定放棄苦苦掙扎，乖乖去圖書館！</p><span id="more"></span><h2 id="圖書館是好東西"><a href="#圖書館是好東西" class="headerlink" title="圖書館是好東西"></a>圖書館是好東西</h2><p>沒想到，一個月過去，效果比我想像得好耶！</p><p>所以我不禁發了這篇<a href="https://www.facebook.com/kyomind/posts/pfbid02e1m3JC6jj8WBSUcMhP5CiPQotPyZs5rqA8S1U5edMRaAhx1vUvC7F4pKfNQL1JP9l">臉書</a>，讚嘆圖書館的偉大。</p><p>我對自己的<strong>期待</strong>是這樣：一星期就去個 3、4 次，而且每次大概就讀 1 個半小時左右，時間不夠就 1 小時即可。不求多，只求能持續為之。</p><p>這樣做有兩個好處：</p><ol><li><strong>壓力不會太大</strong>：雖然讀書沒有健身那麼讓我想逃避🐥，但它依舊不是一件輕鬆的事。既然如此，還是不要太求好心切，以免適得其反。</li><li><strong>保留彈性，容易長久</strong>：雖然目前為止，也才持續了 2 個月左右。但我相信，之所以能夠持續，正是因為我的要求不高！這是我喜歡的實踐風格：適度的努力——<strong>適度就好。</strong></li></ol><p>還有一個原因是：我往往讀 1 個半小時就會很想回家了！</p><p>總之，平日一到四的晚上如果沒事，我就會去圖書館。通常是 7 點到，9 點前離開，我很喜歡這樣的「<strong>固定感</strong>」。</p><h2 id="需要認真讀的書，其實不多"><a href="#需要認真讀的書，其實不多" class="headerlink" title="需要認真讀的書，其實不多"></a>需要認真讀的書，其實不多</h2><p>這兩個月，我有一個<strong>很直接的感受</strong>，那就是：大部分的書，可讀可不讀啦！</p><p>說真的，大部分的書，都很難，可惜，<strong>難不等於有用</strong>。</p><p>有沒有用，還是看<strong>自己所處的階段、狀態</strong>而定。當然，書寫得好也挺重要。</p><p>不過話說回來，雖然大部分的書，我認為並不值得細讀。但是，想要知道哪些書應該細讀，而哪些則否，基本上還是得把它們都「<strong>粗讀</strong>」過才行XD</p><p>這通常不會花太多時間，了不起幾個小時——或 5-10 小時🤣</p><p>我去圖書館的第 1 個月，基本上就是在對過去買的書進行粗讀。不過，粗歸粗，有些地方也很難速速帶過，還是得停下來思考才行。所以有時候幾個小時不夠。</p><p>而且，這種「<strong>有意識的節奏變換</strong>」，真的很需要練習，因為「忽快忽慢」的閱讀會讓人不太適應——我們總是本能地想要勻速前進。</p><h2 id="粗讀之後，是細讀"><a href="#粗讀之後，是細讀" class="headerlink" title="粗讀之後，是細讀"></a>粗讀之後，是細讀</h2><p>粗讀完之後，接下來就是細讀了。</p><p>在我看來，有<strong>兩種書</strong>需要細讀：</p><ol><li>有些書的「其中一部分」很重要，對這些重要部分進行細讀就好了。比如我已經寫了<a href="https://blog.kyomind.tw/robust-python-01/">第一篇筆記</a>的《<a href="https://www.tenlong.com.tw/products/9786263241015">強健的 Python</a>》，只有前 1&#x2F;3 我會再次細讀。</li><li>大部分都很重要的書。如前所述，這種書不多，但還是要再次強調，重要與否，與每個人的當前條件有關。對我來說，《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠</a>》和《<a href="https://www.tenlong.com.tw/products/9786263246331">流暢的 Python</a>》是值得<strong>整本細讀</strong>的好書。</li></ol><p>這些細讀，往往需要花<strong>很多時間</strong>。而且，<strong>最好</strong>（應該說「必須」）搭配<strong>實作</strong>，不然恐怕也是事倍功半。</p><p>而就我的經驗，<strong>寫文章</strong>也是一種不錯的實作方式唷！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;今年 2 月下旬，我決定晚上（下班後）去圖書館讀書！&lt;/p&gt;
&lt;p&gt;原因很簡單，我在家不好讀書，主要有兩點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如你所知，房間誘惑較多。不過這點其實還好，畢竟我工作、學習都是在家，所以不是主因。&lt;/li&gt;
&lt;li&gt;這才是主因，因為目前升降桌的燈光、螢幕都是為了「&lt;strong&gt;使用電腦&lt;/strong&gt;」而設計，並不適合用來讀書。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以前我有兩張桌子，直接切換，一張專門用來讀書，那樣比較合乎實際。但換了升降桌後，小小的租屋空間就不夠了，不得不把「書桌」丟棄。&lt;/p&gt;
&lt;p&gt;一直都有勉強試著讀書，但效果真的好差！&lt;/p&gt;
&lt;p&gt;因為過程很麻煩，要先移開鍵盤，如果滑鼠沒放好，螢幕不時會被喚醒。檯燈我用的是 BenQ 的 ScreenBar，看螢幕很棒，但讀書的話，光源距離桌面又有點太遠了！而且角度也需要再調整。&lt;/p&gt;
&lt;p&gt;讀個書猶如&lt;strong&gt;愚公移山&lt;/strong&gt;，最後，我決定放棄苦苦掙扎，乖乖去圖書館！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="圖書館" scheme="https://blog.kyomind.tw/tags/%E5%9C%96%E6%9B%B8%E9%A4%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python API 開發：善用 Enum 的三大關鍵特性</title>
    <link href="https://blog.kyomind.tw/python-enum/"/>
    <id>https://blog.kyomind.tw/python-enum/</id>
    <published>2024-04-19T09:11:47.000Z</published>
    <updated>2024-05-07T17:47:14.575Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5lvKO0a.jpeg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>想必你知道 Python 中有一個內建的特殊類別叫 <a href="https://docs.python.org/zh-tw/3.12/library/enum.html#enum.Enum">Enum</a>（來自 <a href="https://docs.python.org/zh-tw/3.12/library/enum.html">enum</a> 模組），專門用來處理「列舉」態型的資料集合。</p><p>如同 <a href="https://docs.python.org/zh-tw/3/library/collections.html">collection</a> 模組中的各種容器（比如：<a href="https://docs.python.org/zh-tw/3/library/collections.html#collections.deque"><code>deque</code></a>、<a href="https://docs.python.org/zh-tw/3/library/collections.html#collections.Counter"><code>Counter</code></a>），Enum 已經定義好很多「<strong>內建特性（屬性、方法、行為）</strong>」供你使用。這些特性會讓你在<strong>處理特定情境</strong>時非常順手。</p><p>但是，這些特性也使得 Enum 類別與一般類別<strong>有著很大的差異，增加了學習門檻</strong>。</p><p>如你所見，Enum 的特性頗多，這讓人在學習、使用之前，難免有點<strong>望之卻步</strong>——至少我是這樣！</p><h2 id="本文主旨與架構"><a href="#本文主旨與架構" class="headerlink" title="本文主旨與架構"></a>本文主旨與架構</h2><p>本文分享我最近才開始把 Enum 應用在 API 開發中的經驗——從它的三大特性入手，並輔以一個實際問題情境。</p><p>Enum 的特性不少，但只要知曉這三件事，就可以在遇到「列舉」欄位時，善用 Enum 來提升開發效率，同時增進程式碼的簡潔與穩健。</p><p>不過話說回來，即使不是開發 API，也不影響你對本文的理解。只是我的經驗是從後端開發而來。</p><h3 id="本文架構"><a href="#本文架構" class="headerlink" title="本文架構"></a>本文架構</h3><p>為了讓你感受 Enum 的強大與美妙，<strong>本文的架構經過精心設計。</strong>共分為<strong>三個部分</strong>：</p><ol><li><strong>問題情境</strong>：我會先提出一個<strong>問題情境</strong>，突顯舊方法的不足。</li><li>然後再介紹 Enum 的<strong>三大特性</strong>，帶你進入 Enum 的世界。</li><li>最後看 Enum 特性在問題情境中<strong>如何有效發揮</strong>，讓程式碼變得更加優雅——也就是它<strong>解決的痛點</strong>。</li></ol><p>藉由這個流程，相信你對 Enum 會有更進一步的理解。</p><span id="more"></span><hr><p>話不多說，先從問題情境開始。</p><h2 id="第一部分：問題情境"><a href="#第一部分：問題情境" class="headerlink" title="第一部分：問題情境"></a>第一部分：問題情境</h2><p>為了有效講解，舉個<strong>實例</strong>是必要的，但我會<strong>盡可能簡化</strong>，只著眼於能夠彰顯 Enum 價值的部分。</p><p>作為一個 Django API 開發者，不管是什麼專案，幾乎都會出現「列舉型」資料。此時 Django ORM 中對應的就是「<a href="https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.Field.choices">choices</a>」欄位。</p><p>假設我們現在要開發一個 Docker 相關的服務（這是我實際遇到的情境），其中一個 API 是「新增容器」。而容器有一個需要使用者輸入的設定是：restart policy。</p><p>從官方文件可知，Docker 容器的 restart policy <a href="https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy">總共就只有 4 種而已</a>——沒錯，它屬於<strong>列舉型資料</strong>！</p><h3 id="Django-Model-欄位設計"><a href="#Django-Model-欄位設計" class="headerlink" title="Django Model 欄位設計"></a>Django Model 欄位設計</h3><p>此時，我們的 Django model 欄位會長這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    RESTART_POLICIES = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&#x27;always&#x27;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&#x27;unless-stopped&#x27;</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="string">&#x27;on-failure&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    restart_policy = models.PositiveSmallIntegerField(</span><br><span class="line">        choices=RESTART_POLICIES, default=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>為了方便講解與避免混淆，這裡我採用了「數字（0-3）」作為列舉成員。但實際工作中，我使用的是「字串」，也就是<code>&#39;no&#39;</code>、<code>&#39;always&#39;</code>等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    RESTART_POLICIES = (</span><br><span class="line">        (<span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;no&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;always&#x27;</span>, <span class="string">&#x27;always&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;unless-stopped&#x27;</span>, <span class="string">&#x27;unless-stopped&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;on-failure&#x27;</span>, <span class="string">&#x27;on-failure&#x27;</span>),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>這是一個<strong>重要的細節</strong>，以後會另篇討論：什麼時候列舉成員應該用數字，而什麼時候用字串更好。</p><p>為了專注於對 Enum 的學習，這裡採最常見的「數字」版本。</p><hr><h2 id="以往的做法"><a href="#以往的做法" class="headerlink" title="以往的做法"></a>以往的做法</h2><p>以前用 DRF（<a href="https://www.django-rest-framework.org/">Django REST framework</a>）開發 API 列舉資料時，除了在 model 增加了上述的 choices 限制，我並沒有使用 Enum。</p><p>這裡有一個問題：那前端人員怎麼知道列舉的「成員」<strong>有幾個、有哪些？</strong>當然只能靠 API 文件！</p><p>以往我們都是用 <a href="https://apiblueprint.org/">API Blueprint</a> 寫 API 文件。說真的，<strong>我不喜歡（我的後端同事們也都不喜歡XD）</strong>，太多手刻細節了——難怪它的普及率不高🙂‍↔️</p><p>雖然在 codebase 中看不到 Enum 的身影，但是，為了增加<strong>程式碼可讀性</strong>，我們還是會額外設計這樣的類別（這是為了後端開發者們在維護上的考慮）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如何使用這個類別？</p><p>一個典型的情境是，在 view 函式中<strong>將變數值與列舉成員進行比較</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> restart_policy == RestartPolicy.UNLESS_STOPPED</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>有了<code>RestartPolicy</code>，程式碼變得更加<strong>直觀</strong>，<strong>易讀</strong>。</p><p>換句話說，我們<strong>不會</strong>直接這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> restart_policy == <span class="number">2</span>  <span class="comment"># 咦，2 是什麼東西？</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><hr><h2 id="驗證列舉成員"><a href="#驗證列舉成員" class="headerlink" title="驗證列舉成員"></a>驗證列舉成員</h2><p>如果列舉資料只限於後端自行使用，那上述的寫法其實就足夠了。</p><p>但是，很多時候列舉資料是從<strong>前端（使用者輸入）</strong>來的。</p><p>此時你<strong>首先</strong>要驗證前端給的資料，<strong>是不是屬於這個列舉集合的成員</strong>！套用上面的寫法就會顯得囉嗦：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    RestartPolicy.NO,</span><br><span class="line">    RestartPolicy.ALWAYS,</span><br><span class="line">    RestartPolicy.UNLESS_STOPPED,</span><br><span class="line">    RestartPolicy.ON_FAILURE):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>為了不要讓程式這麼冗長，我們通常會幫這個類別加上一個簡單的<code>ALL</code>屬性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br><span class="line">    ALL = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>於是程式碼變成這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">not</span> <span class="keyword">in</span> RestartPolicy.ALL:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>好像還可以，不是嗎？——但這顯然<strong>不是最佳實踐</strong>。</p><p>雖然在這個例子中，restart policy 主要就這 4 種，而且也不太會變動。</p><p>但如果在別的列舉場合，偶爾甚至不時會增加成員時，我們的 ALL 屬性的值也要跟著修正，這會產生潛在的「同步」問題——<strong>忘記</strong>一併更新 ALL 屬性。</p><h3 id="使用序列化器驗證"><a href="#使用序列化器驗證" class="headerlink" title="使用序列化器驗證"></a>使用序列化器驗證</h3><p>話說回來，DRF 有<a href="https://www.django-rest-framework.org/api-guide/serializers/">序列化器模組</a>，作為驗證輸入資料正確性的手段。</p><p>只要你有寫序列化器，通常也不需要像上述程式碼一般手工驗證。</p><p>本文適用於<strong>沒有序列化器輔助</strong>的情況，或者說，你就是要在某些自定義的邏輯進行手動驗證。</p><h2 id="小結：目前寫法的問題"><a href="#小結：目前寫法的問題" class="headerlink" title="小結：目前寫法的問題"></a>小結：目前寫法的問題</h2><p>假設沒有序列化器輔助，要在程式碼中進行手動驗證，則上述寫法有兩個不妥之處：</p><ol><li>要驗證 input 資料是否為合法列舉成員，太囉嗦、冗長了。</li><li>如果加上<code>ALL</code>這類自定義屬性，雖然可以減緩程式碼冗長問題，又產生了潛在的同步問題。</li></ol><p>事實上，即使沒有<code>ALL</code>屬性，<strong>第一種寫法一樣存在同步問題</strong>。因為你要<strong>手動</strong>維護這個驗證條件。</p><p><code>ALL</code>屬性只是把這個「<strong>新增、刪除列舉成員</strong>」的<strong>同步議題</strong>從 view 函式中（或任何其它用到的地方）抽離出來，統一移到類別中控管。</p><p>這或許可以算是一個<strong>改進</strong>：當情況變動時，需要跟著修改的地方<strong>只剩下一個</strong>——<code>ALL</code>本身。<strong>但依舊不是最佳解法。</strong></p><hr><h2 id="第二部分：介紹-Python-Enum-的三大特性"><a href="#第二部分：介紹-Python-Enum-的三大特性" class="headerlink" title="第二部分：介紹 Python Enum 的三大特性"></a>第二部分：介紹 Python Enum 的三大特性</h2><p>自從寫 <a href="https://django-ninja.dev/">Django Ninja</a> 後，為了渲染出嚴謹的 API 文件，我不得不用 Enum 了（可參考文章最後的<a href="/python-enum/#%E8%A3%9C%E5%85%85%EF%BC%9AEnum-%E9%A1%9E%E5%88%A5%E5%9C%A8-Django-Ninja-%E4%B8%AD%E7%9A%84%E6%87%89%E7%94%A8">補充</a>部分），同時也感受到了它的強大！</p><p>我們來看看，採用 Enum 之後會有什麼改變。</p><p>在此之前，我們要先介紹 Enum 中，<strong>我認為最重要的三大特性</strong>。至少在我的例子中，知道這三個特性會<strong>非常有用</strong>。</p><p>我們看一下加入了 Enum 後的類別模樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>我把<code>ALL</code>屬性移除了，因為它不再需要。</p><p>我們就以這個新類別為例，來看看 Enum 的三大特性。</p><hr><h2 id="一、Enum-類別可以用-for-迴圈迭代"><a href="#一、Enum-類別可以用-for-迴圈迭代" class="headerlink" title="一、Enum 類別可以用 for 迴圈迭代"></a>一、Enum 類別可以用 for 迴圈迭代</h2><p>一般的類別並不能以 for 迴圈迭代，因為沒有實作<code>__iter__</code>方法，<strong>但 Enum 有！</strong></p><p>對於「列舉」這種有限成員的情況，能迭代它非常重要。</p><p>還記得原來的<code>ALL</code>屬性嗎？ <code>ALL = [0, 1, 2, 3]</code></p><p>這個<code>ALL</code>屬性的值，其實就是<strong>為了取得類別中的每一個屬性值</strong>。但有了 Enum，我們不用這麼麻煩了！</p><p>那我要怎麼取得 Enum 類別中的所有屬性值？這就要看下面第二個特性。</p><h2 id="二、了解-Enum-實例"><a href="#二、了解-Enum-實例" class="headerlink" title="二、了解 Enum 實例"></a>二、了解 Enum 實例</h2><p>這段特別長，因為它包含了<strong>三個子命題</strong>，都和 Enum 實例有關。</p><p>這裡要先問：<strong>如何取得 Enum 實例？</strong></p><h3 id="Enum-實例的建構與條件"><a href="#Enum-實例的建構與條件" class="headerlink" title="Enum 實例的建構與條件"></a>Enum 實例的建構與條件</h3><p>沒錯，和一般的類別相同，都是從建構與初始化開始，依舊使用上面的例子，我們可以像這樣獲得 Enum 實例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = RestartPolicy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>和一般類別<strong>不同</strong>的是，這裡的建構<strong>引數</strong>，<strong>只能</strong>是「<strong>任一 Enum 成員的屬性值</strong>」。也就是範例類別中的<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>。</p><p>這是 Enum 類別的<strong>限制</strong>，也是它的<strong>重要特性</strong>。</p><p>換句話說，<strong>所有 Enum 類別的實例，都一定是由 Enum 成員值（比如上述的 2）建構而來的</strong>。</p><p>此外，<strong>沒有引數也不行！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沒有引數會報錯</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy()</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">TypeError: EnumMeta.__call__() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure><p>而建構出的實例，就是<strong>「代表該成員」的 Enum 實例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>)</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Enum-類別屬性「就是」Enum-實例"><a href="#Enum-類別屬性「就是」Enum-實例" class="headerlink" title="Enum 類別屬性「就是」Enum 實例"></a>Enum 類別屬性「就是」Enum 實例</h2><blockquote><p><strong>這是 Enum 最重要的特性之一，也是最容易讓人困惑的地方。</strong></p></blockquote><p>除了透過建構，其實<strong>直接呼叫類別屬性</strong>，也能夠得到<strong>同一個</strong> Enum 成員實例！</p><p>這是一般類別所<strong>難以想像</strong>的，因為一般類別呼叫類別屬性後，只會得到單純的<strong>值</strong>，比如本文一開始的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這裡是非 Enum 版的 RestartPolicy</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>回到 Enum。換言之，下面兩種寫法，獲得的結果<strong>完全相同</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>)</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>不了解這個特性，會讓你對 Enum 的使用產生很大困惑。</strong></p><h3 id="單例模式"><a href="#單例模式" class="headerlink" title="單例模式"></a>單例模式</h3><p>更進一步說，Enum 類別的每一個成員實例，實際上都是<strong>單例</strong>。</p><p>這意味著對於每個成員，無論你在程式碼中呼叫多少次，<strong>都是指向「同一個」物件。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = RestartPolicy(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>p2 = RestartPolicy(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>p1 <span class="keyword">is</span> p2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) <span class="keyword">is</span> RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>了解這一點，就能夠更好地利用 Enum 來處理列舉資料。</p><hr><h2 id="Enum-實例的兩個屬性"><a href="#Enum-實例的兩個屬性" class="headerlink" title="Enum 實例的兩個屬性"></a>Enum 實例的兩個屬性</h2><p>所有 Enum 成員實例都有兩個內建的屬性：<code>name</code>與<code>value</code>。</p><p><code>name</code>是<strong>成員的名稱</strong>，也就是<strong>類別屬性名稱</strong>；<code>value</code>則是<strong>成員的值</strong>。</p><p>我們分別使用<strong>兩種不同的實例取得方式</strong>來呼叫這兩個屬性！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>).name</span><br><span class="line"><span class="string">&#x27;UNLESS_STOPPED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同於</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED.name</span><br><span class="line"><span class="string">&#x27;UNLESS_STOPPED&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED.value</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同於</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>).value</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>綜上所述，如果用 for 迴圈迭代<code>RestartPolicy</code>，你將得到（這裡使用<code>repr</code>突顯）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> RestartPolicy:</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="built_in">repr</span>(i))</span><br><span class="line"></span><br><span class="line">&lt;RestartPolicy.NO: <span class="number">0</span>&gt;</span><br><span class="line">&lt;RestartPolicy.ALWAYS: <span class="number">1</span>&gt;</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br><span class="line">&lt;RestartPolicy.ON_FAILURE: <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>得到<code>RestartPolicy</code>的每一個成員實例。</strong></p><hr><h2 id="三、Enum-實例之間可以進行比較"><a href="#三、Enum-實例之間可以進行比較" class="headerlink" title="三、Enum 實例之間可以進行比較"></a>三、Enum 實例之間可以進行比較</h2><p>Enum 成員之間，支援身分比較（<code>is</code>）和等值（<code>==</code>）比較。</p><p>只不過，如前所述，每一個 Enum 成員都是「<strong>單例</strong>」。所以身分比較和等值比較對於 Enum 成員是<strong>等價</strong>的，也就是<strong>結果都相同</strong>。因為每個成員都是<strong>唯一</strong>的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) == RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) <span class="keyword">is</span> RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>我認為大部分時候，使用等值（<code>==</code>）比較就已經足夠了。</p><hr><h2 id="第三部分：使用-Enum-改進原有程式！"><a href="#第三部分：使用-Enum-改進原有程式！" class="headerlink" title="第三部分：使用 Enum 改進原有程式！"></a>第三部分：使用 Enum 改進原有程式！</h2><p>現在你對 Enum 的特性已經有了相當的了解。我們來看看原來的程式碼在使用 Enum 版本後，會發生什麼樣的變化。</p><p>回顧一下之前的問題：</p><ol><li>要驗證 input 資料是否為合法列舉成員，太囉嗦、冗長了。</li><li>如果加上<code>ALL</code>這類自定義屬性，雖然可以減緩程式碼冗長問題，又產生了潛在的同步問題。</li></ol><h3 id="對問題一的改善"><a href="#對問題一的改善" class="headerlink" title="對問題一的改善"></a>對問題一的改善</h3><p>現在，你想要驗證 input 值是否屬於列舉成員，可以這樣寫（我們假設 input 值為 2，代表<code>&#39;unless-stopped&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">in</span> [p.value <span class="keyword">for</span> p <span class="keyword">in</span> RestartPolicy]:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>因為 <code>RestartPolicy</code> 類別現在是可以用 <code>for</code> 迭代了！而每一個元素則是成員實例，需要透過<code>value</code>屬性取值，所以可以像上面那樣寫。</p><p>乍看之下，好像也沒有方便到哪去？確實如此😅，沒關係，我們還有<a href="#%E9%80%8F%E9%81%8E%E3%80%8C%E5%BB%BA%E7%AB%8B-Enum-%E5%AF%A6%E4%BE%8B%E3%80%8D%E9%80%B2%E8%A1%8C%E9%A9%97%E8%AD%89">後手</a>。</p><h3 id="Pydantic-預處理"><a href="#Pydantic-預處理" class="headerlink" title="Pydantic 預處理"></a>Pydantic 預處理</h3><p>如果你有用 Pydantic 對資料預處理（FastAPI、Django Ninja 等後端框架會自動做這件事），通常<code>payload.restart_policy</code>的值，就<strong>已經是一個 Enum 實例了。</strong></p><blockquote><p>當然，如果有用 Pydantic 預處理，這個驗證根本不需要XD，這裡只是為了舉例。</p></blockquote><p>無論如何，現在你有一個 Enum 實例，那驗證成員身分的寫法將<strong>異常簡單</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">in</span> RestartPolicy:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>對，就這麼簡單！</p><p>也就是你可以輕鬆寫下這樣的句型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;Enum 實例&gt; <span class="keyword">in</span> &lt;Enum 類別&gt;:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="關於in運算子"><a href="#關於in運算子" class="headerlink" title="關於in運算子"></a>關於<code>in</code>運算子</h3><p>因為<code>in</code>運算子的內部，本來就會<strong>「視情況」迭代後面接的物件</strong>了——<code>in</code>會優先調用<code>__contains__</code>方法，沒有實作此方法，才退回<code>__iter__</code>，也就是所謂的迭代。</p><p>所以<code>in</code>後面可以接兩種物件，以落實成員的查找：</p><ol><li>有實作<code>__contains__</code>方法的物件。比如<code>set</code>、<code>dict</code>等。</li><li>有實作<code>__iter__</code>方法的物件。（所有的 iterable 都有）</li></ol><p><strong>而 Enum 類別正是一個 iterable——它實作了<code>__iter__</code>方法</strong>。</p><hr><h2 id="透過「建立-Enum-實例」進行驗證"><a href="#透過「建立-Enum-實例」進行驗證" class="headerlink" title="透過「建立 Enum 實例」進行驗證"></a>透過「建立 Enum 實例」進行驗證</h2><p>但如果你的<code>payload.restart_policy</code>，就<strong>只是一般的值</strong>，而不是 Enum 成員。那該怎麼辦？難道真的要像上面那樣，寫落落長的<code>[p.value in p in RestartPolicy]</code>嗎？</p><p>當然不！其實做法一樣非常簡單，那就是「<strong>直接用這個值來建立實例</strong>」。</p><p><a href="#Enum-%E5%AF%A6%E4%BE%8B%E7%9A%84%E5%BB%BA%E6%A7%8B%E8%88%87%E6%A2%9D%E4%BB%B6">前面</a>說過，Enum 實例<strong>只能由 Enum 成員值建構而來</strong>。所以，如果你輸入的值不是<strong>合法</strong>的 Enum 成員，建構實例時就會拋出<code>ValueError</code>。</p><p>換句話說，<strong>只要能成功建立實例，就是合法的成員</strong>！所以你可以這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    RestartPolicy(payload.restart_policy)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果是不合法的，比如 4，則會拋出<code>ValueError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ValueError: <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid RestartPolicy</span><br></pre></td></tr></table></figure><p>總之，<strong>記得處理這個例外。</strong></p><h3 id="對問題二的改善"><a href="#對問題二的改善" class="headerlink" title="對問題二的改善"></a>對問題二的改善</h3><p>既然 Enum 類別本身就可以用 for 迭代以取得所有成員（甚至直接使用<code>in</code>運算子），那就<strong>完全沒必要</strong>再寫前面像<code>ALL</code>一樣的屬性，然後還要維護它。</p><p>由此可見，Enum 真的棒！</p><hr><h2 id="補充：Enum-類別在-Django-Ninja-中的應用"><a href="#補充：Enum-類別在-Django-Ninja-中的應用" class="headerlink" title="補充：Enum 類別在 Django Ninja 中的應用"></a>補充：Enum 類別在 Django Ninja 中的應用</h2><p>前面說到我會開始用 Enum，正是因為 Django Ninja。</p><p>Django Ninja 的 <a href="https://django-ninja.dev/guides/response/">Schema</a> 實際上就是 Pydantic 的 <a href="https://docs.pydantic.dev/latest/concepts/models/#validation">BaseModel</a>。</p><p>Schema 用來描述 API 輸入與輸出的資料結構。主要的功能有二：</p><ol><li><strong>驗證</strong>輸入資料是否符合規範。</li><li><strong>自動產生</strong> API 文件。</li></ol><p>我們看一下使用了 Enum 型別後的 Schema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateContainerRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    restart_policy: RestartPolicy</span><br></pre></td></tr></table></figure><p>直接將<code>restart_policy</code>欄位型別標記為<code>RestartPolicy</code>，如此渲染出的 API 文件，不止能限定輸入資料的型別，連「<strong>值域</strong>」也會有<strong>明確標示</strong>：</p><p><img src="https://i.imgur.com/A8RgBlS.png" alt="型別：integer；值域：僅限 0、1、2、3"><span class="cap">型別：integer；值域：僅限 0、1、2、3</span></p><p>甚至還能把<code>RestartPolicy</code>類別中的<code>docstring</code><strong>直接渲染成欄位說明</strong>，太貼心了吧！偉哉 Pydantic！</p><p>好處不止如此，一旦你<strong>變更</strong>了<code>RestartPolicy</code>的內容（比如<strong>增加了成員選項</strong>），API 文件也會<strong>自動更新</strong>。</p><p>不必再手動修改 API 文件，也不必修改 Schema 的 type hints，完全省去了「同步」的煩惱。</p><h3 id="使用「字串」列舉"><a href="#使用「字串」列舉" class="headerlink" title="使用「字串」列舉"></a>使用「字串」列舉</h3><p>除了上述的「<strong>數字列舉</strong>」版，我同時再附上「<strong>字串列舉</strong>」版本，看圖你應該就能理解，為何我一開始說，有時候列舉資料用字串會更好。</p><p><img src="https://i.imgur.com/9eCQcFB.png"></p><p>直接採用字串選項，對前端人員更加友善——<strong>更容易了解每個選項代表的意義。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5lvKO0a.jpeg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;想必你知道 Python 中有一個內建的特殊類別叫 &lt;a href=&quot;https://docs.python.org/zh-tw/3.12/library/enum.html#enum.Enum&quot;&gt;Enum&lt;/a&gt;（來自 &lt;a href=&quot;https://docs.python.org/zh-tw/3.12/library/enum.html&quot;&gt;enum&lt;/a&gt; 模組），專門用來處理「列舉」態型的資料集合。&lt;/p&gt;
&lt;p&gt;如同 &lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html&quot;&gt;collection&lt;/a&gt; 模組中的各種容器（比如：&lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html#collections.deque&quot;&gt;&lt;code&gt;deque&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt;），Enum 已經定義好很多「&lt;strong&gt;內建特性（屬性、方法、行為）&lt;/strong&gt;」供你使用。這些特性會讓你在&lt;strong&gt;處理特定情境&lt;/strong&gt;時非常順手。&lt;/p&gt;
&lt;p&gt;但是，這些特性也使得 Enum 類別與一般類別&lt;strong&gt;有著很大的差異，增加了學習門檻&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如你所見，Enum 的特性頗多，這讓人在學習、使用之前，難免有點&lt;strong&gt;望之卻步&lt;/strong&gt;——至少我是這樣！&lt;/p&gt;
&lt;h2 id=&quot;本文主旨與架構&quot;&gt;&lt;a href=&quot;#本文主旨與架構&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與架構&quot;&gt;&lt;/a&gt;本文主旨與架構&lt;/h2&gt;&lt;p&gt;本文分享我最近才開始把 Enum 應用在 API 開發中的經驗——從它的三大特性入手，並輔以一個實際問題情境。&lt;/p&gt;
&lt;p&gt;Enum 的特性不少，但只要知曉這三件事，就可以在遇到「列舉」欄位時，善用 Enum 來提升開發效率，同時增進程式碼的簡潔與穩健。&lt;/p&gt;
&lt;p&gt;不過話說回來，即使不是開發 API，也不影響你對本文的理解。只是我的經驗是從後端開發而來。&lt;/p&gt;
&lt;h3 id=&quot;本文架構&quot;&gt;&lt;a href=&quot;#本文架構&quot; class=&quot;headerlink&quot; title=&quot;本文架構&quot;&gt;&lt;/a&gt;本文架構&lt;/h3&gt;&lt;p&gt;為了讓你感受 Enum 的強大與美妙，&lt;strong&gt;本文的架構經過精心設計。&lt;/strong&gt;共分為&lt;strong&gt;三個部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;問題情境&lt;/strong&gt;：我會先提出一個&lt;strong&gt;問題情境&lt;/strong&gt;，突顯舊方法的不足。&lt;/li&gt;
&lt;li&gt;然後再介紹 Enum 的&lt;strong&gt;三大特性&lt;/strong&gt;，帶你進入 Enum 的世界。&lt;/li&gt;
&lt;li&gt;最後看 Enum 特性在問題情境中&lt;strong&gt;如何有效發揮&lt;/strong&gt;，讓程式碼變得更加優雅——也就是它&lt;strong&gt;解決的痛點&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;藉由這個流程，相信你對 Enum 會有更進一步的理解。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5lvKO0a.jpeg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Enum" scheme="https://blog.kyomind.tw/tags/Enum/"/>
    
    <category term="Pydantic" scheme="https://blog.kyomind.tw/tags/Pydantic/"/>
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>27，正式入手《流暢的 Python》第二版</title>
    <link href="https://blog.kyomind.tw/weekly-review-27/"/>
    <id>https://blog.kyomind.tw/weekly-review-27/</id>
    <published>2024-04-14T15:17:50.000Z</published>
    <updated>2024-04-19T03:44:10.072Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>Weekly Review 原則上著眼於「<strong>非程式類</strong>」內容，而這是一本程式相關的書，所以這期不會討論書中的技術細節，只聊聊<strong>我的主觀感受</strong>。</p><p>講它，是因為我對這本書的<strong>期待很高</strong>，它絕對有這個地位與份量，更別說它真的很厚！（量了一下有 5 公分厚，打算這星期拿去影印店<strong>拆成 3 本</strong>）</p><p>趁著清明連假的天瓏日（滿千折百活動），我總算入手了 Python 進階書籍中的口碑之作——《<a href="https://www.tenlong.com.tw/products/9786263246331">流暢的 Python</a>》，第二版。</p><p>還沒有開始讀，但先簡單分享一下<strong>我的看法與期待。</strong></p><span id="more"></span><h2 id="作為第一版讀者"><a href="#作為第一版讀者" class="headerlink" title="作為第一版讀者"></a>作為第一版讀者</h2><p>早在我開始 Python 軟體工程師職涯之前，即 2019 上半年準備轉職的期間，就讀過了《流暢的 Python》第一版——的一部分。</p><p>所以在面試 StreetVoice 寫程式測驗試題的時候（其中一題就是「以 mutable 資料作為函式參數預設值」的經典題目），立刻就想到了書中「幽靈公車」的例子。</p><p>不過，那時只讀了一部分，就早早束之高閣了。因為剩下部分對當時的我來說，還太過進階。</p><h2 id="2021-年，第二版消息與精讀計畫"><a href="#2021-年，第二版消息與精讀計畫" class="headerlink" title="2021 年，第二版消息與精讀計畫"></a>2021 年，第二版消息與精讀計畫</h2><p>2021，已經當了 2 年的 Python 工程師，這一年我總算把《流暢的 Python》讀完了。</p><p>但說真的，讀完也沒用。如果工作中用不到，這些東西，對我來說依舊是「書上的知識」，而不是我真實能力的一部分。</p><p>所以有點失落，不知該如何是好，想說是不是再認真細讀一次、兩次……結果下半年就得知了第二版正在撰寫中的消息。</p><p>喜新厭舊如我，自然不想再看舊書（以前對法律的參考書也是如此），想等中文版出了再說。於是這個「精讀」計畫就被無限期延後了。</p><h2 id="繁體中文版，正式出爐"><a href="#繁體中文版，正式出爐" class="headerlink" title="繁體中文版，正式出爐"></a>繁體中文版，正式出爐</h2><p>台灣中文版在英文出版後的一年內，遲遲沒有消息（我的判斷方式是繁中的第一版是否絕版不賣了），讓我不禁擔心：該不會不引進繁中版了吧？</p><p>還好，我想多了，應該只是第二版書更厚，翻譯花了更多時間而已。去年 10 月，本書的繁體中文版正式在台灣上市。</p><p><strong>但我並沒有在第一時間入手。</strong></p><h2 id="眾裡尋他千百度"><a href="#眾裡尋他千百度" class="headerlink" title="眾裡尋他千百度"></a>眾裡尋他千百度</h2><p>因為我不禁在想，是不是有「<strong>更好、更簡單</strong>」的選擇。</p><p>說來矛盾，明明是學 Python 的進階特性（也就是<strong>比較難</strong>的部分），我卻希望能「更簡單」。</p><p>但也不奇怪，這裡的更簡單，指的是「<strong>更容易上手、入門</strong>」——也就是<strong>更少痛苦</strong>。對於這些<strong>相對棘手</strong>的主題，我總是想找到一個「<strong>比較好啃</strong>」的方式。</p><p>所以我開始把期望寄託在其它書上，這些書本來就買了好多本，一直只是都沒讀！</p><p>所幸，過去一個多月的「<a href="https://www.facebook.com/kyomind/posts/pfbid02eQaYDFtE13cfsDofWPXZuiHjBuSqjr1nhBGiYpysGDktveGRiEVB9SxaKnJjy2zpl">圖書館時間</a>」，我基本把它們都翻完了。</p><p>並初步確認了每一本書對我的價值，以及後續還要投入多少時間。</p><h2 id="燈火闌珊處"><a href="#燈火闌珊處" class="headerlink" title="燈火闌珊處"></a>燈火闌珊處</h2><p>翻完這些書，我明白了一件事——《流暢的 Python》確實是最好的！</p><p>當然，無論《Python 精粹》或是《Python 神乎其技》，都有其可看之處。但《流暢的 Python》終歸還是 Python 進階書籍中的佼佼者。</p><p>正因為看過了其它書，所以我才更明白本書的精彩與不可取代。</p><p>前兩本書，我不會想從頭到尾精讀，但《流暢的 Python》有這個價值。</p><p>一言以蔽之，如果只打算好好讀一本 Python 進階書籍，就這本吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Weekly Review 原則上著眼於「&lt;strong&gt;非程式類&lt;/strong&gt;」內容，而這是一本程式相關的書，所以這期不會討論書中的技術細節，只聊聊&lt;strong&gt;我的主觀感受&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;講它，是因為我對這本書的&lt;strong&gt;期待很高&lt;/strong&gt;，它絕對有這個地位與份量，更別說它真的很厚！（量了一下有 5 公分厚，打算這星期拿去影印店&lt;strong&gt;拆成 3 本&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;趁著清明連假的天瓏日（滿千折百活動），我總算入手了 Python 進階書籍中的口碑之作——《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263246331&quot;&gt;流暢的 Python&lt;/a&gt;》，第二版。&lt;/p&gt;
&lt;p&gt;還沒有開始讀，但先簡單分享一下&lt;strong&gt;我的看法與期待。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>26，改用 Buttondown 作為文章訂閱服務</title>
    <link href="https://blog.kyomind.tw/weekly-review-26/"/>
    <id>https://blog.kyomind.tw/weekly-review-26/</id>
    <published>2024-04-10T14:22:04.000Z</published>
    <updated>2024-05-01T16:30:16.427Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>去年 2 月，部落格新增了「email 文章訂閱」功能，採用的方案是免費的 <a href="http://follow.it/">follow.it</a>。</p><p>它會把我的 RSS 新文章轉成 email，然後寄送給訂閱的讀者。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-12/">12，blog 新增文章訂閱功能——使用 follow.it</a></p></blockquote><p>如該篇中所言，「<strong>文章訂閱功能</strong>」確實是現代部落格的一大需求。</p><p>網路上的資訊眾多，我自己作為讀者，也常常感覺<strong>被淹沒</strong>。遇到一個喜歡的作者，想要追蹤，此時<strong>作者是否提供了訂閱功能，就至關重要。</strong></p><p>文章訂閱功能，可以由寫作平台提供，比如 Medium、Substack。不然就得自己來，因此我一開始就為 blog 提供了 RSS 訂閱。</p><p>但 RSS 畢竟不是一般人常用的資訊接收方式（<strong>我自己也不用</strong>），它只能滿足小眾人口的需求。所以最終我還是選擇了像 follow.it 這樣的「RSS to email」服務。</p><span id="more"></span><h2 id="為何選擇-follow-it"><a href="#為何選擇-follow-it" class="headerlink" title="為何選擇 follow.it"></a>為何選擇 follow.it</h2><p>用過電子報服務的都知道，這些服務<strong>真的不便宜！</strong></p><p>比如其中相對「高貴」的 ConvertKit，從它的 <a href="https://convertkit.com/pricing">pricing</a> 頁面可以看到，它的付費版僅僅 300 個訂戶，每月就要 9 美元！（而且這還是基於<strong>年繳</strong>的「優惠價」）</p><p>這也是為何很多人選擇在 Substack 上寫作，它對於需要發送「大量」電子報給讀者的創作者非常友好——<strong>不用錢。</strong></p><p>但我既已從 Medium 獨立，有了自己的 blog，自然不會再跑去 Substack 上寫作。選擇免費的 follow.it，也是情理之中。</p><blockquote><p>相關文章：</p><ul><li><a href="https://blog.kyomind.tw/my-own-blog-part-one/">我自架部落格的理由與選擇（上）理由篇</a></li><li><a href="https://blog.kyomind.tw/my-own-blog-part-two/">我自架部落格的理由與選擇（下）選擇篇</a></li></ul></blockquote><h2 id="改用-Buttondown"><a href="#改用-Buttondown" class="headerlink" title="改用 Buttondown"></a>改用 Buttondown</h2><p>一年過去，在佛系經營下（畢竟我的「電子報」就只是純粹的新文章通知，也不好意思鼓吹訂閱），訂戶也超過了 100 人，讓我不禁尋思更好的文章訂閱方案。</p><p>畢竟免費有一定<strong>代價</strong>，follow.it 的電子報會在你文章的開頭、結尾夾帶大量廣告。而且廣告的<strong>格調不高</strong>，讓人看了不禁有點<strong>傷眼</strong>🤡</p><p>那為何不一開始就採用電子報供應商的方案？主要有兩個原因：</p><ol><li>不是每家都有「RSS to email」功能，有提供這個功能的，都要花錢！</li><li>那時覺得 follow.it 就完全滿足我了。</li></ol><p>不過，此一時，彼一時。</p><p>就在今年 3 月上旬，我決定正式付費改用 <a href="https://buttondown.email/pricing">Buttondown</a>。</p><blockquote><p>如果你有興趣，可以考慮使用我的<a href="https://buttondown.email/refer/kyo">推薦連結</a>註冊。</p></blockquote><h2 id="為何選擇-Buttondown"><a href="#為何選擇-Buttondown" class="headerlink" title="為何選擇 Buttondown"></a>為何選擇 Buttondown</h2><p>知道它，以及決定選擇它，主要有兩個原因。</p><p>一方面，它是我有在 follow 的兩位作者都推薦過的電子報服務，可參考這兩篇文章：</p><ul><li><a href="https://vocus.cc/article/61a48a31fd89780001ed3b87">我念念不忘的電子報平台 Buttondown</a></li><li><a href="https://pinchlime.com/blog/first-impression-of-buttondown/">令人忍不住想掏錢支持的 Buttondown</a></li></ul><p>另一方面，以我預想的長期訂戶數量（5 年內不超過 1000 人）——也就是 1000 人以內，Buttondown 的價格<strong>還算是可接受的</strong>。</p><p>一年要價 90 美元（月付則是每個月 9 美元），雖然稱不上便宜，但相比於市面上其他常見選擇（必須有「RSS to email」功能），仍有一定的競爭力。</p><p>在嘗試性地付費了一個月、寄了 2 次信以後，我覺得不錯，就決定直接轉年費了。在達到 1000 訂戶以前，應該不會變動。</p><h2 id="一年-90-美元，值得嗎？"><a href="#一年-90-美元，值得嗎？" class="headerlink" title="一年 90 美元，值得嗎？"></a>一年 90 美元，值得嗎？</h2><p>一年 90 美元，相當於我租 DigitalOcean VM 一年的費用，值得嗎？</p><p>我想還是值得的，畢竟它帶來的好處<strong>非常直接</strong>——讓讀者透過電子報，第一時間收到你的文章內容。</p><p><strong>既沒有廣告，也不需要綁定任何創作平台，算是用金錢換來更大的「創作自由」。</strong></p><p>再說，我幾乎所有的文章，都需要等待 SEO 慢慢發酵。這過程往往須耗時數週到數月不等，說真的有點難熬，而且也不一定有亮眼的結果。</p><p>有了電子報文章通知，至少我能<strong>確信</strong>，在發文的當下，有<strong>一小部分人</strong>能夠立刻知曉。</p><p>對作者而言，這無疑能帶來一定的<strong>欣慰</strong>，與<strong>安全感</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年 2 月，部落格新增了「email 文章訂閱」功能，採用的方案是免費的 &lt;a href=&quot;http://follow.it/&quot;&gt;follow.it&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;它會把我的 RSS 新文章轉成 email，然後寄送給訂閱的讀者。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-12/&quot;&gt;12，blog 新增文章訂閱功能——使用 follow.it&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如該篇中所言，「&lt;strong&gt;文章訂閱功能&lt;/strong&gt;」確實是現代部落格的一大需求。&lt;/p&gt;
&lt;p&gt;網路上的資訊眾多，我自己作為讀者，也常常感覺&lt;strong&gt;被淹沒&lt;/strong&gt;。遇到一個喜歡的作者，想要追蹤，此時&lt;strong&gt;作者是否提供了訂閱功能，就至關重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章訂閱功能，可以由寫作平台提供，比如 Medium、Substack。不然就得自己來，因此我一開始就為 blog 提供了 RSS 訂閱。&lt;/p&gt;
&lt;p&gt;但 RSS 畢竟不是一般人常用的資訊接收方式（&lt;strong&gt;我自己也不用&lt;/strong&gt;），它只能滿足小眾人口的需求。所以最終我還是選擇了像 follow.it 這樣的「RSS to email」服務。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="blog" scheme="https://blog.kyomind.tw/tags/blog/"/>
    
    <category term="電子報" scheme="https://blog.kyomind.tw/tags/%E9%9B%BB%E5%AD%90%E5%A0%B1/"/>
    
  </entry>
  
  <entry>
    <title>《強健的 Python》筆記（一）Type Hints 的成本與挑戰</title>
    <link href="https://blog.kyomind.tw/robust-python-01/"/>
    <id>https://blog.kyomind.tw/robust-python-01/</id>
    <published>2024-04-06T18:44:00.000Z</published>
    <updated>2024-05-19T00:31:37.659Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/nqKDYbc.png" alt="強健的 Python"><span class="cap">強健的 Python</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263241015">強健的 Python｜撰寫潔淨且可維護的程式碼</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>本書翻譯自《<a href="https://www.amazon.com/-/zh_TW/Patrick-Viafore/dp/1098100662">Robust Python: Write Clean and Maintainable Code</a>》，原文的副標題容易讓人<strong>誤以為</strong>這又是另一本關於「Clean Code in Python」的書。</p><p>實際上，本書所聚焦的，是 Python 的一大特性——<a href="https://docs.python.org/3/library/typing.html">type hints</a>。全書大半篇幅都圍繞著這個核心主軸。</p><p>所以它並非教你「如何寫出 Pythonic 程式碼」的書，而是介紹 type hints 寫法與使用相關工具（比如 Mypy）以確保 type hints 有效落實的作品。</p><p>如果你還不熟悉 Python type hints，本文也可以作為認識 type hints 的起點。</p><span id="more"></span><hr><h2 id="場景與緣由"><a href="#場景與緣由" class="headerlink" title="場景與緣由"></a>場景與緣由</h2><p>上個月，我在一個新的 Django 工作專案中加入了 Mypy，主要做了這兩件事：</p><ol><li>整合 Mypy VS Code 套件（包括 Mypy 設定檔），讓開發者在寫程式的當下，可以在編輯器中隨時收到來自 Mypy 的「提醒」。</li><li>設定 Mypy pre-commit hook。</li></ol><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p></blockquote><p>上述二者（主要是第二點），讓新專案真正落實了 Python type hints——這下子你不寫 type hints 也不行了。</p><p>這個過程並不困難，但還是需要一番摸索才能順利到位，這部分我會另外寫成一篇文章作為教學。</p><p>本文的重點，在於<strong>專案落實 type hints 的挑戰</strong>。</p><h2 id="專案落實-type-hints-的真正難點"><a href="#專案落實-type-hints-的真正難點" class="headerlink" title="專案落實 type hints 的真正難點"></a>專案落實 type hints 的真正難點</h2><p>在為 Django 專案導入 Mypy 之前，我讀了本書——前後讀了兩次。</p><p>之所以寫這篇筆記，主要是深刻感受到，在工作上要落實 type hints、把它們加入到 Python 專案中，整個環節<strong>最難的部分</strong>，並非關於 type hints 語法的學習。</p><p>而是其它種種因素。</p><p>事實上，我去年就打算<a href="https://blog.kyomind.tw/weekly-review-08/#%E5%B0%8F%E7%B5%90%EF%BC%9A2023-%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9B%AE%E6%A8%99">為 Django 專案全面導入 type hints</a>，但是失敗了！直到本次的時機「更加成熟」，才下定決心推行。</p><p>本文藉由對書中內容的整理與我的經驗，好好介紹一下，為專案加入 type hints 時，<strong>你一定會遇到的困難</strong>，與對應的思考。</p><hr><h2 id="Python-type-hints-簡介"><a href="#Python-type-hints-簡介" class="headerlink" title="Python type hints 簡介"></a>Python type hints 簡介</h2><p>Python  3.5 首次導入了 type hints，可見〈<a href="https://peps.python.org/pep-0484/">PEP 484 – Type Hints</a>〉，該 PEP 提案的共同發起人除了 Python 之父 Guido van Rossum，還有 Mypy 作者。</p><p>接下來的每一版 Python，<strong>都少不了對 type hints 的擴充與增強</strong>。可以說，type hints 是經過「一系列」漫長的發展與迭代，才有了今日的氣象。</p><h2 id="Type-hints-的野心"><a href="#Type-hints-的野心" class="headerlink" title="Type hints 的野心"></a>Type hints 的野心</h2><p>Guido van Rossum 本人對 type hints 非常重視，從良葛格的〈<a href="https://www.ithome.com.tw/voice/116983">Type Hints 的野心</a>〉中這一段話可知：</p><blockquote><p>本來 Python 在動態定型語言中，相對來說，就是極為重視工程性的語言，然而曾經在某個地方看過的說法是，<strong>Guido 長年以來的野心，就是讓 Python 在工程性上更進一步</strong>，而在靜態分析工具上投入精力會是必要的。事實上，從 2000 年以來，Guido 一直想在 Python 中，加入可選的靜態定型，一直到 PEP 484、526 的實現，本人也在 PyCon 2015 親自上場講演〈<a href="https://goo.gl/wPZYWo">Type Hints</a>〉，似乎也印證了這點。</p></blockquote><h3 id="Type-hints-的價值"><a href="#Type-hints-的價值" class="headerlink" title="Type hints 的價值"></a>Type hints 的價值</h3><p>專案程式碼加入 type hints 的好處顯而易見，它們賦予 Python 在開發階段就能如靜態型別語言般，為變數、參數、回傳值<strong>明示型別</strong>的能力，從而提高專案的穩定性和可維護性——這在大型專案中尤其重要。</p><p>說真的，很多時候我光是看型別，對於程式碼的理解就有<strong>明顯的提升</strong>，這對於程式碼的<strong>閱讀、維護、重構</strong>都有<strong>很大的幫助</strong>。</p><p>搭配 Mypy 這類 type checker，加上 IDE 整合，更是妙不可言！</p><p>這直接提高了 Python 在團隊協作的競爭力，讓大型專案採用 Python 變得更加可能。</p><h3 id="Type-hints-的代價"><a href="#Type-hints-的代價" class="headerlink" title="Type hints 的代價"></a>Type hints 的代價</h3><p>儘管 type hints 有種種好，但平心而論，它的<strong>代價也不小</strong>！（後面會提到）</p><p>所以，有時候你不寫 type hints，可能是「明智」的，尤其是在一些不需要長期維護，或是小型個人專案中。</p><p>但是，要徹底了解 type hints 的優點與缺點，我們需要<strong>更加全面且務實</strong>的的觀點。</p><hr><p>呼，鋪陳有點長，以下才是本書的重點整理！</p><h2 id="Type-hints-的利弊分析"><a href="#Type-hints-的利弊分析" class="headerlink" title="Type hints 的利弊分析"></a>Type hints 的利弊分析</h2><p>關於採用 type hints 的利弊分析，本書的第 100 頁，有相對完整的論述。</p><p>利的部分上面已經說了，這裡我們主要關注導入 type hints 的「<strong>缺點</strong>」。</p><p>在此直接引用書中所舉的內容（我加上<strong>粗體</strong>作為<strong>重點標示</strong>），講述專案導入 type hints 的<strong>阻力與成本</strong>，包括：</p><blockquote><ul><li><strong>需要獲得支持</strong>。根據文化的不同，可能需要一些時間來<strong>說服</strong>一個組纖採用型別檢查。</li><li>一旦你獲得支持，就會有一個<strong>最初的採用成本</strong>。開發人員不會在一夜之間就能開始對他們的程式碼進行型別注釋，他們<strong>需要時間來掌握</strong>。他們<strong>需要學習和實驗</strong>，然後才能實際動手。</li><li>採用工具需要時間和努力。你需要某種形式的<strong>中央化檢查</strong>，而開發者<strong>需要熟悉工具作為他們工作流程一部分的執行。</strong></li><li>在你的專案中編寫型別注釋<strong>需要時間。</strong></li><li>隨著型別注釋開始受到檢查，開發人員將不得不習慣於<strong>與型別檢查器對抗所帶來的速度減慢</strong>。思考型別帶來了<strong>額外的認知負載。</strong></li></ul></blockquote><p>不愧是專門討論 Python type hints 的書，我只能說，每一條都非常真實！這也是為何我們在今年才成功導入，去年可以說還沒有準備好——但也不是毫無收獲。</p><p>如作者所言：</p><blockquote><p>這個問題從根本上說，就是一種雞和蛋的難題：你在專案中寫下<strong>足夠多</strong>的型別注釋之前，你<strong>不會看到</strong>注釋型別的好處。然而，在<strong>早期沒有效益</strong>的情況下，要讓人接受去撰寫型別是<strong>很困難的</strong>。</p></blockquote><p>綜上所述，為專案加上 type hints 看起來困難重重，難道我們要就此放棄嗎？</p><p>當然不。否則作者不需要寫這本書，而我也不需要寫這篇文章。</p><p>與之相反，我們不妨更早開始學習 type hints ，早點達到並跨過書中所謂的「投入與收益的平衡點」。</p><hr><h2 id="更早「收支平衡」"><a href="#更早「收支平衡」" class="headerlink" title="更早「收支平衡」"></a>更早「收支平衡」</h2><blockquote><p>為了使型別注釋的效益最大化，你需要更早取得價值或更早降低成本。這兩條曲線的交點是一個收支平衡點（break-even point），這就是你所付出的努力因為你所得到的價值而有報償的地方。</p></blockquote><p>Type hints 的投入與報酬關係，書中用了一張圖來說明，我重繪如下：</p><p><img src="https://i.imgur.com/y7RL42J.png"></p><p>作者解釋道：</p><blockquote><p>你的成本<strong>一開始會很高</strong>，但隨著採用率的提高會變得更和緩。你的效益一開始會很低，但隨著你注釋 codebase，你會看到更多的價值。<strong>在這兩條曲線相遇之前，你不會看到投資的回報。為了使價值最大化，你需要儘早達到這個交叉點。</strong></p></blockquote><p>講白了就是，寫愈多，阻力就會愈低。這雖然像是「廢話」，但也給了我們希望！</p><p>對於這張圖，我的看法是：type hints 的收益<strong>絕對是累積出來的</strong>，但成本的下降<strong>也許沒這麼快</strong>。</p><p>畢竟每次寫 type hints，多少都需要思考（所幸我們有 GitHub Copilot 🥰），它不會是完全機械性的反射動作。</p><hr><p>文末我會提出自己對於「降低導入 type hints 阻力」的看法。我們先來看書中的建議。</p><h2 id="書中的一些建議"><a href="#書中的一些建議" class="headerlink" title="書中的一些建議"></a>書中的一些建議</h2><blockquote><p>你想在能維持前進動力的情況下，儘快達到這個點，以讓你的型別注釋帶來正面的影響。這裡有一些策略可以做到這一點。</p></blockquote><p>作者給出的大方向，就是先為「<strong>部分</strong>」——而非全部——程式碼加上 type hints。讓你可以早點感受到 type hints 帶來的好處。</p><p>那要「<strong>怎麼選擇</strong>」哪些程式碼應該優先加上 type hints？他的看法大概有下：</p><ul><li>只為<strong>新程式碼</strong>進行型別注釋（這裡的新程式碼包括了<strong>對舊程式碼的修改</strong>）</li><li>型別注釋「為你賺錢」的程式碼</li><li>型別注釋「經常變化」的程式碼</li><li>型別注釋「複雜」的程式碼</li></ul><p>以上這幾點取自書中的小標題，但我想說的是——這些看法雖然有道理，但其實<strong>大部分都很難操作！</strong></p><p>什麼叫賺錢的程式碼？怎麼樣才算複雜？書中並非沒有解釋，但這些都需要<strong>人為定義</strong>，而且有「<strong>標準浮動</strong>」之嫌，難以一體適用。</p><h3 id="為新程式碼加上-type-hints"><a href="#為新程式碼加上-type-hints" class="headerlink" title="為新程式碼加上 type hints"></a>為新程式碼加上 type hints</h3><p>「為新程式碼加上 type hints 」部分，是我唯一認為<strong>值得參考且可行</strong>的！</p><blockquote><p>考慮讓你當前未注釋的程式碼保持原樣，並<strong>根據這兩條規則</strong>來注釋程式碼：</p><ul><li>為你所寫的<strong>任何新程式碼</strong>進行注釋。</li><li>注釋你<strong>變更</strong>的任何<strong>舊程式碼</strong>。</li></ul></blockquote><p>對於已經完成的舊專案，我們就是採用這個策略！</p><p>意即修改舊函式的其中幾行、或寫一個全新的函式時，該函式就必須有完整的 type hints——我會在 code review 時進行檢查。</p><p>這樣的好處是<strong>標準清晰、判斷簡單，而且不用一次到位。</strong></p><p>當然，想要透過慢慢更新，最終讓整個專案都可以通過 Mypy 檢查，還是不太現實的。這算是一種「對舊的、暫時無力全面適用 type hints 專案的<strong>折衷</strong>」。</p><h2 id="並非所有程式碼都要加上-type-hints"><a href="#並非所有程式碼都要加上-type-hints" class="headerlink" title="並非所有程式碼都要加上 type hints"></a>並非所有程式碼都要加上 type hints</h2><p>有件事必須<strong>釐清與強調</strong>，以免造成誤解。</p><p>所謂「<strong>完整</strong>」的 type hints，並不是把專案程式碼中的每一個地方都加上 type hints。</p><p>為<strong>變數</strong>加上 type hints 往往<strong>過於囉嗦而且實益不大</strong>（書中 39 頁也有提及），我們只會偶爾為之——因為大部分情況直譯器、IDE、type checker 都能夠<strong>自行推測</strong>了！</p><blockquote><p>那到底怎麼樣才算「<strong>完整</strong>」？</p></blockquote><p>一般而言，為所有的<strong>函式</strong>、類別中的<strong>方法</strong>加上 type hints，就已經很不錯。</p><p>不過，Mypy 畢竟提供了一個<strong>標準</strong>。讓你不必自己去判斷。只要使用 Mypy 的基本設定<strong>檢查整個專案</strong>而且不報錯，我認為就算完整了。</p><p>當然你可以排除檢查一些檔案，比如 Django 中的「資料庫遷移檔」。</p><hr><h2 id="我的經驗與看法"><a href="#我的經驗與看法" class="headerlink" title="我的經驗與看法"></a>我的經驗與看法</h2><p>去年想為 DRF 專案加入完整的 type hints（也就是要<strong>可以通過 Mypy 檢查</strong>的程度），最後放棄了。</p><p>主要有兩個原因：</p><ol><li>DRF 本身並不要求型別，而且專案誕生的早，也沒有完整的型別支援。不過現在有 stubs 套件（專門標示 type hints 的套件，比如 <a href="https://github.com/typeddjango/djangorestframework-stubs">djangorestframework-stubs</a>），這應該不至於成為關鍵難點。</li><li>這個才是我覺得<strong>最難的</strong>，那就是<strong>「不易說服」成員寫 type hints</strong>。儘管 type hints 肯定有好處，但我沒有信心，這好處會<strong>明顯超過</strong>投入的心力——尤其在一開始的時候。</li></ol><p>顯然我不太可能只是給同事看上面那張圖，就能輕易說服大家要開始寫 type hints 🐸</p><p>所以最後我還是放棄「完整」type hints 的企圖，只是要求大家要開始「試著」寫 type hints。（事實證明，這樣也不錯，至少大家開始有了 type hints 的概念）</p><h2 id="Django-Ninja-與-Pydantic"><a href="#Django-Ninja-與-Pydantic" class="headerlink" title="Django Ninja 與 Pydantic"></a>Django Ninja 與 Pydantic</h2><p>那怎樣才能讓我在「<strong>事前</strong>」就有足夠信心說服大家呢？</p><p>就是採用像 FastAPI、Django Ninja 這類，透過 Pydantic 來產生 API 文件的框架！</p><p>撰寫高品質的 API 文件是後端開發的一大痛點，DRF 雖然也有 <a href="https://github.com/axnsan12/drf-yasg">drf-yasg</a> 這樣，可以依程式碼產生文件的套件。但說真的，和 Pydantic 這種透過<strong>採用 type hints 產生 API 文件</strong>的工具相比，依舊有所不及。</p><p>今年的新專案開始用了 Django Ninja，因此情況大不相同——即<strong>時機成熟</strong>了。</p><h3 id="Type-hints-輔助輪"><a href="#Type-hints-輔助輪" class="headerlink" title="Type hints 輔助輪"></a>Type hints 輔助輪</h3><p>寫 Django Ninja（或 FastAPI），你本來就要書寫大量 type hints，來產生正確、合理的 API 文件。那要求為專案的其餘部分，比如自定義的函式、類別加上 type hints，阻力相對就小得多。</p><p>這主要差別在於，大家能因為 API 文件的自動渲染，<strong>直接感受到 type hints 的價值！</strong></p><p>其實不止如此，剛學習 Django Ninja 時，我還發出過<a href="https://twitter.com/kyomind/status/1748007109646786873">這樣的讚嘆</a>：</p><blockquote><p>竟然可以充分運用 Python type hints 到這般程度，讓它不僅僅是為了型別安全而服務，而是融入到整個 api 流程中</p></blockquote><p>在我看來，這類採用了 Pydantic 框架所帶來的效應，就像腳踏車的輔助輪，在剛起步使用 type hints 時，<strong>有著明顯的正面引導效果。</strong></p><hr><h2 id="小結與整理"><a href="#小結與整理" class="headerlink" title="小結與整理"></a>小結與整理</h2><p>然而，我並不是說，只有寫 FastAPI 或 Django Ninja 才能成功落實 type hints，只不過<strong>它們遇到的阻力會相對小</strong>。</p><p>如果能夠先有這類專案作為「甜頭」，那要在其餘專案落實可能會容易得多。因為要讓成員「相信」寫 type hints 有價值，確實不容易。</p><p>經過一段時間，目前我與我的同事們，都對 type hints 抱持著正面態度，因為很多錯誤可以在<strong>非常早的階段（也就是開發的當下）</strong>就被發現。（比如 Django ORM 物件的屬性根本寫錯了！）</p><p>省去了後續來回修正的時間浪費。</p><h3 id="個人看法"><a href="#個人看法" class="headerlink" title="個人看法"></a>個人看法</h3><p>最後，我再整理一下「<strong>降低導入 type hints 阻力</strong>」的一些個人看法：</p><ol><li>建議從<strong>全新的專案</strong>開始，因為要將舊專案改為「type hints 版本」會困難得多。</li><li>建議從 FastAPI、Django Ninja，或其它採用了 Pydantic 的專案開始，成員會<strong>更有動力</strong>。</li><li>雖然 type hints 對大專案有更顯著的效益，但建議<strong>從小型專案開始著手</strong>，以降低成員們<strong>練習、適應與接納</strong>的阻力。</li></ol><p>綜上所述，你可以看出，要落實 type hints，<strong>其實沒有多少「捷徑」可走。</strong></p><p>這也是為何我們需要<strong>了解其中的困難</strong>，才更可能<strong>適度地堅持</strong>，直到獲得 type hints 帶來的<strong>長期優勢</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nqKDYbc.png&quot; alt=&quot;強健的 Python&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263241015&quot;&gt;強健的 Python｜撰寫潔淨且可維護的程式碼&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;本書翻譯自《&lt;a href=&quot;https://www.amazon.com/-/zh_TW/Patrick-Viafore/dp/1098100662&quot;&gt;Robust Python: Write Clean and Maintainable Code&lt;/a&gt;》，原文的副標題容易讓人&lt;strong&gt;誤以為&lt;/strong&gt;這又是另一本關於「Clean Code in Python」的書。&lt;/p&gt;
&lt;p&gt;實際上，本書所聚焦的，是 Python 的一大特性——&lt;a href=&quot;https://docs.python.org/3/library/typing.html&quot;&gt;type hints&lt;/a&gt;。全書大半篇幅都圍繞著這個核心主軸。&lt;/p&gt;
&lt;p&gt;所以它並非教你「如何寫出 Pythonic 程式碼」的書，而是介紹 type hints 寫法與使用相關工具（比如 Mypy）以確保 type hints 有效落實的作品。&lt;/p&gt;
&lt;p&gt;如果你還不熟悉 Python type hints，本文也可以作為認識 type hints 的起點。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/nqKDYbc.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Type Hints" scheme="https://blog.kyomind.tw/tags/Type-Hints/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
</feed>
