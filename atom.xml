<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-03-01T16:35:51.881Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Python 工匠》筆記（一）如何寫好註解</title>
    <link href="https://blog.kyomind.tw/python-craftsman-01/"/>
    <id>https://blog.kyomind.tw/python-craftsman-01/</id>
    <published>2024-02-28T04:40:57.000Z</published>
    <updated>2024-03-01T16:35:51.881Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/beoEztr.png" alt="Python 工匠"><span class="cap">Python 工匠</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠｜案例、技巧與開發實戰</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>從書名推敲，我們並不容易知道本書的主題為何。事實上，和《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣</a>》類似，這是一本關於「<strong>Clean Code in Python</strong>」的書。</p><p>而且我認為它的<strong>難度適中</strong>（好吧，後半部難度比較高，而且本書<strong>「不適合」</strong>初學者），非常推薦看完《Python 功力提升的樂趣》後，想要更進一步寫出 Pythonic 程式碼的讀者與開發人員。</p><p>我覺得，兩本恰恰都是屬於「從書名看很容易被忽略」的好書。因此，作為喜歡本書的讀者，我覺得自己有<strong>義務</strong>，向你們轉述書中一些值得傳誦的內容。</p><p>這也是「<a href="/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/">閱讀筆記</a>」系列的核心精神。</p><span id="more"></span><hr><h2 id="如何寫好-Python-註解"><a href="#如何寫好-Python-註解" class="headerlink" title="如何寫好 Python 註解"></a>如何寫好 Python 註解</h2><p>本文整理第一章的其中一部分——關於「如何寫好註解」的討論。</p><p>之所以要特別寫成筆記，是因為這是我目前看過的書中，討論註解時講最得好的一本。尤其是一些使用上的建議，和我的開發經驗與價值觀可謂非常吻合！</p><p>其實我一直也想整理一篇關於寫好註解的基本守則，但遲遲沒有行動。但現在有這本書，我只要整理書中的內容，並加上自己的看法即可。</p><p>有關 Python 註解或 docstring 的討論，我在過去多篇文章中都有提到，可參考如下：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/#%E4%B8%80%E3%80%81Docstring-%E7%9C%9F%E7%9A%84%E5%BE%88%E9%87%8D%E8%A6%81">Docstring 真的很重要</a></li><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E8%A8%BB%E8%A7%A3%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%EF%BC%9F">註解是不需要的？</a></li><li><a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a></li></ul><p>開始正文。</p><hr><h2 id="Python-註解基礎知識"><a href="#Python-註解基礎知識" class="headerlink" title="Python 註解基礎知識"></a>Python 註解基礎知識</h2><p>Python 中，一般我們講到註解，指的是程式碼中的註解，用<code>#</code>來實現。</p><p>而 <a href="https://en.wikipedia.org/wiki/Docstring">docstring</a> 則是另一種更具有 Python 特色的註解。主要寫在模組、類別、與函式的開頭，並透過物件的<code>__doc__</code>屬性，自然地化為程式碼的一部分。</p><p>書中提到了 docstring 的幾種常見風格（畢竟它本質只是一堆字串，所以怎麼寫都行），最常見的為 Sphinx 文件風格。而我個人在工作上最常用的，則是 <a href="https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html">Google 風格</a>。</p><p>簡言之，下面提到「註解」二字時，對上述兩種 Python 註解都適用。</p><h2 id="新手常犯的三種註解錯誤"><a href="#新手常犯的三種註解錯誤" class="headerlink" title="新手常犯的三種註解錯誤"></a>新手常犯的三種註解錯誤</h2><p>你可能聽過「很多註解都是爛註解」這種說法。不得不承認，這相當程度是對的！我確實看過很多爛註解——但這不是我們因此不寫註解的理由。</p><p>實務上會有很多爛註解，正是因為我們沒有正視註解的價值，認真學習如何寫好註解。</p><p>因此，<strong>就讓我們用書中所舉三種常見的註解錯誤，作為學習的切入點。</strong></p><p>書中提到的這三點——尤其是第 3 點，應盡可能避免。作者也提出了相應的解決之道，而我會適時補充我的看法。</p><p>附帶一提，本書是從作者過去的網路文章整理、出版——但內容增加了很多。而且作者也很大方，在網路上公開了部分的內容。而本文整理的部分恰恰是公開的部分。有興趣的話可以直接參考<a href="https://www.piglei.com/book/ch01_variables.html">本頁</a>。</p><p>當然，我還是強烈建議，為自己入手一本，你絕對不會後悔。</p><hr><h2 id="一、直接註解程式碼"><a href="#一、直接註解程式碼" class="headerlink" title="一、直接註解程式碼"></a>一、直接註解程式碼</h2><p>把已經寫完但暫不需要（以後是否需要還不確定）的程式碼，先註解起來，方便日後需要時可以快速「還原」，絕對是我們非常熟悉的手段。</p><p>我回想一下，不得不說，這類被註解的程式碼，<strong>十之八九都是不會再用到了！</strong>如果這類「程式碼註解」愈積愈多，真的會讓人看了很「阿雜」！</p><p>所以基本上，現在比較正規的做法，都是建議你直接刪除，以後真的需要時，再透過版控回復即可。</p><p>對此我基本認同，所以工作上 code review 時，我「不會」放行這種直接註解的程式碼。</p><h3 id="僅有的例外"><a href="#僅有的例外" class="headerlink" title="僅有的例外"></a>僅有的例外</h3><p>但，你我都知道，有時事情也沒那麼簡單。</p><p>用 Git 版控回復的前提是：你的團隊 commit 記錄要寫好！不然真的要「回復」的時候，你可能連它在哪一個 commit 都要找好一陣子。</p><p>所以，基於方便與實際考量，事實上我還是有<strong>一點點折衷</strong>：原則上不可以註解程式碼，但如果確定只是「<strong>暫時</strong>」用不到，等別的元件完成後，就會繼續開發、使用，例外可以暫時註解就好——但必須加上 <a href="https://peps.python.org/pep-0350/">codetag</a> 標記。</p><p>一般我們用 <code>TODO</code> 這個 codetag。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO 日後改回一對一時，請用下面方式重寫：</span></span><br><span class="line"><span class="comment"># user = User.objects.select_related(&#x27;oversee_tenant&#x27;)</span></span><br><span class="line"><span class="comment"># .prefetch_related(&#x27;oversee_projects&#x27;).get(user_uuid=user_uuid)</span></span><br></pre></td></tr></table></figure><p>不過<strong>大原則</strong>還是：</p><blockquote><p><strong>別註解了，刪除吧！</strong></p></blockquote><hr><h2 id="二、僅用註解「重述」程式碼行為"><a href="#二、僅用註解「重述」程式碼行為" class="headerlink" title="二、僅用註解「重述」程式碼行為"></a>二、僅用註解「重述」程式碼行為</h2><p>這應該是我們最常看到的爛註解的形式，也是你在所有討論程式碼註解的書中，一定會提及的。</p><p>而且它真的爛，沒有藉口。比如這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 x 為 0</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 x 是否小於 10</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="comment"># 印出 x 小於 10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is less than 10&quot;</span>)</span><br></pre></td></tr></table></figure><p>這當然是一個誇張的例子🤣。但在日常開發中，這種「脫褲子放屁」的註解還真的不算少見。</p><p>確實，如果我常常看到這樣的註解，恐怕真的會忍不住說出「你還別寫註解了吧！」</p><p>但，請不要放棄治療！</p><p>想避免這個問題，請遵守一個簡單且常見的大原則，如書中所言：</p><blockquote><p>應該儘量提供那些讀者<strong>無法</strong>從程式碼裡讀出來的資訊。描述程式<strong>為什麼</strong>要這麼做，而不是簡單複述程式碼本身。</p></blockquote><p>不過，光寫「為什麼」註解，有時候還是遠遠不夠的。</p><h2 id="指引型註解"><a href="#指引型註解" class="headerlink" title="指引型註解"></a>指引型註解</h2><p>因此，本書更進一步提出所謂的「<strong>指引性註解</strong>」：</p><blockquote><p>這種註解並不「直接」複述程式，而是簡明扼地概括程式碼功能，起到「<strong>程式碼導讀</strong>」的效果。</p></blockquote><p>書中的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化存取服務的 client 物件</span></span><br><span class="line">token = token_service.get_token()</span><br><span class="line">service_client = ServiceClient(token=token)</span><br><span class="line">service_client.ready()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 呼叫服務取得資料，然後進行過濾</span></span><br><span class="line">data = service_client.fetch_full_data()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> item.value &gt; SOME_VALUE:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>不難看出，這種描述「程式碼流程大綱」的指引型註解，<strong>很像 docstring 在做的事</strong>。從這個角度，我們可以說 docstring <strong>也是</strong>一種指引型註解。</p><p>但是，docstring 畢竟只出現在元件的「<strong>開頭</strong>」，對複雜的程式而言，在元件的內部，往往也需要這樣的註解，作為閱讀<strong>複雜程式碼</strong>的指引。</p><p>要寫好指引型註解，甚至知曉「什麼時候」應該要寫下指引型註解，需要你內心清楚——「這段程式碼的哪些部分，別人可能會看不懂！」</p><p>這是為什麼我總說，要寫好註解，就一定要培養好「<strong>讀者意識</strong>」的理由。</p><h3 id="指引型註解的價值"><a href="#指引型註解的價值" class="headerlink" title="指引型註解的價值"></a>指引型註解的價值</h3><p>前面提到，寫註解時「應該儘量提供那些讀者<strong>無法從程式碼裡讀出來</strong>的資訊」，這是我們寫註解的大原則。</p><p>但指引性註解和上述註解<strong>所有區別</strong>，它的<strong>獨特價值</strong>，如書中所言：</p><blockquote><p>指引性註解<strong>並不提供</strong>程式碼裡<strong>讀不到</strong>的東西——如果沒有註解，耐心讀完所有程式碼，你也能知道程式做了什麼事。指引性註解的主要作用是<strong>降低程式碼的認知成本</strong>，讓我們能<strong>更容易理解</strong>程式碼的<strong>意圖</strong>。</p></blockquote><p>說得非常好。</p><h2 id="提煉為獨立函式"><a href="#提煉為獨立函式" class="headerlink" title="提煉為獨立函式"></a>提煉為獨立函式</h2><p>對於複雜而冗長的程式流程，書寫「指引性註解」是一個協助閱讀理解的好方法。</p><p>而另一個有效的方法，就是把這些程式碼片段<strong>獨立成一個又一個的函式</strong>，透過<strong>有意義的函式名稱</strong>來描述流程、展現意圖，此時就可以刪除指引性註解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service_client = make_client()</span><br><span class="line">data = fetch_and_filter(service_client)</span><br></pre></td></tr></table></figure><p>其中的重點在於，你要能判斷，什麼時候該寫「指引性註解」，而什麼時候則適合獨立成函式、方法。</p><p>這當然需要經驗累積，但我們心中要先有這樣的意識，不是嗎？</p><hr><h2 id="三、弄錯註解的「受眾」"><a href="#三、弄錯註解的「受眾」" class="headerlink" title="三、弄錯註解的「受眾」"></a>三、弄錯註解的「受眾」</h2><p>本書這段主要適用的是 docstring，不過我覺得「指引型註解」也有類似議題，所以本段提到「註解」一詞時，皆包括這兩者。</p><p>註解的正確<strong>受眾</strong>，或說<strong>讀者</strong>，應該是誰？我想基本上是這兩種人：</p><ol><li><strong>未來</strong>的自己（注意「未來」二字）</li><li>專案<strong>協作者</strong>（同事、主管）</li></ol><p>我們先看看書中所舉的「反例」：（我直接引用<a href="https://www.piglei.com/book/ch01_variables.html">網頁</a>上的內容，所以技術名詞並非台灣用語，還請見諒）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resize_image</span>(<span class="params">image, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;將圖片縮放為指定尺寸，並返回新的圖片。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    該函數將使用 Pilot 模塊讀取文件對象，然後調用 .resize() 方法將其縮放為指定尺寸。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    但由於 Pilot 模塊自身限制，這個函數不能很好的處理尺寸過大的文件，當文件大小</span></span><br><span class="line"><span class="string">    超過 5MB 時，resize() 方法的性能就會因為內存分配問題急劇下降，詳見 Pilot 模塊的</span></span><br><span class="line"><span class="string">    Issue #007。因此，對於超過 5MB 的圖片文件，請使用 resize_big_image() 替代，後者</span></span><br><span class="line"><span class="string">    基於 Pillow 模塊開發，很好的解決了內存分配問題，性能更好。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param image: 圖片文件對象</span></span><br><span class="line"><span class="string">    :param size: 包含寬高的元組：（width, height）</span></span><br><span class="line"><span class="string">    :return: 新圖片對象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>這個例子的最大問題，是寫了太多「實作細節」，講白了就是提供了「太多」程式碼的讀者<strong>並不關心</strong>的內容！</p><blockquote><p>為什麼這樣是不妥的？細節不是很好嗎？</p></blockquote><p>對，但大部分時候，docstring 或「指引型註解」的主要寫作<strong>目的</strong>，是為了讓讀者<strong>不用一行一行閱讀程式碼</strong>，就能夠快速知道目前程式碼的<strong>流程與意圖</strong>。</p><p>這種過多細節的寫法，恰恰與這個目標<strong>背道而馳</strong>——增加了太多理解上的「<strong>雜訊</strong>」。</p><p>書中給出的改善版本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resize_image</span>(<span class="params">image, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;將圖片縮放為指定尺寸，並返回新的圖片。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意：當文件超過 5MB 時，請使用 resize_big_image()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param image: 圖片文件對象</span></span><br><span class="line"><span class="string">    :param size: 包含寬高的元組：（width, height）</span></span><br><span class="line"><span class="string">    :return: 新圖片對象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="自言自語的註解"><a href="#自言自語的註解" class="headerlink" title="自言自語的註解"></a>自言自語的註解</h2><p>你有沒有一個疑問，為什麼說註解寫了太多細節，是「弄錯受眾」？</p><p>我是這樣看的：留下這麼多細節的註解，與其說是註解，更像寫給自己看的<strong>筆記</strong>——而且是給「現在」的自己，真的就像在作筆記一樣！</p><p>我想強調，<strong>「現在的自己」並不是註解的受眾！</strong>因為現在的自己對程式細節非常清楚，即使沒有註解也能讀懂程式碼。</p><p>相反的，註解是為<strong>沒時間慢慢讀程式碼</strong>的人服務的。</p><p>未來的你，再回來看這段程式，絕對不會想要在 docstring 看到這麼多「<strong>廢話</strong>」。這種寫法無疑是搞錯了對象。</p><p>當然，你的同事也不會想看這麼多雜訊——同事往往更關心「這函式到底要怎麼用」！</p><h2 id="抽象層次混亂"><a href="#抽象層次混亂" class="headerlink" title="抽象層次混亂"></a>抽象層次混亂</h2><p>我覺得還有另一種「弄錯受眾」的註解也很經典，甚至更加常見！那就是混合底層實作與業務邏輯：</p><blockquote><p>註解中參雜了業務邏輯，又不時會出現底層實作的細節描述。</p></blockquote><p>事實上，我倒覺得實務中會願意寫一大串 docstring 的人，可以說是少之又少。大部分的問題其實是：有寫，但寫得「<strong>零零落落</strong>」。</p><h2 id="Docstring-與讀者意識"><a href="#Docstring-與讀者意識" class="headerlink" title="Docstring 與讀者意識"></a>Docstring 與讀者意識</h2><p>Docstring 絕對能看出一個人的<strong>基本寫作能力</strong>，以及是否具備「<strong>讀者意識</strong>」。</p><p>說真的，這不止是作為一個軟體工程師的核心技能——更是任何<strong>表達者</strong>的核心技能。而程式，只是表達的其中一種形式。</p><p>我很想要寫一篇「如何寫好 docstring」，這需要再構思一番。但常見的錯誤不外乎：</p><ol><li><strong>預知能力</strong>：知曉「函式以外」的事、不僅知道函式會怎麼、何時被調用，還會在 docstring 中寫下呼叫時的情境細節——<strong>你知道的太多了！</strong></li><li><strong>太多底層細節</strong>：跟前面的書中內容相似，只是我覺得現實中，往往是<strong>東寫一點、西寫一點</strong>，不會像寫筆記一般完整——所以讀起來更痛苦，真的是自言自語！除了開發者自己，誰能輕易讀懂那些細節？</li><li><strong>業務邏輯與底層實作的用詞混雜</strong>：一下子是「無法取得租戶資訊」一下子卻又是「防止 SQL insert 錯誤、RabbitMQ 如何如何」——讓人大腦很混亂。</li></ol><p>總的來說，無論是「自言自語」還是「抽象層次混亂」，它們的本質都差不多——這些註解都像是寫給「<strong>現在的自己</strong>」看的<strong>筆記</strong>。</p><p>但就像前面說的，現在的自己是<strong>最不需要看註解的人</strong>！所以才說是「弄錯受眾」了。</p><hr><h3 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h3><ul><li><a href="https://www.explainthis.io/zh-hant/swe/a-philosophy-of-software-design/part3">《A Philosophy of Software Design》心得 3 — 寫程式時該寫註解 (comments) 嗎？如果要的話該怎麼寫？</a></li><li><a href="https://www.facebook.com/darkthread.net/photos/a.345323768929153/1185728258222029/">【程序員的日常】程式註解該寫多細？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/beoEztr.png&quot; alt=&quot;Python 工匠&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263245174&quot;&gt;Python 工匠｜案例、技巧與開發實戰&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;從書名推敲，我們並不容易知道本書的主題為何。事實上，和《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣&lt;/a&gt;》類似，這是一本關於「&lt;strong&gt;Clean Code in Python&lt;/strong&gt;」的書。&lt;/p&gt;
&lt;p&gt;而且我認為它的&lt;strong&gt;難度適中&lt;/strong&gt;（好吧，後半部難度比較高，而且本書&lt;strong&gt;「不適合」&lt;/strong&gt;初學者），非常推薦看完《Python 功力提升的樂趣》後，想要更進一步寫出 Pythonic 程式碼的讀者與開發人員。&lt;/p&gt;
&lt;p&gt;我覺得，兩本恰恰都是屬於「從書名看很容易被忽略」的好書。因此，作為喜歡本書的讀者，我覺得自己有&lt;strong&gt;義務&lt;/strong&gt;，向你們轉述書中一些值得傳誦的內容。&lt;/p&gt;
&lt;p&gt;這也是「&lt;a href=&quot;/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/&quot;&gt;閱讀筆記&lt;/a&gt;」系列的核心精神。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/beoEztr.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="閱讀筆記" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>為什麼你「不需要」所謂的人生管理系統</title>
    <link href="https://blog.kyomind.tw/less-is-more/"/>
    <id>https://blog.kyomind.tw/less-is-more/</id>
    <published>2024-01-21T20:33:14.000Z</published>
    <updated>2024-01-31T13:40:50.826Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/PwPTWYK.jpg" alt="by Myriam Wares"><span class="cap">by Myriam Wares</span></p><p>在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉一文與其所屬的「<a href="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion/">Simple Notion 系列</a>」中，我已用不少幅篇，明確表達我對這類「<strong>大而全</strong>」生產力系統的<strong>隱憂</strong>與<strong>質疑</strong>。</p><p>在其它文章中，也有過類似討論：</p><ul><li><a href="https://blog.kyomind.tw/four-thousand-weeks-01/">《人生 4 千個禮拜》筆記（一）病態的生產力</a></li><li><a href="https://blog.kyomind.tw/weekly-review-11/">11，我絕不當資訊的聚合者</a></li></ul><p>本文將進行一次「<strong>總結式</strong>」的整理，重新闡述<strong>不用這類系統的三大理由</strong>。並提出我認為相對可行的<strong>替代方案：局部實現</strong>。</p><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85">本文主旨與目標讀者</a></li><li><a href="#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D">所謂的「人生管理系統」</a></li><li><a href="#%E5%A4%A7%E7%B3%BB%E7%B5%B1%E7%9A%84%E5%85%A9%E5%80%8B%E7%89%B9%E5%BE%B5">大系統的兩個特徵</a></li><li><a href="#%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E8%A6%81%E9%80%99%E9%BA%BC%E7%94%A8">為什麼不要這麼用</a></li><li><a href="#3-%E5%80%8B%E3%80%8C%E4%B8%8D%E3%80%8D%E7%9A%84%E7%90%86%E7%94%B1">3 個「不」的理由</a></li><li><a href="#%E4%B8%80%E3%80%81%E6%88%90%E6%9C%AC%E9%81%8E%E9%AB%98%EF%BC%9A%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8%E7%9A%84%E4%BB%A3%E5%83%B9">一、成本過高：神兵利器的代價</a></li><li><a href="#%E4%BA%8C%E3%80%81%E9%81%A9%E5%BE%97%E5%85%B6%E5%8F%8D%EF%BC%9A%E5%81%9A%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%91%A3%E4%BA%8B">二、適得其反：做了更多瑣事</a></li><li><a href="#%E4%B8%89%E3%80%81%E7%B3%BB%E7%B5%B1%E6%9C%83%E8%A7%B8%E7%99%BC%E4%BD%A0%E3%80%8C%E8%BF%BD%E6%B1%82%E5%AE%8C%E6%95%B4%E3%80%8D%E7%9A%84%E6%9C%AC%E8%83%BD">三、系統會觸發你「追求完整」的本能</a></li><li><a href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%82%96%E8%AB%96">完整的悖論</a></li><li><a href="#%E8%88%89%E4%BE%8B%EF%BC%9ANotion-%E9%96%B1%E8%AE%80%E7%AE%A1%E7%90%86">舉例：Notion 閱讀管理</a></li><li><a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D">不必要的欄位</a></li><li><a href="#%E5%86%8D%E8%AB%96%E7%94%9F%E7%94%A2%E5%8A%9B%E9%81%94%E4%BA%BA">再論生產力達人</a></li><li><a href="#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE">更適合一般人的做法：局部實現</a></li><li><a href="#%E7%94%A8%E3%80%8C%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE%E3%80%8D%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1">用「局部實現」取代人生管理系統</a></li><li><a href="#%E7%B5%90%E8%AA%9E%EF%BC%9A%E6%8E%A5%E5%8F%97%E6%AE%98%E7%BC%BA%E8%88%87%E9%81%BA%E6%86%BE">結語：接受殘缺與遺憾</a></li></ol><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文想表達一個<strong>核心看法</strong>：打造大而全的<strong>人生管理系統</strong>，期望它全面提升你的生產力，<strong>可能不是一個好主意。</strong></p><p>我知道，在這個資訊爆炸、快速變遷的時代，<strong>追求生產力</strong>幾乎可說是一種「<strong>顯學</strong>」。</p><p>這類系統也許為「<strong>少部分人</strong>」帶來了可觀的成就、自我掌控感，甚至是<strong>安全感</strong>。</p><p>因此他們能夠<strong>信誓旦旦</strong>地告訴你：「相信我！這是一個超棒的方法，而且你也能夠！」</p><p>老實說，連我自己都很難完全抗拒「高效、生產力」這類的主題，我想這是所有懷抱著自我期許之人的本能吧！</p><p>所以我並不打算阻止你去追求、建立屬於自己的<strong>生產力方法論</strong>。本文想要<strong>提醒</strong>的是——這些方法<strong>最好不要</strong>是「大而全」的那種，而是要能夠做到「<strong>取捨</strong>」。</p><p>不過，人生之難，就難在取捨。</p><span id="more"></span><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文目標讀者有二：</p><ol><li>像我一樣，已經一定程度地追逐過所謂「生產力工作流」的人，卻因此<a href="https://blog.kyomind.tw/simple-notion/#%E3%80%8C%E8%B3%A6%E8%83%BD%E5%BC%8F%E6%8C%AB%E6%95%97%E3%80%8D">感到失望或懷疑</a>，覺得<strong>並沒有從中獲得真正的提升</strong>。</li><li><strong>想提高生產力，還在這條路上摸索，尋找自己適合工具、方法的人。</strong></li></ol><p>對於這兩類讀者，我希望通過<strong>我的經驗和觀察</strong>，提供一個<strong>不同於「<a href="https://www.google.com/search?q=%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1">主流</a>」的視角</strong>。</p><p>一言以蔽之，我相信對大部分人而言，真正有效的提升並不在於建立一個龐大而複雜的系統。<strong>反而一些簡單的做法，往往更有效。</strong></p><hr><h2 id="所謂的「人生管理系統」"><a href="#所謂的「人生管理系統」" class="headerlink" title="所謂的「人生管理系統」"></a>所謂的「人生管理系統」</h2><p>文章一開始，我們需要對本文中提到的這類「<strong>系統</strong>」——或者應該稱為「<strong>提高生產力的方法論</strong>」，做出基本的定義。</p><p>從上古時期的 <a href="https://en.wikipedia.org/wiki/Getting_Things_Done">GTD</a>、到現在的 <a href="https://fortelabs.com/blog/para/">PARA</a>，以至於你在網路上、YouTube 影片中，所看到任何關於建立一套「<strong>流程</strong>」來<strong>組織與管理</strong>你的<strong>生產力活動</strong>（比如工作、學習、寫作），都算。</p><p>這些系統、方法論，往往都不打算只解決你一、兩個小問題，而是雄心壯志地宣稱<strong>可以改變你的人生</strong>。</p><p>藉由<strong>全方位自我管理</strong>，帶給你不同於以往的<strong>全新做事思維</strong>，讓你從<strong>混亂、瞎忙、事情做不完</strong>的焦頭爛額中<strong>解脫</strong>出來。</p><p>從此過上「<strong>高效、優雅、有目標</strong>」的充實生活。</p><p>聽起來對我們的人生真的很有幫助呢！☺️</p><p>所以我們姑且稱它為「人生管理系統」。</p><p>在這個強調終身學習的時代，這類系統也很常以「<strong>個人知識管理系統</strong>」的形式活躍，從 GTD（把事情做完）到 PARA（整理知識、有效學習），能看出時代的變遷。</p><hr><h2 id="大系統的兩個特徵"><a href="#大系統的兩個特徵" class="headerlink" title="大系統的兩個特徵"></a>大系統的兩個特徵</h2><p>這些方法論，往往具備<strong>兩個特徵</strong>，這也是它們可以自稱為「系統」的主要原因。</p><h3 id="一、複雜"><a href="#一、複雜" class="headerlink" title="一、複雜"></a>一、複雜</h3><p>所謂的複雜，指的是<strong>你幾乎很難一看就學會</strong>。往往還需要<strong>看書、上課，或者看一堆教學影片</strong>，才能慢慢領略其中具體的做法與精神。</p><p>總之，<strong>這個「系統」本身就是一套需要學習的方法。</strong></p><p>毫無疑問，在這個自媒體時代，這類系統的「<strong>最佳代言人</strong>」，就是眾多<strong>生產力 KOL</strong>。可能是一個 YouTuber，或生產力部落客。</p><p>他們會在 YouTube 或自己的部落格上，分享關於「<strong>如何建立與使用</strong>」這類系統的文章影片。再多一點，則是會有自己的<strong>課程</strong>或<strong>書籍</strong>。</p><h3 id="二、流程化"><a href="#二、流程化" class="headerlink" title="二、流程化"></a>二、流程化</h3><p>除了複雜，這類系統的另一個明顯的特徵——「<strong>流程化</strong>」。</p><p>遵循一定的規則、順序、條件，就像生產線一樣，把知識——或任何其它你需要處理、學習的事物——當作原料，透過<strong>一套完整的工具使用流程</strong>，讓它們變成「你的東西」，或產出相對應的成果。</p><p>想當然爾，<strong>這不會是簡單的幾個步驟</strong>，而是一整套理論（甚至說是「<strong>信仰</strong>」可能也不為過），加上各式各樣實踐上的細節、建議所組成。</p><p>什麼！GTD、PARA 你都沒聽過？沒關係，因為本文要討論的，不是任何具體的生產力方法，也不是它們究竟有沒有效，而是<strong>更高層次的價值觀議題</strong>。</p><hr><h2 id="為什麼不要這麼用"><a href="#為什麼不要這麼用" class="headerlink" title="為什麼不要這麼用"></a>為什麼不要這麼用</h2><p>如「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E7%94%9F%E7%94%A2%E5%8A%9B%E8%BB%9F%E9%AB%94%E7%9A%84%E6%88%B0%E5%9C%8B%E6%99%82%E4%BB%A3">生產力軟體的戰國時代</a>」中所說，上述的系統或方法論，無一例外都是透過某一款<strong>筆記軟體</strong>（有時甚至是一整套工具）來實現，無論是 Notion 或 Evernote。</p><p>這可以理解，畢竟理論終歸是理論，還是需要工具來落實。以前可能是紙筆，但在這個時代，軟體、app 才是我們最常用的工具。</p><p>而本文要強調的則是「為什麼<strong>不要這麼用</strong>」這些軟體——<strong>不要</strong>在這些軟體之上，或好些軟體之間，建立一個<strong>複雜的工作流程</strong>。</p><blockquote><p><strong>不要在這些軟體之上，或好些軟體之間，建立一個複雜的工作流程。</strong></p></blockquote><hr><h2 id="3-個「不」的理由"><a href="#3-個「不」的理由" class="headerlink" title="3 個「不」的理由"></a>3 個「不」的理由</h2><p><strong>為什麼不？</strong></p><p>開頭的 3 篇文章中，都有提到不這麼做的理由，讓我搭配引述，重新為你疏理一番。</p><p>歸納起來，主要有下列 3 個理由。</p><p>特別提醒：用來落實本文中「系統」的工具，<strong>並不限於 Notion</strong>，只不過 Notion 可能是最常被使用、提及的工具而已。</p><h2 id="一、成本過高：神兵利器的代價"><a href="#一、成本過高：神兵利器的代價" class="headerlink" title="一、成本過高：神兵利器的代價"></a>一、成本過高：神兵利器的代價</h2><p>在「<a href="https://blog.kyomind.tw/simple-notion/#%E7%B6%AD%E6%8C%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8C%81%E7%BA%8C%E9%81%8B%E8%BD%89%EF%BC%8C%E6%98%AF%E5%80%8B%E3%80%8C%E9%AB%94%E5%8A%9B%E6%B4%BB%E3%80%8D">維持工作流持續運轉，是個『體力活』</a>」中，我是這麼說的：</p><blockquote><p>很遺憾，<strong>對這套「系統」每一天的落實、記錄，大多仍須由你「手動」執行</strong>。<br>　<br>哪怕 Notion 有 <strong>API 整合</strong>，可以省下一些時間。網路上也有眾多<strong>模板</strong>，供你直接套用。但是，你設計出來的工作流，<strong>其中最核心的部分，往往只能由你自己——手動維護。</strong></p></blockquote><p>而這些手動的功夫，勢必將帶來大量的時間、精力的消耗。<strong>系統愈大、愈是精巧，成本就愈高。</strong></p><p>我認為對大部分人而言，如此巨大的投入，<strong>幾乎很難獲得「相應」的回報。</strong></p><blockquote><p><strong>為什麼？</strong></p></blockquote><p>因為你其實<strong>不需要</strong>這麼多回報。</p><p>大部分時候，產出價值的關鍵在於「<strong>把事情做好</strong>」，而不是「做<strong>好多</strong>事情」。</p><p><strong>而就我所知，要把一些事情做好，並不需要太複雜的工具或管理技巧。</strong></p><p>不過話說回來，如果你的野心更大，想要「<strong>把好多事情都做好</strong>」，那可能確實需要這類系統。</p><p>然而，這樣的想法，也有其背後的<strong>隱憂</strong>——讓我們看第二個理由。</p><hr><h2 id="二、適得其反：做了更多瑣事"><a href="#二、適得其反：做了更多瑣事" class="headerlink" title="二、適得其反：做了更多瑣事"></a>二、適得其反：做了更多瑣事</h2><p><strong>時間成本</strong>，是採用「人生管理系統」的<strong>一大門檻</strong>，而且光是需要投入的時間成本，<strong>其實就足以勸退一半以上的嘗試者。</strong></p><p>其中的理由可想而知：<strong>因為太累了嘛！</strong>🤣</p><p>但是！如果你動力過人、積極實踐，並沒有因為成本而卻步。那第二個理由則是我們<strong>更需要關心的。</strong></p><p>我在「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1">效率陷阱</a>」中提到：</p><blockquote><p>有時候，這些<strong>額外增加的效率</strong>（生產力）就像是超商的「<strong>第二件 6 折</strong>」零食。平時你知道零食不健康，所以不會多買。<br>　<br>但有了這個折扣，我們往往忍不住，買更多——內心還覺得很划算。<br>　<br>正如前述，這些事如果不是「必須的」，那「提高對此事的生產力」，往往只是讓你花費更多時間，做那些<strong>本來就不需要做的事</strong>！——就像<strong>多吃了一堆零食</strong>。</p></blockquote><p>換句話說，如果你真的能「把好多事情都做好」，那你<strong>也</strong>很可能——<strong>且幾乎不可避免地</strong>——會增加做「<strong>不重要瑣事</strong>」的<strong>數量與比例</strong>。</p><p>而這些瑣事對<strong>整體產出的價值，當然是「有害」的！</strong></p><hr><p>你乍聽可能覺得：「會嗎？事情是否重要，我一直都是<strong>了然於心</strong>的啊！」</p><p>但我想說，現實恐怕沒有這般美好。</p><p>接下來的第三個理由，將會一定程度論證這一點：<strong>我們對事物重要性的判斷，並不總是那麼敏感。</strong></p><h2 id="三、系統會觸發你「追求完整」的本能"><a href="#三、系統會觸發你「追求完整」的本能" class="headerlink" title="三、系統會觸發你「追求完整」的本能"></a>三、系統會觸發你「追求完整」的本能</h2><p>還記得十多年前，超商非常流行的「<a href="https://www.foodnext.net/column/columnist/paper/5357454895">集點公仔收集</a>」活動嗎？</p><p>年輕的讀者可能沒什麼印象，這個熱潮當時真的流行了好幾年才慢慢消退。</p><p>仔細想想，為什麼會這麼流行？是因為這些公仔、飾品真的很吸引人嗎？這只是一部分原因。當然，也不乏對特定主題本來就有興趣的愛好者。</p><p>但其中一個<strong>不容忽視的要素</strong>是——<strong>我們對於「事物完整性」的本能追求</strong>：</p><blockquote><p>而純喫茶則是運用包裝上的瓢蟲元素，推出了一系列不同品種花紋的公仔，<strong>不少人也是特別去購買產品來完成收集的目標</strong>。</p></blockquote><p>「完成收集目標」意謂著，<strong>為什麼收集</strong>並不那麼重要，重要的是它<strong>必須被完成</strong>。</p><p>可想而知，對<strong>完整性</strong>的本能偏好，很可能會讓我們<strong>忽略</strong>，追求完整<strong>究竟是為了什麼？</strong></p><h3 id="系統讓人想要「更完整」"><a href="#系統讓人想要「更完整」" class="headerlink" title="系統讓人想要「更完整」"></a>系統讓人想要「更完整」</h3><p>那這個本能和「系統」有什麼關係？</p><p>系統，<strong>特別是那些複雜的「人生管理系統」</strong>，它的設計往往<strong>很容易激發</strong>我們追求完整的本能。</p><p>回顧一下我在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉提過的，那些鼓吹你入坑「人生管理系統」的<strong>迷人標語</strong>：</p><ul><li>我用 Notion <strong>高效管理工作與生活</strong>，告別瞎忙，重新找回人生主導權。</li><li>透過 Notion「<strong>打造○○系統、輕鬆整合✕✕</strong>」，讓我可以<strong>一站式管理一切</strong>。</li><li>Notion 幫助我<strong>實現夢想，完成目標</strong>，創造屬於我的美好人生。</li></ul><p>就算沒有真的實踐過，我們光看這些宣傳詞，<strong>想必也能合理推測：</strong></p><blockquote><p>這樣的系統，勢必要追求<strong>一定的完整性，才能有效應對不同面向上的各種需求</strong>——畢竟它可是要<strong>改變你的人生</strong>！</p></blockquote><p>結合不同功能模組（在 Notion 中就是許多 database），形成一套<strong>完整的「工作流」、「系統」</strong>，正是它們主要的<strong>設計思路</strong>。</p><hr><h2 id="完整的悖論"><a href="#完整的悖論" class="headerlink" title="完整的悖論"></a>完整的悖論</h2><p>這種大而全的設計思路，讓我們不自覺地想要<strong>填滿每一個環節上的空白、講究每一個角落的細節——即使這些細節對我們的整體目標並不重要。</strong></p><p>就像那些公仔收集活動一樣，系統<strong>觸發</strong>了我們對「完整性」的<strong>渴望</strong>，讓我們陷入了一種<strong>錯誤的追求方向</strong>——「我要把它們都收集完！」</p><p>在大系統中，我們可能花很多時間思考<strong>系統本身的設計、優化管理方法</strong>，而忽略了<strong>真正對我們重要的事情</strong>，也就是<strong>系統「本來」想達到的目的。</strong></p><p>追求完整的本能，再結合複雜的系統設計，<strong>最終可能導致我們的生產力「下降」，而非提升。</strong></p><p>到頭來，我們花費了太多時間在維護、優化系統，而非利用它來提升我們的生活品質或工作效率。</p><blockquote><p>這是<strong>我曾有過的經驗</strong>，不知你是否也熟悉？</p></blockquote><p>因此，與其說是<strong>完整的悖論</strong>，或許更適合稱之為——完整的「<strong>詛咒</strong>」。</p><hr><h2 id="舉例：Notion-閱讀管理"><a href="#舉例：Notion-閱讀管理" class="headerlink" title="舉例：Notion 閱讀管理"></a>舉例：Notion 閱讀管理</h2><p>我們舉一個<strong>典型且普遍</strong>的例子來感受一下，「追求完整」導致你花時間在鎖事上，真的<strong>比想像中的更容易發生。</strong></p><p>「<strong>用 Notion 做閱讀書籍的管理</strong>」這個需求場景，絕對是一搜尋就一大堆。在 YouTube 上搜尋「Notion 閱讀筆記」之類的關鍵字，能找到的相關影片更是多不勝數。</p><p>甚至不用搜尋，Notion 官方已經幫你收集了大量用戶提供的模板，供你直接套用：</p><ul><li><a href="https://www.notion.so/templates/category/books">Books templates</a></li></ul><p>並不是說，用 Notion 整理自己的閱讀清單、筆記有什麼問題。<strong>這絕對是好事。</strong></p><p>但如果你也有過類似的嘗試——用 Notion database 管理自己的閱讀清單。應該很容易發現，這個過程一不小心就可能會「<strong>走火入魔</strong>」。</p><p>一開始是書名、作者這類基本欄位，但隨著這個「系統」愈來感完整，<strong>你會很想要為它加入更多「點綴式」的資訊欄位</strong>，包括一些與排版設計有關的元素，比如封面、icon、顏色等等。</p><h2 id="不必要的欄位"><a href="#不必要的欄位" class="headerlink" title="不必要的欄位"></a>不必要的欄位</h2><p>簡言之，基於一種「完整記錄」的偏好，你可能會增加一些<strong>實際上沒多少用處</strong>，但會「<strong>讓人感覺很好、很完整</strong>」的欄位。</p><p>這些欄位在 Notion 閱讀管理資料庫中<strong>經常出現</strong>，但它們更多是<strong>為了追求「完整性」</strong>，而非<strong>實際的閱讀效益</strong>而設計，比如：</p><ol><li><strong>書籍封面圖片</strong>：封面圖片可以讓整個資料庫看起來<strong>更生動</strong>，但對於實際的閱讀和理解並沒有太大幫助。</li><li><strong>購買、借閱、開始、完成日期</strong>：記錄對這本書相關行動的時間點。</li><li><strong>出版資訊</strong>：包括出版社、出版年份等。</li><li><strong>多重標籤系統</strong>：例如創建多個標籤來分類書籍的主題、風格、情緒等，這增加了管理的複雜性，實際上的用處有限——<strong>不過確實讓人感覺很好XD</strong></li><li><strong>閱讀狀態</strong>：例如「想讀」、「正在讀」、「已讀」等狀態，這一定程度上有助於組織，但太複雜則會變成負擔，比如狀態有 5、6 種之多。</li><li><strong>引用和摘錄</strong>：對書中的特定段落或引言進行詳細記錄。我知道很多人喜歡！我也喜歡。對於學術工作或深入研究比較有用，但對於一般閱讀者而言，很可能只是增加了不必要的工作量。</li></ol><p>這些欄位雖然可以讓你的閱讀資料庫<strong>看起來很全面</strong>，但實際上，對<strong>提升閱讀體驗</strong>或<strong>增進理解</strong>往往<strong>沒有太大幫助</strong>（甚至可以說<strong>毫無關係</strong>）。反而讓你<strong>花費更多時間在製作、管理這些數據，而非真正的閱讀思考。</strong></p><p>讀書本來沒那麼複雜，不外乎<strong>明白一些事，然後有所行動</strong>。但工具可能讓它<strong>變得複雜</strong>，而「<strong>系統</strong>」更是如此。</p><p><img src="https://i.imgur.com/drRrybF.png" alt="工具可能讓閱讀變得複雜，而系統更是如此"><span class="cap">工具可能讓閱讀變得複雜，而系統更是如此</span></p><p><strong>最壞</strong>的情況是，我們被這些強大系統所<strong>吞噬</strong>，淪為「<strong>為系統工作</strong>」的人，而非利用系統的人。</p><hr><p>當然，上述只是最壞情況，而且情況總是在變動，不能一概而論。</p><p>但話說回來，那些知名的生產力達人，他們好像並沒有這樣的困擾？</p><p>確實，因為這些人是「凌駕於系統之上」的人。</p><p>下一段我們要討論，這類人和一般人，<strong>究竟有什麼不同。</strong></p><h2 id="再論生產力達人"><a href="#再論生產力達人" class="headerlink" title="再論生產力達人"></a>再論生產力達人</h2><p>下面舉例的瓦基和電腦玩物，都是我認為「<a href="https://blog.kyomind.tw/simple-notion/#%E5%81%A5%E5%BA%B7%E8%88%87%E7%97%85%E6%85%8B%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B">健康</a>」的生產力達人。以他們為例，有助於我們理解「生產力達人」的<strong>特質</strong>，以及<strong>為什麼——你可能無法成為他們。</strong></p><p>在「<a href="https://blog.kyomind.tw/simple-notion/#%E4%BD%A0%E6%98%AF%E5%93%AA%E4%B8%80%E7%A8%AE%E4%BA%BA%EF%BC%9F">你是哪一種人？</a>」中，我使用了「生產力狂魔」一詞來形容那些擁有強大生產力且<strong>能持續貫徹</strong>的人：</p><blockquote><p>你得承認，有些人就是<strong>紀律良好且生產力過人</strong>，一樣時間他們能產出數倍成果，且品質有保證。比如<a href="https://readingoutpost.com/">閱讀前哨站</a>站長「<a href="https://readingoutpost.com/about/">瓦基</a>」，在台積電當工程師時，他能利用下班時間完成大量書籍閱讀與心得輸出，週而復始，筆耕不綴，進而<a href="https://crossing.cw.com.tw/article/15467">實踐了自己的志業</a>。</p></blockquote><p>這裡改用「生產力達人」這個詞彙，更加中性。</p><p>上述的瓦基，或我們熟悉的<a href="https://www.playpcesor.com/">電腦玩物</a>站長，他們都擁有驚人的生產力，更可貴的是——<strong>持續產出</strong>的能力。</p><p>我相信，他們不太會受困於系統，因為：</p><blockquote><p>這樣的人有著<strong>很強的自我調節能力，能持續地調整自己的行為，讓自己不斷進步</strong>——近乎<strong>本能</strong>。</p></blockquote><p>相比於一般人，他們擁有「<strong>更遠大的目標</strong>」，他們是「<strong>利用系統</strong>」的人。</p><blockquote><p>不過，我同時也相信，<strong>這樣的人，只是少數</strong>。</p></blockquote><p>沒錯，我真心認為，這樣的人只是少數，而且<strong>只會是少數。</strong></p><h3 id="生產力達人終究只是少數"><a href="#生產力達人終究只是少數" class="headerlink" title="生產力達人終究只是少數"></a>生產力達人終究只是少數</h3><p>生產力達人<strong>當然不是天生的</strong>，但必定是經過<strong>不斷自我追求、精進而煉成。</strong>（不然這世界也太不公平😂）</p><p>而我認為，這種<strong>不斷追求</strong>生產力的<strong>動力與本能——很大程度是天生的。</strong></p><p><strong>這是一種非常強烈的價值觀偏好。</strong></p><p>對我們這些普通人來說，要達到生產力達人的輸出量，肯定相當困難，<strong>但並非不可能。</strong>然而，如果要「<strong>持續</strong>」為之，沒有一定的動力與本能，恐怕還是不行的。</p><blockquote><p><strong>大部分人對生產力的渴求，並沒有那麼強烈。</strong></p></blockquote><p>這就是為什麼我們需要<strong>更實用、更適合自己</strong>的管理方法，而非盲目追求那些<strong>「強大」</strong>的系統。</p><p>畢竟，最有效的生產力提升方法，應該是能幫助我們<strong>專注於真正重要的事情</strong>，而不是讓我們陷入<strong>無止境的系統維護、資訊收集和管理壓力</strong>中。</p><hr><h2 id="更適合一般人的做法：局部實現"><a href="#更適合一般人的做法：局部實現" class="headerlink" title="更適合一般人的做法：局部實現"></a>更適合一般人的做法：局部實現</h2><p><strong>絕對有人需要大系統，而且能利用它們做的很好。</strong>只不過，大部分人如果也想按照相同的方式來提升生產力，基於上述三大理由，恐怕將<strong>適得其反</strong>。</p><p>因此，我相信，對大多數人來說，一個<strong>更現實且可行</strong>的方法是「<strong>局部實現</strong>」。</p><h3 id="局部實現：不完整，但更有效"><a href="#局部實現：不完整，但更有效" class="headerlink" title="局部實現：不完整，但更有效"></a>局部實現：不完整，但更有效</h3><p>局部實現，是一種<strong>心法或價值觀</strong>，說穿了沒什麼，就是「<strong>緊扣著需求尋找並選定方法，需要多少才投入多少</strong>」。</p><p>更具體地說，它有兩大核心內涵。</p><h3 id="一、方法改進宜適可而止"><a href="#一、方法改進宜適可而止" class="headerlink" title="一、方法改進宜適可而止"></a>一、方法改進宜適可而止</h3><p>如果當前方法<strong>已能做出 80 分成果，一定程度滿足需求了</strong>，就<strong>不要</strong>再繼續追尋「更有效方法」——宜適可而止。</p><p>必須強調，這裡不是指結果一律只追求 80 分就好。</p><p>而是，如果結果已經有 80 分，但你想要進一步提升，<strong>建議不要試圖從「手段、方法」上去改進。更不需要去建立一個複雜的系統。</strong></p><p>無論什麼系統，對於已有 80 分的產出結果，<strong>很可能已不構成影響</strong>。再從方法上改進，企圖更進一步提升產出品質，往往只是緣木求魚。</p><h3 id="二、分別而非整體：謹慎關聯"><a href="#二、分別而非整體：謹慎關聯" class="headerlink" title="二、分別而非整體：謹慎關聯"></a>二、分別而非整體：謹慎關聯</h3><p>「系統」二字最讓我<strong>害怕</strong>的，就是它隱約<strong>暗示</strong>著系統的各個元件之間，存在著<strong>巧妙的「關聯」</strong>，所以它們能共同組合成一個「工作流」。</p><p>我的建議是：<strong>謹慎關聯</strong>。</p><p>可以的話，<strong>不要關聯，因為所有關聯都是有「代價」的。</strong></p><p>我還是要用 Notion 舉例，因為我比較熟。Notion 的資料庫關聯，無疑是強大的功能，但真的不宜濫用。</p><p>何謂濫用？那就是本來一個 db 就能完成的需求，因為可以「關聯」，所以你決定把它拆成兩個甚至更多 db 來做，因為這樣<strong>更條理分明</strong>，也更有「<strong>組合後的整體美感</strong>」——我就幹過這種事！而且還不止一次。</p><p>最後我往往還是把 db 砍到剩 1 個。因為<strong>實在太煩了</strong>。</p><blockquote><p>相關內容：</p><ul><li><a href="https://blog.kyomind.tw/stumbling-on-notion/#%E9%81%8E%E5%BA%A6%E8%A8%AD%E8%A8%88%EF%BC%9A%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E7%AD%86%E8%A8%98%E6%9E%B6%E6%A7%8B%E5%B8%AB">過度設計：人人都是筆記架構師</a></li><li><a href="https://blog.kyomind.tw/notion-database/#%E8%B3%87%E6%96%99%E5%BA%AB%E5%A4%AA%E5%A4%9A%E4%BA%86%EF%BC%81">資料庫太多了！</a></li></ul></blockquote><h3 id="對關聯的渴望"><a href="#對關聯的渴望" class="headerlink" title="對關聯的渴望"></a>對關聯的渴望</h3><p>為什麼總是<strong>忍不住</strong>想要關聯呢？</p><p>我想你也看出來了，對「關聯」的渴望，正是「追求完整」的本能所致——我們<strong>很喜歡</strong>事物看起來是一個<strong>整體</strong>，更甚於只是一堆<strong>零散的部分</strong>。</p><blockquote><p><strong>所以必須把它們關聯起來。</strong></p></blockquote><p>追求完整往往帶來不必要的複雜，<strong>而「關聯」正是複雜小惡魔們誕生的溫床😈</strong></p><p>在我看來，對付複雜的最佳思維就是：<strong>各個擊破就好</strong>——不關聯，不整體。方法簡單、有效，<strong>能「恰如其分」解決問題</strong>，就是足夠好的方法。</p><p>當然，這會破壞一個大系統的「<strong>美感與整體感</strong>」，使之<strong>不再完整。</strong></p><p>對，我<strong>就是要</strong>破懷這樣的美感。</p><p>因為這種美感，正是讓我們「<strong>感覺良好</strong>」的來源，卻也是<strong>陷入困境</strong>的開端。</p><hr><h2 id="用「局部實現」取代人生管理系統"><a href="#用「局部實現」取代人生管理系統" class="headerlink" title="用「局部實現」取代人生管理系統"></a>用「局部實現」取代人生管理系統</h2><p>接下來<strong>以我自己為例</strong>，再聊聊更多「局部實現」的<strong>具體實作</strong>。</p><p><a href="https://blog.kyomind.tw/bear/#%E6%88%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E6%AC%BE%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94">我目前的主力筆記軟體</a>包括了 Notion 與 Logseq。說真的，這兩款軟體，都能創造出非常複雜的系統——它們在功能上皆強大而靈活。</p><p>但無論 Notion 還是 Logseq，「局部實現」策略都是可行的。</p><p>這意味著你可以在這些平台上建立<strong>特定的、專注於某一個或幾個目標的小流程</strong>，而不是一個涵蓋所有事情的龐大系統。</p><h3 id="我在-Notion-的局部實現"><a href="#我在-Notion-的局部實現" class="headerlink" title="我在 Notion 的局部實現"></a>我在 Notion 的局部實現</h3><p>Notion 中，我目前有在用的，<strong>只有一個</strong> database。用來管理我的寫作（主要）與個人 side project。</p><p><img src="https://i.imgur.com/BjE4elR.png" alt="Notion 寫作管理看板"><span class="cap">Notion 寫作管理看板</span></p><p>Notion 的簡易看板對我來說完全夠用，我不需要 Trello 這類更專業的專案管理軟體。</p><p>附帶一提，如果你有<strong>更加專業</strong>的「看板」需求，尤其是<strong>工作上的專案管理</strong>，千萬不要用 Notion，<strong>會很痛苦</strong>。</p><blockquote><p>我怎麼知道？望向工作上的 Notion 看板……🥲</p></blockquote><p>關於這個看板與 Notion 寫作，可參考：</p><ul><li><a href="https://www.facebook.com/kyomind/posts/pfbid03Zbm1vC5QGPVVeoH9YmhUBdmL88CW5whKtcwj2QssHHUyBT8oReRdSoytL3H2p1Gl">靠「看板」吧！</a>（臉書貼文，講述該看板誕生緣由）</li><li><a href="https://blog.kyomind.tw/my-markdown-writing-flow/">Notion + VS Code：我的 Markdown 寫作工作流</a>（講述我用 Notion 寫作部分，而且已經融入上述看板了）</li></ul><p>沒了，我主要就用 Notion 管理與進行「<strong>寫作</strong>」這一件事而已。</p><p>我以前也把很多事塞進 Notion，但我發現<strong>它能勝任的部分不多</strong>。很多事它都能做，但<strong>做的不是特別好</strong>——尤其是學習。</p><p>現在這樣的 Notion 用法，讓我非常喜歡且滿意。而設計上述看板需花多久的時間呢？<strong>應該不到半小時。</strong></p><p>使用看板的過程中，我嘗試過上述的「<strong>把一個資料庫拆成兩個，再互相關聯</strong>」，但始終<strong>沒有成功</strong>。（前後還試了兩次！😱）</p><p>用了一個月左右，我發現這樣簡單的看板，<strong>效果竟超乎想像的好——我的「發文紀律」明顯提升了！</strong></p><p>既然如此，這方法已經足夠，依「<strong>局部實現</strong>」思維，<strong>我也該適可而止了。</strong></p><h3 id="我在-Logseq-的局部實現"><a href="#我在-Logseq-的局部實現" class="headerlink" title="我在 Logseq 的局部實現"></a>我在 Logseq 的局部實現</h3><p>前面提到，Notion 對我的學習效果不是很好。</p><p>但我做筆記，最大的訴求就是學習，尤其是學習程式。所以我後來改用了 Logseq。</p><p>把<strong>學習用筆記軟體</strong>從 Notion 換成 Logseq 的具體緣由，我會再另篇討論。</p><p>而我現在用 Logseq 的學習方式，也很簡單：</p><ol><li>用 Logseq 寫學習筆記。大部分是<strong>程式相關</strong>，記錄實作時的<strong>踩坑經驗、重要知識、歸納與心得</strong>。認真寫筆記，對我<strong>幫助很大</strong>，可參考<a href="https://www.facebook.com/kyomind/posts/pfbid0sotiMpKkNWAR9w6kTyLeZj3LAF29qEhbiAfBWfHWyGU46EzAiozc3475ixYU47Azl">這篇臉書貼文</a>。</li><li>把上述筆記做成<strong>閃卡</strong>，按時複習。卡片的<strong>具體模樣</strong>，可參考<a href="https://www.facebook.com/fomo.kyo/posts/pfbid0KMyv8WAyMJSQBz8kvVQsmhXmHRspVknx3wwCcdjwvNJrH22bpZKZPMxcEZHECVJVl">這篇臉書貼文</a>。</li></ol><p>容我引用第二篇中的一段：</p><blockquote><p>程式開發時勤做筆記，把筆記切成一張張閃卡（flashcard），每天複習一些卡片。不用多，10-20 張就夠了<br>　<br>對我而言，是不錯的學習方式（我以前還很不以為然呢 XD）<br>　<br>經實測，它有助於我於更靈活運用這些開發知識。簡言之，我比以前「更容易想起」實作上要注意的細節，與其中的原理——因為我踩過這些坑、做了筆記，然後用閃卡複習</p></blockquote><p>Logseq 對我當然還有別的重要使用方式，比如記錄我的晚餐與當次用餐心得！但主要的大目標，就只有<strong>學習</strong>。</p><p>我從來不覺得自己正在使用什麼「系統」。</p><p>對我來說，<strong>筆記就只是筆記而已。</strong></p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a></p></blockquote><hr><h3 id="局部實現更可能讓工具為你所用，而不是被系統束縛"><a href="#局部實現更可能讓工具為你所用，而不是被系統束縛" class="headerlink" title="局部實現更可能讓工具為你所用，而不是被系統束縛"></a>局部實現更可能讓工具為你所用，而不是被系統束縛</h3><p>上述這些方法，說真的，都滿「<strong>平淡</strong>」的。我也不知道怎麼樣才能把它們寫得更 fancy 一點——可能是因為<strong>我沒有「系統」可言。</strong></p><p>採用「局部實現」思維，意味著你可以選擇最適合當前需求的工具和方法，從而使工具真正為你所用。<strong>因為這些方法都比較「小」，要用不用，皆操之在己。</strong></p><p>雖然系統提倡者們都不約而同地宣稱：精緻而完善的系統，能使人找回生活的主導權！（此時文案旁通常還要搭配一則<strong>漂亮的圖表</strong>，讓你感受「<strong>系統的整體之美</strong>」）</p><p><strong>但我不這麼看。</strong></p><p>我認為，相比於大系統，使用小方法的局部實現，更容易讓我專注於<strong>事物的本質</strong>，而非被系統所束縛。</p><p>回想一下，學習所謂「人生管理系統」的過程中，你是否曾有過這樣的<strong>自我懷疑</strong>：</p><blockquote><p><strong>我覺得這東西真的很棒！但是我不夠認真，所以還用不好。</strong></p></blockquote><p><strong>相信我——</strong></p><blockquote><p><strong>那很可能不是你的問題。</strong></p></blockquote><p>我誠摯認為，<strong>不值得</strong>再花費時間精力去維護那些「<strong>看起來很棒</strong>」，但<strong>實際效果極其有限</strong>的功能模組。比如上述「<a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D">不必要的欄位</a>」。</p><p><strong>人生苦短</strong>，你完全可以把精力集中在<strong>真正重要的事情</strong>上，<strong>直接提高</strong>結果的品質。</p><hr><h2 id="結語：接受殘缺與遺憾"><a href="#結語：接受殘缺與遺憾" class="headerlink" title="結語：接受殘缺與遺憾"></a>結語：接受殘缺與遺憾</h2><p>我本來想要使用「<strong>擁抱</strong>」這個詞，但這詞常常被濫用在一些心靈雞湯中，情感上也不是非常協調。</p><p>因為殘缺或遺憾，<strong>都不是我們喜歡的東西（我們喜歡完整）</strong>，要「擁抱」它們，本身就已<strong>違反人性</strong>——太虛假。</p><p>而「<strong>接受</strong>」一詞則更貼切些，<strong>帶有幾分不捨，與幾分坦然</strong>，很適合。</p><p>我相信，我們面對「大系統」的心態，也是如此。</p><h3 id="「完整性」的誘惑"><a href="#「完整性」的誘惑" class="headerlink" title="「完整性」的誘惑"></a>「完整性」的誘惑</h3><p>前面講的我自己的局部實現案例，可以說，沒什麼特別之處，任何人都能做到。</p><p>不過連我自己在這個過程中，<strong>都還是很容易受到「完整性」的誘惑。</strong></p><p>我可是寫了這篇七千字長文，不斷提醒你要小心「完整性誘惑」的作者，但我自己還是會受到誘惑。只能說，<strong>本能的力量，真的很強大。</strong></p><p>當然我並非「系統愛好者」，所以不太可能被誘惑到去建立一個完整的系統。<strong>但不得不承認，我也常常很想要去「優化方法」。</strong></p><p>在此，我想要再次告訴你，<strong>也提醒我自己：方法真的沒那麼重要。</strong></p><p>大系統、工作流，<strong>真正讓人著迷的</strong>，往往是這些系統「<strong>本身</strong>」，而非其產出的結果。</p><p>人生管理系統就像一座<strong>壯麗的城堡，它的外觀、內部設計、各個房間的佈置，無不讓人陶醉其中。</strong>但這座城堡的<strong>主人</strong>——也就是你——<strong>卻未必快樂。</strong></p><h3 id="畫框與畫作"><a href="#畫框與畫作" class="headerlink" title="畫框與畫作"></a>畫框與畫作</h3><p>就像畫框與畫的關係，我們被<strong>精緻的畫框</strong>所吸引，甚至忘記了畫框的存在目的，是為了<strong>襯托畫作</strong>。</p><p>當然，話說回來，<strong>沒有方法確實不妥</strong>，但方法的改進，應適可而止。</p><p>上述看板就是很好的例子，它實在很簡單，簡單到不值一提，但對我寫作紀律的提升，大概從 0 分提高到了 60 分。</p><p>我還要<strong>繼續改進</strong>這個看板嗎？或許可以，或許不必。</p><p>寫文章並不是我的工作，如果能擁有 60 分的寫作紀律，且能夠持續保持，那我已<strong>相當自豪。</strong>這意味著我的「<strong>寫作畫框</strong>」已經<strong>足夠好了。</strong></p><h3 id="殘缺與遺憾"><a href="#殘缺與遺憾" class="headerlink" title="殘缺與遺憾"></a>殘缺與遺憾</h3><p>我認為，保持方法的殘缺與遺憾，是一種「<strong>高明的妥協</strong>」。</p><p>小方法比大系統更容易掌握，更可能讓我們<strong>專注於「畫作」本身</strong>。</p><p>接受殘缺並不意味著放棄進步，而是在進步的過程中，<strong>試著學會區分：哪些只是手段，而哪些才是本質。</strong></p><blockquote><p><strong>手段可以殘缺。唯有本質的完整，才值得我們一心追求——至死方休。</strong></p></blockquote><p>擺脫對系統的「<strong>依賴</strong>」後，甚至會發現，我們的生產力<strong>其實已經有了顯著的提升</strong>。這樣的提升，<strong>來自於我們對「自身局限」的理解和接受。</strong></p><p>這種心態的轉變，不僅提高了生產力，更重要的是：<strong>減少了不必要的壓力和焦慮。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/PwPTWYK.jpg&quot; alt=&quot;by Myriam Wares&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉一文與其所屬的「&lt;a href=&quot;https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion/&quot;&gt;Simple Notion 系列&lt;/a&gt;」中，我已用不少幅篇，明確表達我對這類「&lt;strong&gt;大而全&lt;/strong&gt;」生產力系統的&lt;strong&gt;隱憂&lt;/strong&gt;與&lt;strong&gt;質疑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在其它文章中，也有過類似討論：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/four-thousand-weeks-01/&quot;&gt;《人生 4 千個禮拜》筆記（一）病態的生產力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-11/&quot;&gt;11，我絕不當資訊的聚合者&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文將進行一次「&lt;strong&gt;總結式&lt;/strong&gt;」的整理，重新闡述&lt;strong&gt;不用這類系統的三大理由&lt;/strong&gt;。並提出我認為相對可行的&lt;strong&gt;替代方案：局部實現&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;本文目錄&quot;&gt;&lt;a href=&quot;#本文目錄&quot; class=&quot;headerlink&quot; title=&quot;本文目錄&quot;&gt;&lt;/a&gt;本文目錄&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85&quot;&gt;本文主旨與目標讀者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D&quot;&gt;所謂的「人生管理系統」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%A7%E7%B3%BB%E7%B5%B1%E7%9A%84%E5%85%A9%E5%80%8B%E7%89%B9%E5%BE%B5&quot;&gt;大系統的兩個特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E8%A6%81%E9%80%99%E9%BA%BC%E7%94%A8&quot;&gt;為什麼不要這麼用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-%E5%80%8B%E3%80%8C%E4%B8%8D%E3%80%8D%E7%9A%84%E7%90%86%E7%94%B1&quot;&gt;3 個「不」的理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E3%80%81%E6%88%90%E6%9C%AC%E9%81%8E%E9%AB%98%EF%BC%9A%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8%E7%9A%84%E4%BB%A3%E5%83%B9&quot;&gt;一、成本過高：神兵利器的代價&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E3%80%81%E9%81%A9%E5%BE%97%E5%85%B6%E5%8F%8D%EF%BC%9A%E5%81%9A%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%91%A3%E4%BA%8B&quot;&gt;二、適得其反：做了更多瑣事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89%E3%80%81%E7%B3%BB%E7%B5%B1%E6%9C%83%E8%A7%B8%E7%99%BC%E4%BD%A0%E3%80%8C%E8%BF%BD%E6%B1%82%E5%AE%8C%E6%95%B4%E3%80%8D%E7%9A%84%E6%9C%AC%E8%83%BD&quot;&gt;三、系統會觸發你「追求完整」的本能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%82%96%E8%AB%96&quot;&gt;完整的悖論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%88%89%E4%BE%8B%EF%BC%9ANotion-%E9%96%B1%E8%AE%80%E7%AE%A1%E7%90%86&quot;&gt;舉例：Notion 閱讀管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D&quot;&gt;不必要的欄位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%8D%E8%AB%96%E7%94%9F%E7%94%A2%E5%8A%9B%E9%81%94%E4%BA%BA&quot;&gt;再論生產力達人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE&quot;&gt;更適合一般人的做法：局部實現&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%94%A8%E3%80%8C%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE%E3%80%8D%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1&quot;&gt;用「局部實現」取代人生管理系統&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B5%90%E8%AA%9E%EF%BC%9A%E6%8E%A5%E5%8F%97%E6%AE%98%E7%BC%BA%E8%88%87%E9%81%BA%E6%86%BE&quot;&gt;結語：接受殘缺與遺憾&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;本文想表達一個&lt;strong&gt;核心看法&lt;/strong&gt;：打造大而全的&lt;strong&gt;人生管理系統&lt;/strong&gt;，期望它全面提升你的生產力，&lt;strong&gt;可能不是一個好主意。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我知道，在這個資訊爆炸、快速變遷的時代，&lt;strong&gt;追求生產力&lt;/strong&gt;幾乎可說是一種「&lt;strong&gt;顯學&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;這類系統也許為「&lt;strong&gt;少部分人&lt;/strong&gt;」帶來了可觀的成就、自我掌控感，甚至是&lt;strong&gt;安全感&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此他們能夠&lt;strong&gt;信誓旦旦&lt;/strong&gt;地告訴你：「相信我！這是一個超棒的方法，而且你也能夠！」&lt;/p&gt;
&lt;p&gt;老實說，連我自己都很難完全抗拒「高效、生產力」這類的主題，我想這是所有懷抱著自我期許之人的本能吧！&lt;/p&gt;
&lt;p&gt;所以我並不打算阻止你去追求、建立屬於自己的&lt;strong&gt;生產力方法論&lt;/strong&gt;。本文想要&lt;strong&gt;提醒&lt;/strong&gt;的是——這些方法&lt;strong&gt;最好不要&lt;/strong&gt;是「大而全」的那種，而是要能夠做到「&lt;strong&gt;取捨&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;不過，人生之難，就難在取捨。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/PwPTWYK.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>為文章標註 Not By AI？ 我覺得大可不必</title>
    <link href="https://blog.kyomind.tw/not-by-ai/"/>
    <id>https://blog.kyomind.tw/not-by-ai/</id>
    <published>2024-01-14T16:37:05.000Z</published>
    <updated>2024-01-30T14:56:38.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/917fAxf.png" alt="notbyai.fyi"><span class="cap">notbyai.fyi</span></p><p>前陣子，我得知了「<a href="https://notbyai.fyi/">Not By AI</a>」這個徽章的存在。</p><p>它提倡為你的創作（以下都指文章）加上這個標籤，<strong>聲明是由人類所寫</strong>。</p><p>我們先看一下這個徽章的<a href="https://notbyai.fyi/#not-by-ai-mission">創立使命</a>（中文為 Google 翻譯）：</p><blockquote><p><strong>使命</strong><br>「Not By AI」徽章的創建是為了鼓勵更多的人製作原創內容並幫助用戶識別人類生成的內容。最終目標是確保人類繼續進步。<br>　<br>專家估計，到 2025 年，90% 的線上內容將由人工智慧產生。隨著人工智慧產生內容的激增，值得注意的是人工智慧是根據人類生成的內容進行訓練的。如果人類僅僅依靠人工智慧來產生前進的內容，那麼人工智慧產生的任何新內容都可能只是過去的內容的回收。這可能對人類進步構成重大障礙。只有限制對人工智慧的依賴並繼續創造原創內容才能推動我們作為一個物種向前發展。</p></blockquote><p>我乍一看覺得<strong>有點心動</strong>，而且作為一個長期創作的部落格作者，像「Not By AI」這種「自我主張型」的標籤，僅是在本能情感上，就有股莫名的吸引力。</p><p>但同時又覺得，好像哪裡<strong>怪怪的</strong>。</p><span id="more"></span><hr><h2 id="寫在前頭"><a href="#寫在前頭" class="headerlink" title="寫在前頭"></a>寫在前頭</h2><p>這篇文章與其說是討論「Not By AI」徽章的必要性，不如說是討論背後透露出的更大議題：「<strong>在人工智慧時代，我們該如何看待自己與 AI 的關係？</strong>」。</p><p>而「Not By AI」則是一個<strong>支點</strong>，讓我們可以從中展開討論。</p><p>換言之，它提供了一個<strong>具體的情境與切入視角</strong>，讓我們可以挖掘並獲得自己的思考、喜好、想法，進而發現自己在這個議題上的相關立場。</p><p>而本文表述<strong>我的立場。</strong></p><hr><h2 id="和-AI-討論「Not-By-AI」"><a href="#和-AI-討論「Not-By-AI」" class="headerlink" title="和 AI 討論「Not By AI」"></a>和 AI 討論「Not By AI」</h2><p>雖然我在情感上很想要直接使用這個徽章，但我的理性與直覺卻告訴我：<strong>先等等</strong>。</p><p>這個時候該怎麼辦？以前，你可以慢慢獨立思考，把一些可能的思考素材與蛛絲馬跡寫下來。但現在你有更好的夥伴了！——ChatGPT。</p><p>這個議題，我們直接問問 AI 吧！看看「它」怎麼說（這是我自己訂製的 GPT，回答的口吻比較機車一點，請多多擔待🙏）：</p><blockquote><p>這個「Not By AI」徽章，看起來像是一種懷舊情懷和對 AI 的不信任感結合的產物。實話實說，這種做法有點自欺欺人。當然，表明你的內容是純手工、未經 AI 處理的，<strong>對某些讀者來說可能有點吸引力</strong>，就像有機食品對某些消費者來說更有吸引力一樣。但別自欺了，這不過是一種行銷手段，<strong>實際上對內容的品質沒有任何保證。</strong><br>　<br>使命中提到限制對 AI 的依賴並繼續創造原創內容是推動人類進步的關鍵。<strong>這種觀點忽略了技術與人類創意的互補性</strong>。僅僅通過拒絕或限制 AI 的使用，無法推動人類在藝術、科學或任何其他領域的真正進步。相反，我們應該學會如何更好地利用 AI 來擴展我們的創作能力和視野。<br>　<br>我的建議？專注於創作高品質、有價值的內容。如果你的內容夠好，無論是不是 AI 生成的，讀者都會欣賞。別太在意這些浮華的徽章。真正的價值在於你的內容和你作為開發者的專業知識，而不是某個標籤。<strong>讓你的創作自己說話吧！</strong></p></blockquote><p>我覺得它講得很好，讓我豁然開朗。</p><p>這也是為什麼，在面對那些我認為重要的課題時，我一定會先跟 AI 討論一番——它帶給我的啟發，往往超乎想像。</p><hr><h2 id="我的兩個看法"><a href="#我的兩個看法" class="headerlink" title="我的兩個看法"></a>我的兩個看法</h2><p>參考上述 AI 的回答，我大致得出了自己的結論。</p><p>同時也明白，為什麼一開始，我雖然受到「Not By AI」徽章在情感上的吸引，但心裡卻始終覺得不自然、不自在。</p><p>我的看法如下。</p><h2 id="讀者或許沒那麼在意，文章是人還是-AI-寫的"><a href="#讀者或許沒那麼在意，文章是人還是-AI-寫的" class="headerlink" title="讀者或許沒那麼在意，文章是人還是 AI 寫的"></a>讀者或許沒那麼在意，文章是人還是 AI 寫的</h2><p>為了闡述好這個命題，我得從文章<strong>「作者」與「讀者」兩個角度</strong>分別討論。讀者角度，再依照不同的「<strong>閱讀目的</strong>」，說明為何大部分時候，讀者並不那麼在乎，文章是人還是 AI 寫的。</p><h3 id="作者角度"><a href="#作者角度" class="headerlink" title="作者角度"></a>作者角度</h3><p>身為作者，我非常希望自己的文章能夠做到邏輯清晰、文筆生動、內容對讀者有價值，最好還很有<strong>個人特色</strong>！</p><p>這是為什麼我看到「Not By AI」的號召時，會覺得心動：「作為茫茫人海中的一員，<strong>我想要被看見、被記得！</strong>」</p><p>但，這也只是我從作者角度的<strong>個人期望</strong>而已。</p><h3 id="讀者角度"><a href="#讀者角度" class="headerlink" title="讀者角度"></a>讀者角度</h3><p><strong>更多時候，我是一個讀者。</strong></p><p>當我是讀者，對於眼前這篇文章是人還是 AI 寫的，依<strong>不同的閱讀目的</strong>，我會有不同的在意程度。</p><h4 id="一、具有個人特色、經驗、感受的文章"><a href="#一、具有個人特色、經驗、感受的文章" class="headerlink" title="一、具有個人特色、經驗、感受的文章"></a>一、具有個人特色、經驗、感受的文章</h4><p>看這類文章，我通常是因為「<strong>喜歡或認同該作者</strong>」，比如《<a href="https://zebraletter.substack.com/">斑馬通信</a>》。此時我的確會在意，文章是出自人類之手。</p><p>這或許是「Not By AI」徽章對身為讀者的我而言，少數的價值。</p><p>但若再深挖一尺，會進一步發現：與其說我在意「<strong>文章是人類寫的</strong>」這件事，還不如說我<strong>真正在意</strong>的是「<strong>文章是『這個人』寫的</strong>」。</p><p>換句話說，如果文章是別人代筆，即使代筆的是人類，那也是不行的！</p><h4 id="二、實用性文章"><a href="#二、實用性文章" class="headerlink" title="二、實用性文章"></a>二、實用性文章</h4><p>前述文章只佔一小部分，我看的文章有 9 成以上，都屬於「實用性」文章。</p><p>這類文章，我更在乎寫得好不好、對我是否有幫助。作者是誰，則相對次要。</p><p>當然，能寫出好文章的作者，<strong>絕對值得被記住</strong>、讚賞、追蹤。我也希望能夠看到更多好文章。</p><p>好的作者，我會記得，慢慢的，他們的文章就變成了第一類文章。</p><p>但，這個作者，就非得是個「人」嗎？就算是 AI 寫的，只要寫得好，那為什麼我不追蹤、不多看呢？<strong>只因為文章不是出自人類之手？</strong></p><blockquote><p>這個理由，略嫌薄弱。</p></blockquote><p>綜上所述，作為一個讀者，我會記得那些，帶給我心情與智識上滿足感的作者們——但不是只有人類才能辦到。</p><p><strong>AI 也常常帶給我智識上的滿足感、讓我感到欣慰。</strong></p><hr><h2 id="標註「Not-By-AI」解決不了任何問題"><a href="#標註「Not-By-AI」解決不了任何問題" class="headerlink" title="標註「Not By AI」解決不了任何問題"></a>標註「Not By AI」解決不了任何問題</h2><p>如果「解決」二字太沉重，我們可以解讀成「改善」。</p><p>老實說，我覺得「Not By AI」徽章能夠改善的，大概只有「<strong>身為作者的焦慮感</strong>」——我們真的很怕被 AI 取代！</p><p>然而，為文章加上「Not By AI」標籤，對讀者而言，究竟可以改善什麼問題呢？</p><h3 id="文章的真實性？"><a href="#文章的真實性？" class="headerlink" title="文章的真實性？"></a>文章的真實性？</h3><p>顯然「Not By AI」徽章對改善文章「真實性」部分，幫不上忙。</p><p>因為不管是 AI 還是人類創造的內容，都有錯誤或造假的可能。現有的內容農場，不就是源自人類的惡意與對內容的不尊重？</p><p>甚至，這種標籤還可能會給讀者一種<strong>虛假的安全感</strong>，使我們降低身為一個讀者，對內容品質、真實的<strong>思考敏感度</strong>——人類寫的應該更可靠的，對吧？</p><h3 id="內容的品質與創新？"><a href="#內容的品質與創新？" class="headerlink" title="內容的品質與創新？"></a>內容的品質與創新？</h3><p>想當然爾，「Not By AI」不能保證內容的品質或創新，畢竟這個徽章本來就不是拿來聲明與內容品質相關的事項。</p><p>但是，如前所述，身為讀者，我更在乎的是內容本身。好的文章應該是具有深度、引人思考，或者提供新的視角，而這些特性與其是否由 AI 創作<strong>無關</strong>。</p><p>看完一篇文章，我看到了作者放的「Not By AI」徽章，我依舊不禁會想：「所以呢？這個『Not By AI』聲明，對我有實質幫助嗎？」</p><h3 id="「Not-By-AI」的重點就是它本身？"><a href="#「Not-By-AI」的重點就是它本身？" class="headerlink" title="「Not By AI」的重點就是它本身？"></a>「Not By AI」的重點就是它本身？</h3><p>我們當然可以說，上述這些問題，本來就不是「Not By AI」徽章的重點。畢竟它只是一個「<strong>聲明</strong>」，而非「解決方案」。</p><p>這個徽章的重點，就是它本身——強調由「人類」所創作。</p><p>我可以理解，但仍不禁好奇，這種強調，對讀者而言，真的有那麼重要嗎？讀者真的會因為看到「Not By AI」徽章，而<strong>更願意閱讀</strong>這篇文章嗎？</p><p>退萬步言，假設讀者<strong>真的更在乎</strong>「人類」創作的內容。<strong>可是，讀者要如何驗證，這個徽章「說的是真的」呢？</strong></p><p>比如，我可以為文章標示「Not By AI」，卻透過 AI 幫我產生大部分內容，只要修改到<strong>讓讀者看不出來</strong>就好。</p><hr><p>總的來說，我覺得「Not By AI」<strong>唯一的價值</strong>就是……<strong>讓作者感受到一絲心安與自豪。</strong></p><p>寫出一篇文章，絕對值得自豪。但我認為這種<strong>自豪感</strong>，應該來自於<strong>對內容本身的投入</strong>，而非只因為「<strong>這是我親手寫的喔！</strong>」。</p><p>所以，儘管本站的任一篇文章，都能夠符合「<a href="https://notbyai.fyi/#who-can-use-not-by-ai-badge">The Not By AI 90% Rule</a>」（9 成以上的內容由人類創作），我依舊不會放上「Not By AI」徽章。</p><p>我認為一個作者在創作與呈現作品時，強調「人類 vs AI」的二分法，對讀者而言，並沒有太大價值。</p><p>在我看來，文章內容真正的二分法，只有「好看 vs 不好看」而已。</p><p>如果真的想為自己的文章<strong>宣誓點什麼</strong>，除了「Not By AI」，我覺得也不妨考慮「<strong>本文寫了 4 小時</strong>」、「<strong>用生命創作</strong>」等徽章——我一定對你刮目相看👀</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我倒是不反對作者為自己的文章加上「Not By AI」標籤，甚至還會因此而<strong>多看兩眼</strong>。只是我知道，那就<strong>只是一個標籤</strong>而已。</p><p>作為一個讀者，我真正在乎的，只有<strong>作品本身帶給我的連結與共鳴</strong>，無論是人類創作，還是 AI 生成。</p><p>當然，有些事物是<strong>人類專屬</strong>的，比如某篇食記與對某道料理的感受。如果你告訴我這是「AI 親自去試吃的心得」，那我會感到<strong>十分無言</strong>🐸</p><p>但問題的關鍵始終不在於<strong>「誰寫的」</strong>，而在於<strong>「寫得怎麼樣」</strong>。</p><p>一篇文章能否觸動人心、提供有價值的見解，或帶來新的洞察，永遠是最重要的。</p><p>而一個簡單的「Not By AI」標籤，永遠無法帶給你這些答案或線索。</p><hr><h2 id="後記：為何我仍相信-AI"><a href="#後記：為何我仍相信-AI" class="headerlink" title="後記：為何我仍相信 AI"></a>後記：為何我仍相信 AI</h2><p>我並非一個 AI 樂觀主義者。</p><p>真要說的話，我應該屬於悲觀的那一方，身為一個軟體工程師，我時常擔憂，未來可能被 AI 取代。</p><p>但是，就像我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#AI-%E8%BC%94%E5%8A%A9%E5%AF%AB-Code">AI 輔助寫 Code</a>」中說的：</p><blockquote><p>不同的時代有不同的努力方式，作為一個 AI 時代的開發者，我們要學習<strong>與 AI 共舞。</strong></p></blockquote><p>活在這個時代，我所能選擇<strong>最好的努力方式</strong>，就是<strong>用心和 AI 協作</strong>。</p><p>事實上，本文的創作過程，就是我和 ChatGPT 不斷對話的過程。</p><p>我花費了大量時間與它交談、討論，甚至讓它挑戰我的觀點。如果沒有 AI，這篇文章會比你現在看到的更平庸且無聊得多——連我自己都不想看。</p><p>所以，我無法發自內心認為，為自己的文章加上「Not By AI」標籤，是一件值得自豪的事。（但我覺得這是一件「<strong>可愛</strong>」的事，所以我不反對你這麼做）</p><p>畢竟，一篇文章的好壞，最終還是要由讀者來評價。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/917fAxf.png&quot; alt=&quot;notbyai.fyi&quot;&gt;&lt;/p&gt;
&lt;p&gt;前陣子，我得知了「&lt;a href=&quot;https://notbyai.fyi/&quot;&gt;Not By AI&lt;/a&gt;」這個徽章的存在。&lt;/p&gt;
&lt;p&gt;它提倡為你的創作（以下都指文章）加上這個標籤，&lt;strong&gt;聲明是由人類所寫&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們先看一下這個徽章的&lt;a href=&quot;https://notbyai.fyi/#not-by-ai-mission&quot;&gt;創立使命&lt;/a&gt;（中文為 Google 翻譯）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使命&lt;/strong&gt;&lt;br&gt;「Not By AI」徽章的創建是為了鼓勵更多的人製作原創內容並幫助用戶識別人類生成的內容。最終目標是確保人類繼續進步。&lt;br&gt;　&lt;br&gt;專家估計，到 2025 年，90% 的線上內容將由人工智慧產生。隨著人工智慧產生內容的激增，值得注意的是人工智慧是根據人類生成的內容進行訓練的。如果人類僅僅依靠人工智慧來產生前進的內容，那麼人工智慧產生的任何新內容都可能只是過去的內容的回收。這可能對人類進步構成重大障礙。只有限制對人工智慧的依賴並繼續創造原創內容才能推動我們作為一個物種向前發展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我乍一看覺得&lt;strong&gt;有點心動&lt;/strong&gt;，而且作為一個長期創作的部落格作者，像「Not By AI」這種「自我主張型」的標籤，僅是在本能情感上，就有股莫名的吸引力。&lt;/p&gt;
&lt;p&gt;但同時又覺得，好像哪裡&lt;strong&gt;怪怪的&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/917fAxf.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Django ORM：一對一、一對多外鍵教學（中）反向關聯</title>
    <link href="https://blog.kyomind.tw/reverse-relationships/"/>
    <id>https://blog.kyomind.tw/reverse-relationships/</id>
    <published>2024-01-06T17:07:40.000Z</published>
    <updated>2024-01-16T19:38:13.119Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a> 系列連載的第 2 篇。</p><p>搭配學習的範例程式碼，可參考 GitHub 專案：<a href="https://github.com/kyomind/Django-Tutorial">Django-Tutorial</a>。更多 Django 教學，請見「<a href="https://blog.kyomind.tw/django/">Django 文章總覽</a>」。</p><h3 id="系列：Django-ORM-外鍵入門"><a href="#系列：Django-ORM-外鍵入門" class="headerlink" title="系列：Django ORM 外鍵入門"></a>系列：Django ORM 外鍵入門</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/django-models/">Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</a></li><li><strong>Django ORM：一對一、一對多外鍵教學（中）反向關聯</strong></li></ol></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我們介紹完 Django ORM 的關聯設定，接下來本應該要進入查詢部分。不過，由於「反向關聯」在 ORM 查詢中扮演著十分重要的角色。</p><p>所以我決定專門寫這個（中）篇，好好介紹 Django ORM 中的「<strong>反向關聯</strong>」。</p><span id="more"></span><p>本文可以視為是第一篇的「<strong>補充</strong>」——對「反向關聯屬性」多加著墨。</p><p>不用說，這篇文章需要你先充分理解<a href="https://blog.kyomind.tw/django-models/">第一篇</a>的內容，再行閱讀。尤其是該文中的這三個部分：</p><ul><li><a href="https://blog.kyomind.tw/django-models/#related-name-%E8%88%87%E5%8F%8D%E5%90%91%E9%97%9C%E8%81%AF">related_name 與反向關聯</a></li><li><a href="https://blog.kyomind.tw/django-models/#related-name-%E5%9C%A8%E4%B8%80%E5%B0%8D%E5%A4%9A%E9%97%9C%E4%BF%82%E4%B8%AD%E7%9A%84%E9%87%8D%E9%BB%9E">related_name 在一對多關係中的重點</a></li><li><a href="http://localhost:4000/django-models/#related-name-%E7%9A%84%E9%A0%90%E8%A8%AD%E5%90%8D%E7%A8%B1">related_name 的預設名稱</a></li></ul><p>請務必熟悉。</p><hr><h2 id="理解反向關聯"><a href="#理解反向關聯" class="headerlink" title="理解反向關聯"></a>理解反向關聯</h2><p>我們可以從「正向關聯」來比較反向關聯，會更好理解。</p><p>在 Django ORM 中，正向關聯意指那些<strong>由我們明示定義的欄位</strong>，比如<code>ForeignKey</code>、<code>OneToOneField</code>等欄位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    <span class="comment"># 這是一個正向關聯欄位</span></span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><p>正向關聯屬性的<strong>最大特色</strong>是，它對應著資料庫 table 中的<strong>特定外鍵欄位</strong>。換句話說，它和 model 中的其它欄位一樣，都是「<strong>實體</strong>」的。</p><h3 id="反向關聯是「虛擬」的"><a href="#反向關聯是「虛擬」的" class="headerlink" title="反向關聯是「虛擬」的"></a><strong>反向關聯是「虛擬」的</strong></h3><p>而反向關聯是「<strong>虛擬</strong>」的。</p><p>所謂的「虛擬」，是指反向關聯<strong>並不直接對應於資料庫中的一個實際欄位</strong>。它只存在於 Django ORM 層面上，作為模型關係的一部分。</p><p>這種設計使得我們可以在不增加額外資料庫欄位的情況下，輕鬆地管理和查詢模型間的關係與對應的實例。</p><p>換言之，即使沒有反向關聯，我們<strong>還是可以</strong>透過標準 ORM 語法，查詢想要的資料——<strong>只是比較麻煩！</strong></p><p>反向關聯在「快速獲得關聯實例」這個需求場景，<strong>大大突顯</strong>了 ORM 查詢相對於原生 SQL 查詢的便利性。也讓你多增加了一個使用 ORM 的理由。</p><h3 id="反向關聯屬性的返回值"><a href="#反向關聯屬性的返回值" class="headerlink" title="反向關聯屬性的返回值"></a><strong>反向關聯屬性的返回值</strong></h3><p>根據關聯的類型，反向關聯的「屬性值」會有所不同。</p><p>在一對一關係中，反向關聯屬性返回的是一個的<strong>關聯模型實例</strong>。在一對多關係中，返回的是一個<code>QuerySet</code>（嚴格來說其實是<strong>關係管理器</strong>——<code>RelatedManager</code>），代表所有相關聯的模型實例集合。</p><p>這種彈性使得反向關聯成為 Django ORM 中一個極其強大且靈活的存在。</p><hr><p>好，講完了定義，我們趕緊來看，反向關聯屬性在實務上究竟是如何被使用。以及使用上的注意事項。</p><p>不過在此之前，我必須對原來範例程式碼中的 model 結構，做出一些<strong>調整</strong>。</p><h2 id="範例程式碼模型調整"><a href="#範例程式碼模型調整" class="headerlink" title="範例程式碼模型調整"></a>範例程式碼模型調整</h2><p>我要變更其中的「一對一」model 關係，因為原來的設計<strong>有兩個比較大的缺陷</strong>。我們先看看舊的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(<span class="string">&#x27;Title&#x27;</span>,</span><br><span class="line">                                 on_delete=models.PROTECT,</span><br><span class="line">                                 related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.title.main&#125;</span> - <span class="subst">&#123;self.title.subtitle&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Title</span>(models.Model):</span><br><span class="line">    main = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    subtitle = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.main&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure><p>第一個缺陷，是 Post 和 Title 的一對一關係，<strong>有違現實</strong>。</p><p>把 Title 變成一個關聯物件，是非常少見的。這不僅會讓讀者「難以想像」，無法感同身受。後續使用這模型來實作 API 時，這個設計不良問題會更加突顯。</p><p>所以，還是改成比較符合現實的版本——但又不能脫離「部落格文章關係模型」這個大框架，如何再想一個更「有感」的一對一關係，不禁又讓我苦思了一段時間。</p><p>和 ChatGPT 討論很多可能，始終找不到非常適合的例子。最後我決定這樣：把 Title 改為 Post 的一個欄位，這是比較尋常且合理的做法。</p><p>一對一部分，改用「Subtitle」模型替代。這樣一來，Post 就有了一個「可選」的副標題。</p><p>沒錯，為了突顯「<strong>反向關聯不存在</strong>」這個議題，Subtitle 必須是「可選」的。也就是<strong>不一定每篇文章都要有關聯的 Subtitle。</strong></p><p>原來的「Post - Title」關聯，就不是「可選」的——即<strong>兩者都一定要有</strong>。不能呈現一對一關係不存在時的情境，這是舊程式碼第二個缺陷。</p><h3 id="Subtitle-模型介紹"><a href="#Subtitle-模型介紹" class="headerlink" title="Subtitle 模型介紹"></a>Subtitle 模型介紹</h3><p>我們來到更新後的業務邏輯中。想像每一篇部落格文章，都一定會有標題，所以標題現在只是 Post 模型的一個欄位而已。</p><p>但是，如果你願意，你可以為這篇文章加上「<strong>副標題</strong>」，也就是關聯 Subtitle。這完全是「可選」的，加不加隨你。</p><p>如果你用過寫作平台 <a href="https://medium.com/">Medium</a>，就知道它的文章正是「副標題可選」的設定。</p><p>雖然新設計還是不盡理想，因為它和 Title 一樣，其實也可以只是 Post 的一個欄位就好。但無論如何，Subtitle 主要是為了讓本文可以舉例，它的存在價值與合理性，我們暫不深究。</p><p>這裡我們只需知曉一件事：Post 可能有關聯的 Subtitle，也可能沒有。且兩者是一對一關係。</p><h3 id="新模型關聯"><a href="#新模型關聯" class="headerlink" title="新模型關聯"></a>新模型關聯</h3><p>如上述修正後，新的<code>models.py</code>內容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.title&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可選的副標題</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtitle</span>(models.Model):</span><br><span class="line">    content = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    post = models.OneToOneField(Post,</span><br><span class="line">                                on_delete=models.CASCADE,</span><br><span class="line">                                related_name=<span class="string">&#x27;subtitle&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.content&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 留言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    post = models.ForeignKey(Post,</span><br><span class="line">                             on_delete=models.CASCADE,</span><br><span class="line">                             related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.content&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure><p>不知道你覺得如何？我感覺更加井然有序了！很適合用來作為教學文章解說的範例。</p><hr><p>接下來，我們就用上述的程式碼實例，來一一解說反向關聯。</p><h2 id="一對一反向關聯"><a href="#一對一反向關聯" class="headerlink" title="一對一反向關聯"></a>一對一反向關聯</h2><p>請看 Post 與 Subtitle 這兩個模型，它們是典型的一對一關係。</p><p>Subtitle 實例有著「正向關聯」屬性——<code>post</code>，關聯某個 Post 模型實例。</p><p>Post 實例有著「反向關聯」屬性——<code>subtitle</code>，來自<code>related_name=&#39;subtitle&#39;</code>。不過，即使你沒有特別定義<code>related_name</code>，這裡的「預設」反向關聯屬性名稱，也是<code>subtitle</code>（即關聯模型名稱的「小寫」型態）。</p><h3 id="一對一反向關聯查詢重點"><a href="#一對一反向關聯查詢重點" class="headerlink" title="一對一反向關聯查詢重點"></a>一對一反向關聯查詢重點</h3><p>假設 Post 模型的實例為<code>post_1</code>。</p><p>想要查詢<code>post_1</code>所關聯的 Subtile 實例，有兩種方法，分別是<strong>一般查詢</strong>，與<strong>反向關聯查詢</strong>。</p><p>一般查詢方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtitle = Subtitle.objects.<span class="built_in">filter</span>(post=post_1)</span><br></pre></td></tr></table></figure><p>如前所述，即使沒有反向關聯，我們一樣可以得到我們想查詢的資料。</p><p>但透過反向關聯屬性，則會更加方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtitle = post_1.subtitle</span><br></pre></td></tr></table></figure><h3 id="一對一反向關聯不存在與錯誤錯理"><a href="#一對一反向關聯不存在與錯誤錯理" class="headerlink" title="一對一反向關聯不存在與錯誤錯理"></a>一對一反向關聯不存在與錯誤錯理</h3><p>一對一反向關聯有一個重點，那就是「關聯物件不存在時的錯誤處理」。</p><p>兩個「可以」建立關聯的模型物件，並非「一定要」建立關聯。因此，<code>post_1</code>的反向關聯屬性，不一定總是對應著一個 Subtitle 實例——有可能<strong>關聯不存在</strong>。</p><p>當關聯不存在時，訪問<code>post_1.subtitle</code>會引發<code>RelatedObjectDoesNotExist</code>例外。</p><p>考慮到「關聯不存在」的可能，我們的程式常常會這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    subtitle = post_1.subtitle</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中<code>ObjectDoesNotExist</code>是<code>RelatedObjectDoesNotExist</code>的父類別，因為你無法直接引用<code>RelatedObjectDoesNotExist</code>。</p><p>這種寫法雖然不算優雅，但它<strong>明確地表達了你的意圖</strong>。</p><hr><h2 id="一對多反向關聯"><a href="#一對多反向關聯" class="headerlink" title="一對多反向關聯"></a>一對多反向關聯</h2><p>一對多關係，我們要把目光放到 Post 與 Comment 這兩個模型。</p><p>其中 Post 是「一方」，而 Comment 則是「多方」。</p><p>一對多關係中，<code>ForeignKey</code>欄位<strong>肯定是實作在「多方」</strong>，所以上述程式碼，定義這個欄位的模型是 Comment：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    post = models.ForeignKey(Post,</span><br><span class="line">                             on_delete=models.CASCADE,</span><br><span class="line">                             related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="一對多反向關聯查詢重點"><a href="#一對多反向關聯查詢重點" class="headerlink" title="一對多反向關聯查詢重點"></a>一對多反向關聯查詢重點</h3><p>一樣，我們假設上述模型實例分別為<code>post_1</code>、<code>comment_1</code>。</p><p>其中<code>comment_1</code>有正向關聯屬性<code>post</code>（即 ForeignKey）。而<code>post_1</code>有「一對多」反向關聯屬性<code>comments</code>（從<code>related_name=&#39;comments&#39;</code>獲得）——注意這個複數。</p><p>同理，想獲得<code>post_1</code>所有關聯 Comment 實例，有一般查詢和透過反向關聯查詢。</p><p><strong>一般查詢：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments = Comment.objects.<span class="built_in">filter</span>(post=post_1)</span><br></pre></td></tr></table></figure><p><strong>反向關聯查詢：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure><h3 id="與一對一關係的區別"><a href="#與一對一關係的區別" class="headerlink" title="與一對一關係的區別"></a>與一對一關係的區別</h3><p>訪問一對一反向關聯屬性，會得到兩種可能：</p><ol><li>關聯物件。</li><li><code>RelatedObjectDoesNotExist</code>例外。</li></ol><p>而一對多的反向關聯，則<strong>只有一種可能：關係管理器物件</strong>（<code>RelatedManager</code>）。</p><p><code>RelatedManager</code>和<code>Manager</code>（即<code>.objects</code>的屬性值）類似，都是獲取 QuerySet 的「入口」。所以上述的<code>post_1.comments.all()</code>需要最後的<code>all()</code>方法，透過「關係管理器」再獲取「由關聯實例組成的 QuerySet」。</p><p>換句話說，光是呼叫<code>post_1.comments</code>本身，<strong>你只會得到「關係管理器」物件</strong>。記住這點，這將影響你對於「關聯不存在」時的處理。</p><h3 id="一對多反向關聯不存在"><a href="#一對多反向關聯不存在" class="headerlink" title="一對多反向關聯不存在"></a>一對多反向關聯不存在</h3><p>如果<code>post_1</code>有可能還沒有任何 Comment 關聯實例。那我們應該怎麼樣在程式中考慮進去呢？</p><p>我們第一個想到的可能是這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">if</span> comments:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上面這樣寫確實是可以的，當 QuerySet 為空，會被視為 falsy。不過更好、更 Django 的寫法則是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> post_1.comments.exists():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>然後千萬不要寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments</span><br><span class="line"><span class="keyword">if</span> comments:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>因為此時的<code>comments</code>變數內容是一個<strong>關係管理器物件</strong>，它一定會被視為 <a href="https://www.freecodecamp.org/news/truthy-and-falsy-values-in-python/">truthy</a>。意即這個判斷條件<strong>永遠會成立</strong>。</p><hr><h2 id="以「反向關聯是否存在」為查詢條件"><a href="#以「反向關聯是否存在」為查詢條件" class="headerlink" title="以「反向關聯是否存在」為查詢條件"></a>以「反向關聯是否存在」為查詢條件</h2><p>如果你想以「反向關聯是否存在」作為<strong>查詢的條件</strong>，比如我想查詢「<strong>沒有留言的文章</strong>」有哪些，要怎麼做呢？答案是——<code>isnull</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts_without_comments = Post.<span class="built_in">object</span>.<span class="built_in">filter</span>(comments__isnull=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>注意其中的<strong>雙底線</strong>，這是典型的 ORM 查詢條件使用方式。</p><p>同理，我想要查詢「<strong>有副標題（subtitle）的文章</strong>」則是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts_with_subtitle = Post.<span class="built_in">object</span>.<span class="built_in">filter</span>(subtitle__isnull=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>可以看到，上面兩個例子，都用透過 Post 的「反向關聯屬性」來進行過濾查詢——就像是一個普通的欄位一樣。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Django ORM 中的反向關聯，是 ORM 皇冠上的一顆明珠。</p><p>為什麼說 ORM 相對於原生 SQL 查詢更加優雅？從上述程式碼範例中，反向關聯無疑是最好的答案——像<code>post_1.subtitle</code>和<code>post_1.comments.exists()</code>這樣的語句，不僅簡潔，且非常可讀。</p><p>善用反向關聯，你將成為更加道地、成熟的 Django 開發者。</p><hr><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>我很少為自己的文章寫「後記」，不過仔細想想，為這篇好不容易才產出的文章寫點後記，也是值得的。</p><p>平常開發使用 Django ORM，其實也沒有想太多，只要「熟悉、習慣」就好。有時候用久了，對於常見的元素，甚至就不怎麼思考了。</p><p>但是！寫文章就不同了。為了向讀者解釋其中的細節，思考上不能草草帶過，至少要了解文中提到的部分，大概是怎麼一回事。</p><h3 id="創作流程與心得"><a href="#創作流程與心得" class="headerlink" title="創作流程與心得"></a>創作流程與心得</h3><p>為了完成這篇文章，我實際上做了這些事：</p><ol><li>先和 ChatGPT 討論文章架構、內容的取捨。同時我意識到了第一篇文章所提出的模型，在「一對一」部分有一開始提到的兩個設計缺陷。怎麼補救，也經過了一番取捨：<ol><li>第一種做法是另外提出不同的模型作為舉例，只適用於本篇，這個解法比較簡單。</li><li>第二種做法則是重新設計模型中的「一對一」部分。雖然比較辛苦，但對強化範例程例程式碼的整體感、完成度，更有助益。顯然，我選擇了後者。</li></ol></li><li>重新把塵封在 Notion 的 Django 筆記（Django ORM 部分）拿出來讀，大概有 2 萬字。雖然花時間，但我覺得很有幫助，難怪人家說寫文章一定會進步。<ol><li>以前做這些筆記，也複習過幾次，但最後還是不了了之。</li><li>趁這次機會，我把它們「移植」到 Logseq 上，以「閃卡」形式重見天日。我還發現，需要做成的卡片張數，原來並沒有我想像中的多。</li></ol></li><li>完成前兩步，最後才是把本文的內容生出來。但正因為有前兩步的鋪墊，這一步也走得相對踏實（雖然過程依舊不輕鬆）。</li></ol><p>總之，寫一篇文章真是不容易呀！希望它對你有所幫助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;https://blog.kyomind.tw/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 系列連載的第 2 篇。&lt;/p&gt;
&lt;p&gt;搭配學習的範例程式碼，可參考 GitHub 專案：&lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;Django-Tutorial&lt;/a&gt;。更多 Django 教學，請見「&lt;a href=&quot;https://blog.kyomind.tw/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;h3 id=&quot;系列：Django-ORM-外鍵入門&quot;&gt;&lt;a href=&quot;#系列：Django-ORM-外鍵入門&quot; class=&quot;headerlink&quot; title=&quot;系列：Django ORM 外鍵入門&quot;&gt;&lt;/a&gt;系列：Django ORM 外鍵入門&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/django-models/&quot;&gt;Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Django ORM：一對一、一對多外鍵教學（中）反向關聯&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇我們介紹完 Django ORM 的關聯設定，接下來本應該要進入查詢部分。不過，由於「反向關聯」在 ORM 查詢中扮演著十分重要的角色。&lt;/p&gt;
&lt;p&gt;所以我決定專門寫這個（中）篇，好好介紹 Django ORM 中的「&lt;strong&gt;反向關聯&lt;/strong&gt;」。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="ORM" scheme="https://blog.kyomind.tw/tags/ORM/"/>
    
    <category term="Django ORM" scheme="https://blog.kyomind.tw/tags/Django-ORM/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="系列：Django ORM 外鍵入門" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ADjango-ORM-%E5%A4%96%E9%8D%B5%E5%85%A5%E9%96%80/"/>
    
  </entry>
  
  <entry>
    <title>《人生 4 千個禮拜》筆記（一）病態的生產力</title>
    <link href="https://blog.kyomind.tw/four-thousand-weeks-01/"/>
    <id>https://blog.kyomind.tw/four-thousand-weeks-01/</id>
    <published>2023-12-23T18:05:48.000Z</published>
    <updated>2024-03-02T18:08:34.095Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/UNr2AmS.png" alt="人生 4 千個禮拜"><span class="cap">人生 4 千個禮拜</span></p><p>這是《<a href="https://www.books.com.tw/products/0010914255">人生 4 千個禮拜</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上<strong>大量我個人的經驗與想法</strong>。</p><p>我認為，如果你不是書中描寫的這類人——<strong>在某些方面、某種程度上對追求生產力有過一定追求的人</strong>。那看本書很可能只覺得它像是<strong>一連串的高級雞湯文</strong>。</p><p>比如「接受人生有限」這樣的話，你可能早就聽過無數次，甚至已經麻木了。</p><p>然而，作者在書中把這類人在「生產力追求路上」所伴隨的種種「<strong>荒謬</strong>」與「<strong>弔詭</strong>」之處，精準地勾勒出來，令人拍案叫絕。</p><p>或許你不是這樣的人，沒關係，因為我（某種程度）是。</p><p>所以我會試著把這樣的努力與隨之而來的困境，盡可能展現出來，好比是種自嘲。就像〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉中的我。</p><span id="more"></span><h3 id="系列：人生-4-千個禮拜"><a href="#系列：人生-4-千個禮拜" class="headerlink" title="系列：人生 4 千個禮拜"></a>系列：人生 4 千個禮拜</h3><blockquote><ul><li>《人生 4 千個禮拜》筆記（一）病態的生產力</li></ul></blockquote><p>和「<a href="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%8A%9F%E5%8A%9B%E6%8F%90%E5%8D%87%E7%9A%84%E6%A8%82%E8%B6%A3/">系列：Python 功力提升的樂趣</a>」一樣，我們<a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E5%8F%AA%E8%AC%9B%E9%87%8D%E9%BB%9E">只講重點</a>。</p><p>再次提醒，本文中有相當部分屬於我自己的看法，而非單純書中觀點的整理。我會適度明示地區分這兩者，還請讀者留意。</p><p>本文整理書中的前言到第 2 章。</p><hr><h2 id="作者簡介"><a href="#作者簡介" class="headerlink" title="作者簡介"></a>作者簡介</h2><blockquote><p>本書的確又是一本談善用時間的書，但宗旨是我們所知的時間管理大慘敗，<strong>我們需要停止假裝那些方法有用。</strong></p></blockquote><p>作者 Oliver Burkeman 是《<a href="https://zh.wikipedia.org/zh-tw/%E8%A1%9B%E5%A0%B1">衛報</a>》的專欄作家，寫的正是有關「如何提高生產力」、「時間管理」等主題。</p><p>只不過他後來發現：這些所謂的「<strong>提高</strong>」，並不像想像中的那般美好。因此才有了本書的誕生。</p><p>換言之，<strong>本書可說是他對自己與「提高生產力」這個議題的重新觀察、自我反省。</strong></p><p>當然，也不是每一個人張口閉口都是生產力。但不可諱言地，現代人對生產力的重視與追求，確實與日俱增。</p><h2 id="從成功學到生產力"><a href="#從成功學到生產力" class="headerlink" title="從成功學到生產力"></a>從成功學到生產力</h2><p>以往書店的書架上，總有一櫃是滿滿的「自我提升」、「成功學」。現在當然還是有，但就我的觀察，它們更多被一大票「<strong>工具方法論</strong>」的書所取代了。比如電腦玩物站長的《<a href="https://www.books.com.tw/products/0010929730">防彈筆記法</a>》。</p><p>這是一個<strong>從抽象到具體</strong>的演化過程，也不難理解其中的緣由。</p><p>畢竟，無論是成功學還是自我提升，都是高度的抽象概念，很難有具體的方法可以直接照著做，而結果又很難驗證，它們都太空泛了！</p><p>這些內容已經無法滿足現代人，我們想要更加「<strong>看得到、摸得著</strong>」的東西，最好能立刻看到這些方法、工具的效果——於是我們有了「生產力」。</p><p>從抽象的「成功、自我提升」到具體的「<strong>提高生產力、時間管理</strong>」。</p><hr><h2 id="生產力至上"><a href="#生產力至上" class="headerlink" title="生產力至上"></a>生產力至上</h2><blockquote><p>最近幾年，我們被活出百分之百全效生活的建議給淹沒，市面上的書籍鼓勵我們做到《極度生產力》，《一週工作 4 小時》，還要《更聰明、更快、更好》。</p></blockquote><p>這些書暗示著：我們應該不斷地改進自己，讓自己變得更有效率，更有生產力。</p><blockquote><p>五花八門的網站要我們化身為「生活駭客」，好讓完成日常事務的時間能少個幾秒鐘（「生活駭客」一詞本身就是<strong>古怪的建議</strong>，彷彿你的人生頂多稱得上某種老是出錯的裝置，需要加以調整，不再處於未達最佳運轉的狀態）。</p></blockquote><p>你對上述現象可能不陌生，又或許你並不是這樣的人，甚至感到嗤之以鼻。</p><p>但這個世界上，確實有這麼一部分人（包括我），時常在乎「怎麼做會比較快？還能再快嗎？」等議題。</p><p>雖然我自認為不是一個追求極致生產力的人——遠遠不是。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-11/">11，我絕不當資訊的聚合者</a></p></blockquote><p>然而，我發現，追求生產力並不是只有「實踐」這個面向而已。有時候光是「空想」，就是一種<strong>貪婪</strong>。</p><p>而這樣的貪婪會帶來所謂的「<a href="https://zh.wikipedia.org/zh-tw/%E9%94%99%E5%A4%B1%E6%81%90%E6%83%A7%E7%97%87">FOMO</a>」（這裡指對資訊的錯失恐懼）與<strong>明顯的焦慮感</strong>。從這個角度看，我依舊深陷其中。所以我需要這本書。</p><hr><h2 id="現代生產力離不開工具"><a href="#現代生產力離不開工具" class="headerlink" title="現代生產力離不開工具"></a>現代生產力離不開工具</h2><p>這部分不是書中內容，而是我的看法。</p><p>生產力其實也不是什麼新概念，就算是幾千年前的人，也會追求怎麼「怎麼做事更快、更好」——只不過他們可能不是用「生產力」這個詞而已。</p><p>那為何現在「生產力」一詞已經成為顯學？</p><p>仔細想想，「生產力」一詞大概是這近 10 年才比較頻繁被使用、強調。這其中的差別究竟是什麼？</p><p>我認為關鍵的差別是「工具」——工具進化了。</p><h2 id="軟體即生產力"><a href="#軟體即生產力" class="headerlink" title="軟體即生產力"></a>軟體即生產力</h2><p>工具，尤其是電腦、網路時代的核心工具——<strong>軟體</strong>，和以往相比，已經大大地進化了。我們使用各式各樣軟體，來完成工作上的簡報、提案、包括我的程式碼。</p><p>這些軟體讓我們更有效率地完成任務，並且增加了我們的工作能力。當然，這也意味著我們需要學習和掌握更多的軟體技能。</p><p><strong>說穿了，我們其實就是把「使用這些軟體的產出成果」視為生產力。</strong></p><p><strong>而所謂「提高生產力」，某種程度就是指：提高我們對這些軟體的使用技巧、方法。</strong></p><p>這些軟體對現代人而言太過尋常，以致「生產力」一詞也變得如此普及、朗朗上口。</p><p>這樣的論述可能不夠全面，但我覺得在大方向上確實如此，你說呢？</p><h2 id="生產力軟體的戰國時代"><a href="#生產力軟體的戰國時代" class="headerlink" title="生產力軟體的戰國時代"></a>生產力軟體的戰國時代</h2><p>而在各式工具軟體中，哪一種更能成為生產力的代名詞？</p><p>如果是 2000 到 2010 年，所謂的生產力軟體，大概是指微軟 Office 系列——忘掉那個美好的上古時代吧！</p><p>2010 年代至今，毫無疑問，生產力軟體的代名詞，就是「<strong>筆記軟體</strong>」。</p><p>當然還有各式各樣讓你工作、生活更加「方便」的軟體，如：</p><ul><li>專案管理軟體：Trello、Asana。</li><li>個人時間管理軟體：Todoist、TickTick。</li><li>工作流程自動化軟體：Zapier、IFTTT。</li></ul><p>但筆記軟體絕對是其中的<strong>主角</strong>。</p><h2 id="筆記軟體為王"><a href="#筆記軟體為王" class="headerlink" title="筆記軟體為王"></a>筆記軟體為王</h2><p>筆記軟體是現代生產力舞台的主角，這點你可能很難否認。</p><p>比如時間管理，你聽過 GTD。目標管理，你聽過 OKR。甚至還有關於個人知識管理的 <a href="https://fortelabs.com/blog/para/">PARA Method</a>、卡片盒筆記法。太多太多了。</p><p>凡此種種，當你決定要<strong>實踐</strong>的時候，你幾乎都必須選擇一套筆記軟體來使用。（當然也是可以用紙本啦！不過，呃…你懂的）</p><p>難怪現代生產力 KOL 們，多離不開教你怎麼「高效使用」某某筆記軟體。彷彿不好好學習、善用這些工具，就要被時代拋棄。</p><hr><p>說得有點遠了，讓我們回到本書。</p><p>作者並沒有提及筆記軟體，但他也認為，善用各種技巧、產品，能讓你做事更快、更有效率，當下能帶給你強烈的掌控感——這種感覺真的很好！</p><blockquote><p>問題不在於這些技巧與產品沒用。它們確實有用。你可以完成更多事，趕去開更多會，送孩子去更多課後活動，替你的雇主賺更多錢。</p></blockquote><p>但接下來的故事可能就沒那麼迷人了。</p><blockquote><p>然而矛盾的是，成功後，我們得到的只有感到更忙碌、更焦慮，某方面來講還更空虛。</p></blockquote><h2 id="生產力的弔詭"><a href="#生產力的弔詭" class="headerlink" title="生產力的弔詭"></a>生產力的弔詭</h2><p>生產力最大的弔詭在於，當你學習了新技巧，新工具，把以往要花上 2 小時的事，在半小時內俐落地完成之後——你發現新任務以更快的速度進來了！</p><p>這描述有點誇張，但也有真實之處。</p><p>誇張的部分在於，不是每件都能夠藉由工具、技巧，大幅縮短所需要的時間。有些事——<strong>尤其是那些困難的事</strong>——就是需要佔用你大量的心力與精神。</p><p>能夠大幅縮短的，往往是一些瑣事。當然，我認為，能夠減少做瑣事的時間，絕對是好的、有益的。只要你確保你做的是「<strong>必要</strong>」的瑣事。</p><h3 id="工作是做的不完的"><a href="#工作是做的不完的" class="headerlink" title="工作是做的不完的"></a>工作是做的不完的</h3><p>而真實之處在於，我們都知道，工作——長期而言——是做不完的。你能夠做得更快，往往就會做得更多。</p><blockquote><p>美國人類學家愛德華．霍爾（Edward T. Hall）談到現代世界的時間，感覺就像是永遠不會停下的輸送帶，我們一送出完成的工作，就會冒出新工作。</p></blockquote><p>所謂變得「更有生產力」，似乎只是<strong>加快輸送帶的運轉速度</strong>，而不是讓我們變得比以前更加從容、有餘裕。</p><p>這裡的關鍵命題應該是：這些多出來的時間、多完成的工作，對你而言是否有足夠的價值？如果有，那生產力仍是值得追求的。</p><p>所以，我倒不認為作者說的「感到更忙碌、更焦慮，某方面來講還更空虛」現象一定會發生——這個描述有點太片面、太戲劇化了。</p><p>不過接下來的「<strong>效率陷阱</strong>」，則是我認為本書<strong>必讀</strong>的部分。</p><hr><h2 id="效率陷阱"><a href="#效率陷阱" class="headerlink" title="效率陷阱"></a>效率陷阱</h2><blockquote><p>效率陷阱最糟糕的地方，在於「質」也會受到影響，你愈是努力塞進每一件事，<strong>你用在最沒意義的事情上的時間，反而會增多。</strong></p></blockquote><p>換言之，一旦你做某些事情的速度變快、變容易，你很可能會傾向<strong>做更多</strong>。</p><p>這真是一個巨大的諷刺，卻又如此的真實。</p><h3 id="第二件-6-折"><a href="#第二件-6-折" class="headerlink" title="第二件 6 折"></a>第二件 6 折</h3><p>有時候，這些<strong>額外增加的效率</strong>（生產力）就像是超商的「<strong>第二件 6 折</strong>」零食。平時你知道零食不健康，所以不會多買。</p><p>但有了這個折扣，我們往往忍不住，買更多——內心還覺得很划算。</p><p>正如前述，這些事如果不是「必須的」，那「提高對此事的生產力」，往往只是讓你花費更多時間，做那些<strong>本來就不需要做的事</strong>！——就像<strong>多吃了一堆零食</strong>。</p><p>我在〈<a href="https://blog.kyomind.tw/stumbling-on-notion/">少則得，多則惑：使用 Notion 時的兩個常見陷阱</a>〉提到的兩種典型情況，就屬於不必要的瑣事——卻能夠消耗你大量心力☺️</p><p>難怪文中不禁感嘆：</p><blockquote><p>但如果你讓我選，我寧可<strong>沒有這些自由</strong>——因為一不小心，就容易沉迷其中。</p></blockquote><h3 id="我才不會！——真的嗎？"><a href="#我才不會！——真的嗎？" class="headerlink" title="我才不會！——真的嗎？"></a>我才不會！——真的嗎？</h3><p>看到這裡，你可能還是有點不服，覺得會掉入上述的陷阱的人，肯定是因為<strong>沒有分清楚事情的輕重緩急。</strong></p><p>換句話說，只要把事情分清楚，好好規畫、時時提醒自己，就不會掉入這樣的陷阱。</p><p>老實說，在看完本書之前，我也是這麼想的。</p><p>但我覺得，我們往往還是低估了「<a href="https://blog.kyomind.tw/less-is-more/#%E4%B8%89%E3%80%81%E7%B3%BB%E7%B5%B1%E6%9C%83%E8%A7%B8%E7%99%BC%E4%BD%A0%E3%80%8C%E8%BF%BD%E6%B1%82%E5%AE%8C%E6%95%B4%E3%80%8D%E7%9A%84%E6%9C%AC%E8%83%BD">完整性的誘惑</a>」，與隨之而來的時間浪費。</p><hr><h2 id="再論「人生管理系統」"><a href="#再論「人生管理系統」" class="headerlink" title="再論「人生管理系統」"></a>再論「人生管理系統」</h2><p>書中這兩段話讓我特別有感：</p><blockquote><p>你要是採用<strong>超級有雄心壯志的時間管理系統</strong>，也就是那種承諾能搞定整張待辦清單的方法，<strong>你最後大概沒機會處理清單上最重要的事項。</strong></p></blockquote><p>上述「超級有雄心壯志的時間管理系統」，不正是所謂的「<a href="https://blog.kyomind.tw/less-is-more/#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D">人生管理系統</a>」？</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/less-is-more/">為什麼你「不需要」所謂的人生管理系統</a></p></blockquote><p>我在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉中不建議你用 Notion 建立一個大而全的「人生管理系統」，主要理由是它的「<strong>維護成本太高</strong>」。</p><p>維護成本太高，是我認為這類「人生管理系統」的<strong>第一個重大隱憂</strong>。</p><h3 id="第二個隱憂"><a href="#第二個隱憂" class="headerlink" title="第二個隱憂"></a>第二個隱憂</h3><p>而本書作者提出了一個「<strong>更加高級</strong>」的切入視角。</p><p>換句話說，縱使「人生管理系統」的維護成本為 0（這當然不可能，不過這樣的假設有助於你理解，這類系統的「<strong>危險</strong>」之處），擁有這樣的系統，<strong>也未必是全是好事</strong>。</p><blockquote><p>你愈是堅定地說服自己，有足夠時間做每一件事，<strong>你就愈不會感到有必要質疑</strong>，從事某項活動<strong>是不是</strong>善用你一部分時間的最佳方法。</p></blockquote><p>於是待辦事項愈堆愈多。</p><p>仔細想想，這不正是另一種——無所不能的「<a href="https://blog.kyomind.tw/simple-notion/#%E7%84%A1%E6%89%80%E4%B8%8D%E8%83%BD%E7%9A%84%E3%80%8C%E8%A9%9B%E5%92%92%E3%80%8D">詛咒</a>」？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UNr2AmS.png&quot; alt=&quot;人生 4 千個禮拜&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.books.com.tw/products/0010914255&quot;&gt;人生 4 千個禮拜&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上&lt;strong&gt;大量我個人的經驗與想法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我認為，如果你不是書中描寫的這類人——&lt;strong&gt;在某些方面、某種程度上對追求生產力有過一定追求的人&lt;/strong&gt;。那看本書很可能只覺得它像是&lt;strong&gt;一連串的高級雞湯文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如「接受人生有限」這樣的話，你可能早就聽過無數次，甚至已經麻木了。&lt;/p&gt;
&lt;p&gt;然而，作者在書中把這類人在「生產力追求路上」所伴隨的種種「&lt;strong&gt;荒謬&lt;/strong&gt;」與「&lt;strong&gt;弔詭&lt;/strong&gt;」之處，精準地勾勒出來，令人拍案叫絕。&lt;/p&gt;
&lt;p&gt;或許你不是這樣的人，沒關係，因為我（某種程度）是。&lt;/p&gt;
&lt;p&gt;所以我會試著把這樣的努力與隨之而來的困境，盡可能展現出來，好比是種自嘲。就像〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉中的我。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/UNr2AmS.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="閱讀筆記" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="系列：人生 4 千個禮拜" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%BA%E7%94%9F-4-%E5%8D%83%E5%80%8B%E7%A6%AE%E6%8B%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python 開發：Ruff Linter、Formatter 介紹 + 設定教學</title>
    <link href="https://blog.kyomind.tw/ruff/"/>
    <id>https://blog.kyomind.tw/ruff/</id>
    <published>2023-12-17T17:41:36.000Z</published>
    <updated>2024-01-20T07:22:11.398Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/klPlw0x.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p><a href="https://github.com/astral-sh/ruff">Ruff</a> 從去年（2022）6 月正式開源起算，已過去一年半，知道此工具的開發者也愈來愈多。雖然在去年就聽過它，但我卻一直沒有任何行動。</p><p>隨著前陣子 <a href="https://github.com/astral-sh/ruff/releases/tag/v0.1.0">v0.1.0</a> 的發布（先別覺得這版本號怎麼乍看像早期測試版本🤣，畢竟前一版可是 v0.0.292），我覺得時機已到，所以進行了一番研究、嘗試，於是有了本文的誕生。</p><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E7%B7%A3%E8%B5%B7">緣起</a></li><li><a href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85">本文主旨與目標讀者</a></li><li><a href="#Why-Ruff%EF%BC%9F">Why Ruff？</a></li><li><a href="#%E6%9C%AC%E6%96%87%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC">本文範例程式碼</a></li><li><a href="#Ruff-%E4%BB%8B%E7%B4%B9%E7%AF%87">Ruff 介紹篇</a></li><li><a href="#Linter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Flake8-%E8%88%87-isort-%E7%AD%89%E7%AD%89">Linter 部分：取代 Flake8 與 isort 等等</a></li><li><a href="#Formatter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Black">Formatter 部分：取代 Black</a></li><li><a href="#%E5%96%AE%E3%80%81%E9%9B%99%E5%BC%95%E8%99%9F%E8%AD%B0%E9%A1%8C">單、雙引號議題</a></li><li><a href="#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87">Ruff 設定篇</a></li><li><a href="#pyproject-toml-%E8%A8%AD%E5%AE%9A">pyproject.toml 設定</a></li><li><a href="##Ruff-VS-Code-%E5%A5%97%E4%BB%B6%E8%A8%AD%E5%AE%9A">Ruff VS Code 套件設定</a></li><li><a href="#pre-commit-%E8%A8%AD%E5%AE%9A">pre-commit 設定</a></li><li><a href="#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87%E5%B0%8F%E7%B5%90">Ruff 設定篇小結</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1">工作上我還未採用 Ruff 的理由</a></li><li><a href="#%E7%B5%90%E8%AA%9E%EF%BC%9ATime-to-Ruff">結語：Time to Ruff</a></li></ol><span id="more"></span><hr><h2 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h2><p>工作上，我們團隊使用的 linter、formatter 分別是常見的 Flake8、isort、yapf。這在以往的文章有多次提及。</p><p>隨著 Ruff 的聲量與能見度日漸提高，作為一個 <a href="https://blog.kyomind.tw/tags/Code-Formatting/">Code Formatting</a> 愛好者，我自然也是躍躍欲試——最好是能夠直接應用到工作開發上！</p><p>因為團隊還不大（含我共 3 個後端開發者），所以改用 Ruff 是完全有可能的。</p><p>不過經過一番研究與考慮，我還是暫時推遲了工作上對 Ruff 的採用（只是把 formatter 從 yapf 換成 Black），原因會在<a href="#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1">文末說明</a>。</p><p>但是！我還是很推薦，<strong>從現在就開始使用 Ruff 作為你「個人開發」的預設 linter 甚至 formatter</strong>。而 Ruff 究竟有哪些吸引人之處？且容我娓娓道來。</p><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>我在〈<a href="https://blog.kyomind.tw/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a>〉曾提過：</p><blockquote><p>考慮到「pre-commit」這個主題已經有數篇文章珠玉在前，我下筆前都已拜讀完。<strong>本文的論述重心會盡可能與這些文章錯開，或乾脆直接引用，以降低不必要的重複感。</strong></p></blockquote><p>而 Ruff 也是如此，推薦你先讀過這篇〈<a href="https://myapollo.com.tw/blog/python-linter-ruff/">新世代的 Python Linter - Ruff</a>〉，然後再繼續閱讀本文，將有助於獲得<strong>更全面的理解</strong>。</p><p>接下來對 Ruff 的介紹，會有不同的側重與著墨，與更多的設定細節。</p><h3 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h3><p>本文主要分為三大部分：</p><ol><li>前言。</li><li>Ruff 介紹篇。</li><li>Ruff 設定篇。</li></ol><p>一開始不免俗地先講述我研究與使用 Ruff 的動機與理由，接著介紹 Ruff 的主要功能——linter 與 formatter。這也是它的最大賣點。</p><p>而「設定篇」著重的，則是在初步了解 Ruff 之後，如果真要採用它，我們還需要處理好哪些環節，才能在開發中流暢地使用它。</p><p>畢竟，<strong>開發工具的設定與整合</strong>，可算是本站文章的一大類型。☺️</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文的目標讀者有三：</p><ol><li>Python 開發中還沒有認真用過 linter、formatter 作為規範工具，想要開始導入，並希望用 Ruff 一次解決的人。</li><li>長期使用「<strong>Flake8 + isort + Black</strong>」這套 Python 開發經典組合，對 Ruff 有高度興趣，想要試試看的人。</li><li>Code Formatting in Python 愛好者。</li></ol><p>這篇文章是寫給「已經用 Python 開發一段時間」的人，而非 Python 初學者。</p><p>不過話說回來，如果初學者一開始就肯使用 Ruff 好好規範自己所寫的 Python code，不正是一個絕佳的開端嗎？😎</p><hr><h2 id="Why-Ruff？"><a href="#Why-Ruff？" class="headerlink" title="Why Ruff？"></a>Why Ruff？</h2><p>什麼是 Ruff，一句話說就是：</p><blockquote><p>An extremely fast Python linter and code formatter, written in Rust.</p></blockquote><p>而我認為採用 Ruff 主要基於下面兩大理由。</p><h3 id="一、快，就是快"><a href="#一、快，就是快" class="headerlink" title="一、快，就是快"></a>一、快，就是快</h3><p>下圖來自 <a href="https://github.com/astral-sh/ruff">Ruff 的 GitHub 首頁</a>，很好表達了為何要採用 Ruff——因為快。</p><p><img src="https://i.imgur.com/rjPXQg4.png"></p><p>用 Rust 寫的，快，自然不在話下。</p><p>而「極致的快」在很多時候會大幅改變你做事的方式——不過這對於大型專案可能才更有感。</p><p>對於中、小型專案，我覺得以下第二個理由更加重要。</p><h3 id="二、All-in-One：整合眾多套件"><a href="#二、All-in-One：整合眾多套件" class="headerlink" title="二、All-in-One：整合眾多套件"></a>二、All-in-One：整合眾多套件</h3><p>不止是速度，Ruff 的「整合」能力也不可小覷。</p><p>按照官方文件，有了 Ruff 後，以下的工具都不必再安裝了：</p><ul><li><a href="https://pypi.org/project/flake8/">Flake8</a> 和一堆 Flake8 外掛</li><li><a href="https://github.com/psf/black">Black</a></li><li><a href="https://pypi.org/project/isort/">isort</a></li><li><a href="https://pypi.org/project/pydocstyle/">pydocstyle</a></li><li><a href="https://pypi.org/project/pyupgrade/">pyupgrade</a></li><li><a href="https://pypi.org/project/autoflake/">autoflake</a></li><li>還有更多！</li></ul><p>想想是不是有一點「<a href="https://blog.kyomind.tw/pyproject-toml/#pyproject-toml-%E4%BB%8B%E7%B4%B9">pyproject.toml</a>」企圖統一天下，整合眾多工具設定檔的味道呢？</p><p>上述這些工具，尤其是最常用的 Flake8、isort、Black，如果現在只需要用一個工具就能實現，而且還更快、更好。</p><p>那我們何樂而不為？</p><hr><h2 id="本文範例程式碼"><a href="#本文範例程式碼" class="headerlink" title="本文範例程式碼"></a>本文範例程式碼</h2><p>本文中所提到的 Ruff 設定具體內容，包括 pyproject、VS Code、pre-commit 部分，都會加到 <a href="https://github.com/kyomind/Django-Tutorial">Django-Tutorial</a> 這個專案中。</p><p>它是我「<a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a>」系列文章的範例程式碼，恰好也適合作為其它教學文章的實際素材展示。</p><p><code>git clone</code>本專案後，可以直接<code>git checkout</code>到<code>02-ruff</code>分支。這個分支所在的 commit，就是本文的具體設定內容與改動。</p><p>你也可以直接在 GitHub 上查看 <a href="https://github.com/kyomind/Django-Tutorial/commit/42a5a678ba5fbcc38f4463f593fad024636941ec">commit 內容</a>。</p><hr><p>前言結束，接下來我們進入正題。首先是對 Ruff 的整體介紹。</p><h2 id="Ruff-介紹篇"><a href="#Ruff-介紹篇" class="headerlink" title="Ruff 介紹篇"></a>Ruff 介紹篇</h2><p>Ruff 是一個 Python linter + formatter，雖然大部分人可能只使用它的 linter 部分，因為 formatter 還處於 beta 階段。</p><p>Ruff formatter 是一個相對獨立的功能，在開源後才開始建構。你完全可以只用 Ruff 的 linter，而依舊使用 Black 或 yapf 來格式化程式碼。</p><p>不過，即使只看 Ruff 的 linter 部分，它也並不是一個「單純的 linter」而已。因為它的實際行為超過了<strong>靜態分析</strong>（static analysis）。</p><p>所以，想要全面了解 Ruff，我們需要具體知曉：它究竟能夠做到哪些事、取代哪些工具。</p><h2 id="Linter-部分：取代-Flake8-與-isort-等等"><a href="#Linter-部分：取代-Flake8-與-isort-等等" class="headerlink" title="Linter 部分：取代 Flake8 與 isort 等等"></a>Linter 部分：取代 Flake8 與 isort 等等</h2><p>Ruff 的核心部分就是它的 linter，這點無庸置疑。</p><p>而 Flake8 作為 Python 開發中最流行的 linter，自然是 Ruff 首要取代的目標。所以 Ruff 連錯誤代碼都盡可能與 Flake8 一致，也是考慮到遷移的成本。</p><h3 id="Autofix-功能"><a href="#Autofix-功能" class="headerlink" title="Autofix 功能"></a>Autofix 功能</h3><p>不僅如此，Ruff 還能取代一眾「<strong>帶有 formatter 功能的 linter</strong>」，isort 就是其中的代表。而常見的 <a href="https://github.com/asottile/pyupgrade">pyupgrade</a> 也是。</p><p>這就有趣了，從這點可知，即使你沒有使用 Ruff 的 formatter 功能，它的 linter 部分還是<strong>帶有一定的 format 能力</strong>——其實就是 <a href="https://docs.astral.sh/ruff/linter/#fixes">autofix</a>。</p><p>這個特性<strong>真的很方便</strong>，但也帶來了一定的複雜。</p><p>方便的是，你可以只安裝 Ruff linter，就<strong>獲得多種 linter 附帶的 format 行為</strong>。而複雜則在於：設定上的細節也比一般 linter 更多。</p><h3 id="簡易版-formatter"><a href="#簡易版-formatter" class="headerlink" title="簡易版 formatter"></a>簡易版 formatter</h3><p>我原本以為 Ruff（不考慮<code>ruff-format</code>部分）只是一個比較快的靜態分析工具，顯然事實並非如此。</p><p>總之，我們只要記得：<strong>Ruff linter 有著簡易 format（autofix）能力</strong>——它是個簡易版的 formatter。</p><p>這和 Flake8 只做單純的靜態分析不同，Ruff linter 在檢查過程中，<strong>能夠直接對程式碼進行修改</strong>。當然，如果你不喜歡，這功能是可以關閉的。</p><hr><h2 id="Formatter-部分：取代-Black"><a href="#Formatter-部分：取代-Black" class="headerlink" title="Formatter 部分：取代 Black"></a>Formatter 部分：取代 Black</h2><p>我相信從 Ruff 的開源之初，就已經想過要成為一個 All-in-One 工具。畢竟 Rust 這麼快，只做 linter 未免太可惜了！</p><p>和 linter 不同，formatter 具有<strong>強烈的排它性</strong>。不同的 formatter 之間，<strong>沒有相容可言</strong>。不像 linter 還可以疊加使用——如果你不嫌煩XD。</p><p>如果寫一個全新的 formatter，就必須要有足夠的理由，讓開發者願意放棄當前方案，採用你的新工具——這很不容易。</p><p>比較可行的做法，是<strong>相容並取代</strong>市場上現有的 formatter。</p><p>既然要選一個，那當然是選 <a href="https://github.com/psf/black">Black</a>——目前最流行的 Python formatter。</p><blockquote><p>Black Formatter 相關文章：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a></li><li><a href="https://blog.kyomind.tw/flake8-and-black/">VS Code：Python Flake8 與 Black Formatter 擴充套件快速上手</a></li></ul></blockquote><h3 id="和-Black-的相容性"><a href="#和-Black-的相容性" class="headerlink" title="和 Black 的相容性"></a>和 Black 的相容性</h3><p>因此，和對待 Flake8 一樣，Ruff formatter 必須與 Black 格式化後的結果，有<strong>高度的相容</strong>（一致）。否則你換了它的 formatter，卻帶來一堆格式化結果改動，絕對會造成遷移負擔與採用意願的下降。</p><p>按照官方文件中「<a href="https://docs.astral.sh/ruff/formatter/#black-compatibility">Black compatibility</a> 」這段可知：</p><blockquote><p>Specifically, the formatter is intended to emit near-identical output when run over Black-formatted code. When run over extensive Black-formatted projects like Django and Zulip, <strong>&gt; 99.9% of lines are formatted identically</strong>. When migrating an existing project from Black to Ruff, you should expect to see a few differences on the margins, <strong>but the vast majority of your code should be unchanged.</strong></p></blockquote><p>兩者的相容性（一致性）高達 99.9% 以上，基本可以放心遷移。</p><p>附帶一提，如果你是從 yapf 遷移到 Black，就能夠明顯感受到格式化風格差異所帶來的困擾——程式碼變動的地方太多了！</p><p>這種情況最好還是<strong>獨立一個分支或 commit，一次就把所有格式化差異都處理掉。</strong>而不要直接繼續開發，讓開發中的程式碼、檔案隨著開發進度被新 formatter 自動格式化，因為這會很影響 code review——格式化變動和開發變動混雜。</p><h3 id="還處於-Beta-階段"><a href="#還處於-Beta-階段" class="headerlink" title="還處於 Beta 階段"></a>還處於 Beta 階段</h3><blockquote><p>The Ruff formatter is available as a <a href="https://astral.sh/blog/the-ruff-formatter">production-ready Beta</a> as of Ruff v0.1.2.</p></blockquote><p>引言中的「<a href="https://astral.sh/blog/the-ruff-formatter">production-ready Beta</a>」超連結，指向 Ruff Formatter 的官方介紹文章與發展現況總結。</p><p>所謂的 beta 並不是還有很多 bug，更像是「設計與方向上」還沒有完全底定——比如下面要討論的「單、雙引號」議題。所以才會在前面加上「production-ready」。</p><p>如果你想要在個人的生產環境中使用，我相信是沒什麼問題。畢竟 <a href="https://github.com/tiangolo/fastapi/pull/10517">FastAPI 專案已經直接使用了</a>！</p><p>不過如果是公司專案，我還是會選擇觀望，不急於一時。</p><h2 id="單、雙引號議題"><a href="#單、雙引號議題" class="headerlink" title="單、雙引號議題"></a>單、雙引號議題</h2><p>Python 允許開發者自由選擇要在程式碼中使用單引號或雙引號。</p><p>只有在比如 docstring 這種<strong>連續使用 3 個引號</strong>的場景——即<code>&quot;&quot;&quot; &lt;內容&gt; &quot;&quot;&quot;</code>——時，慣例上要求使用雙引號。見 <a href="https://peps.python.org/pep-0257/#what-is-a-docstring">PEP 257</a>：</p><blockquote><p>For consistency, always use <code>&quot;&quot;&quot;triple double quotes&quot;&quot;&quot;</code> around docstrings.</p></blockquote><p>如果你對 Black 有一些了解，應該會知道，早期 Black 是<strong>完全不管</strong>你習慣用單引號還是雙引號，<strong>它一律把你的 Python 程式碼格式化為雙引號！</strong></p><p>這小小的硬性規則帶來了<strong>巨大的反彈</strong>，畢竟 Python 開發者中想必有不少人和我一樣，是「單引號」的支持者。</p><p>最後，Black 開發團隊也不得不妥協（這是 Black 少數的妥協，因為該工具本身就是以「不妥協」為賣點、slogan🤣），加入了<code>skip-string-normalization</code>選項。</p><h3 id="Ruff-Formatter-發展中"><a href="#Ruff-Formatter-發展中" class="headerlink" title="Ruff Formatter 發展中"></a>Ruff Formatter 發展中</h3><p>而 Ruff linter 作為 Black 的替代方案，也會遇到相同的「困境」。不同於 Black，目前 Ruff linter 提供的是<code>quote-style</code>這個選項：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quote-style = <span class="string">&quot;single&quot;</span></span><br></pre></td></tr></table></figure><p>即使你選了 single，在上述的慣例部分，Ruff 還是會格式化為雙引號，不用擔心。</p><p>至於要不要像 Black 加上<code>skip-string-normalization</code>，目前似乎還沒有定論。</p><p>整體而言，這個議題仍然在持續中，有興趣可以關注這個 <a href="https://github.com/astral-sh/ruff/issues/7615">GitHub Issue 討論串</a>。</p><p>這裡只是提醒你，採用 Ruff formatter 會有「單、雙引號」議題（而且和 Black 的處理方式不完全相同）。</p><p>至少對我而言，這非常重要。</p><hr><p>接下來，我們要進入 Ruff 的「<strong>設定篇</strong>」。</p><h2 id="Ruff-設定篇"><a href="#Ruff-設定篇" class="headerlink" title="Ruff 設定篇"></a>Ruff 設定篇</h2><p>當要採用一個新的 linter、formatter 時（尤其站在團隊開發考量），以下這三個部分的支援成熟度，是我一定會慎重考慮的。</p><h3 id="設定檔（pyproject-toml-支援）"><a href="#設定檔（pyproject-toml-支援）" class="headerlink" title="設定檔（pyproject.toml 支援）"></a>設定檔（pyproject.toml 支援）</h3><p>不用說，複雜的工具都一定有自己的設定檔，讓你可以客製化一些需求。如果能支援 pyproject.toml 則會更受到我的青睞。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pyproject-toml/">Python 開發：pyproject.toml 介紹 + 使用教學</a></p></blockquote><h3 id="VS-Code-套件支援"><a href="#VS-Code-套件支援" class="headerlink" title="VS Code 套件支援"></a>VS Code 套件支援</h3><p>它能讓你在寫程式的同時，就能夠看到 linter 發出的警告，而不必等到 commit 之際才被 pre-commit 擋下來。</p><p>相較於 linter，<strong>formatter 更需要有自己的 VS Code 套件</strong>。讓你能直接在 VS Code 中進行格式化，而不用透過 CLI 指令或等到 pre-commit 時才自動修正。</p><p>而且，雖然你可以只用 Ruff 的 linter 功能，但因為有「autofix」存在，本質上它也是一個<strong>簡易（附帶）的格式化器</strong>，所以最好有 VS Code 整合。</p><h3 id="pre-commit-支援"><a href="#pre-commit-支援" class="headerlink" title="pre-commit 支援"></a>pre-commit 支援</h3><p>pre-commit 是團隊協作中一道重要的關卡，我在「<a href="https://blog.kyomind.tw/pre-commit/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E4%BD%BF%E7%94%A8-pre-commit%EF%BC%9F">為什麼要使用 pre-commit？</a>」中已有相當的闡述。</p><p>對於一個開發工具，我們主要關心的是：「它是否提供 pre-commit hook？」</p><hr><p>以上 3 點，Ruff 都有完整支援。下面就來一一解說。</p><h2 id="pyproject-toml-設定"><a href="#pyproject-toml-設定" class="headerlink" title="pyproject.toml 設定"></a>pyproject.toml 設定</h2><p>Ruff 總共支援三種設定檔：<code>pyproject.toml</code>、<code>ruff.toml</code>、<code>.ruff.toml</code>。</p><p>如果設定不算多，那我一律推薦放<code>pyproject.toml</code>。反之如果有大量的客製，那獨立一個設定檔可能是比較好的選擇。</p><p>如果不知道怎麼開始，參考<a href="https://docs.astral.sh/ruff/configuration/">文件</a>是最快上手的方式。文件中的範例內容同時有著註解式的解說。</p><p><strong>不過大部分時候，我們只需要設定一些基本的項目</strong>。比如以下是我目前的設定，包含了 linter 與 formatter 部分：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff]</span></span><br><span class="line"><span class="attr">line-length</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">select</span> = [<span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;UP&quot;</span>]</span><br><span class="line"><span class="attr">target-version</span> = <span class="string">&quot;py310&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.format]</span></span><br><span class="line"><span class="attr">quote-style</span> = <span class="string">&quot;single&quot;</span></span><br></pre></td></tr></table></figure><h3 id="設定解說"><a href="#設定解說" class="headerlink" title="設定解說"></a>設定解說</h3><p>首先，因為在<code>pyproject.toml</code>中，所以設定的 key 定是<code>[tool.xxx]</code>格式。</p><p>Linter 部分，一些基本的設定比如<code>line-length</code>和 Flake8 類似。其中<code>select</code>和沒有列出的<code>ignore</code>相對重要。</p><p>Ruff 預設只會顯示 <code>E</code> 和 <code>F</code> 系列的錯誤訊息（而 Flake8 還有 <code>W</code> 系列）。想要增加或排除特定部分的錯誤訊息警示（包含 autofix），就得透過上述兩個欄位調整。比如：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff.lint]</span></span><br><span class="line"><span class="comment"># 1. Enable flake8-bugbear (`B`) rules, in addition to the defaults.</span></span><br><span class="line"><span class="attr">select</span> = [<span class="string">&quot;E4&quot;</span>, <span class="string">&quot;E7&quot;</span>, <span class="string">&quot;E9&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Avoid enforcing line-length violations (`E501`)</span></span><br><span class="line"><span class="attr">ignore</span> = [<span class="string">&quot;E501&quot;</span>]</span><br></pre></td></tr></table></figure><p>在我的設定中，<code>select</code>加上了<code>I</code>和<code>UP</code>。分別代表了 isort 和 pyupgrade。一旦你開啟了它們，Ruff 就會提示相關錯誤，並在有錯誤時自動修正。（autofix 預設為開啟）</p><p>因為開啟了<code>UP</code>，所以我必須設定<code>target-version</code>（這裡為<code>py310</code>），意味著 Ruff 會將程式碼中<strong>舊的寫法</strong>自動轉換（autofix）為 Python 3.10 的寫法。</p><p>總之，可設定的項目非常豐富。</p><hr><h2 id="Ruff-VS-Code-套件設定"><a href="#Ruff-VS-Code-套件設定" class="headerlink" title="Ruff VS Code 套件設定"></a>Ruff VS Code 套件設定</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=charliermarsh.ruff">Ruff 的 VS Code 套件</a>在 2022 年 12 月首次發表。</p><p>說真的，如果一個全新的 linter 或 formatter 沒有相關的 VS Code 套件，我絕不會考慮使用。</p><p>套件的重要性前面有提過，在此再次闡述：</p><ul><li>Linter：在 IDE 中有直接的提示，不必等到 commit 才發現錯誤。</li><li>Formatter：直接執行格式化（尤其配合「<strong>存檔時格式化</strong>」），不需透過指令。</li></ul><p>絕大部分情況下，linter 提示的錯誤都會直接被 formatter 自動修正，感覺上沒有開啟 linter 提示似乎也無妨？</p><p>但是，兩者在少數時候會有<strong>不同的行為</strong>，所以我認為 linter 的提示仍是必要的。</p><p>當然，另一方面也因為我已習慣看 linter 提示👀——沒有會很不自在！</p><h3 id="安裝與設定-Ruff-套件"><a href="#安裝與設定-Ruff-套件" class="headerlink" title="安裝與設定 Ruff 套件"></a>安裝與設定 Ruff 套件</h3><p>套件安裝後就可以直接使用，如果你的專案中已有專屬的 Ruff 設定檔，我覺得<strong>不需要再特別設定</strong> VS Code Ruff 套件部分。</p><p>不過還是提供我的設定：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ruff.lint.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;--line-length=100&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.organizeImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.fixAll&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.showNotifications&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onError&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="建議設定-Python-行為"><a href="#建議設定-Python-行為" class="headerlink" title="建議設定 Python 行為"></a>建議設定 Python 行為</h3><p>Ruff 套件我覺得不設定也沒關係，有設定檔就夠了。</p><p>除非你不想要為每個專案一一建立 Ruff 設定檔，那就還是得弄一下（會套用到每一個專案）。同時也要考慮不同專案間的設定衝突問題——使用者全局設定 vs 專案設定。</p><p>相對的，VS Code 的 Python 部分則建議一定要設定。</p><p>這部分的具體內容，Ruff 套件首頁也有完整說明。我們直接看最完整的版本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;[python]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;source.organizeImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;charliermarsh.ruff&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>效果：</p><ol><li><code>editor.formatOnSave</code>：存檔時自動格式化（對所有 formatter 都有效）。</li><li><code>source.fixAll</code>：存檔時自動 fix。（類似 pre-commit 時，hook 的自動修正）</li><li><code>source.organizeImports</code>：存檔時自動排序 imports。</li></ol><p>我想上述這些 Python 設定才是 Ruff 在 VS Code 中流暢使用的重點。</p><h3 id="不同專案間切換"><a href="#不同專案間切換" class="headerlink" title="不同專案間切換"></a>不同專案間切換</h3><p>還有一個小細節，就是專案之間的切換問題。</p><p>因為不一定每個專案都用 Ruff。比如我，只在個人專案使用 Ruff，但工作上還沒有。或是相反的情況。</p><p>此時記得要把可能發生衝突的 VS Code 套件（主要是 linter 和 isort）在「工作區」範圍內停用！做法如下圖。不然 linter 部分很可能一起運作，產生意料之外的結果。</p><p><img src="https://i.imgur.com/lknGhsJ.png"></p><p>Formatter 部分，因為每個專案只能選定一種格式化器，比較沒有衝突問題。</p><hr><h2 id="pre-commit-設定"><a href="#pre-commit-設定" class="headerlink" title="pre-commit 設定"></a>pre-commit 設定</h2><p>pre-commit 設定相對單純，更細部的行為，hook 會自動讀取設定檔中的內容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/astral-sh/ruff-pre-commit</span></span><br><span class="line">  <span class="attr">rev:</span> <span class="string">v0.1.4</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--fix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff-format</span></span><br></pre></td></tr></table></figure><p>這裡只要注意版本和 hook 的 id 即可。</p><hr><h2 id="Ruff-設定篇小結"><a href="#Ruff-設定篇小結" class="headerlink" title="Ruff 設定篇小結"></a>Ruff 設定篇小結</h2><p>Ruff 的設定真的滿多樣且可以很複雜——儘管它的預設值已能滿足大多數人。</p><p>如果你不清楚究竟有哪些項目可以調整，又想了解更多。除了研究官方文件、Github 首頁的 README 外，去看看那些<a href="https://github.com/astral-sh/ruff?tab=readme-ov-file#whos-using-ruff">已經採用了 Ruff  的開源專案</a>的設定檔，也是很好的學習！</p><p>比如，我就習慣參考 <a href="https://github.com/tiangolo/fastapi/blob/master/pyproject.toml#L125">FastAPI 的 Ruff 設定</a>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff]</span></span><br><span class="line"><span class="attr">select</span> = [</span><br><span class="line">    <span class="string">&quot;E&quot;</span>,  <span class="comment"># pycodestyle errors</span></span><br><span class="line">    <span class="string">&quot;W&quot;</span>,  <span class="comment"># pycodestyle warnings</span></span><br><span class="line">    <span class="string">&quot;F&quot;</span>,  <span class="comment"># pyflakes</span></span><br><span class="line">    <span class="string">&quot;I&quot;</span>,  <span class="comment"># isort</span></span><br><span class="line">    <span class="string">&quot;C&quot;</span>,  <span class="comment"># flake8-comprehensions</span></span><br><span class="line">    <span class="string">&quot;B&quot;</span>,  <span class="comment"># flake8-bugbear</span></span><br><span class="line">    <span class="string">&quot;UP&quot;</span>,  <span class="comment"># pyupgrade</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="attr">ignore</span> = [</span><br><span class="line">    <span class="string">&quot;E501&quot;</span>,  <span class="comment"># line too long, handled by black</span></span><br><span class="line">    <span class="string">&quot;B008&quot;</span>,  <span class="comment"># do not perform function calls in argument defaults</span></span><br><span class="line">    <span class="string">&quot;C901&quot;</span>,  <span class="comment"># too complex</span></span><br><span class="line">    <span class="string">&quot;W191&quot;</span>,  <span class="comment"># indentation contains tabs</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.isort]</span></span><br><span class="line"><span class="attr">known-third-party</span> = [<span class="string">&quot;fastapi&quot;</span>, <span class="string">&quot;pydantic&quot;</span>, <span class="string">&quot;starlette&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.pyupgrade]</span></span><br><span class="line"><span class="comment"># Preserve types, even if a file imports `from __future__ import annotations`.</span></span><br><span class="line"><span class="attr">keep-runtime-typing</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>而且 FastAPI 真的很貼心，還加了註解！</p><hr><h2 id="工作上我還未採用-Ruff-的理由"><a href="#工作上我還未採用-Ruff-的理由" class="headerlink" title="工作上我還未採用 Ruff 的理由"></a>工作上我還未採用 Ruff 的理由</h2><p>結語之前，講講我在一番研究後，仍未建議團隊在此刻就採用 Ruff 的理由。</p><p>放到最後不是為了賣關子，而是看到這裡，你應該比較能夠理解其中的顧慮。</p><p>主要有三個。</p><h3 id="一、設定相對複雜"><a href="#一、設定相對複雜" class="headerlink" title="一、設定相對複雜"></a>一、設定相對複雜</h3><p>首先我覺得 Ruff 的設定太多樣了，畢竟它一口氣整合了這麼多的工具。</p><p>而且要同時考慮 pyproject.toml、VS Code、pre-commit 的整合，加上各種 linter 在設定上的開關，想想有點頭痛。</p><p>這會帶來一定的認知負擔，同事可能會覺得「搞這些真的有必要嗎？」——其實我也這麼想🤣</p><h3 id="二、需求不足"><a href="#二、需求不足" class="headerlink" title="二、需求不足"></a>二、需求不足</h3><p>我們目前的專案最多只能算中型，用「Flake8 + isort + Black Formatter」經典組合已能運作良好。改用 Ruff，可能看不出太大差別。</p><p>如果看不出差別，設定又要重新調整、學習，難免讓人卻步。</p><h3 id="三、讓子彈再飛一會兒"><a href="#三、讓子彈再飛一會兒" class="headerlink" title="三、讓子彈再飛一會兒"></a>三、讓子彈再飛一會兒</h3><p>說起來，前兩個理由並不算什麼重大阻礙，只是也沒有明顯的動力。</p><p>我打算等 Ruff formatter 的「beta」字樣拿掉後，直接「一換三」一次到位。</p><p>所以，不妨讓子彈再飛一會兒。</p><hr><h2 id="結語：Time-to-Ruff"><a href="#結語：Time-to-Ruff" class="headerlink" title="結語：Time to Ruff"></a>結語：Time to Ruff</h2><p>Ruff 現階段對我的重要性，顯然還遠不如 <a href="https://blog.kyomind.tw/python-poetry/">Poetry 套件管理器</a>。但這樣的工具依舊讓人興奮且充滿期待。</p><p>我並不認為目前的 Python 開發一定要用上 Ruff，但值得你嘗試一下。</p><p>如果你也是一個 Code Formatting 愛好者，那麼 Ruff 絕對是一個值得你花時間研究的工具。</p><p>更重要的是，由 Rust 所引發的 Python 生態革命，現在才剛剛開始。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/klPlw0x.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/astral-sh/ruff&quot;&gt;Ruff&lt;/a&gt; 從去年（2022）6 月正式開源起算，已過去一年半，知道此工具的開發者也愈來愈多。雖然在去年就聽過它，但我卻一直沒有任何行動。&lt;/p&gt;
&lt;p&gt;隨著前陣子 &lt;a href=&quot;https://github.com/astral-sh/ruff/releases/tag/v0.1.0&quot;&gt;v0.1.0&lt;/a&gt; 的發布（先別覺得這版本號怎麼乍看像早期測試版本🤣，畢竟前一版可是 v0.0.292），我覺得時機已到，所以進行了一番研究、嘗試，於是有了本文的誕生。&lt;/p&gt;
&lt;h3 id=&quot;本文目錄&quot;&gt;&lt;a href=&quot;#本文目錄&quot; class=&quot;headerlink&quot; title=&quot;本文目錄&quot;&gt;&lt;/a&gt;本文目錄&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B7%A3%E8%B5%B7&quot;&gt;緣起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85&quot;&gt;本文主旨與目標讀者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Why-Ruff%EF%BC%9F&quot;&gt;Why Ruff？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC&quot;&gt;本文範例程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E4%BB%8B%E7%B4%B9%E7%AF%87&quot;&gt;Ruff 介紹篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Linter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Flake8-%E8%88%87-isort-%E7%AD%89%E7%AD%89&quot;&gt;Linter 部分：取代 Flake8 與 isort 等等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Formatter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Black&quot;&gt;Formatter 部分：取代 Black&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%96%AE%E3%80%81%E9%9B%99%E5%BC%95%E8%99%9F%E8%AD%B0%E9%A1%8C&quot;&gt;單、雙引號議題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87&quot;&gt;Ruff 設定篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pyproject-toml-%E8%A8%AD%E5%AE%9A&quot;&gt;pyproject.toml 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;##Ruff-VS-Code-%E5%A5%97%E4%BB%B6%E8%A8%AD%E5%AE%9A&quot;&gt;Ruff VS Code 套件設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pre-commit-%E8%A8%AD%E5%AE%9A&quot;&gt;pre-commit 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87%E5%B0%8F%E7%B5%90&quot;&gt;Ruff 設定篇小結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1&quot;&gt;工作上我還未採用 Ruff 的理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B5%90%E8%AA%9E%EF%BC%9ATime-to-Ruff&quot;&gt;結語：Time to Ruff&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    <content src="https://i.imgur.com/klPlw0x.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Flake8" scheme="https://blog.kyomind.tw/tags/Flake8/"/>
    
    <category term="isort" scheme="https://blog.kyomind.tw/tags/isort/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
    <category term="Black Formatter" scheme="https://blog.kyomind.tw/tags/Black-Formatter/"/>
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
    <category term="Ruff" scheme="https://blog.kyomind.tw/tags/Ruff/"/>
    
  </entry>
  
  <entry>
    <title>24，收回「發文計畫」</title>
    <link href="https://blog.kyomind.tw/weekly-review-24/"/>
    <id>https://blog.kyomind.tw/weekly-review-24/</id>
    <published>2023-11-03T18:22:04.000Z</published>
    <updated>2024-01-02T02:45:59.835Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/mmEzb21.png"></p><p>你現在看網站的選單，已經沒有「發文計畫」了。</p><p>至於那是什麼，可以參考上一期〈<a href="https://blog.kyomind.tw/weekly-review-23/">23，Blog 新增「發文計畫」與我的思路</a>〉。</p><p>這篇就來解釋，為什麼它失敗了，與我的一點想法。</p><span id="more"></span><hr><h2 id="結束的理由"><a href="#結束的理由" class="headerlink" title="結束的理由"></a>結束的理由</h2><p>先簡單回顧一下，發文計畫的兩大初衷：</p><ol><li>可預見性。</li><li>公開承諾。</li></ol><p>從這一個多月的實施結果來看，上述這兩件事情，基本都搞砸了。</p><h3 id="可預見但不可信"><a href="#可預見但不可信" class="headerlink" title="可預見但不可信"></a>可預見但不可信</h3><p>首先是可預見，這確實有一定的效果。畢竟我把接下來的要寫的東西，都先公開其中。</p><p>但是，很多文章（尤其是較長的內容）的發文日期，卻是一延再延，如此一來，即使可預見，也沒有太大的參考價值。</p><h3 id="無法兌現的承諾"><a href="#無法兌現的承諾" class="headerlink" title="無法兌現的承諾"></a>無法兌現的承諾</h3><p>既然文章發布日可以一延再延，那公開承諾就沒有了原來想像的拘束力（至少在心理上沒有足夠的拘束力）。</p><p>如此一來，想透過公開承諾培養一定紀律的期待，也就落了空。</p><h2 id="收穫與反省"><a href="#收穫與反省" class="headerlink" title="收穫與反省"></a>收穫與反省</h2><p>其實，並不是所有的文章都是一延再延。</p><h3 id="意料之外的收穫"><a href="#意料之外的收穫" class="headerlink" title="意料之外的收穫"></a>意料之外的收穫</h3><p>有一部分文章，反而因為有了這份「發文行事曆」，而事先完成了！這實在超乎了我的預料，可謂意外的驚喜。</p><blockquote><p>這是我少數能感受到「計畫」強大威力的時刻。</p></blockquote><p>不過，即使已經完稿，我通常還是會等到上面寫的發文日期才正式公開。</p><p>這是好的部分。</p><h3 id="問題反省"><a href="#問題反省" class="headerlink" title="問題反省"></a>問題反省</h3><p>但是，那些真正「困難」的文章（主要是技術相關的長篇文章），我卻還是一拖再拖，直接架空了這個行事曆。</p><p>我也真正了解到，除非我有辦法真正降低這些主題的寫作門檻，或許找到其它更有效的創作手段。</p><p>不然面對這些棘手的主題，常常就是一逃再逃。</p><p>本來我是這麼說的：</p><blockquote><p>公開承諾會<strong>強化其中的痛苦</strong>，讓我對這樣的拖延感到壓力。</p></blockquote><p>確實如此，但從結果看來，這樣的壓力，還是不足以讓我按時完成！</p><hr><p>既然事與願違，索性還是撤掉了。</p><p>此外，網站的選單部分我一向是寸土寸金，捨不得增加太多雜訊。</p><p>既然發文計畫無法達到當初的期待，又佔據了選單列表，我還是選擇拿掉。不再公開。</p><h2 id="行事曆是好東西"><a href="#行事曆是好東西" class="headerlink" title="行事曆是好東西"></a>行事曆是好東西</h2><p>儘管如此，我發現「發文行事曆」確實是很棒的規劃工具，尤其是可以「拖曳」這個特性，令人愛不釋手。</p><p>一直把日期後延，對讀者很不好意思，所以我只能「關門」。但如果只有我自己的話，行事曆仍不失為稱手好用的發文管理利器！</p><p>這和「僅把待發表文章列在清單中」的感覺，截然不同。推薦你也試試。</p><hr><h2 id="總結與重新思考"><a href="#總結與重新思考" class="headerlink" title="總結與重新思考"></a>總結與重新思考</h2><p>整體而言，我目前的寫作還是略嫌發散了，主要受到三股勢力的牽引：</p><ol><li><strong>有流量的內容</strong>：主要就是筆記軟體類的文章。當然，我也確實熱衷於此。</li><li><strong>我感興趣的內容</strong>：通常是個人價值觀的闡述。</li><li><strong>我認為自己可以寫好，也值得好好寫的內容</strong>：程式類文章。</li></ol><p>上述三者雖然不算涇渭分明，但仍有一定的排它性。</p><p>然而時間就這麼多，我必須有所取捨。而現在的我，還做得不夠好。</p><blockquote><p><strong>講白了就是太貪心！</strong></p></blockquote><p>所以我應該會<strong>減少發文量</strong>。把主要精力集中在<strong>中長篇內容</strong>，尤其是那些我常常想要逃避的主題。</p><p>這類文章往往需要很大的心力來創作，但也是真正具有「<a href="https://blog.kyomind.tw/a-mind-for-blogs/#%E4%BA%8C%E3%80%81%E5%8F%96%E6%8D%A8%E4%BB%A5%E7%AA%81%E9%A1%AF">自我代表性</a>」的作品。</p><p>至於發文頻率，則不再強求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mmEzb21.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;你現在看網站的選單，已經沒有「發文計畫」了。&lt;/p&gt;
&lt;p&gt;至於那是什麼，可以參考上一期〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-23/&quot;&gt;23，Blog 新增「發文計畫」與我的思路&lt;/a&gt;〉。&lt;/p&gt;
&lt;p&gt;這篇就來解釋，為什麼它失敗了，與我的一點想法。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/mmEzb21.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>《Python 功力提升的樂趣》筆記（三）函式、註解、docstring</title>
    <link href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/"/>
    <id>https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/</id>
    <published>2023-10-21T08:46:34.000Z</published>
    <updated>2024-02-28T04:47:28.329Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/tS78Ke0.png" alt="Python 功力提升的樂趣"><span class="cap">Python 功力提升的樂趣</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務</a>》閱讀筆記的第 3 篇，也是最後一篇。</p><p>你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>本文整理書中的第 10、11 章，而且篇幅幾乎集中在前者。畢竟無論什麼語言，「<strong>寫好函式</strong>」這件事總是如此重要，Python 自然也不例外。</p><h3 id="系列：Python-功力提升的樂趣"><a href="#系列：Python-功力提升的樂趣" class="headerlink" title="系列：Python 功力提升的樂趣"></a>系列：Python 功力提升的樂趣</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a></li><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-02/">《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱</a></li><li><strong>《Python 功力提升的樂趣》筆記（三）函式、註解、docstring</strong></li></ol></blockquote><hr><h2 id="第-10-章：寫出有效率的函式"><a href="#第-10-章：寫出有效率的函式" class="headerlink" title="第 10 章：寫出有效率的函式"></a>第 10 章：寫出有效率的函式</h2><p>有效率的函式（或說「<strong>好的</strong>」函式）需要你在「<strong>命名、規模大小（行數）、參數數量和複雜性</strong>」之間，做出許多決定和<strong>取捨</strong>。</p><p>這無疑是極具挑戰的事——尤其是取捨。</p><p>人生之難，就難在取捨。</p><p>本章探討的正是這些取捨之間的利弊得失，以及編寫函式的重要原則。不用說，絕對是關鍵的一章。</p><span id="more"></span><hr><h2 id="函式的規模：小就是好？"><a href="#函式的規模：小就是好？" class="headerlink" title="函式的規模：小就是好？"></a>函式的規模：小就是好？</h2><p>我們都聽過「函式應該盡可能簡單、一次只做一次件事」之類的建言，也表示認同。從這個精神出發，太大或太複雜的函式就應該要進行拆分。</p><p>但！事實是，有效拆分函式是一件耗神、講究細節，且沒有標準答案的事。以致於我們即使知道，也很難完全貫徹，包括我自己。</p><p>出於各種原因，我們常常對現實世界作出一定的妥協。</p><h3 id="小函式的優點"><a href="#小函式的優點" class="headerlink" title="小函式的優點"></a>小函式的優點</h3><p>有些人覺得任何函式都不應該超過 20 行，甚至 10、5 行😂。因為函式「短」往往有下面這些優點：</p><ul><li>單一函式容易理解</li><li>較少的參數（這確實非常重要！）</li><li>易於測試與除錯</li></ul><h3 id="小函式的缺點"><a href="#小函式的缺點" class="headerlink" title="小函式的缺點"></a>小函式的缺點</h3><p>但小也有缺點：</p><ul><li>一樣的邏輯，更小的函式也意味著「更多」的小函式</li><li>函式愈多，結構就愈複雜。即「函式間」的關係會變得更加複雜</li><li>愈多函式，函式間的精準命名將成為巨大的挑戰——這真的很困難！</li></ul><p>這些「缺點」往往也解釋了為何我們不一定那麼積極拆分函式，讓每一個函式都符合「一次只做一件事」原則。</p><p>尤其是小函式造成的大量命名問題，對於命名很講究的我而言，有時確實感到棘手。</p><h3 id="小結：小不等於短"><a href="#小結：小不等於短" class="headerlink" title="小結：小不等於短"></a>小結：小不等於短</h3><p>函式原則上還是應該要盡可能單純一點，該拆就要拆，但不一定要很短。而且其中必然會有很多挑戰。</p><p>從「功能」上去劃分界限、拆分函式，會更有意義與指導性，與可行性。</p><p>作者認為，一味追求短函式，確實可以讓各別函式變得簡單，但卻很可能讓程式的「整體」變得複雜，適得其反。</p><p>他的經驗是，理想情況下，函式最好少於 30 行，最多不超過 200 行。<strong>讓函式在合理情況下盡可能短少</strong>，但不只是為了短少而縮減。</p><hr><h2 id="返回值（return）應該都要有相同的資料型別"><a href="#返回值（return）應該都要有相同的資料型別" class="headerlink" title="返回值（return）應該都要有相同的資料型別"></a>返回值（return）應該都要有相同的資料型別</h2><p>對此，我想說：</p><blockquote><p><strong>這真的好重要啊！</strong>（吶喊）</p></blockquote><p>卻常常沒有被好好遵守。</p><p>簡言之，為確保函式的「<strong>可預測性</strong>」，我們應該努力讓函式只回傳「<strong>單一資料型別</strong>」的值。比如<strong>總是</strong>回傳整數或字串，而不要有時回傳字串，有時則回傳布林值。</p><p>這不一定容易做到，但我更常遇到的情況是：<strong>明明有替代方案讓回傳型別單一化，卻沒有善用。</strong></p><h3 id="以False代替raise"><a href="#以False代替raise" class="headerlink" title="以False代替raise"></a>以<code>False</code>代替<code>raise</code></h3><p>最常見的例子就是：<strong>該拋出錯誤時候，卻只用<code>return False</code> 替代</strong>。</p><p>意即，當函式正常執行時，回傳一般正常的 output 值。但當執行失敗時，卻是回傳<code>False</code>——這簡直令人髮指，而且我相信你一定看過這樣的函式。</p><p>必須說明，發生錯誤時不拋出而選擇<code>return False</code>未必總是不好的，就像 Django REST framework 序列化器的<code>is_valid</code>方法，預設也是返回一個布林值（可以用<code>raise_exception=True</code>參數改為直接拋出錯誤），方便你進行更多後續操作。</p><p>不過，<strong>如果你選擇在遇到錯誤時<code>return False</code>，則應該在函式正確執行時，<code>return True</code>，</strong>以保持回傳型別的一致性。</p><p>而且<strong>函式命名</strong>也要跟著配合，讓人一看就知曉<strong>該函式、方法會返回一個布林值</strong>，比如上述的<code>is_valid</code>，或常見的<code>has_permission</code>、<code>is_authenticated</code>等。這些都是常見的最佳實踐。</p><h3 id="錯誤示範"><a href="#錯誤示範" class="headerlink" title="錯誤示範"></a>錯誤示範</h3><p>我們看一下這個錯誤示範：假設我們有一個函式，其目的是從一個<code>JSON</code>文件中讀取配置資訊。如果讀取成功，它會返回一個 Python 字典；如果讀取失敗，它會捕捉異常並返回<code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_config_from_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            config = json.load(f)</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 這裡是問題所在</span></span><br></pre></td></tr></table></figure><p>這個函式在<code>except</code>區塊裡面直接返回<code>False</code>，這會導致以下問題：</p><ol><li><strong>資料型別不一致</strong>：正常情況下返回一個字典，異常情況下返回<code>False</code>（布林值）。</li><li><strong>誤導函式使用者</strong>：使用者可能會誤以為<code>False</code>是一個有效的配置，進而嘗試在其上進行操作，這會導致更多的錯誤。</li><li><strong>後續處理困難</strong>：函式使用者必須額外檢查返回值是否為<code>False</code>，然後再決定是否進行後續的操作。</li></ol><hr><p>其實「<code>return</code>型別不確定」肯定不只發生在例外處理，但它<strong>確實「很常發生」在例外處理</strong>，因為我看過<strong>不止一次</strong>類似的真實案例。</p><p>很多人本能地會這樣寫，這往往是因為不習慣、不擅長處理錯誤，所以想要用自己平常更熟悉的<code>False</code>。</p><p>除此之外，還有「函式正常執行回傳一個類別物件，失敗時回傳一個 Python tuple——包含錯誤代碼和錯誤訊息」這種非常<strong>反直覺</strong>的設計。彷彿是在告訴我們：</p><blockquote><p>這個函式的回傳值，可能是一個物件，也可能是一個 tuple，<strong>你自己判斷吧！</strong></p></blockquote><p>會寫出這樣的函式，原因諸多——工作很忙、重構太麻煩了，要新增什麼功能我直接「加上去」就好！</p><p><strong>充滿了技術債味的寫法。</strong></p><h2 id="技術債與認知負擔"><a href="#技術債與認知負擔" class="headerlink" title="技術債與認知負擔"></a>技術債與認知負擔</h2><p>這類「<strong>雙型別 return</strong>」的函式，對於<strong>函式使用者</strong>（有可能是你的同事）的認知，有著「<strong>更高的要求</strong>」——呼叫方必須很了解這個函式的<strong>怪異行為</strong>，才能正確使用與處理後續衍生的問題。</p><p>這在多行或有多個 return 值的<strong>複雜函式時，真是一場災難。</strong></p><blockquote><p>期望他人知道自己做了什麼「特別的事」，不是我所知曉的軟體開發之道。</p></blockquote><p>當函式具有這種「雙型別 return」的特性時，會明顯增加呼叫方的「<strong>認知負擔</strong>」。</p><p>這使得程式<strong>不僅難以閱讀和維護，也容易出錯</strong>，因為未來的維護者或其他團隊成員<strong>很可能不知道</strong>這個函式的「獨特」行為。</p><p>無論何時，我們都不應該寫這樣的程式。</p><hr><h2 id="我對寫好函式的基本看法"><a href="#我對寫好函式的基本看法" class="headerlink" title="我對寫好函式的基本看法"></a>我對寫好函式的基本看法</h2><p>寫好函式的重點實在太多了，而本文的篇幅有限，只能擇要為之。</p><p>我也講講我認為函式的撰寫中，最重要的兩點。</p><p>至少遵守這兩點，你的同事會很感激你。</p><h2 id="一、Docstring-真的很重要"><a href="#一、Docstring-真的很重要" class="headerlink" title="一、Docstring 真的很重要"></a>一、Docstring 真的很重要</h2><p>其一是盡可能地寫 docstring，這不容易，畢竟維護 docstring 也需要心力。</p><blockquote><p>Docstring 就跟所有開發文件一樣——自己很懶得寫，但如果我想調用別人寫好的程式時，卻希望它們越詳細越好。</p></blockquote><p>而且 docstring 也不是有寫就行，還需要從「<strong>讀者</strong>（也就是你的同事）」的角度去思考與表達。不然看起來會很像開發者的自言自語——沒人看得懂。</p><p>然而我也承認，為所有的模組、類別、函式寫 docstring，未免有點不切實際。在眾多函式中，下列兩種是我認為<strong>一定要寫 docstring</strong> 的：</p><ol><li><strong>專案「自定義」成份濃厚</strong>：除了開發者本人，沒人知道這段程式在幹什麼。這通常源於特殊的業務需求，而且往往行數超多、邏輯超手刻，各種 if&#x2F;else、for 迴圈滿天飛，aka——<strong>沒人想看的程式碼</strong>。</li><li><strong>流程相對複雜</strong>的函式：愈複雜就愈難理解，這時候 docstring 就是你的好朋友。用文字描述函式的<strong>輸入、輸出、邏輯</strong>，能大大提升我們理解程式碼的效率。</li></ol><p>畢竟，看<strong>有描述性的文字</strong>，總比看一長串程式碼，要簡單且友善得多。</p><p>上述兩種情況，若不寫 docstring，那麼<strong>閱讀程式碼的成本</strong>就會大大提升。這相當於在告訴你的同事：</p><blockquote><p>我離開公司後，誰還想維護這段程式碼，先學習<strong>通靈之術</strong>吧！</p></blockquote><p>關於我對 docstring 的其它討論，可以參考這兩個部分：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E8%A8%BB%E8%A7%A3%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%EF%BC%9F">註解是不需要的？</a></li><li><a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a></li></ul><p>我的觀點一向如此：<strong>不寫好 docstring，就稱不上是一流的 Python 開發者。</strong></p><hr><h2 id="二、函式的行為與命名要一致"><a href="#二、函式的行為與命名要一致" class="headerlink" title="二、函式的行為與命名要一致"></a>二、函式的行為與命名要一致</h2><p>其二，好的函式要「言行一致」。</p><p>你可能會想：</p><blockquote><p>這不是理所當然的嗎？</p></blockquote><p>對，它<strong>「本應該」是理所當然</strong>的，畢竟這不就是函式命名的基本目的？——用來描述函式的行為。</p><p>但我們可以回想一下自己在工作中遇到的各式各樣函式，究竟有多少比例，是真正做到「言行一致」？我覺得可能只有一半。</p><p>或許你會認為「一半」也太誇張了！但我並不這麼想。</p><p>「言行不一致」通常有下面幾種症狀：</p><ol><li>函式名稱只表達了函式「<strong>部分</strong>」的行為。也就是函式做了超過它宣稱要做的事，比如「驗證欄位」函式，竟然還把驗證資料格式化了！</li><li>函式名稱「<strong>言過其實</strong>」，說要驗證加格式化，結果只做了一半。</li><li>名稱太模糊、缺乏業務邏輯描述、濫用技術詞彙等等，<strong>根本看不懂它在說什麼</strong>，更別說言行一致了。</li></ol><p>如果你不能從一個函式的名稱中<strong>有效理解並推測</strong>它應有的行為，那麼這個函式基本上就是失敗（或不健康）的。</p><p>很多時候，函式<strong>最初</strong>可能是「言行一致」的，但隨著後來的修改、刪除、擴充，實際上做的事情變更了，但命名卻沒有跟著改變、重構。</p><p>這些言行不一的函式，充滿<strong>誤導性</strong>，不斷地挑戰著你的認知、推理能力，更增加了維護成本。</p><p>這樣的例子還少嗎？恐怕每天都在發生。</p><hr><h2 id="第-11-章：注釋、docstring-和-type-hints"><a href="#第-11-章：注釋、docstring-和-type-hints" class="headerlink" title="第 11 章：注釋、docstring 和 type hints"></a>第 11 章：注釋、docstring 和 type hints</h2><p>這章我只摘錄書中的一段話——我特別欣賞與認同的部分：</p><blockquote><p>好的注釋對程式設計師在未來閱讀並理解程式碼作用時提供了簡潔、有用和準確的資訊。這些注釋應該<strong>用來解說程式設計師原本的意圖，並總結某程式碼的作用，而不是只對某行程式碼進行解說。</strong></p></blockquote><blockquote><p>注釋有時會詳細描述程式設計師在編寫程式碼時<strong>所得到的經驗教訓，這些寶貴的資訊可以讓將來的維護者不必再次經歷這些苦難。</strong></p></blockquote><p>說的太好了！</p><p>團隊寫程式，是關於溝通的藝術，畢竟《<a href="https://www.books.com.tw/products/0010254508">人月神話</a>》已經告訴我們：人多不一定比較快。</p><p>溝通不止發生在會議、Jira、Slack 和規格文件上，程式之內也有著大量的溝通，註解是如此，docstring 亦是如此。</p><p>永遠不要低估「對這些細節的用心」所帶能來的巨大影響力。</p><p>優秀的工程師絕不可能輕忽它們。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tS78Ke0.png&quot; alt=&quot;Python 功力提升的樂趣&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務&lt;/a&gt;》閱讀筆記的第 3 篇，也是最後一篇。&lt;/p&gt;
&lt;p&gt;你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;本文整理書中的第 10、11 章，而且篇幅幾乎集中在前者。畢竟無論什麼語言，「&lt;strong&gt;寫好函式&lt;/strong&gt;」這件事總是如此重要，Python 自然也不例外。&lt;/p&gt;
&lt;h3 id=&quot;系列：Python-功力提升的樂趣&quot;&gt;&lt;a href=&quot;#系列：Python-功力提升的樂趣&quot; class=&quot;headerlink&quot; title=&quot;系列：Python 功力提升的樂趣&quot;&gt;&lt;/a&gt;系列：Python 功力提升的樂趣&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/&quot;&gt;《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-02/&quot;&gt;《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;《Python 功力提升的樂趣》筆記（三）函式、註解、docstring&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第-10-章：寫出有效率的函式&quot;&gt;&lt;a href=&quot;#第-10-章：寫出有效率的函式&quot; class=&quot;headerlink&quot; title=&quot;第 10 章：寫出有效率的函式&quot;&gt;&lt;/a&gt;第 10 章：寫出有效率的函式&lt;/h2&gt;&lt;p&gt;有效率的函式（或說「&lt;strong&gt;好的&lt;/strong&gt;」函式）需要你在「&lt;strong&gt;命名、規模大小（行數）、參數數量和複雜性&lt;/strong&gt;」之間，做出許多決定和&lt;strong&gt;取捨&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這無疑是極具挑戰的事——尤其是取捨。&lt;/p&gt;
&lt;p&gt;人生之難，就難在取捨。&lt;/p&gt;
&lt;p&gt;本章探討的正是這些取捨之間的利弊得失，以及編寫函式的重要原則。不用說，絕對是關鍵的一章。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/tS78Ke0.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="閱讀筆記" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
    <category term="系列：Python 功力提升的樂趣" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%8A%9F%E5%8A%9B%E6%8F%90%E5%8D%87%E7%9A%84%E6%A8%82%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>2023 那些我已不可或缺的「付費訂閱」推薦</title>
    <link href="https://blog.kyomind.tw/essential-subscriptions-2023/"/>
    <id>https://blog.kyomind.tw/essential-subscriptions-2023/</id>
    <published>2023-10-10T16:12:10.000Z</published>
    <updated>2024-01-02T02:45:59.820Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/MDQYOVd.png" alt="DALL·E 3"><span class="cap">DALL·E 3</span></p><p>這篇要來講述，2023 年的當下，對我而言「具有一定重要性」的付費訂閱。</p><p>這屬於完全個人化的心得，我會列出那些不可或缺的訂閱項目，並解釋它們對我的重要性所在。</p><p>所謂的「不可或缺」，意思是一旦我停止訂閱，我的工作和生活都會出現挑戰。而挑戰的大小，就是這些訂閱項目對我的影響力與價值。</p><p>以下排名同時也是重要性排名，就讓我們從最重要的開始吧！</p><span id="more"></span><hr><h2 id="一、ChatGPT-Plus"><a href="#一、ChatGPT-Plus" class="headerlink" title="一、ChatGPT Plus"></a>一、ChatGPT Plus</h2><p>論重中之重，<a href="https://openai.com/blog/chatgpt-plus">ChatGPT Plus</a> 捨我其誰？</p><p>作為一個求知欲旺盛的軟體工程師，ChatGPT 對我而言可不是僅僅「提高工作效率」這麼簡單。</p><p>任何大大小小的事都能問它，而且總能給你一個<strong>相對明確</strong>的回答。在沒有它之前，這是我們無法奢求的。</p><p>所以，它帶給我的遠不只是效率，更是智識上的愉悅與滿足。</p><p>隨著 Plus 附加的功能愈來愈多，更別說最近加入的<a href="https://help.openai.com/en/articles/6825453-chatgpt-release-notes#h_e3a2ee7903">影像辨識</a>（<a href="https://openai.com/research/gpt-4v-system-card">GPT-4V</a>），與整合了 DALL·E 3 的<a href="https://www.ithome.com.tw/news/158860">繪圖功能</a>，我感覺這每月 20 美元的價值實在太過誇張。</p><p>如果你問我，我對這個服務目前為止的定價接受度上限為何？我可能會說是每月 40 美元——可見我確實離不開它。</p><h2 id="二、Setapp"><a href="#二、Setapp" class="headerlink" title="二、Setapp"></a>二、Setapp</h2><p><a href="https://setapp.com/">Setapp</a> 是訂閱制軟體服務，月付 10 美元，可以使用與之有合作的眾多軟體。</p><p>作為一個長期在 Mac 上開發的軟體工程師，Setapp 有好幾樣工具是我的日常必備。而且，考慮到「寫作」也是對我十分重要的生產活動，那它的價值就更加不言而喻了。目前我最常用的 app 有下：</p><ul><li><a href="https://cleanshot.com/">CleanShot X</a>：寫作截圖必備。</li><li><a href="https://www.popclip.app/">PopClip</a>：可以開發自己的外掛！</li><li><a href="https://www.macbartender.com/">Bartender</a>：Mac 上的工具列管理。</li><li><a href="https://pasteapp.io/">Paste</a>：剪貼簿大師！</li><li><a href="https://rapidapi.com/">RapidAPI</a>：Postman 替代品，目前個人使用已經免費。</li><li><a href="https://tableplus.com/">TablePlus</a>：SQL client，而且支持 MongoDB。</li></ul><p>我常用的 Setapp 軟體大概有十幾項，但提這些就足夠了。它們加起來的重要性，已經足以讓 Setapp 名列第二。</p><p>有興趣可以使用<a href="https://go.setapp.com/invite/ga4xxrhb">我的邀請連結</a>註冊，你、我皆可<strong>額外獲得一個月訂閱</strong>：</p><blockquote><p>If you continue with Setapp after your trial ends, <strong>both you and the friend who invited you will get a free month</strong>. That’s our referral program reward.</p></blockquote><h2 id="三、GitHub-Copilot"><a href="#三、GitHub-Copilot" class="headerlink" title="三、GitHub Copilot"></a>三、GitHub Copilot</h2><p>AI 寫程式助手，每月 10 美元，年付為 100 美元。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/github-copilot/">GitHub Copilot 心得——寫文章的利器？</a></p></blockquote><p>我自認不算非常充分利用它，即靠「大量寫註解提示」來讓它幫我生產大部分的程式碼——我不習慣如此。但它還是成為了我現在開發的不可或缺。</p><p>考慮到「寫程式」是我人生中的重要部分，我給它第三名。</p><p>如果不想花錢，可以考慮下面這個免費的替代方案：</p><ul><li><a href="https://codeium.com/">Codeium · Free AI Code Completion &amp; Chat</a></li></ul><h2 id="四、YouTube-Premium"><a href="#四、YouTube-Premium" class="headerlink" title="四、YouTube Premium"></a>四、YouTube Premium</h2><p>沒想到這東西會排第四吧！全因我是一個重度 YouTube 成癮者。</p><p>雖然我也有訂 Netflix，但它對我來說相對可有可無。</p><p>大概是現代生活的節奏讓我沒有足夠的耐心慢慢看一部劇了。</p><h2 id="五、TPASS（北北基桃）"><a href="#五、TPASS（北北基桃）" class="headerlink" title="五、TPASS（北北基桃）"></a>五、TPASS（北北基桃）</h2><p>行政院通勤月票，北北基桃版的月費為 1200 台幣。</p><p>今年 7 月入坑，我感覺這東西真該早點推出的！它帶來了「通勤自由」——我很喜歡這種感覺。曾經寫了一篇<a href="https://www.facebook.com/kyomind/posts/pfbid0jWRm5mfV9ZvN63sfm7j8b8bcWzLmavrjNFHXh1MqQieEjkJoi9DGCFJsAexHVinhl">臉書文</a>講述我的購買（訂閱）動機，可供參考。</p><p>使用至今 3 個月，我很滿意。</p><h2 id="六、Whoscall"><a href="#六、Whoscall" class="headerlink" title="六、Whoscall"></a>六、Whoscall</h2><p>由今年剛在台股上市的 <a href="https://gogolook.com/en">Gogolook</a>（走著瞧股份有限公司）出品，為手機過濾、警示來電號碼的服務。</p><p>作為一個接到推銷電話總是不好意思中斷對方發言的人，這工具對我著實不可或缺。</p><p>一樣，不想付錢的話，Android 手機使用者有 Google 提供的免費替代選項：</p><ul><li><a href="https://play.google.com/store/apps/details?id=com.google.android.dialer&hl=zh_TW">Google 開發的「電話」- 來電顯示和騷擾電話阻擋功能</a></li></ul><h2 id="七、DigitalOcean-VM"><a href="#七、DigitalOcean-VM" class="headerlink" title="七、DigitalOcean VM"></a>七、DigitalOcean VM</h2><p>開發者總是需要一台可以 24 小時對外連線的 VM，來部署一些 side project 或簡易服務，比如之前提到的〈<a href="https://blog.kyomind.tw/weekly-review-21/">21，在 VM 上部署 Umami 替代 GA4</a>〉。</p><p>接下來我會部署更多小專案在上面，所以十分必要。</p><h2 id="八、Google-One"><a href="#八、Google-One" class="headerlink" title="八、Google One"></a>八、Google One</h2><p>Gmail 信箱、Google 相簿等檔案太佔空間，免費額度滿了，訂了最小的 100 GB。</p><p>除非勤刪檔，不然不訂也不行。我選擇後者。</p><h2 id="九、Bear"><a href="#九、Bear" class="headerlink" title="九、Bear"></a>九、Bear</h2><p>筆記軟體 <a href="https://bear.app/">Bear</a> 對我來算是一個「超級加分項」，雖然不算絕對必要，但我願意訂閱，因為它讓我的生活更美好。</p><p>值得一提的是，它的「<strong>同步方案</strong>」採用 Apple 提供的 <a href="https://developer.apple.com/icloud/cloudkit/">CloudKit</a>，在<strong>個人隱私保護</strong>部分明顯優於 Notion、Evernote 等服務。</p><p>有興趣可以看<a href="https://www.reddit.com/r/bearapp/comments/porntu/is_bear_more_secure_than_apple_notes/">這則討論</a>。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/bear/">Evernote 最佳替代方案——筆記軟體 Bear 2 升級心得</a></p></blockquote><h2 id="十、Medium"><a href="#十、Medium" class="headerlink" title="十、Medium"></a>十、Medium</h2><p>主要就是看程式文章用！</p><p>Medium 雖然不是一個開發者平台，但上面還是有許多優質的程式類文章。</p><p>尤其和 <a href="https://dev.to/">DEV Community</a> 這類偏開發者的平台相比，Medium 的文章有一個比較明顯的特色，那就是不完全純技術取向，也有多軟體趨勢、職涯類的文件。</p><p>要說缺點，我認為有很多標題都太聳動了！點進去看，根本雷聲大雨點小，真的是很會「騙」讀者。😈</p><h2 id="十一、Microsoft-365"><a href="#十一、Microsoft-365" class="headerlink" title="十一、Microsoft 365"></a>十一、Microsoft 365</h2><p>訂這個主要是擔心需要開 Office 類檔案——但實際上我似乎完全沒有這類檔案的開啟需求。</p><p>目前對我的實際作用，只有那 1 TB 的 OneDrive。</p><p>因為是家庭方案，不算貴，所以聊勝於無。</p><h2 id="十二、極客時間超級會員"><a href="#十二、極客時間超級會員" class="headerlink" title="十二、極客時間超級會員"></a>十二、極客時間超級會員</h2><p>來自中國的線上學習平台，聚焦在軟體開發，主要以聲音和文字檔為媒介，相當於程式版的「得到 app」。</p><p>前 2 年推出了「<a href="https://time.geekbang.org/hybrid/next/pvip/home">超級會員</a>」這個「吃到飽」服務，可以存取平台 8 成以上的課程。但沒過多久就大幅漲價了（人民幣 499&#x2F;699→2999），還好我也陸續聽了幾十個課程。雖然不算很認真聽，但至少知道哪些課適合自己，以後可以單買。</p><p>考慮到漲價後已然太貴，而且該聽的課其實都差不多了，之後不會再續訂。</p><p>用聽聲音、看文字稿學習程式，當然不是一個特別有效的做法。主要作為「吸收新知」的手段，我覺得還算不錯。</p><hr><h2 id="「內容創作型」付費訂閱"><a href="#「內容創作型」付費訂閱" class="headerlink" title="「內容創作型」付費訂閱"></a>「內容創作型」付費訂閱</h2><p>扣除 Medium 這種「平台式」的內容創作訂閱。在《科技島讀》之後，就沒有我特別感興趣的「<strong>持續性個人創作</strong>」付費訂閱。</p><p>得到 app 上的萬維鋼《精英日課》我每一季都有訂，個人評價也非常高。不過嚴格來說，這只能算是「一次付費、分批交付」而已，稱不上真正的「訂閱制」。</p><p>作為一個文字創作者，想靠純文字吸引我來掏錢，說真的難度不低——我對文字內容含金量的敏感度很高。</p><p>換句話說，我在看一段付費內容時，會去思考：如果我來寫，需要花多少時間？來判斷這錢我付得值不值。</p><p>當然，文字只是一個載體，大部分主題沒有一定背景、資料準備是寫不出來的，比如金融、AI，也包括前述的《科技島讀》。</p><p>此時我的判斷基準則回歸最簡單的「知識愉悅與滿足感」。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/MDQYOVd.png&quot; alt=&quot;DALL·E 3&quot;&gt;&lt;/p&gt;
&lt;p&gt;這篇要來講述，2023 年的當下，對我而言「具有一定重要性」的付費訂閱。&lt;/p&gt;
&lt;p&gt;這屬於完全個人化的心得，我會列出那些不可或缺的訂閱項目，並解釋它們對我的重要性所在。&lt;/p&gt;
&lt;p&gt;所謂的「不可或缺」，意思是一旦我停止訂閱，我的工作和生活都會出現挑戰。而挑戰的大小，就是這些訂閱項目對我的影響力與價值。&lt;/p&gt;
&lt;p&gt;以下排名同時也是重要性排名，就讓我們從最重要的開始吧！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/MDQYOVd.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
    <category term="Medium" scheme="https://blog.kyomind.tw/tags/Medium/"/>
    
    <category term="DigitalOcean" scheme="https://blog.kyomind.tw/tags/DigitalOcean/"/>
    
    <category term="Bear" scheme="https://blog.kyomind.tw/tags/Bear/"/>
    
    <category term="開箱評論" scheme="https://blog.kyomind.tw/tags/%E9%96%8B%E7%AE%B1%E8%A9%95%E8%AB%96/"/>
    
    <category term="付費訂閱" scheme="https://blog.kyomind.tw/tags/%E4%BB%98%E8%B2%BB%E8%A8%82%E9%96%B1/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="極客時間" scheme="https://blog.kyomind.tw/tags/%E6%A5%B5%E5%AE%A2%E6%99%82%E9%96%93/"/>
    
    <category term="Setapp" scheme="https://blog.kyomind.tw/tags/Setapp/"/>
    
  </entry>
  
  <entry>
    <title>別依賴「試誤法」寫程式</title>
    <link href="https://blog.kyomind.tw/stop-trial-and-error/"/>
    <id>https://blog.kyomind.tw/stop-trial-and-error/</id>
    <published>2023-10-04T17:42:55.000Z</published>
    <updated>2024-01-11T16:12:54.834Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/cr4Ay4E.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>這個情況真的太普遍，尤其是知識不夠紮實（指<strong>為開發所做的功課太少</strong>）的開發者。但如下所述，這其實是一個「<strong>開發習慣</strong>」議題。</p><p>無論如何，我不得不為此發聲：「<strong>請停止用『試誤法』來寫程式</strong>！」</p><p>我們先看看維基百科對於「<a href="https://zh.wikipedia.org/zh-tw/%E5%B0%9D%E8%AF%95%E9%94%99%E8%AF%AF%E6%B3%95">試誤法</a>」的闡述：</p><blockquote><p><strong>嘗試錯誤法</strong>，又稱<strong>試誤法</strong>（英語：trial and error），簡稱<strong>試錯</strong>，是用來解決問題、獲取知識。此種方法可以視為簡易解決問題的方法中的一種，與使用洞察力／直覺或理論推理的方法正好相反。</p></blockquote><p>就像這句「此種方法可以視為簡易解決問題的方法中的一種」說的，在我看來，試誤法常常會得到 workaround（雖不能根本解決，但能<strong>暫時繞過問題</strong>的替代方法）等級的答案——這肯定不是好事。</p><p>首先我得說，「試誤」在軟體開發中，是一個常見且實用的手段。</p><p>我自己寫一些邏輯時，也常常在 jupyter notebook 先執行嘗試執行一下程式碼片段，看看結果，以確保我的想法沒錯。<strong>但，這只是一種輔助。</strong></p><p>本文想強調的是：<strong>不要以「試誤」作為開發的基調，或解決問題的主要方式</strong>。換言之，<strong>不要濫用試誤</strong>。</p><p>否則那將是一場災難。</p><p>無數次 trial and error，看起來勤勤懇懇，實際上是<strong>最低效的開發手段</strong>。我覺得，試個兩、三次行不通，就應該<strong>重新思考問題的本質——而非繼續嘗試。</strong></p><span id="more"></span><p>以下我們從除錯（debug）與開發（develop）兩個角度，來看看「濫用試誤法」帶來的悲劇。</p><hr><h2 id="Debug-時的試誤"><a href="#Debug-時的試誤" class="headerlink" title="Debug 時的試誤"></a>Debug 時的試誤</h2><p>Debug 和試誤法似乎挺搭的，不是嗎？一步一步嘗試，直接全都正確了為止。</p><p>看似如此，但實際上<strong>正好相反</strong>。</p><p><strong>把試誤心態用在 debug，恰恰是讓 bug 不斷滋生的主要原因。</strong></p><p>試誤的基本心態是「結果好，一切好」，但我們 debug 往往不僅是為了把當下的錯誤消除掉而已。</p><p>更多時候，<strong>我們想要知曉錯誤發生的「原因」為何</strong>，以及是否存在會引發相關錯誤的其它原由——這些都是試誤法不關心的。</p><p>所以，debug 時，試誤只能作一種<strong>很次要的輔助手段</strong>，我們的目標應該是「<strong>找出錯誤的原因，並想辦法防止同類型錯誤的發生</strong>」。</p><p>只要找不到問題的本源，那後續可有的「試」了。</p><h2 id="開發時的試誤"><a href="#開發時的試誤" class="headerlink" title="開發時的試誤"></a>開發時的試誤</h2><p>別想說只有 debug 才容易讓人陷入試誤的濫用。以「試誤心態」進行開發，我認為也非常普遍！</p><p>這樣的開發者的什麼樣的<strong>習性</strong>？以開發一個新功能為例，常常有以下流程：</p><ul><li>想到什麼就寫什麼——單純把自然語言的需求，翻譯成程式碼，我稱之為「<strong>機器翻譯</strong>」</li><li>從頭到尾寫完，然後看看程式運行會不會出錯（寫完也不重構一下，就像文章草稿完成後，直接發表）</li><li>發現執行結果有錯，看一下錯誤訊息，調整一下程式碼</li><li>可以了！好，下一個功能</li></ul><p>這樣的開發方式有什麼問題？看起來好像也不算太差呀？</p><p>確實，在簡單的需求時，這種開發方式（或說心態、習性）可能是「效率最高」的做法！——姑且不論程式碼品質。</p><h2 id="試誤處理不了變化與複雜"><a href="#試誤處理不了變化與複雜" class="headerlink" title="試誤處理不了變化與複雜"></a>試誤處理不了變化與複雜</h2><p>但只要需求變化、複雜化，包括後續的擴充，這樣的開發方式就不太妙了。</p><p>因為缺乏<strong>全局觀</strong>與開發工具相關（套件、框架）重要知識——<strong>講白了就是文件看太少</strong>，畢竟之前的開發成果主要是靠「試」出來的。</p><p>此時「試誤型開發者」會陷入一個迴圈：</p><ol><li>發現程式執行結果不如預期（未必是無法執行，但就是不如預期）</li><li>不確定原因為何（因為常常都是靠「試誤」在解決問題）</li><li>不斷調整寫法、不斷觀察程式執行結果</li><li>回到前述 1</li></ol><p>隨著專案愈來愈複雜，程式碼行數不斷擴張，這種情況也將隨之增加。</p><p>一言以蔽之，試誤無法有效處理複雜。處理複雜，需要你有系統地思考、更全面的知識——最好多看文件、多問 ChatGPT。而非簡單的試誤。</p><p>但在簡單的需求下，試誤卻是一個<strong>快速完成開發的誘人捷徑</strong>。總是依賴試誤法開發，在複雜的情況就容易原形畢露。</p><hr><h2 id="試誤依賴的根本問題"><a href="#試誤依賴的根本問題" class="headerlink" title="試誤依賴的根本問題"></a>試誤依賴的根本問題</h2><p>現在有了 ChatGPT 這個強力工具，理論上我們的開發水準都在相應提升。</p><p>但是，我必須說，對於依賴試誤開發的人而言，ChatGPT 對他們帶來的提升，<strong>可能是最小的——why</strong>？</p><p>因為這類人很容易把試誤心態帶入 ChatGPT 的使用習慣，所以就變成了「向 ChatGPT 要答案」：</p><ul><li>可以了！→下一題</li><li>不行耶！→修改問題再問一次、補充內容</li></ul><p>反正我要的就是答案，至於原理是什麼，暫且不論。</p><p>沒錯，這只是<strong>另一種方式的試誤</strong>而已。（或許我們可以稱之為「<strong>AI 輔助試誤法</strong>」）</p><p>這樣做絕對可以讓開發變得更快，卻未必能變得「更好」。</p><hr><h2 id="小結：試誤是機器的事"><a href="#小結：試誤是機器的事" class="headerlink" title="小結：試誤是機器的事"></a>小結：試誤是機器的事</h2><p>試誤是機器的事，因為機器擅長此道。沒有人能夠在 1 秒內發出 1000 個請求，但機器卻能輕鬆辦到。</p><p>直白地說，如果軟體工程師終有一天會被 AI 取代，那我相信第一波被取代的，肯定是這些「<strong>只把 AI 當作試誤工具</strong>」的人。</p><p>這樣的用法，相當於把自己當「試誤機器」在運作——但人終究不是機器。</p><p>在快速試誤的競賽中，人和機器，誰更有機會勝出呢？</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-18/">18，論軟體工程師常見的「路徑依賴」問題（上）</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/cr4Ay4E.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;這個情況真的太普遍，尤其是知識不夠紮實（指&lt;strong&gt;為開發所做的功課太少&lt;/strong&gt;）的開發者。但如下所述，這其實是一個「&lt;strong&gt;開發習慣&lt;/strong&gt;」議題。&lt;/p&gt;
&lt;p&gt;無論如何，我不得不為此發聲：「&lt;strong&gt;請停止用『試誤法』來寫程式&lt;/strong&gt;！」&lt;/p&gt;
&lt;p&gt;我們先看看維基百科對於「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%B0%9D%E8%AF%95%E9%94%99%E8%AF%AF%E6%B3%95&quot;&gt;試誤法&lt;/a&gt;」的闡述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;嘗試錯誤法&lt;/strong&gt;，又稱&lt;strong&gt;試誤法&lt;/strong&gt;（英語：trial and error），簡稱&lt;strong&gt;試錯&lt;/strong&gt;，是用來解決問題、獲取知識。此種方法可以視為簡易解決問題的方法中的一種，與使用洞察力／直覺或理論推理的方法正好相反。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就像這句「此種方法可以視為簡易解決問題的方法中的一種」說的，在我看來，試誤法常常會得到 workaround（雖不能根本解決，但能&lt;strong&gt;暫時繞過問題&lt;/strong&gt;的替代方法）等級的答案——這肯定不是好事。&lt;/p&gt;
&lt;p&gt;首先我得說，「試誤」在軟體開發中，是一個常見且實用的手段。&lt;/p&gt;
&lt;p&gt;我自己寫一些邏輯時，也常常在 jupyter notebook 先執行嘗試執行一下程式碼片段，看看結果，以確保我的想法沒錯。&lt;strong&gt;但，這只是一種輔助。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文想強調的是：&lt;strong&gt;不要以「試誤」作為開發的基調，或解決問題的主要方式&lt;/strong&gt;。換言之，&lt;strong&gt;不要濫用試誤&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;否則那將是一場災難。&lt;/p&gt;
&lt;p&gt;無數次 trial and error，看起來勤勤懇懇，實際上是&lt;strong&gt;最低效的開發手段&lt;/strong&gt;。我覺得，試個兩、三次行不通，就應該&lt;strong&gt;重新思考問題的本質——而非繼續嘗試。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/cr4Ay4E.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="工作心得" scheme="https://blog.kyomind.tw/tags/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
</feed>
