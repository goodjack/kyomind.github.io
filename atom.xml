<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-06-03T05:44:58.862Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Effective Python》筆記（一）以拆分代替索引</title>
    <link href="https://blog.kyomind.tw/effective-python-01/"/>
    <id>https://blog.kyomind.tw/effective-python-01/</id>
    <published>2024-06-03T03:06:40.000Z</published>
    <updated>2024-06-03T05:44:58.862Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/8lztFoJ.png" alt="Effective Python 中文版"><span class="cap">Effective Python 中文版</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9789865026325">Effective Python 中文版｜寫出良好 Python 程式的 90 個具體做法</a>》筆記的第 1 篇，你可以當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>毫無疑問，這又是一本關於「Clean Code in Python」的書——而且很可能是<strong>評價最高</strong>的一本。</p><p>本書由 <strong>90 個具體做法</strong>所組成，搭配大量實例，助你寫出更 Pythonic 的程式碼。</p><p>內容有初階也有進階（比如 metaclass），我會挑選書中我認為「<strong>重要且實用</strong>」部分，作為分享的準則。</p><p>本文整理自書中的<strong>「做法 6：優先選用多重指定的拆分而非索引」。</strong></p><p>附帶一提，作者已經把書中的程式碼範例都放在 <a href="https://github.com/bslatkin/effectivepython">effectivepython</a> 這個 repo，這對於我這種要寫筆記、心得文章的人，真是再方便不過。</p><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文的主旨只有一個：試圖說服你，<strong>不要</strong>在程式碼中使用<strong>索引取值</strong>——盡可能改用拆分（unpacking）來代替索引。</p><p>這裡的索引取值，指的是像<code>items[2]</code>這樣，以序列（sequence）的<strong>數字索引</strong>來取值的情況。</p><p>如果程式碼只有你一個人撰寫與維護，且日後也是如此，或許未必要堅持這個原則。</p><p>但如果涉及<strong>多人協作</strong>，以及未來還有<strong>交接與維護需求</strong>，那麼<strong>避免索引取值</strong>，肯定能提升程式的可讀性，也更容易維護。</p><span id="more"></span><h2 id="索引取值的不妥之處"><a href="#索引取值的不妥之處" class="headerlink" title="索引取值的不妥之處"></a>索引取值的不妥之處</h2><p>索引取值的<strong>根本問題</strong>，正是基於上述考量：</p><ol><li><strong>可讀性差</strong>：光憑<code>items[2]</code>，我們不知道 2 代表什麼。</li><li><strong>容易出錯</strong>：索引值取錯，程式很可能也一起出錯。</li><li><strong>維護困難</strong>：今天你還記得 2 是什麼意思，半年後就不一定了。</li></ol><p>就我的經驗，索引取值<strong>很常和 for 迴圈一起使用</strong>，因為它們都是<strong>爬取資料</strong>的常見手段，而且是很「<strong>手刻</strong>」的那種——也就是<strong>完全不通用。</strong></p><p>一般而言，爬取資料的程式碼，對於非實際開發者，往往已經<strong>很不容易閱讀。</strong></p><p>如果再加上索引取值，更容易讓人感到<strong>困惑</strong>。</p><p>為索引值寫註解，可能是一個折衷方法，但依舊不是最好的那個。</p><hr><h2 id="拆分（unpacking）"><a href="#拆分（unpacking）" class="headerlink" title="拆分（unpacking）"></a>拆分（unpacking）</h2><p><strong>拆分</strong>（unpacking）無疑是更好的做法！</p><p>拆分是指<strong>將序列、iterable 中的多個元素，一次賦值給多個變數的操作</strong>。</p><p>這種方式能提高可讀性，避免使用<strong>神秘的數字索引</strong>，讓你的程式碼更加清晰明瞭。</p><p>拆分的基本用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># sequence unpacking</span></span><br><span class="line">x, y, z = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;  <span class="comment"># iterable unpacking</span></span><br></pre></td></tr></table></figure><h3 id="索引-vs-拆分"><a href="#索引-vs-拆分" class="headerlink" title="索引 vs 拆分"></a>索引 vs 拆分</h3><p>拆分相對於索引取值，對可讀性有著明顯的進步。</p><p>我們看書中的例子，這是索引取值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example 2</span></span><br><span class="line">item = (<span class="string">&#x27;Peanut butter&#x27;</span>, <span class="string">&#x27;Jelly&#x27;</span>)</span><br><span class="line">first = item[<span class="number">0</span>]</span><br><span class="line">second = item[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(first, <span class="string">&#x27;and&#x27;</span>, second)</span><br></pre></td></tr></table></figure><p>這是拆分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example 4</span></span><br><span class="line">item = (<span class="string">&#x27;Peanut butter&#x27;</span>, <span class="string">&#x27;Jelly&#x27;</span>)</span><br><span class="line">first, second = item  <span class="comment"># Unpacking</span></span><br><span class="line"><span class="built_in">print</span>(first, <span class="string">&#x27;and&#x27;</span>, second)</span><br></pre></td></tr></table></figure><p>拆分顯然更簡潔、更直接。</p><p>雖然最後都是賦值給了變數<code>first</code>和<code>second</code>，但少了中間的索引取值，程式碼中的「<strong>視覺雜訊</strong>」也減少了——這很重要。</p><hr><h2 id="拆分在協作中的價值"><a href="#拆分在協作中的價值" class="headerlink" title="拆分在協作中的價值"></a>拆分在協作中的價值</h2><p>平心而論，索引取值對於撰寫程式的人而言，往往是<strong>比較輕鬆</strong>的做法，所以我們更偏愛用索引。</p><p>但對於閱讀程式碼的人，就有點<strong>辛苦</strong>了。</p><p>推薦使用拆分的目的很簡單，就是<strong>不要透過索引取值再賦值給變數</strong>，而是<strong>直接賦值多個變數</strong>，少掉那段中間流程，也少掉了視覺雜訊。</p><h3 id="明確的意圖"><a href="#明確的意圖" class="headerlink" title="明確的意圖"></a>明確的意圖</h3><p><strong>重要的是——拆分可以讓你的程式意圖更加明確！</strong>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member_names = [member[<span class="number">1</span>] <span class="keyword">for</span> member <span class="keyword">in</span> members]</span><br></pre></td></tr></table></figure><p>這樣的寫法容易讓我有<strong>兩個疑問</strong>：</p><ol><li>索引 0 是什麼？完全不需要嗎？我可以忽略嗎？</li><li>索引有 2 或 3 嗎？（<code>member</code>有更多元素嗎？——我們無法確定）</li></ol><p>總是存在一些不確定因素，雖然這些不確定，自己很清楚，但是對於閱讀程式碼的人，就<strong>不是 100% 確信</strong>了。</p><p>而拆分的寫法，就明確很多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member_names = [name <span class="keyword">for</span> _, name <span class="keyword">in</span> members]</span><br></pre></td></tr></table></figure><p>因為我們已經<strong>透過變數</strong>大聲宣布：<strong>總共只有兩個元素——而且我只要第二個！</strong></p><hr><h2 id="進階拆分"><a href="#進階拆分" class="headerlink" title="進階拆分"></a>進階拆分</h2><blockquote><p>但我就是<strong>只需要其中一個變數</strong>，怎麼辦？就像上面的<code>items[2]</code></p></blockquote><p>沒錯，以拆分取代索引，常常需要一些「<strong>配套措拖</strong>」，才能夠用得方便、滑順。</p><p>最常用的，就是<code>_</code>和<code>*</code>。</p><h3 id="善用-來進行拆分"><a href="#善用-來進行拆分" class="headerlink" title="善用_來進行拆分"></a>善用<code>_</code>來進行拆分</h3><p>很簡單，把<strong>不要的內容</strong>丟給<code>_</code>變數。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, _, last = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="善用-進行拆分"><a href="#善用-進行拆分" class="headerlink" title="善用*進行拆分"></a>善用<code>*</code>進行拆分</h3><p>如果你想要的元素在<strong>第一個</strong>或<strong>最後一個</strong>，而且<strong>拆分的元素較多</strong>，那用<code>*</code>會更加方便。</p><p>使用星號（<code>*</code>）收集其餘的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first, *middle, last = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>其中<code>*middle</code>的變數內容會是一個<strong>元素數量為 0 到多個</strong>的<code>list</code>。</p><h3 id="結合-和"><a href="#結合-和" class="headerlink" title="結合_和*"></a>結合<code>_</code>和<code>*</code></h3><p>結合兩者，<strong>重構第一個例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*_, last = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br></pre></td></tr></table></figure><p>是不是非常簡潔？</p><h3 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h3><p><code>_</code>我很常用，而<code>*</code>拆分我比較少用，所以大概介紹即可。</p><p>無論如何，只要有數字索引出現，<strong>第一時間就要想到「能否用拆分來取代？」</strong>——當然可以！</p><p>這是一個很好的習慣，相信你的同事會感謝你。</p><h2 id="書中範例欣賞"><a href="#書中範例欣賞" class="headerlink" title="書中範例欣賞"></a>書中範例欣賞</h2><p>我們看一段書中的程式碼，比較索引取值和拆分（其實還加了<code>enumerate</code>），兩者的差別<strong>究竟能有多大</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example 8 使用索引取值</span></span><br><span class="line">snacks = [(<span class="string">&#x27;bacon&#x27;</span>, <span class="number">350</span>), (<span class="string">&#x27;donut&#x27;</span>, <span class="number">240</span>), (<span class="string">&#x27;muffin&#x27;</span>, <span class="number">190</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(snacks)):</span><br><span class="line">    item = snacks[i]</span><br><span class="line">    name = item[<span class="number">0</span>]</span><br><span class="line">    calories = item[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;#<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;name&#125;</span> has <span class="subst">&#123;calories&#125;</span> calories&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example 9 使用拆分（加上 enumerate）</span></span><br><span class="line"><span class="keyword">for</span> rank, (name, calories) <span class="keyword">in</span> <span class="built_in">enumerate</span>(snacks, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;#<span class="subst">&#123;rank&#125;</span>: <span class="subst">&#123;name&#125;</span> has <span class="subst">&#123;calories&#125;</span> calories&#x27;</span>)</span><br></pre></td></tr></table></figure><p>當然，不可否認，上面的拆分寫法需要你認真閱讀才能讀懂，因為它有點複雜。</p><p>但即使不了解其中的細節，也能輕易看出，後者更加優雅。</p><p>而且<strong>大部分需要你拆分的情境，都比這個例子單純。</strong></p><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>總的來說，我覺得拆分是一個<strong>大大被低估</strong>卻<strong>異常實用</strong>的技巧。</p><p>善用拆分能讓你的程式碼更加 Pythonic。</p><p>從今天開始，在 for 迴圈中，就別再索引取值了吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/8lztFoJ.png&quot; alt=&quot;Effective Python 中文版&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865026325&quot;&gt;Effective Python 中文版｜寫出良好 Python 程式的 90 個具體做法&lt;/a&gt;》筆記的第 1 篇，你可以當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;毫無疑問，這又是一本關於「Clean Code in Python」的書——而且很可能是&lt;strong&gt;評價最高&lt;/strong&gt;的一本。&lt;/p&gt;
&lt;p&gt;本書由 &lt;strong&gt;90 個具體做法&lt;/strong&gt;所組成，搭配大量實例，助你寫出更 Pythonic 的程式碼。&lt;/p&gt;
&lt;p&gt;內容有初階也有進階（比如 metaclass），我會挑選書中我認為「&lt;strong&gt;重要且實用&lt;/strong&gt;」部分，作為分享的準則。&lt;/p&gt;
&lt;p&gt;本文整理自書中的&lt;strong&gt;「做法 6：優先選用多重指定的拆分而非索引」。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;附帶一提，作者已經把書中的程式碼範例都放在 &lt;a href=&quot;https://github.com/bslatkin/effectivepython&quot;&gt;effectivepython&lt;/a&gt; 這個 repo，這對於我這種要寫筆記、心得文章的人，真是再方便不過。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;本文的主旨只有一個：試圖說服你，&lt;strong&gt;不要&lt;/strong&gt;在程式碼中使用&lt;strong&gt;索引取值&lt;/strong&gt;——盡可能改用拆分（unpacking）來代替索引。&lt;/p&gt;
&lt;p&gt;這裡的索引取值，指的是像&lt;code&gt;items[2]&lt;/code&gt;這樣，以序列（sequence）的&lt;strong&gt;數字索引&lt;/strong&gt;來取值的情況。&lt;/p&gt;
&lt;p&gt;如果程式碼只有你一個人撰寫與維護，且日後也是如此，或許未必要堅持這個原則。&lt;/p&gt;
&lt;p&gt;但如果涉及&lt;strong&gt;多人協作&lt;/strong&gt;，以及未來還有&lt;strong&gt;交接與維護需求&lt;/strong&gt;，那麼&lt;strong&gt;避免索引取值&lt;/strong&gt;，肯定能提升程式的可讀性，也更容易維護。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/QpRyvxH.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
  </entry>
  
  <entry>
    <title>31，打造新版「熱門文章排名」</title>
    <link href="https://blog.kyomind.tw/weekly-review-31/"/>
    <id>https://blog.kyomind.tw/weekly-review-31/</id>
    <published>2024-06-02T07:58:36.000Z</published>
    <updated>2024-06-03T02:40:41.856Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>建立這個 blog 後不知多久，我在網站選單新增了「<a href="/ranking/">熱門文章排名</a>」頁面。你目前看到的是新版。</p><p>收錄「一段時間內」瀏覽量排名前 10 名的文章，供讀者參考。順便增加全站頁面的總觸及率。</p><p>畢竟作為一個 blogger，誰不希望讀者在我們的 blog 看完一篇又一篇呢？</p><hr><h2 id="如何讓新讀者看更多？"><a href="#如何讓新讀者看更多？" class="headerlink" title="如何讓新讀者看更多？"></a>如何讓新讀者看更多？</h2><p>如何讓讀者願意「多看」，無疑是重要議題。</p><p>大部分部落格的大部分文章，都是靠特定 SEO 關鍵字，吸引到新讀者的第一次瀏覽。</p><p>在讀者還不認識你之前，眼下的這篇文章，就是他 &#x2F; 她決定是否再瞧瞧其它文章的主要依據。</p><p>如果內容寫的有趣、論述風格對了胃口、相關的議題剛好是讀者現在關心的，就有機會獲得第二篇、第三篇瀏覽——這是作者們所期待的。</p><p>不過這些都是讀者的<strong>主觀</strong>因素！除了文章內容外，我們幾乎無法控制。</p><p><strong>那我們可以做什麼？</strong></p><span id="more"></span><h2 id="增加站內瀏覽的三個常見做法"><a href="#增加站內瀏覽的三個常見做法" class="headerlink" title="增加站內瀏覽的三個常見做法"></a>增加站內瀏覽的三個常見做法</h2><p>常見的做法不外乎這三種：</p><ol><li>在文章內容引用站內其它文章。</li><li>建立「相關文章」清單。</li><li>建立「熱門文章」排名。</li></ol><p>新讀者既然不清楚你是誰、不清楚這個部落格上還有哪些他 &#x2F; 她<strong>可能會有興趣</strong>的內容，那<strong>適度的引導</strong>就很有必要。</p><p>注意，一定要「適度」，塞太多對方覺得沒用的資訊，只會<strong>適得其反</strong>，產生「<a href="https://zh.wikipedia.org/zh-tw/%E7%8B%BC%E4%BE%86%E4%BA%86">狼來了</a>」效應。</p><p>我相信，一個認真的作者，會把上述這三點都做到、做好。</p><p>所以我每篇文章結尾都有「相關文章」推薦，並建立了「熱門文章」排名頁面。</p><hr><h2 id="舊版「熱門文章」困境"><a href="#舊版「熱門文章」困境" class="headerlink" title="舊版「熱門文章」困境"></a>舊版「熱門文章」困境</h2><p>頁面是建立了，但在很長的一段時間裡，這個排名非常「<strong>陽春</strong>」，參考價值有限。</p><p>主要問題在於「<strong>更新頻率</strong>」——每個月一次，而且還不太固定！（有時候會忘記更新）</p><p>為何會如此？這和「更新方式」有很大關係：我<strong>純手動更新</strong>。</p><p>舊版的排名是我自己去看 GA 數據，然後自己手動編輯排名頁面的內容。可想而知，這過程並不有趣，而且有點費力，所以只願意一個月做一次。</p><p>這個堪稱石器時代的做法，連我自己都覺得不可思議。</p><h2 id="自動化的契機與實作"><a href="#自動化的契機與實作" class="headerlink" title="自動化的契機與實作"></a>自動化的契機與實作</h2><p>直到我看到這篇〈<a href="https://codingman.cc/how-to-use-google-analytics-data-api/">如何使用 Google Analytics Data API</a>〉才知道——原來還可以這樣搞！</p><p>所以去年下半年，我就打算參考這篇文章，透過 GitHub Actions 進行自動更新（文中有教學）。</p><p>但是，一拖又半年過去，因為我的 blog 的依賴套件偏舊，要重新建立環境不容易，我連在本機重建都沒什麼自信XD。加上對 Node.js 不熟，所以拖了又拖。</p><h3 id="先弄個-MVP-吧！"><a href="#先弄個-MVP-吧！" class="headerlink" title="先弄個 MVP 吧！"></a>先弄個 MVP 吧！</h3><p>後來我想通了：我不應該卡在這種<strong>技術細節</strong>——當前最重要的是自動化，而不是用糾結著<strong>什麼方法</strong>來自動化。</p><p>索性暫時不管 GitHub Actions，我在<strong>本機</strong>直接建立這個流水線，並使用 macOS 自帶的 cron job 來定時執行。</p><p>花了一個晚上，參考上述文章，和 ChatGPT 同心協力，誕生了你目前看到、可以每天下午自動更新的新版。我感動🥹</p><p>再次推薦〈<a href="https://codingman.cc/how-to-use-google-analytics-data-api/">如何使用 Google Analytics Data API</a>〉這篇文章，文中對於 GA4 API 的申請、設定有較完整的圖解說明，很有參考價值。</p><p>（我相信大部分開發者都不喜歡弄這些🤣）</p><p>而我自己的實作，已放在<a href="https://github.com/kyomind/blog-post-ranking">這個 GitHub repo</a>，有興趣的讀者可以隨意參考。</p><hr><h2 id="未來更新"><a href="#未來更新" class="headerlink" title="未來更新"></a>未來更新</h2><p>既然已經可以每日自動更新，就想讓這個排名頁面<strong>更具參考價值</strong>。</p><p>目前僅有的瀏覽數排名，有一個<strong>明顯缺點</strong>是：前 10 名<strong>常常就是那些文章</strong>。沒辦法反應同時期內有顯著增長，但瀏覽數無法進入前 10 的文章。</p><p>所以接下的來更新，會增加「<strong>上升前 10 名</strong>」部分，以更加凸顯這些內容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;建立這個 blog 後不知多久，我在網站選單新增了「&lt;a href=&quot;/ranking/&quot;&gt;熱門文章排名&lt;/a&gt;」頁面。你目前看到的是新版。&lt;/p&gt;
&lt;p&gt;收錄「一段時間內」瀏覽量排名前 10 名的文章，供讀者參考。順便增加全站頁面的總觸及率。&lt;/p&gt;
&lt;p&gt;畢竟作為一個 blogger，誰不希望讀者在我們的 blog 看完一篇又一篇呢？&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;如何讓新讀者看更多？&quot;&gt;&lt;a href=&quot;#如何讓新讀者看更多？&quot; class=&quot;headerlink&quot; title=&quot;如何讓新讀者看更多？&quot;&gt;&lt;/a&gt;如何讓新讀者看更多？&lt;/h2&gt;&lt;p&gt;如何讓讀者願意「多看」，無疑是重要議題。&lt;/p&gt;
&lt;p&gt;大部分部落格的大部分文章，都是靠特定 SEO 關鍵字，吸引到新讀者的第一次瀏覽。&lt;/p&gt;
&lt;p&gt;在讀者還不認識你之前，眼下的這篇文章，就是他 &amp;#x2F; 她決定是否再瞧瞧其它文章的主要依據。&lt;/p&gt;
&lt;p&gt;如果內容寫的有趣、論述風格對了胃口、相關的議題剛好是讀者現在關心的，就有機會獲得第二篇、第三篇瀏覽——這是作者們所期待的。&lt;/p&gt;
&lt;p&gt;不過這些都是讀者的&lt;strong&gt;主觀&lt;/strong&gt;因素！除了文章內容外，我們幾乎無法控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那我們可以做什麼？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="blog" scheme="https://blog.kyomind.tw/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Django REST framework 教學（二）基本設定與路由</title>
    <link href="https://blog.kyomind.tw/django-rest-framework-02/"/>
    <id>https://blog.kyomind.tw/django-rest-framework-02/</id>
    <published>2024-06-01T13:23:50.000Z</published>
    <updated>2024-06-03T01:52:42.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 的第 5 篇、<a href="/series/#Django-REST-framework-%E6%95%99%E5%AD%B8">DRF 系列</a>的第 2 篇。</p><p>範例程式碼可參考我的 <a href="https://github.com/kyomind/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="/django/">Django 文章總覽</a>」。</p><p>本文相關的程式碼改動，都集中在這個 <a href="https://github.com/kyomind/Django-Tutorial/pull/1">PR</a>。</p><hr><p>上一篇我們介紹了 Django 和 Django REST framework（以下簡稱 DRF）之間的區別，與它們各司其職的角色定位。</p><p>兩者相輔相成，讓 Django 在這個「前後端分離」的時代，還能佔有一席之地。</p><p>接下來，我們要開始動手實作 API。</p><h3 id="系列：Django-REST-framework-教學"><a href="#系列：Django-REST-framework-教學" class="headerlink" title="系列：Django REST framework 教學"></a>系列：Django REST framework 教學</h3><ul><li><a href="/series/#Django-REST-framework-%E6%95%99%E5%AD%B8">系列文章清單（連載中）</a></li></ul><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文的目標：<strong>建立一個 Django API，並確保它正常運行。</strong></p><p>為了達到這個目標，我們需要完成以下三件事：</p><ol><li>安裝 Django REST framework 套件。</li><li>設定 Django 的<code>settings.py</code>，加入 DRF 相關內容。</li><li>實作第一個路由（router）與 API。</li></ol><p>就這麼簡單，讓我們直接開始吧！</p><span id="more"></span><hr><h2 id="安裝-Django-REST-framework-套件"><a href="#安裝-Django-REST-framework-套件" class="headerlink" title="安裝 Django REST framework 套件"></a>安裝 Django REST framework 套件</h2><p>安裝之前，請務必<strong>先啟動專案的虛擬環境</strong>，以下命令都是在虛擬環境中執行。</p><p>首先，我們需要安裝 Django 和 Django REST framework。可以使用以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br><span class="line">pip install djangorestframework</span><br></pre></td></tr></table></figure><p>接著，建立一個新的 Django 專案和應用程式（Django app）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject myproject</span><br><span class="line"><span class="built_in">cd</span> myproject</span><br><span class="line">django-admin startapp myapp</span><br></pre></td></tr></table></figure><p>以上是一般範例。</p><p>如果以 Django-Tutorial 為例（使用 Poetry），則指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poetry add django@^4.2</span><br><span class="line">poetry add djangorestframework</span><br></pre></td></tr></table></figure><p>建立 Django 專案與 app：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject DjangoTutorial</span><br><span class="line"><span class="built_in">cd</span> DjangoTutorial</span><br><span class="line">django-admin startapp post</span><br></pre></td></tr></table></figure><p>以下解說都直接採用我的<a href="https://github.com/kyomind/Django-Tutorial">範例專案</a>。</p><hr><h2 id="我的-Django-project-命名習慣"><a href="#我的-Django-project-命名習慣" class="headerlink" title="我的 Django project 命名習慣"></a>我的 Django project 命名習慣</h2><p>一個尋常的 Django 專案，通常是這樣的結構：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── django_project</span><br><span class="line">    ├── django_project</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── asgi.py</span><br><span class="line">    │   ├── settings.py</span><br><span class="line">    │   ├── urls.py</span><br><span class="line">    │   └── wsgi.py</span><br><span class="line">    ├── app1</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── admin.py</span><br><span class="line">    │   ├── models.py</span><br><span class="line">    │   ├── urls.py</span><br><span class="line">    │   └── views.py</span><br><span class="line">    ├── app2</span><br><span class="line">    ├── app3</span><br></pre></td></tr></table></figure><p>最上層我稱為 repo 專案，也就是專案的<strong>根目錄</strong>。</p><p>第二層的 <code>django_project</code> 即本段標題中所謂 Django project，裡面有<code>settings.py</code>等「面向整個專案」的設定。</p><p>你可能注意到，我的 Django project 用的是<a href="https://zh.wikipedia.org/zh-tw/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">大駱峰式命名</a>（DjangoTutorial），而不是典型的小寫加底線（django_tutorial）。</p><p>理由很簡單——為了<strong>快速區別</strong> Django project 和其它的 Django app 目錄。</p><h3 id="區別-Django-project-和-Django-app"><a href="#區別-Django-project-和-Django-app" class="headerlink" title="區別 Django project 和 Django app"></a>區別 Django project 和 Django app</h3><p>畢竟它們都一起放在整個 repo 專案底下（這是 Django 預設的專案組織方式），隨著 Django app 愈來愈多，透過命名風格來區分二者，可能是最簡單且省力的方式。</p><p>雖然這和 PEP 8 的<strong>原則</strong>（即<strong>模組名稱</strong>應該使用「小寫 + 底線」命名）有點出入，但我還是推薦你這麼做。</p><p>至於 repo 專案的命名，則沒有限制，可依個人需求而定。我選擇 Django-Tutorial 是為了看起來顯眼且好辨識。</p><p>但如果是「認真的」開源專案，建議還是採用「<code>aa-bb-cc</code>」格式。</p><hr><p>講完命名，我們進入設定環節。</p><h2 id="設定settings-py"><a href="#設定settings-py" class="headerlink" title="設定settings.py"></a>設定<code>settings.py</code></h2><p>打開 <code>DjangoTutorial/settings.py</code>，為 <code>INSTALLED_APPS</code> 新增以下內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,  <span class="comment"># 新增</span></span><br><span class="line">    <span class="string">&#x27;post&#x27;</span>,  <span class="comment"># 新增</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>新增部分是最後 2 行，其餘則是<strong>預設值</strong>。</p><p>每一個我們建立的 Django app 都要加到這個<code>INSTALLED_APPS</code>，而 DRF 本身也要。</p><hr><h2 id="Django-路由設定"><a href="#Django-路由設定" class="headerlink" title="Django 路由設定"></a>Django 路由設定</h2><p><strong>端點</strong>（<a href="https://zh.wikipedia.org/zh-tw/Endpoint">endpoint</a>）代表特定的 <a href="https://zh.wikipedia.org/zh-tw/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">URL</a>，是 API 的「入口」。</p><p><strong>路徑</strong>（path）是 URL 的一部分——而且是<strong>必要部分</strong>。圖解如下：</p><p><img src="https://i.imgur.com/o2JxS9I.png" alt="en.wikipedia.org/wiki/URL，點圖可放大"><span class="cap">en.wikipedia.org/wiki/URL，點圖可放大</span></p><p>而<strong>路由</strong>（router）則是<strong>連結端點與實際負責處理請求的 view 函式</strong>之間的<strong>橋樑</strong>，也就是「<strong>如何分配請求給處理者</strong>」的<strong>機制</strong>，或者說<strong>規則</strong>。</p><p>我們再複習一下 Django 的路由基本做法：</p><ol><li>建立 app 的二級路由。</li><li>設定 project 的一級路由。</li></ol><p>我也看過把所有路由統一放到 project 的<code>urls.py</code>做法，但這屬少數。</p><h3 id="App-二級路由"><a href="#App-二級路由" class="headerlink" title="App 二級路由"></a>App 二級路由</h3><p>首先，在 Django app 底下新增<code>urls.py</code>。這個檔案預設上沒有，我們要自行建立。</p><p><code>post/urls.py</code>內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> post.views <span class="keyword">import</span> hello_world  <span class="comment"># 這個 view 函式目前還沒寫</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;hello/&#x27;</span>, hello_world),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>path</code>是 Django 內建的路由函式，沒有它，你的請求就<strong>到不了</strong>負責處理請求的 view 函式。</p><p><code>path</code>函式的第一個參數，是具體的 <strong>path 字串</strong>。如上圖，path 是端點的一部分，即上面程式碼中的<code>&#39;hello/&#39;</code></p><p>每一個 app 級路由，都要指向特定的 view 函式，也就是<code>path</code>函式的第二個參數——<code>hello_world</code>，儘管我們實際上還沒有撰寫它的內容。</p><h3 id="專案一級路由與前綴"><a href="#專案一級路由與前綴" class="headerlink" title="專案一級路由與前綴"></a>專案一級路由與前綴</h3><p><code>DjangoTutorial/urls.py</code>中的一級路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;post/&#x27;</span>, include(<span class="string">&#x27;post.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>&#39;post.urls&#39;</code>就是 post app 的<code>urls.py</code>。</p><p>通常我們會對它加上一個 <strong>path 前綴</strong>，比如<code>&#39;post/&#39;</code>。</p><p>有了<code>&#39;post/&#39;</code>這個前綴，在 post app 的所有路由設定中，都不必再一一加上，這做法有助於路由的管理與維護。</p><p>經過這些設定，我們第一個路由就完成了。</p><p>但是，我們還沒有寫 API 的內部邏輯呢！</p><hr><h2 id="完成第一個-API"><a href="#完成第一個-API" class="headerlink" title="完成第一個 API"></a>完成第一個 API</h2><p>有了端點和路由，剩下的就是 view 函式。</p><p>在<code>post/views.py</code>中建立一個新的 view 函式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, world!&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>這還不是一個 DRF 的 view 函式，但它可以正常運作。</p><p>它將回應一個內容為 JSON 的 HTTP response——這是典型的 API 行為。</p><p>此時，我們在 path「<code>/post/hello/</code>」已經定義了一個 API。</p><h2 id="啟動伺服器，測試-API"><a href="#啟動伺服器，測試-API" class="headerlink" title="啟動伺服器，測試 API"></a>啟動伺服器，測試 API</h2><p>大功告成，我們立刻來測試它！</p><p>直接啟動 Django 內建的<strong>開發伺服器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ python manage.py runserver</span><br><span class="line">...</span><br><span class="line">Django version 4.2.13, using settings <span class="string">&#x27;DjangoTutorial.settings&#x27;</span></span><br><span class="line">Starting development server at http://127.0.0.1:8000/</span><br><span class="line">Quit the server with CONTROL-C.</span><br></pre></td></tr></table></figure><p>伺服器在本機啟動後，我們預期<a href="http://127.0.0.1:8000/post/hello/">這個端點</a>，會回應我們剛定義的 JSON response：</p><p><img src="https://i.imgur.com/KLcJTrD.png"></p><p>果然如此！可見我們的 API 已正常運作。</p><hr><h2 id="小結：路由很重要"><a href="#小結：路由很重要" class="headerlink" title="小結：路由很重要"></a>小結：路由很重要</h2><p>Django 路由設定不難，甚至有些死板。但它們是連接請求與處理邏輯的關鍵部分。</p><p>正確的路由確保 API 的正確運行。透過清晰、簡潔的路由設計，可以更容易地管理和擴展我們的 API 服務。</p><p>DRF 的路由規則<strong>幾乎完全遵循</strong>了 Django 原有的做法，所以沒有特別介紹。</p><p>本篇對於熟悉 Django 的人可能沒有太多新東西——這是好事。</p><p>下一篇，我們將進入重頭戲——view 函式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 的第 5 篇、&lt;a href=&quot;/series/#Django-REST-framework-%E6%95%99%E5%AD%B8&quot;&gt;DRF 系列&lt;/a&gt;的第 2 篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;本文相關的程式碼改動，都集中在這個 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial/pull/1&quot;&gt;PR&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上一篇我們介紹了 Django 和 Django REST framework（以下簡稱 DRF）之間的區別，與它們各司其職的角色定位。&lt;/p&gt;
&lt;p&gt;兩者相輔相成，讓 Django 在這個「前後端分離」的時代，還能佔有一席之地。&lt;/p&gt;
&lt;p&gt;接下來，我們要開始動手實作 API。&lt;/p&gt;
&lt;h3 id=&quot;系列：Django-REST-framework-教學&quot;&gt;&lt;a href=&quot;#系列：Django-REST-framework-教學&quot; class=&quot;headerlink&quot; title=&quot;系列：Django REST framework 教學&quot;&gt;&lt;/a&gt;系列：Django REST framework 教學&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/series/#Django-REST-framework-%E6%95%99%E5%AD%B8&quot;&gt;系列文章清單（連載中）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;本文的目標：&lt;strong&gt;建立一個 Django API，並確保它正常運行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;為了達到這個目標，我們需要完成以下三件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安裝 Django REST framework 套件。&lt;/li&gt;
&lt;li&gt;設定 Django 的&lt;code&gt;settings.py&lt;/code&gt;，加入 DRF 相關內容。&lt;/li&gt;
&lt;li&gt;實作第一個路由（router）與 API。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就這麼簡單，讓我們直接開始吧！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="Django REST framework" scheme="https://blog.kyomind.tw/tags/Django-REST-framework/"/>
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>30，如何持續寫作——Part 3</title>
    <link href="https://blog.kyomind.tw/weekly-review-30/"/>
    <id>https://blog.kyomind.tw/weekly-review-30/</id>
    <published>2024-05-26T05:51:05.000Z</published>
    <updated>2024-05-26T15:09:58.408Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>你寫作嗎？</p><p>我一直覺得，<strong>持續寫作真的很不容易！</strong></p><p>所以我們需要一些方法或看法，來增加持續的可能性、降低其中的門檻。</p><p>在過去的文章中，我曾兩次討論「<strong>持續寫作</strong>」這個議題。本文將整理從上一次到現在，<strong>我的 3 個新想法。</strong></p><h3 id="回顧-Part-1、Part-2"><a href="#回顧-Part-1、Part-2" class="headerlink" title="回顧 Part 1、Part 2"></a>回顧 Part 1、Part 2</h3><p>前兩次討論，其實都只是某篇文章的一個<strong>段落</strong>，分別是：</p><ol><li><a href="/on-writing/#%E5%B0%8F%E7%B5%90%EF%BC%9A%E5%A6%82%E4%BD%95%E7%9B%A1%E5%8F%AF%E8%83%BD%E6%8C%81%E7%BA%8C%E5%AF%AB%EF%BC%9F">小結：如何盡可能持續寫？</a>（2021 年）</li><li><a href="/a-mind-for-blogs/#%E5%A6%82%E4%BD%95%E6%8C%81%E7%BA%8C%E5%AF%AB%E4%BD%9C-Part-2">如何持續寫作 Part 2</a>（2022 年）</li></ol><p>它們代表了我不同時期的看法，不過都是<strong>一脈相承</strong>的，後者往往是對前者的<strong>追加、補充或是具體化。</strong></p><p>本文也是如此，我會提出新想法，也會對過去的看法提出更加具體的建議。</p><p>純個人見解！但保證都是我的肺腑之言。讓我們開始。</p><span id="more"></span><hr><h2 id="一、再論流量的重要性"><a href="#一、再論流量的重要性" class="headerlink" title="一、再論流量的重要性"></a>一、再論流量的重要性</h2><p>前兩次我都強調過流量的重要，事實上，在寫作早期，我認為它就是<strong>最重要</strong>的事！</p><p>因此，我要再度補充，讓這個建議更有「<strong>可操作性</strong>」。</p><p>要知曉流量，首先得要有流量的監控後台，最常見的是 GA4。如果你重視（讀者的）隱私，也可以考慮我曾介紹過的 <a href="https://github.com/umami-software/umami">Umami</a>。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-21/">21，在 VM 上部署 Umami 替代 GA4</a></p></blockquote><p>附帶一提，我後來就不用 Umami 了。因為我太常修改文章，每一次重新整理，count 就會增加一次XD，這樣數據很容易失真。</p><h3 id="多少才算「有流量」？"><a href="#多少才算「有流量」？" class="headerlink" title="多少才算「有流量」？"></a>多少才算「有流量」？</h3><p>Part 2 提過，<strong>流量是雙面刃，但又不能沒有。</strong></p><p>那麼，具體而言，對於流量的追求，究竟<strong>什麼時候</strong>才能停止或放慢腳步呢？</p><p>我建議以「每個月有 500、1000 個瀏覽數（二擇一即可）」為目標——這是我架站的第 6、7 個月才做到的🥹</p><blockquote><p>PS：本文專指<strong>部落格寫作</strong>，如果是社群平台，這個數字可能要高得多。</p></blockquote><p>對此，也許有人不服，心想：「寫作不就是應該要表達自我，怎麼可以被流量綁架？」</p><h3 id="折衷方案"><a href="#折衷方案" class="headerlink" title="折衷方案"></a>折衷方案</h3><p>確實如此！不過考慮到持續下去（活下去）才是我們<strong>起步時的第一要務</strong>，這類看法<strong>可以有一些折衷。</strong></p><p>比如，在自己想要的寫作方向上（對我而言是程式相關），試著<strong>優先</strong>寫一些流量「<strong>相對較多</strong>」的主題。</p><p>以我自己為例，就是 pyenv：</p><ul><li><a href="https://blog.kyomind.tw/pyenv-setup/">告別 Anaconda：在 macOS 上使用 pyenv 建立 Python 開發環境</a></li><li><a href="https://blog.kyomind.tw/ubuntu-pyenv/">Ubuntu 安裝使用 pyenv + pyenv-virtualenv</a></li></ul><p>這兩篇文章在我架站的初期，帶來了一定的流量，並建立起信心。</p><hr><h2 id="二、專業內容與個人心得交錯"><a href="#二、專業內容與個人心得交錯" class="headerlink" title="二、專業內容與個人心得交錯"></a>二、專業內容與個人心得交錯</h2><p>第一個建議是面向寫作入門者，以下兩點則是我自己喜歡的做法——可以<strong>增加我寫作的動力。</strong></p><p>觀察本站「<a href="https://blog.kyomind.tw/archives/">文章列表</a>」，細心的讀者或許能看出，我的主題存在一定程度的「<strong>交錯</strong>」。</p><p>沒錯，這是我有意為之。</p><p>有別於大部分技術部落格以程式為主，<strong>我自己很難連續兩、三篇都寫程式相關內容</strong>——因為很累，而且心理上會有一種<strong>厭倦、排斥感</strong>。</p><p>所以我通常寫完一篇技術文章，下一篇就會寫和程式無關的事。</p><p>這對於「專注耕耘特定議題」顯然一種「拖累」，所以我的 <a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a> 系列進展緩慢XD</p><p>但是，這麼做也讓我<strong>更容易持續發文</strong>，而且<strong>創作壓力較小。</strong></p><p>有得必有失，而這樣的結果，我自己是可以接受的。</p><hr><h2 id="三、短一點，好一點"><a href="#三、短一點，好一點" class="headerlink" title="三、短一點，好一點"></a>三、短一點，好一點</h2><p>在很長一段時間裡，我對「<strong>長文</strong>」（3000 字以上）存在著一定程度的偏好甚至迷戀。</p><p>但現在的我覺得：<strong>不要這樣——不要以創作長文為榮。</strong></p><p>雖然，不可否認，本站大部分的流量，都來自於長文XD。它們動輒三四五千字，沒完沒了。</p><p>但我還是認為，為了寫作的可持續性，<strong>甚至是為了讀者</strong>，請試著把文章寫短一點。</p><p>這裡的短，指的是 1000 到 2000 字之間。</p><h3 id="短，也需要練習"><a href="#短，也需要練習" class="headerlink" title="短，也需要練習"></a>短，也需要練習</h3><p>我很常遇到一個情況：本來打算寫 1500 字，結果完稿後往往超過 3000 字。</p><p>為什麼？因為<strong>想把事情說好、說完整</strong>。想要做到盡善盡美。</p><p>對此，我斗膽建議：<strong>不要「總」這麼想——儘管這是好的追求。</strong></p><p>因為我發現，文章只要一長，就很容易<strong>寫偏</strong>。</p><p>所謂的寫偏，不一定是文不對題，只不過這段內容對於讀者而言，<strong>其實沒有你想得那麼重要。</strong></p><p>你需要很強的<strong>自我覺察</strong>（作者都覺得自己的東西好——但讀者未必買帳）和駕馭能力，才能<strong>持續把論述緊扣在主軸上</strong>——這一點也不容易，而長文更是如此。</p><p>「短」這個議題，我還有更多想法，但為了遵守自己對 Weekly Review 的字數上限。且容我另篇再談。</p><p>總之，寫短一點吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;你寫作嗎？&lt;/p&gt;
&lt;p&gt;我一直覺得，&lt;strong&gt;持續寫作真的很不容易！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以我們需要一些方法或看法，來增加持續的可能性、降低其中的門檻。&lt;/p&gt;
&lt;p&gt;在過去的文章中，我曾兩次討論「&lt;strong&gt;持續寫作&lt;/strong&gt;」這個議題。本文將整理從上一次到現在，&lt;strong&gt;我的 3 個新想法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;回顧-Part-1、Part-2&quot;&gt;&lt;a href=&quot;#回顧-Part-1、Part-2&quot; class=&quot;headerlink&quot; title=&quot;回顧 Part 1、Part 2&quot;&gt;&lt;/a&gt;回顧 Part 1、Part 2&lt;/h3&gt;&lt;p&gt;前兩次討論，其實都只是某篇文章的一個&lt;strong&gt;段落&lt;/strong&gt;，分別是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/on-writing/#%E5%B0%8F%E7%B5%90%EF%BC%9A%E5%A6%82%E4%BD%95%E7%9B%A1%E5%8F%AF%E8%83%BD%E6%8C%81%E7%BA%8C%E5%AF%AB%EF%BC%9F&quot;&gt;小結：如何盡可能持續寫？&lt;/a&gt;（2021 年）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/a-mind-for-blogs/#%E5%A6%82%E4%BD%95%E6%8C%81%E7%BA%8C%E5%AF%AB%E4%BD%9C-Part-2&quot;&gt;如何持續寫作 Part 2&lt;/a&gt;（2022 年）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它們代表了我不同時期的看法，不過都是&lt;strong&gt;一脈相承&lt;/strong&gt;的，後者往往是對前者的&lt;strong&gt;追加、補充或是具體化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文也是如此，我會提出新想法，也會對過去的看法提出更加具體的建議。&lt;/p&gt;
&lt;p&gt;純個人見解！但保證都是我的肺腑之言。讓我們開始。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="blog" scheme="https://blog.kyomind.tw/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Python 專案從 Flake8、isort、Black 遷移至 Ruff 指南</title>
    <link href="https://blog.kyomind.tw/migrate-to-ruff/"/>
    <id>https://blog.kyomind.tw/migrate-to-ruff/</id>
    <published>2024-05-25T02:54:07.000Z</published>
    <updated>2024-05-30T23:37:41.860Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/klPlw0x.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>上個月，我將工作上幾個專案的 Python linter、formatter，從原本的 Flake8、isort、Black Formatter 遷移至 <a href="https://github.com/astral-sh/ruff">Ruff</a>。</p><p>本來以為很簡單，應該半小時就可以搞定。沒想到細節比想像的多，前前後後還是花了近 2 小時。</p><p>可能我比較龜毛吧！</p><p>正因耗費的時間有點多，所以寫下這篇懶人包教學，作為讀者遷移時的參考。</p><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>這篇文章是寫給，目前正使用上述 Flake8、isort、Black Formatter 作為格式化工具，<strong>並打算遷移至 Ruff 的 Python 開發者。</strong></p><p>受眾就是〈<a href="https://blog.kyomind.tw/flake8-yapf-setting/">VS Code 設定 Python Linter、Formatter 教學</a>〉中描述的那樣。在專案中使用上述工具，也安裝了相關的 VS Code 套件，設定好 pre-commit hook，以及使用 pyproject.toml 作為這些工具的設定檔。</p><p>而本文的目標，就是讓專案的 linter、formatter，最終都統一使用 Ruff。</p><span id="more"></span><h3 id="系列：Python-Ruff-教學"><a href="#系列：Python-Ruff-教學" class="headerlink" title="系列：Python Ruff 教學"></a>系列：Python Ruff 教學</h3><ul><li><a href="/series/#Python-Ruff-%E6%95%99%E5%AD%B8">系列文章清單（連載中）</a></li></ul><hr><h2 id="為什麼要用-Ruff？"><a href="#為什麼要用-Ruff？" class="headerlink" title="為什麼要用 Ruff？"></a>為什麼要用 Ruff？</h2><p>在系列第一篇，即〈<a href="https://blog.kyomind.tw/ruff/">Python 開發：Ruff Linter、Formatter 介紹 + 設定教學</a>〉中，我闡述了<a href="https://blog.kyomind.tw/ruff/#Why-Ruff%EF%BC%9F">使用 Ruff 的兩大理由</a>。</p><p>在工作上用了 Ruff 近 2 個月後，我覺得<strong>這兩個理由都很真實</strong>。而且，速度帶來的差異與感受，比我想像的更多！</p><p>除此之外，還有一個我之前沒想到的優點——「<strong>避免衝突</strong>」。</p><h3 id="工具間的行為衝突"><a href="#工具間的行為衝突" class="headerlink" title="工具間的行為衝突"></a>工具間的行為衝突</h3><p>我們知道，linter 與 formatter 如果進行客製化設定，那兩者對於格式的要求可能會發生<strong>不一致</strong>，這在設定上需要留意。</p><p>比如最常見的「單行最大字元上限」。如果在 Flake8 從 79 字元改成 100，那 isort 和 Black 也要跟著設定才行！</p><p>尤其 isort 和 Black 都是格式化器，兩者都有「格式化程式碼」的能力，如果設定不一致，會帶來一定的困擾。</p><p>所以 isort 才會有以下這個<a href="https://blog.kyomind.tw/pyproject-toml/#isort">常見設定</a>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tool.isort]</span><br><span class="line">profile = &quot;black&quot;</span><br></pre></td></tr></table></figure><p>為的就是和 Black「達成一致」。</p><p>而這些潛在的「衝突」議題，在統一使用 Ruff 後，將不復存在。</p><hr><h2 id="遷移任務清單"><a href="#遷移任務清單" class="headerlink" title="遷移任務清單"></a>遷移任務清單</h2><p>我們先看一下，遷移至 Ruff 需要完成的任務有哪些：</p><ol><li>更新 pyproject.toml：新增、移除套件。更新工具設定檔內容。</li><li>更新 VS Code 套件、設定格式化行為。</li><li>更新 pre-commit 設定。</li><li>統一格式化專案所有程式碼。</li></ol><p>以下說明其中的重點。</p><h2 id="一、更新-pyproject-toml"><a href="#一、更新-pyproject-toml" class="headerlink" title="一、更新 pyproject.toml"></a>一、更新 pyproject.toml</h2><p>這是所有步驟中，<strong>比較需要費心</strong>的部分。</p><p>首先是移除舊套件，並新增 Ruff。</p><p>在此假設你也是用 Poetry 來管理虛擬環境，所以我們可以直接修改 pyproject.toml 的 Poetry 設定部分：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.group.dev.dependencies]</span></span><br><span class="line"><span class="attr">ruff</span> = <span class="string">&quot;0.4.5&quot;</span>  <span class="comment"># 版本必須固定，與 pre-commit 一致</span></span><br><span class="line"><span class="comment"># 移除 flake8 = &quot;6.1.0&quot;</span></span><br><span class="line"><span class="comment"># 移除 black = &quot;23.10.1&quot;</span></span><br><span class="line"><span class="comment"># 移除 isort = &quot;5.12.0&quot;</span></span><br></pre></td></tr></table></figure><p>修改完成後，記得執行<code>poetry lock</code>和<code>poetry install</code>。</p><p>一般使用 Poetry，套件版本的指定我們會採<code>^</code>運算子，讓套件有一個<strong>自動升級範圍</strong>，增加相容性。</p><p>但 linter、formatter 這類工具，因為還要配合 pre-commit hook，所以我幾乎都是<strong>固定版本、手動更新。</strong></p><h2 id="Ruff-Linter、Formatter-設定"><a href="#Ruff-Linter、Formatter-設定" class="headerlink" title="Ruff Linter、Formatter 設定"></a>Ruff Linter、Formatter 設定</h2><p>接下來是<strong>重頭戲</strong>——在 pyproject.toml 中設定 Ruff 行為。我們先看結果：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[project]</span></span><br><span class="line"><span class="attr">requires-python</span> = <span class="string">&quot;&gt;=3.11&quot;</span> <span class="comment">#影響pyupgrade檢查與自動修正的版本</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff]</span>  <span class="comment"># https://docs.astral.sh/ruff/settings/#top-level</span></span><br><span class="line"><span class="attr">line-length</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">exclude</span> = [<span class="string">&quot;**/migrations/&quot;</span>, <span class="string">&quot;**/manage.py&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.lint]</span>  <span class="comment"># https://docs.astral.sh/ruff/settings/#lint</span></span><br><span class="line"><span class="attr">select</span> = [</span><br><span class="line">    <span class="string">&quot;E&quot;</span>,  <span class="comment"># pycodestyle errors</span></span><br><span class="line">    <span class="string">&quot;W&quot;</span>,  <span class="comment"># pycodestyle warnings</span></span><br><span class="line">    <span class="string">&quot;F&quot;</span>,  <span class="comment"># pyflakes</span></span><br><span class="line">    <span class="string">&quot;I&quot;</span>,  <span class="comment"># isort</span></span><br><span class="line">    <span class="string">&quot;UP&quot;</span>,  <span class="comment"># pyupgrade</span></span><br><span class="line">]</span><br><span class="line"><span class="attr">ignore</span> = [</span><br><span class="line">    <span class="string">&quot;E402&quot;</span>,  <span class="comment"># module level import not at top of file</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.format]</span>  <span class="comment"># https://docs.astral.sh/ruff/settings/#format</span></span><br><span class="line"><span class="attr">quote-style</span> = <span class="string">&quot;double&quot;</span>  <span class="comment"># 引號風格，雙引號是預設值，這裡只是明示這個設定</span></span><br></pre></td></tr></table></figure><p>為了教學說明與維護方便，我加上了<strong>大量註解</strong>。</p><p>我<strong>強烈建議</strong>你在工作專案中，也要為這些設定<strong>適度加入註解</strong>——畢竟不是每個人都熟悉 Ruff。而且，Ruff 可設定的項目眾多，久了自己可能也會忘記。</p><p>大部分的設定，我們在第一篇都已提過，不再重複。</p><p>以下補充一些<strong>值得留意的點。</strong></p><h3 id="一、必須明確區分-Linter-和-Formatter-設定"><a href="#一、必須明確區分-Linter-和-Formatter-設定" class="headerlink" title="一、必須明確區分 Linter 和 Formatter 設定"></a>一、必須明確區分 Linter 和 Formatter 設定</h3><p>從 Ruff 0.2 版開始，對於 <strong>section 名稱</strong>（即<code>tool.ruff</code>、<code>tool.ruff.format</code>等）有比較嚴格的要求。可以參考<a href="https://github.com/tiangolo/fastapi/pull/11075">這個 PR</a>。</p><p>簡言之，共用設定放<code>tool.ruff</code>。如果是 linter 專用的設定就要放<code>tool.ruff.lint</code>，Ruff Formatter 的設定則要放<code>tool.ruff.format</code>。</p><p>不像以前那麼寬鬆。</p><p>設定不合法時，會有錯誤提醒，留意一下即可。</p><h3 id="二、requires-python-設定"><a href="#二、requires-python-設定" class="headerlink" title="二、requires-python 設定"></a>二、requires-python 設定</h3><p>這個 key 是讓你<strong>指定專案的 Python 版本</strong>，有兩種表達方式。第一篇我們用的是<a href="/ruff/#%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A%E8%88%87%E8%A7%A3%E8%AA%AA">這種</a>，本文用的是第二種。</p><p><a href="https://docs.astral.sh/ruff/settings/#target-version">官方文件</a>推薦使用第二種：</p><blockquote><p>If you’re already using a <code>pyproject.toml</code> file, we recommend <code>project.requires-python</code> instead, as it’s based on Python packaging standards, and will be respected by other tools.</p></blockquote><p>我們從善如流。</p><h3 id="三、quote-style"><a href="#三、quote-style" class="headerlink" title="三、quote-style"></a>三、quote-style</h3><p>最後不忘提醒，Ruff formatter 的 quote-style 設定，<strong>將會使整個專案的「引號」風格趨於統一</strong>（PEP 8 慣例除外，比如 docstring）。</p><p>換句話說，有些人習慣用單引號，有些則是雙引號，遷移後將會統一。</p><p>這對任何專案都是<strong>不小的變動</strong>，遷移前需要認真考慮，尤其是團隊對於要用哪一種風格，是否已達成<strong>初步的一致</strong>。</p><p>比如<strong>我自己是單引號支持者</strong>，但是在工作中，為了提高大家採用新工具的意願，我願意稍作妥協。所以上面的例子是雙引號。</p><hr><h2 id="二、更新-VS-Code-套件"><a href="#二、更新-VS-Code-套件" class="headerlink" title="二、更新 VS Code 套件"></a>二、更新 VS Code 套件</h2><p>這部分就很簡單了。</p><p>移除舊套件，安裝<a href="https://marketplace.visualstudio.com/items?itemName=charliermarsh.ruff">新套件</a>。但如果你還有其他專案需要使用 Flake8 等工具，那也不能輕易移除。此時可以參考前一篇的「<a href="/ruff/#%E4%B8%8D%E5%90%8C%E5%B0%88%E6%A1%88%E9%96%93%E5%88%87%E6%8F%9B">在工作區停用</a>」。</p><p>以免不同套件相互干擾。</p><p>至於 Python 部分的 VS Code 設定，可直接參考前篇。</p><h2 id="三、更新-pre-commit-設定"><a href="#三、更新-pre-commit-設定" class="headerlink" title="三、更新 pre-commit 設定"></a>三、更新 pre-commit 設定</h2><p>這部分比以前簡潔很多：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repos:</span><br><span class="line">  - repo: https://github.com/astral-sh/ruff-pre-commit</span><br><span class="line">    rev: v0.4.5</span><br><span class="line">    hooks:</span><br><span class="line">      - id: ruff</span><br><span class="line">        args: <span class="section">[ --fix ]</span>  <span class="comment"># 啟用ruff --fix自動修復，會有類似format的效果</span></span><br><span class="line">      - id: ruff-format</span><br></pre></td></tr></table></figure><p>畢竟以前要設定三個工具，如今只剩下一個。</p><h2 id="四、統一格式化"><a href="#四、統一格式化" class="headerlink" title="四、統一格式化"></a>四、統一格式化</h2><p>統一格式化，而不是一邊開發一邊格式化，以免造成<strong>功能更新</strong>與<strong>格式化更新</strong>混淆，導致 code review 時的大量視覺干擾。</p><p>怎麼做呢？回到命令列以指令操作。</p><p>在<strong>專案根目錄</strong>使用下列指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruff format</span><br></pre></td></tr></table></figure><p>就這麼簡單，0.1.7 版以後，它實際上有一個預設參數是「<code>.</code>」，也就是整個目錄。</p><p>詳情可參考<a href="https://docs.astral.sh/ruff/formatter/#ruff-format">官方文件</a>。</p><p>注意，有些檔案<strong>沒必要格式化</strong>，比如 Django 專案 migrations 目錄下的資料庫遷移檔，可以在 pyproject.toml 中設定<code>exclude</code>。</p><hr><h2 id="補充：pyupgrade-真是棒！"><a href="#補充：pyupgrade-真是棒！" class="headerlink" title="補充：pyupgrade 真是棒！"></a>補充：pyupgrade 真是棒！</h2><p>Ruff 整合了 <a href="https://github.com/asottile/pyupgrade">pyupgrade</a>，讓我第一次認識到這個強大的工具。</p><p>我強烈建議，一定要開啟 pyupgrade 功能！讓專案中的 Python 語法維持<strong>更高程度的一致性。</strong></p><p>畢竟，<strong>在團隊協作中，「一致性」有時比慣例更加重要。</strong></p><h3 id="例示：修正-type-hints-語法"><a href="#例示：修正-type-hints-語法" class="headerlink" title="例示：修正 type hints 語法"></a>例示：修正 type hints 語法</h3><p>比如 Python type hints 中，關於 Optional 的寫法，3.9 以前會這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">arg: <span class="type">Optional</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>Optional 本身是 Union 在特定情況下的<strong>別名</strong>，但它常常讓人<strong>感到困惑。</strong></p><p>而在 Python 3.10 之後，上述寫法可以改為：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">arg: <span class="built_in">int</span> | <span class="literal">None</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>後者顯然<strong>更加簡潔且直觀。</strong>（讓你一望即知，參數型別不是 int 就是 None）</p><p>不過話說回來，這個例子<strong>並不是</strong>一個好的 type hints 示範，理由可參考這篇〈<a href="https://haosquare.com/python-type-hints-3-beginner-mistakes/">Python Type Hints 教學：我犯過的 3 個菜鳥錯誤</a>〉底下，良葛格的留言。</p><h3 id="pyupgrade-功能與小結"><a href="#pyupgrade-功能與小結" class="headerlink" title="pyupgrade 功能與小結"></a>pyupgrade 功能與小結</h3><p>具體來說，pyupgrade 會自動將舊的 type hints 語法轉換為新版語法。</p><p>上述的<code>Optional</code>，將自動修正為<code>|</code>寫法——只要我指定了 Python 3.10 以上的版本。</p><p><strong>但 pyupgrade 會修正的部分，遠不止 type hints</strong>，這只是一個例子。</p><p>啟用 pyupgrade，可以<strong>自動幫你把這些舊語法轉換為新版</strong>（由 requires-python 指定目標 Python 版本）語法。</p><p>這不僅讓你的程式碼更乾淨，也能避免不同成員寫出風格不一致的 Python 程式碼。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/klPlw0x.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;上個月，我將工作上幾個專案的 Python linter、formatter，從原本的 Flake8、isort、Black Formatter 遷移至 &lt;a href=&quot;https://github.com/astral-sh/ruff&quot;&gt;Ruff&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本來以為很簡單，應該半小時就可以搞定。沒想到細節比想像的多，前前後後還是花了近 2 小時。&lt;/p&gt;
&lt;p&gt;可能我比較龜毛吧！&lt;/p&gt;
&lt;p&gt;正因耗費的時間有點多，所以寫下這篇懶人包教學，作為讀者遷移時的參考。&lt;/p&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;這篇文章是寫給，目前正使用上述 Flake8、isort、Black Formatter 作為格式化工具，&lt;strong&gt;並打算遷移至 Ruff 的 Python 開發者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;受眾就是〈&lt;a href=&quot;https://blog.kyomind.tw/flake8-yapf-setting/&quot;&gt;VS Code 設定 Python Linter、Formatter 教學&lt;/a&gt;〉中描述的那樣。在專案中使用上述工具，也安裝了相關的 VS Code 套件，設定好 pre-commit hook，以及使用 pyproject.toml 作為這些工具的設定檔。&lt;/p&gt;
&lt;p&gt;而本文的目標，就是讓專案的 linter、formatter，最終都統一使用 Ruff。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/klPlw0x.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
    <category term="Ruff" scheme="https://blog.kyomind.tw/tags/Ruff/"/>
    
    <category term="Flake8" scheme="https://blog.kyomind.tw/tags/Flake8/"/>
    
    <category term="Black Formatter" scheme="https://blog.kyomind.tw/tags/Black-Formatter/"/>
    
    <category term="isort" scheme="https://blog.kyomind.tw/tags/isort/"/>
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
  </entry>
  
  <entry>
    <title>我寫「AI 對話筆記」的方法與思考</title>
    <link href="https://blog.kyomind.tw/my-ai-dialogue-notes/"/>
    <id>https://blog.kyomind.tw/my-ai-dialogue-notes/</id>
    <published>2024-05-14T17:47:41.000Z</published>
    <updated>2024-05-16T09:43:05.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/YmlPRz1.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>你會把「和 ChatGPT 的對話、問答」寫成筆記嗎？<a href="https://twitter.com/kyomind/status/1790032744598188070">顯然我會，而且很大量！</a></p><p>其中有 8 成以上都是程式相關，來自每天和 ChatGPT 的日常開發問答。</p><p>應該說，與 ChatGPT 對話<strong>早已成為我工作、學習的重要環節</strong>。在〈<a href="https://blog.kyomind.tw/stop-trial-and-error/">別依賴「試誤法」寫程式</a>〉中我也<a href="https://blog.kyomind.tw/stop-trial-and-error/#%E8%A9%A6%E8%AA%A4%E4%BE%9D%E8%B3%B4%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%95%8F%E9%A1%8C">強調過</a>，像 ChatGPT 這樣的工具，如果僅僅用來「獲得答案」，<strong>未免也太可惜。</strong></p><p>因此，我幾乎每天都會有新的「AI 對話筆記」。</p><p>話說回來，把 AI 的回答寫成筆記，並作為主要的知識來源，<strong>這是一個好的實踐嗎？</strong></p><p>本文無法回答這個問題XD，但我可以分享一下，做了一年 AI 對話筆記後，我的看法與注意事項。</p><span id="more"></span><p>附帶一提，我的筆記是 Logseq 閃卡（Flash card），大致做法可參考「<a href="https://blog.kyomind.tw/less-is-more/#%E6%88%91%E5%9C%A8-Logseq-%E7%9A%84%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE">我在 Logseq 的局部實現</a>」或這篇<a href="https://www.facebook.com/fomo.kyo/posts/pfbid0KMyv8WAyMJSQBz8kvVQsmhXmHRspVknx3wwCcdjwvNJrH22bpZKZPMxcEZHECVJVl">臉書</a>。更多閃卡實作細節，我們另篇再談。</p><hr><h2 id="事實、觀點與幻覺"><a href="#事實、觀點與幻覺" class="headerlink" title="事實、觀點與幻覺"></a>事實、觀點與幻覺</h2><p>事實、觀點的定義與區別，這裡不多作闡述。只要能大概區分這兩者，就可以繼續往下閱讀。</p><p>筆記內容，往往是事實與觀點兼具，而我們常說 AI 有「<a href="https://zh.wikipedia.org/zh-tw/%E5%B9%BB%E8%A7%89_(%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD)">幻覺</a>」，主要著眼於它對事實的瞎掰胡扯。</p><p>如果你跟我一樣，把 AI 回答做成筆記並複習，而且為的是「專業技術養成」，那 AI 對於事實的幻覺，當然會是一個重要議題。</p><p>殘酷的是，幻覺目前還很難完全避免。</p><p>因此，把 AI 的回答寫成筆記，還是要有一些方法與準則才好。</p><h2 id="加上標籤"><a href="#加上標籤" class="headerlink" title="加上標籤"></a>加上標籤</h2><p>基於這個擔憂，所有對 AI 的回答整理，我會加上一個標籤，我自己是用 #Session，代表我和 AI 的對話內容。</p><p>貼上標籤只是一個提醒：告訴自己，這些內容是 AI 產生的，只能作為「參考」。雖然嚴格來說，我們所知道的一切，都是參考。</p><h2 id="預設相信八成"><a href="#預設相信八成" class="headerlink" title="預設相信八成"></a>預設相信八成</h2><p>我的看法是，在「<strong>一般情況</strong>（下面會討論「非一般」情況）」下，AI 的回答我會給予 80% 的相信程度。（這只是一種量化的表達方式，不必太認真）</p><p>所謂的「一般情況」，就是<strong>你大概能相信它不會講錯</strong>的情況，這好像是廢話XD。舉例而言，好比我問 ChatGPT 關於 Python 的議題。</p><p>而 Python 是一個很「<strong>一般（general）</strong>」的主題，意謂<strong>網路、文獻資料極多</strong>，我幾乎不擔心它會說謊（有幻覺）——除非是太新的功能。</p><p>對，我只會這樣分XD！所以很依賴個人判斷，但有這個「<strong>場景意識（知曉討論主題的一般與特殊程度）</strong>」確實很重要。</p><p>其實我覺得，加上標籤就很有幫助了！至少是對大腦的一種<strong>提醒</strong>。</p><p>此外，如果不是和 AI 的對話，但是我問了 AI 並用它的回答作為補充，也會上個標籤，此時我用 #GPT——但不限於 ChatGPT 的回答。</p><hr><h2 id="非一般情況——我半信半疑"><a href="#非一般情況——我半信半疑" class="headerlink" title="非一般情況——我半信半疑"></a>非一般情況——我半信半疑</h2><p>上述的「一般」議題我不怕它說謊，但<strong>只要討論主題稍為「特殊」一點，我對它可信度的把握，也隨之下降。</strong></p><p>比如，我工作中很常遇到的 Django 議題。Django 算是「一般」還是「特殊」議題，取決於你問的<strong>具體內容（子議題）</strong>是什麼。</p><p>Django 的<strong>基本概念</strong>，問 ChatGPT 沒問題，這些屬於一般議題。</p><p>但<strong>複雜的 ORM 查詢語法</strong>，就<strong>很不一般</strong>（相關資料少得多），你問 ChatGPT，它也都能說出個所以然，但我對它的回答就會半信半疑。</p><p>這時，我需要一些手段來確認。不然乾脆不要記錄，或者記錄時寫下「待驗證」之類的短語。</p><h2 id="降低不確定性的手段"><a href="#降低不確定性的手段" class="headerlink" title="降低不確定性的手段"></a>降低不確定性的手段</h2><p>遇到半信半疑的時候，有三種方法降低我的不確定性。</p><h3 id="一、看文件"><a href="#一、看文件" class="headerlink" title="一、看文件"></a>一、看文件</h3><p>看文件，這肯定是最重要的，文件說了算！——雖然文件有時候也會描述不清楚，讓人愈看愈糊塗。</p><p>但看文件是作為開發者的義務，可以罵文件沒寫好，但自己沒查，總是說不過去。</p><h3 id="二、Google"><a href="#二、Google" class="headerlink" title="二、Google"></a>二、Google</h3><p>老方法，其中 Stack Overflow 的回答還有 GitHub 上的 issue 討論，往往特別有幫助。</p><h3 id="二、問其它-AI-工具"><a href="#二、問其它-AI-工具" class="headerlink" title="二、問其它 AI 工具"></a>二、問其它 AI 工具</h3><p>除了 ChatGPT（GPT-4），是我的絕對開發主力，我使用的其它工具如下：（都沒有付費）</p><ol><li><a href="https://www.phind.com/">Phind</a></li><li><a href="https://claude.ai/">Claude</a></li><li><a href="https://devv.ai/">Devv AI</a></li></ol><p>上述順序恰恰也是我詢問的順序。不過通常問完 Phind 我就收手了，除非我非常想知道答案。（其實這個時候不會有答案，只有更多的疑問和不確定）</p><p>然而，如果我真問完一輪上述的 AI，那這個問題肯定是沒有讓我滿意的回答，<strong>我全部的回答都不信</strong>，只是想知道這些模型怎麼說而已😷</p><hr><h2 id="小結：就算正確，也可能是暫時的"><a href="#小結：就算正確，也可能是暫時的" class="headerlink" title="小結：就算正確，也可能是暫時的"></a>小結：就算正確，也可能是暫時的</h2><p>總的來說，我做筆記的基本態度是：所有的筆記，都只能算「<strong>我暫時相信的事</strong>」，後面有了新的事實、觀點，就要<strong>繼續修改或廢棄內容。</strong></p><p>當然，如果這些筆記參雜太多 AI 幻覺，也是挺困擾的！</p><p>所以我們<strong>需要一些 sense</strong>，知道什麼情況下，對它的回答<strong>不能認真</strong>。加上適時查證，我相信幻覺問題會大大減少。</p><p>而且，無論資訊是否來自 AI，筆記終歸是筆記，我們還是得保持一顆<strong>懷疑的心</strong>，即使是書中的內容，也不能盡信。</p><p>畢竟書的內容即使正確，也可能<strong>被我誤解地記錄下來</strong>。退萬步言，就算是正確的，這樣的正確，<strong>也可能只是暫時的。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YmlPRz1.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;你會把「和 ChatGPT 的對話、問答」寫成筆記嗎？&lt;a href=&quot;https://twitter.com/kyomind/status/1790032744598188070&quot;&gt;顯然我會，而且很大量！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中有 8 成以上都是程式相關，來自每天和 ChatGPT 的日常開發問答。&lt;/p&gt;
&lt;p&gt;應該說，與 ChatGPT 對話&lt;strong&gt;早已成為我工作、學習的重要環節&lt;/strong&gt;。在〈&lt;a href=&quot;https://blog.kyomind.tw/stop-trial-and-error/&quot;&gt;別依賴「試誤法」寫程式&lt;/a&gt;〉中我也&lt;a href=&quot;https://blog.kyomind.tw/stop-trial-and-error/#%E8%A9%A6%E8%AA%A4%E4%BE%9D%E8%B3%B4%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%95%8F%E9%A1%8C&quot;&gt;強調過&lt;/a&gt;，像 ChatGPT 這樣的工具，如果僅僅用來「獲得答案」，&lt;strong&gt;未免也太可惜。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此，我幾乎每天都會有新的「AI 對話筆記」。&lt;/p&gt;
&lt;p&gt;話說回來，把 AI 的回答寫成筆記，並作為主要的知識來源，&lt;strong&gt;這是一個好的實踐嗎？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文無法回答這個問題XD，但我可以分享一下，做了一年 AI 對話筆記後，我的看法與注意事項。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/YmlPRz1.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="學習" scheme="https://blog.kyomind.tw/tags/%E5%AD%B8%E7%BF%92/"/>
    
  </entry>
  
  <entry>
    <title>Django REST framework 教學（一）前言篇</title>
    <link href="https://blog.kyomind.tw/django-rest-framework-01/"/>
    <id>https://blog.kyomind.tw/django-rest-framework-01/</id>
    <published>2024-05-11T17:15:37.000Z</published>
    <updated>2024-05-14T03:36:09.559Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 的第 4 篇。</p><p>範例程式碼可參考我的 <a href="https://github.com/kyomind/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="/django/">Django 文章總覽</a>」。</p><hr><p>終於要進入 Django API 的世界了！</p><p>不過，在開始 DRF 教學之前，我要先介紹 Django、DRF 兩者間的<strong>關係</strong>。</p><p>為什麼 Django 不乾脆自己實作 API 功能就好？而是把這個任務交給第三方套件，比如本文的 Django REST framework。</p><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>因此，本文的主要目標是：<strong>為讀者建立一個「high level」的世界觀</strong>。讓你了解為何在 Django 之外，我們還需要 Django REST framework。</p><p>了解兩者的關係，更能體會<strong>它們所扮演的不同角色。</strong></p><p>簡言之，這一篇還沒有要開始寫 API。</p><h3 id="系列：Django-REST-framework-教學"><a href="#系列：Django-REST-framework-教學" class="headerlink" title="系列：Django REST framework 教學"></a>系列：Django REST framework 教學</h3><ul><li><a href="/series/#Django-REST-framework-%E6%95%99%E5%AD%B8">系列文章清單（連載中）</a></li></ul><span id="more"></span><hr><h2 id="Django-介紹"><a href="#Django-介紹" class="headerlink" title="Django 介紹"></a>Django 介紹</h2><p>Django 是一個<strong>全端框架</strong>（其實是附有<strong>前端模板</strong>的<strong>後端框架</strong>），它強大而靈活，能處理從模板渲染、表單生成、後台管理、資料庫模型等，幾乎所有事情。</p><p>我們常說 Python 是「<a href="https://en.wikipedia.org/wiki/Batteries_Included">Batteries Included</a>」（意味有豐富的標準函式庫），<strong>而 Django 也是如此——它大而全。</strong></p><p>在這個設計理念下，Django 關心的是「<strong>整個網站的建構</strong>」，所以它必須要從前端包到後端，而不會只專注在後端 API。</p><h2 id="Django-REST-framework-介紹"><a href="#Django-REST-framework-介紹" class="headerlink" title="Django REST framework 介紹"></a>Django REST framework 介紹</h2><p>當涉及到現代 Web 開發，尤其是與前端框架如 React、Vue 的配合，我們需要<strong>更專注於 API 的開發方式</strong>。畢竟「<strong>前後端分離</strong>」是當前 Web 開發主流。</p><p>於是我們有了 <a href="https://www.django-rest-framework.org/">Django REST framework</a>。</p><blockquote><p>我仔細看，<strong>f 真的是小寫，而 REST 要全大寫</strong>，這是官方的寫法。為了表述方便，以下簡稱為 DRF。</p></blockquote><p>DRF 引入了專門針對 API 的功能，如強大的序列化器、權限管理、通用 API 視圖。</p><p>這些功能使得 DRF 不僅能夠擴充 Django 的原有能力，而且提供了對 RESTful API 開發的專門支持。</p><p>不得不承認，在「前後端分離」已成顯學的今日，有了 DRF 這樣的框架，能有效維持 Django 作為一個開源後端框架的<strong>整體競爭力</strong>。</p><hr><h2 id="為何需要-DRF"><a href="#為何需要-DRF" class="headerlink" title="為何需要 DRF"></a>為何需要 DRF</h2><p>但又話說回來，為何 Django 不自己強化 API 功能，而是交給 DRF 這類套件呢？</p><p>我們可以從以下兩個方向考慮：</p><h3 id="一、專注與專業分工"><a href="#一、專注與專業分工" class="headerlink" title="一、專注與專業分工"></a>一、專注與專業分工</h3><ul><li>Django 的核心團隊專注於框架的<strong>基礎功能</strong>——比如 ORM、Middleware，這些是所有使用 Django 的開發者都需要的核心功能。</li><li>API 開發則是一個<strong>專業領域</strong>，涉及不同的需求和專業知識，如資料驗證與序列化。DRF 對建構 REST API 功能進行擴充，提供了<strong>一整套工具與實踐。</strong></li></ul><h3 id="二、模組化與彈性"><a href="#二、模組化與彈性" class="headerlink" title="二、模組化與彈性"></a>二、模組化與彈性</h3><ul><li>通過將 API 功能外包給如 DRF 這樣的套件，Django <strong>保持了核心的簡潔</strong>，同時提供了一定<strong>彈性</strong>。讓開發者可以<strong>根據需求</strong>，選擇合適自己的工具。</li><li>換句話說，Django 專注在核心功能而不是 API，可以讓它<strong>更全面、更靈活。</strong></li><li>這意味著你可以<strong>只在需要時</strong>引入 DRF，進而保持專案的<strong>輕量</strong>。畢竟，Django 本身已經非常豐富。</li></ul><h2 id="Django-與-DRF-比較"><a href="#Django-與-DRF-比較" class="headerlink" title="Django 與 DRF 比較"></a>Django 與 DRF 比較</h2><p>綜上所述，我們直接用表格來比較兩者的功能與角色差異：</p><table><thead><tr><th></th><th>Django</th><th>DRF</th></tr></thead><tbody><tr><td>主要目的</td><td>全面的 Web 框架，提供完整的 Web 應用開發支持。</td><td>專注於 Web API 的建立，特別是 RESTful API。</td></tr><tr><td>設計哲學</td><td>提供高度可重用性和快速開發元件，比如 Django ORM。</td><td>API 優先：提供 API 特定的工具和功能，比如序列化器。</td></tr><tr><td>核心功能</td><td>模板渲染、表單生成、管理界面、資料庫模型。</td><td>序列化、權限控制、API View。</td></tr><tr><td>目標用戶</td><td>面向所有類型的 Web 開發者，包括初學者和專業人士。</td><td>面向需要建立複雜 API 的開發者。</td></tr></tbody></table><hr><p>了解 Django 與 DRF 的差異後，還有一個議題也很重要——CBV 與 FBV。</p><h2 id="CBV-vs-FBV"><a href="#CBV-vs-FBV" class="headerlink" title="CBV vs FBV"></a>CBV vs FBV</h2><p>Class-based view 與 function-based view，兩者都是實現 Django 中 view 的手段，各有適合的場景。</p><p>CBV 有著<strong>重用程式碼</strong>優勢，適合大型專案。而 FBV 則以<strong>簡單、直接</strong>為賣點，方便快速開發中小型專案。</p><p>老實說，我只寫過 FBV，而且我也更愛 FBV。</p><h3 id="DRF-更擅長-CBV"><a href="#DRF-更擅長-CBV" class="headerlink" title="DRF 更擅長 CBV"></a>DRF 更擅長 CBV</h3><p>不過，DRF 本身對於 CBV 有著「<strong>更完整的支援</strong>」。</p><p>所以如果你想要將 DRF 發揮到極致，那它提供的 <a href="https://www.django-rest-framework.org/api-guide/generic-views/#genericapiview">GenericAPIView</a> 值得了解一下。並且和 DRF 其它元件有著<strong>高度整合。</strong></p><h3 id="本系列只會使用-FBV"><a href="#本系列只會使用-FBV" class="headerlink" title="本系列只會使用 FBV"></a>本系列只會使用 FBV</h3><p>不過因為我沒真正大量使用過 CBV，而且 DRF 系列只是入門教學，所以我只會用 FBV 進行示範。</p><p>另一方面，Django Ninja、FastAPI、Flask 都是以 FBV 為主，或許對大部分人而言，能善用 FBV 已然足夠。</p><hr><h2 id="DRF-vs-Django-Ninja"><a href="#DRF-vs-Django-Ninja" class="headerlink" title="DRF vs Django Ninja"></a>DRF vs Django Ninja</h2><p>長期以來，DRF 一直是開發 Django API 的主要甚至唯一選擇——直到 <a href="https://django-ninja.dev/">Django Ninja</a> 的出現。</p><p>Django Ninja 是烏克蘭開發者 <a href="https://github.com/vitalik">Vitaliy Kucheryaviy</a> 的力作，可以想成是「<strong>Django 版 FastAPI</strong>」。</p><p>它提供不同於傳統寫法的 FBV，高度整合了 Python type hints。並使用 Pydantic 進行資料的驗證與序列化，還有最重要的——自動產生 API 文件。</p><p>關於 Django Ninja，以及它和 DRF 的比較，我會放到 Django Ninja 系列，再行介紹。</p><hr><h2 id="小結：入門者的選擇"><a href="#小結：入門者的選擇" class="headerlink" title="小結：入門者的選擇"></a>小結：入門者的選擇</h2><p>本文講述了 Django 與 DRF 在現代開發中扮演的角色，與它們之間相輔相成的關係。</p><p>如果你是剛開始接觸 Django API 的開發者，我相信 DRF 仍是第一選擇。因為它更加成熟，而且累積了大量的歷史資料，可作為開發時的參考。</p><p>在熟悉了基本的 Django API 開發流程與常見元素後，再學習 Django Ninja 也不遲。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 的第 4 篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;終於要進入 Django API 的世界了！&lt;/p&gt;
&lt;p&gt;不過，在開始 DRF 教學之前，我要先介紹 Django、DRF 兩者間的&lt;strong&gt;關係&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;為什麼 Django 不乾脆自己實作 API 功能就好？而是把這個任務交給第三方套件，比如本文的 Django REST framework。&lt;/p&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;因此，本文的主要目標是：&lt;strong&gt;為讀者建立一個「high level」的世界觀&lt;/strong&gt;。讓你了解為何在 Django 之外，我們還需要 Django REST framework。&lt;/p&gt;
&lt;p&gt;了解兩者的關係，更能體會&lt;strong&gt;它們所扮演的不同角色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;簡言之，這一篇還沒有要開始寫 API。&lt;/p&gt;
&lt;h3 id=&quot;系列：Django-REST-framework-教學&quot;&gt;&lt;a href=&quot;#系列：Django-REST-framework-教學&quot; class=&quot;headerlink&quot; title=&quot;系列：Django REST framework 教學&quot;&gt;&lt;/a&gt;系列：Django REST framework 教學&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/series/#Django-REST-framework-%E6%95%99%E5%AD%B8&quot;&gt;系列文章清單（連載中）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Django REST framework" scheme="https://blog.kyomind.tw/tags/Django-REST-framework/"/>
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>我絕不用 result 作為變數名稱</title>
    <link href="https://blog.kyomind.tw/no-result/"/>
    <id>https://blog.kyomind.tw/no-result/</id>
    <published>2024-05-04T07:28:56.000Z</published>
    <updated>2024-05-26T15:00:52.217Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/YmlPRz1.jpg" alt="by Sam Chivers"><span class="cap">by Sam Chivers</span></p><p>在〈<a href="/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a>〉中，我們提到了「<a href="/beyond-the-basic-stuff-with-python-01/#%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%B3%9F%E7%9A%84%E8%AE%8A%E6%95%B8%E5%90%8D%E7%A8%B1%E2%80%94%E2%80%94data">data</a>」這個不佳的變數名稱。</p><p>以及應該要用<strong>什麼樣的名稱</strong>取代它，與<strong>例外可以使用</strong> data 的情況。</p><p>看過那段後，你可以發現，data 雖爛，但還是<strong>偶有派上用場</strong>的時候。雖然絕大部分的情況，我依舊會避免使用。</p><p>然而有一個變數名稱，<strong>我絕對不會用</strong>。</p><h2 id="比-data-更糟的變數名稱——result"><a href="#比-data-更糟的變數名稱——result" class="headerlink" title="比 data 更糟的變數名稱——result"></a>比 data 更糟的變數名稱——result</h2><p>當我遵守了好習慣，盡可能避免在程式碼中使用 data 命名後，本以為能從此過上幸福快樂的生活，<strong>但我錯了！</strong></p><p>因為沒多久後我就發現，還有一個比 data 更<strong>駭人聽聞</strong>的變數名稱——<code>result</code>。</p><p>和 data 相比，其<strong>糟糕的程度</strong>，簡直<strong>有過之而無不及</strong>。畢竟<strong>萬事萬物都有「result」</strong>，因果循環、生生不息，而且這個命名<strong>更加抽象</strong>，令人不禁想問：</p><blockquote><p><strong>到底是什麼結果？</strong></p></blockquote><p>result 命名的濫用，在「儲存呼叫函式的<strong>結果</strong>」時最為常見，<strong>難怪到處都是 result。</strong></p><span id="more"></span><hr><h2 id="3-個代表性案例"><a href="#3-個代表性案例" class="headerlink" title="3 個代表性案例"></a>3 個代表性案例</h2><p>不誇張地說，code review 時我看到 result 這個變數名稱，<strong>幾乎都會建議改掉</strong>。因為它<strong>太過籠統</strong>，讓人無法立刻了解這個變數的內容與用途。</p><p><strong>甚至有一種噁心感。</strong>（內心 OS：就這麼懶得想名字？）</p><p>不過，若細看後發現，眼前的情況<strong>真的不容易命名</strong>，我可能會選擇睜一隻眼閉一隻眼，暫時就先算了吧！😷</p><p>但平心而論，這<strong>真的是少數</strong>。我遇到大部分使用 result 的情況，都是<strong>懶得想名字XD</strong>。無論如何，我自己寫程式時，不會考慮使用 result，<strong>而且我認為這並不難。</strong></p><p>下面我們就舉 3 個代表性案例，來看看 result 到底有多糟糕。以及應該要用什麼名稱來取代它——基本上就是<strong>更直接、具體、精確</strong>的名稱。</p><h2 id="一、從資料庫查詢訂單"><a href="#一、從資料庫查詢訂單" class="headerlink" title="一、從資料庫查詢訂單"></a>一、從資料庫查詢訂單</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不好的寫法</span></span><br><span class="line">result = query_orders_from_database(customer_id)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更好的寫法</span></span><br><span class="line">orders = query_orders_from_database(customer_id)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一種典型的情況是，<strong>明明有更具體的名稱可以使用</strong>，卻偏偏用了籠統的 result。</p><p>這樣的寫法，讓人看了一頭霧水，不確定 result 到底是指什麼。</p><p>類似的例子還有求平均值、性別、數量等等，太多了，都有一個 result，但明顯都可以用更具體的名稱來取代。</p><p>事實上，如前所述，會把變數命名為 result，<strong>往往不是真的遇到什麼難以命名的情境</strong>，而是因為懶XD。可是這份懶惰，<strong>會讓你的程式碼變得難讀</strong>。</p><p>其中的代價，不可謂不大。</p><hr><h2 id="二、檢查用戶是否有管理員權限"><a href="#二、檢查用戶是否有管理員權限" class="headerlink" title="二、檢查用戶是否有管理員權限"></a>二、檢查用戶是否有管理員權限</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不好的寫法</span></span><br><span class="line">result = check_user_is_admin(user_id)</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更好的寫法</span></span><br><span class="line">is_admin = check_user_is_admin(user_id)</span><br><span class="line"><span class="keyword">if</span> is_admin:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>這是我認為<strong>最重要</strong>的一條守則，簡言之：<strong>你不應該使用 result 來表示「狀態」</strong>。</p><p>尤其當這個狀態是一個<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E6%9E%97_(%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B)">布林值</a>時，代表「操作成功與否」或「特定條件是否符合」等等情況，你更應該使用<strong>具體的名稱</strong>。</p><p>這個時候，我們可以考慮使用充滿了「<strong>布林味</strong>」的變數名稱，比如<code>has_permission</code>、<code>is_valid</code>、<code>is_success</code>等等——而不是<code>result</code>。</p><h3 id="為什麼布林值最不適合用-result？"><a href="#為什麼布林值最不適合用-result？" class="headerlink" title="為什麼布林值最不適合用 result？"></a>為什麼布林值最不適合用 result？</h3><p>回傳內容如果由<strong>很多部分組成，此時確實不容易概括成一個名稱</strong>。</p><p>要命名好這類的回傳結果，<strong>需要花一定時間思考、評估其合適性，並不輕鬆</strong>。所以有些開發者乾脆用 result 來表示，姑且算是一種 <strong>workaround</strong> 吧！情有可原。</p><p>但如果回傳只是一個布林值，那就沒有「<strong>內涵太複雜以至於不易命名</strong>」問題。因為布林就只有兩種可能性：<strong>True 或 False</strong>。</p><p>此時再偷懶用 result，恐怕就說不太過去了。</p><hr><h2 id="三、使用-requests-發出-HTTP-請求"><a href="#三、使用-requests-發出-HTTP-請求" class="headerlink" title="三、使用 requests 發出 HTTP 請求"></a>三、使用 requests 發出 HTTP 請求</h2><p>終於來你最常見到的情境了，使用<code>requests</code>（或<code>httpx</code>）發出 HTTP 請求，並將回傳的結果存入 result。</p><p>雖然大部分人都會將這個變數命名為 response，但<strong>還是有人會用 result</strong>——而且覺得兩者「<strong>其實也沒什麼不同</strong>」啊！</p><p>（這種「我覺得都差不多啊！」的思維才是真正嚇人的，你懂的。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不好的寫法</span></span><br><span class="line">result = requests.get(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> result.status_code == <span class="number">200</span>:</span><br><span class="line">    process_data(result.json())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更好的寫法</span></span><br><span class="line">response = requests.get(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    process_data(response.json())</span><br></pre></td></tr></table></figure><p>在這個例子中，使用 response 作為變數名稱會比使用 result <strong>更加清晰和具描述性。</strong></p><p>當其他開發者看到這段程式碼時，會立即明白這個變數存儲的是一個 HTTP response（通常就是<code>requests</code>的<code>response</code>物件），而不是某個抽象的「結果」。</p><p>如果隨意地命名為 result，後續使用該變數時，result <strong>預期</strong>會有什麼屬性？什麼方法？<strong>一切都不明朗</strong>，因為它有<strong>無限可能</strong>。</p><p>往往要回去看變數的<strong>定義</strong>部分，才能知曉 result 究竟代表什麼。</p><p><strong>當這變數的生命週期愈長、呼叫的次數愈多，使用 result 名稱造成的「可讀性問題」就愈嚴重。</strong></p><p>這個例子還有一個常見的「<strong>變形</strong>」——<code>res</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = requests.get(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">    process_data(res.json())</span><br></pre></td></tr></table></figure><p>這麼巧！response 和 result 兩者恰好都是以 res 為前綴，只要命名為<code>res</code>就天下太平了——才怪。</p><p>有什麼比 result 更讓人想握緊拳頭的變數名稱嗎？<strong>恐怕就是 res 了。</strong></p><hr><h2 id="小結：No-result"><a href="#小結：No-result" class="headerlink" title="小結：No result"></a>小結：No result</h2><p>總的來說，data 至少還有適用的例外情況，但 result，<strong>我真的想不到。</strong></p><p>我非常確信，打從我轉職後工作的第二年起（第一年還懵懂無知），再就也沒有使用過 result 這個變數名稱。</p><p><strong>一次也沒有。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YmlPRz1.jpg&quot; alt=&quot;by Sam Chivers&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;/beyond-the-basic-stuff-with-python-01/&quot;&gt;《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道&lt;/a&gt;〉中，我們提到了「&lt;a href=&quot;/beyond-the-basic-stuff-with-python-01/#%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%B3%9F%E7%9A%84%E8%AE%8A%E6%95%B8%E5%90%8D%E7%A8%B1%E2%80%94%E2%80%94data&quot;&gt;data&lt;/a&gt;」這個不佳的變數名稱。&lt;/p&gt;
&lt;p&gt;以及應該要用&lt;strong&gt;什麼樣的名稱&lt;/strong&gt;取代它，與&lt;strong&gt;例外可以使用&lt;/strong&gt; data 的情況。&lt;/p&gt;
&lt;p&gt;看過那段後，你可以發現，data 雖爛，但還是&lt;strong&gt;偶有派上用場&lt;/strong&gt;的時候。雖然絕大部分的情況，我依舊會避免使用。&lt;/p&gt;
&lt;p&gt;然而有一個變數名稱，&lt;strong&gt;我絕對不會用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;比-data-更糟的變數名稱——result&quot;&gt;&lt;a href=&quot;#比-data-更糟的變數名稱——result&quot; class=&quot;headerlink&quot; title=&quot;比 data 更糟的變數名稱——result&quot;&gt;&lt;/a&gt;比 data 更糟的變數名稱——result&lt;/h2&gt;&lt;p&gt;當我遵守了好習慣，盡可能避免在程式碼中使用 data 命名後，本以為能從此過上幸福快樂的生活，&lt;strong&gt;但我錯了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因為沒多久後我就發現，還有一個比 data 更&lt;strong&gt;駭人聽聞&lt;/strong&gt;的變數名稱——&lt;code&gt;result&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;和 data 相比，其&lt;strong&gt;糟糕的程度&lt;/strong&gt;，簡直&lt;strong&gt;有過之而無不及&lt;/strong&gt;。畢竟&lt;strong&gt;萬事萬物都有「result」&lt;/strong&gt;，因果循環、生生不息，而且這個命名&lt;strong&gt;更加抽象&lt;/strong&gt;，令人不禁想問：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;到底是什麼結果？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;result 命名的濫用，在「儲存呼叫函式的&lt;strong&gt;結果&lt;/strong&gt;」時最為常見，&lt;strong&gt;難怪到處都是 result。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/YmlPRz1.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="程式設計" scheme="https://blog.kyomind.tw/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="壞味道" scheme="https://blog.kyomind.tw/tags/%E5%A3%9E%E5%91%B3%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>29，我編輯舊文的三個理由</title>
    <link href="https://blog.kyomind.tw/weekly-review-29/"/>
    <id>https://blog.kyomind.tw/weekly-review-29/</id>
    <published>2024-04-30T18:50:09.000Z</published>
    <updated>2024-05-01T16:49:49.825Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>作為一個 blog 創作者，我算是比較常<strong>編輯、翻修舊文</strong>的人。</p><p>編輯舊文往往需要花費不少時間，而且讀者也未必看得出有哪裡不同——所以我一定會在文章開頭備註、提醒☺️</p><p>部分文章，編輯過不止一次，比如〈<a href="https://blog.kyomind.tw/python-poetry/">Python 套件管理器——Poetry 完全入門指南</a>〉，我將它視為代表作之一，編輯的次數應該是全站之最。</p><p>這樣的行為，雖然源於<strong>對文字與表達的追求</strong>，但其中也有<strong>實際的理由</strong>。</p><p>這篇來就分享一下，我考慮編輯舊文的<strong>三個實際理由。</strong></p><span id="more"></span><hr><h2 id="一、流量起來了"><a href="#一、流量起來了" class="headerlink" title="一、流量起來了"></a>一、流量起來了</h2><p>這應該不用解釋，當一篇文章看的人變多時，你會有<strong>兩種感受</strong>：</p><ol><li><strong>虛榮感</strong>——受歡迎的感覺真好！</li><li><strong>責任感</strong>——我應該沒有哪邊寫錯了吧？👀</li></ol><p>即使不考慮上述感受，我認為「流量」仍可作為編輯舊文的<strong>首要理由</strong>。</p><p>如果該文章<strong>突顯你的個人風格或價值觀</strong>，花費心思去增進文字的精確度與表達的流暢，確實更加值得——因為它會被更多人看到。</p><p>儘管這不是一個高大上的理由，但我覺得它是<strong>最實際</strong>的理由。</p><p>倘若你身處於部落格寫作的第一年，建議以這個指標作為編輯舊文的主要依據。</p><h2 id="二、內容過時了"><a href="#二、內容過時了" class="headerlink" title="二、內容過時了"></a>二、內容過時了</h2><p>文章內容是否會過時，和主題的<strong>性質</strong>有很大關係。</p><p>個人情感抒發或價值觀表述，即使<strong>現在已經不這麼想了</strong>，也稱不上「過時」，因為那就是當時的想法。</p><p>相對的，技術類文章就比較容易遇到過時問題——尤其是工具教學！</p><p>面對這種「技術上的過時」，你有三種處理方式：</p><ol><li>不理它，反正有發文日期，雖然現在已經過時了，至少它曾經是對的！這屬於最簡單的做法——<strong>什麼都不做</strong>。說真的，通常讀者也不會苛責啦！</li><li>在文中（通常是開頭）表示：「本文部分內容已經過時，請讀者留意或自行查閱官方文件。」這已經算不錯的了，<strong>至少願意提醒讀者。</strong></li><li>依照新的事實，更新文章內容！雖然很累，<strong>但我願意為你喝采！</strong></li></ol><p>〈<a href="https://blog.kyomind.tw/ubuntu-pyenv/">Ubuntu 安裝使用 pyenv + pyenv-virtualenv</a>〉就是很好的例子，以下是文章在重新編輯後新增的段落：</p><blockquote><p><code>2023/04/07</code>重要更新：pyenv 2.3.0 以後，已經大幅簡化了設定操作，本段內容在新版仍可適用，但建議直接升級最新版 pyenv 並直接改用以下設定：（我把指令改成新版）</p></blockquote><p>而且，上述例子也不是單純更新指令就好。我往往還得判斷：哪些內容過時了，要直接刪除。哪些要留下，以及是否需要改寫等等。</p><p><strong>這通常不是一件有趣的事。但你的用心，讀者會看到。</strong></p><h2 id="三、廢話太多了"><a href="#三、廢話太多了" class="headerlink" title="三、廢話太多了"></a>三、廢話太多了</h2><p>為這個理由而編輯舊文，顯示出你<strong>身為作者的自我追求。</strong></p><p>容我解釋一下，所謂的「廢話太多」指的是，你發現文中有一些段落，和主軸<strong>沒有那麼大的關聯</strong>，或可能<strong>增加讀者閱讀上的負擔</strong>——讀者不明白你為什麼要寫這一段。</p><p>然而，作者對自己的內容，肯定都是有<strong>盲點</strong>的——否則就不需要編輯了。想要<strong>自行發現這類問題，說真的，著實不易</strong>！</p><p>畢竟，一字一句都是我的嘔心瀝血之作啊！</p><blockquote><p>那我要怎麼發現這些「廢話」呢？</p></blockquote><p>有一個簡單的判斷方式（雖然未必準確），那就是明明文章篇幅不短，但從後台數據的「平均閱讀時間」看，卻偏短。</p><p>這可能意味著，你的內容，讀者<strong>並不買帳</strong>！你覺得很棒的東西，<strong>他們只覺得很煩</strong>。所以選擇匆匆略過。</p><p>這時我會把<strong>編輯重心</strong>放在「<strong>閱讀流暢度</strong>」上，而提升閱讀流暢度的一個<strong>有效方法</strong>，就是<strong>刪掉那些冗餘的段落</strong>！（要注意刪除後的落段銜接，必要時甚至得增補）</p><p>這真的很不容易——都是自己的孩子啊啊啊！</p><p>但通常這類編輯，<strong>效果特別好，成就感也特別高。</strong></p><p>以下 3 篇是我認為「<strong>刪減後更佳</strong>」的適例（雖然還是很長XD），供讀者參考：</p><ol><li><a href="https://blog.kyomind.tw/the-quick-python-book/">最佳 Python 入門書——《Python 技術者們 - 練功！》心得與導讀</a></li><li><a href="https://blog.kyomind.tw/pyproject-toml/">Python 開發：pyproject.toml 介紹 + 使用教學</a></li><li><a href="https://blog.kyomind.tw/poetry-pyenv-practical-tips/">Poetry + pyenv 教學：常用指令與注意事項</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;作為一個 blog 創作者，我算是比較常&lt;strong&gt;編輯、翻修舊文&lt;/strong&gt;的人。&lt;/p&gt;
&lt;p&gt;編輯舊文往往需要花費不少時間，而且讀者也未必看得出有哪裡不同——所以我一定會在文章開頭備註、提醒☺️&lt;/p&gt;
&lt;p&gt;部分文章，編輯過不止一次，比如〈&lt;a href=&quot;https://blog.kyomind.tw/python-poetry/&quot;&gt;Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;〉，我將它視為代表作之一，編輯的次數應該是全站之最。&lt;/p&gt;
&lt;p&gt;這樣的行為，雖然源於&lt;strong&gt;對文字與表達的追求&lt;/strong&gt;，但其中也有&lt;strong&gt;實際的理由&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這篇來就分享一下，我考慮編輯舊文的&lt;strong&gt;三個實際理由。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="重構" scheme="https://blog.kyomind.tw/tags/%E9%87%8D%E6%A7%8B/"/>
    
    <category term="blog" scheme="https://blog.kyomind.tw/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Django HttpRequest 常用屬性介紹</title>
    <link href="https://blog.kyomind.tw/django-request/"/>
    <id>https://blog.kyomind.tw/django-request/</id>
    <published>2024-04-28T07:08:53.000Z</published>
    <updated>2024-04-29T05:17:53.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 系列連載的第 3 篇。</p><p>範例程式碼可參考我的 <a href="https://github.com/kyomind/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="https://blog.kyomind.tw/django/">Django 文章總覽</a>」。</p><hr><p>如〈<a href="https://blog.kyomind.tw/django-tutorial/">Django Tutorial：系列介紹與導讀</a>〉所言，這個系列主要是圍繞著「Django API」教學展開的。</p><p>但無論是用 Django 建立全端網站，還是開發 API，Django 的 <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/">HttpRequest</a>——也就是我們熟悉的<code>request</code>參數——都是必不可少的元素。</p><p><code>HttpRequest</code>封裝了來自前端的 HTTP 請求，而 Django 會將<code>HttpRequest</code>物件自動帶入 view 函式的<strong>第一位置參數</strong>（通常就叫<code>request</code>），讓我們可以直接使用。</p><h2 id="為何需要了解-HttpRequest-物件"><a href="#為何需要了解-HttpRequest-物件" class="headerlink" title="為何需要了解 HttpRequest 物件"></a>為何需要了解 <code>HttpRequest</code> 物件</h2><p>在我剛開始寫 Django 的時候，根本不太清楚<code>HttpRequest</code>具體有哪些屬性。</p><p>通常是看教學或為了實作某個功能而 Google 的時候，看到範例程式碼使用某個屬性，然後才知道這個屬性的存在。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">    do_something_else()</span><br></pre></td></tr></table></figure><p>看到這段，才知道<code>request</code>有一個<code>method</code>屬性。</p><p>這樣學當然可以，但如果一開始就對常用的<code>HttpRequest</code>屬性有<strong>基本了解</strong>，會讓你在學習 Django 的路上<strong>更加踏實</strong>。</p><span id="more"></span><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>基於上述考量，我覺得還是有必要整理一下，對於 Django 初學者而言，最常用或需要了解的<code>HttpRequest</code>屬性。</p><p>不求多深，或知悉所有屬性的具體用法。面對<code>HttpRequest</code>這樣內容豐富的物件，我們掌握 80&#x2F;20 法則，了解其中<strong>最重要的幾個</strong>，往往就能很有收獲。</p><p>至少，如果讓我重來，我會希望自己一開始就對這些屬性有一定認識。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文的目標讀者，是 <strong>Django 初學者</strong>。</p><p>無論想寫 Django 全端網站（也就是會用到 <a href="https://docs.djangoproject.com/en/5.0/topics/forms/">Django Form</a> 與 <a href="https://docs.djangoproject.com/en/5.0/ref/templates/language/">Template</a>），還是開發 API。這些屬性都相對重要，或至少要知道它有何「替代品」。</p><p>因此，我還會適時補充，使用框架（DRF、Django Ninja）開發 API 時，這些屬性是否被框架提供的新屬性取代。</p><h3 id="開始前的小提醒"><a href="#開始前的小提醒" class="headerlink" title="開始前的小提醒"></a>開始前的小提醒</h3><p>本文對<code>HttpRequest</code>屬性與介紹內容，主要整理自<a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#httprequest-objects">官方文件</a>，<strong>我會適度引用原文，並加上我的經驗、看法。</strong></p><p>提醒你：</p><ol><li>看完之後，如果<strong>依舊覺得不熟悉</strong>這些屬性，那也無妨，<strong>有基本的認識就很好了！</strong></li><li>所有的例示以 FBV（function-based view）為主，這是 Django 初學者最常接觸的 view 寫法。</li></ol><hr><p>以下依各個屬性在文件中出現的順序，一一介紹。</p><h2 id="一、HttpRequest-method"><a href="#一、HttpRequest-method" class="headerlink" title="一、HttpRequest.method"></a>一、HttpRequest.method</h2><blockquote><p>A string representing the HTTP method used in the request. This is guaranteed to be uppercase.</p></blockquote><p>表示請求所使用的 HTTP 方法，有兩個重點：</p><ol><li>型別為字串。</li><li>而且字串值一定是全大寫。比如<code>&quot;GET&quot;</code>、<code>&quot;POST&quot;</code>等。</li></ol><p>這或許是新手一開始最常呼叫的屬性XD。當然，前提是你寫的是 FBV（function-based view）。</p><p>在 view 函式中的用法前面已經提過：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">    do_something_else()</span><br></pre></td></tr></table></figure><hr><h2 id="二、HttpRequest-GET"><a href="#二、HttpRequest-GET" class="headerlink" title="二、HttpRequest.GET"></a>二、HttpRequest.GET</h2><blockquote><p>A dictionary-like object containing all given HTTP GET parameters. See the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.QueryDict"><code>QueryDict</code></a> documentation below.</p></blockquote><p>用來獲得 HTTP request 的「<strong>URL 參數</strong>」內容，比如你透過 GET 方法存取下列網址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.books.com/search?category=novel&amp;author=Asimov</span><br></pre></td></tr></table></figure><p>這個屬性可取得<code>?</code>後面的「<code>category=novel&amp;author=Asimov</code>」這段資訊。</p><p>而且屬性值的資料型別，是一個<code>QueryDict</code>。</p><p>關於<code>QueryDict</code>，你目前只需要知道，它是一個類似字典的物件，而<strong>值</strong>主要是<strong>字串</strong>，或<strong>元素為字串的 Python list</strong>——如果一個 key 有多個值。</p><p>以下是用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_books</span>(<span class="params">request</span>):</span><br><span class="line">    category = request.GET.get(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">    author = request.GET.get(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="不限於-GET-方法"><a href="#不限於-GET-方法" class="headerlink" title="不限於 GET 方法"></a>不限於 GET 方法</h3><p>雖然叫做<code>GET</code>，但實際上這個屬性不限於 GET 方法，只要是 URL 參數，都可以透過這個屬性取得。</p><p>畢竟除了 GET 方法，還有 DELETE、PATCH 等方法，也都可以透過 URL 參數傳遞資訊。只是因為 GET 方法最常見，所以這個屬性叫做<code>GET</code>。</p><p>我覺得這個命名<strong>多少有點誤導性</strong>，但不算是大問題。</p><h3 id="使用-DRF-框架"><a href="#使用-DRF-框架" class="headerlink" title="使用 DRF 框架"></a>使用 DRF 框架</h3><p>在 DRF（<a href="https://www.django-rest-framework.org/">Django REST framework</a>）的 <a href="https://www.django-rest-framework.org/api-guide/requests/#request-parsing">request</a> 中，官方推薦你使用 <a href="https://www.django-rest-framework.org/api-guide/requests/#query_params">query_params</a> 屬性代替<code>GET</code>屬性：</p><blockquote><p>For clarity inside your code, we recommend using <code>request.query_params</code> instead of the Django’s standard <code>request.GET</code>.</p></blockquote><p>如前所述，<code>GET</code>屬性名稱有點誤導性，而 DRF 的<code>query_params</code>確實比較合理。</p><p>至於是不是要遵守這個建議，我覺得最大的重點是「整個專案的<strong>一致性</strong>」——不要有人寫<code>query_params</code>、有人寫<code>GET</code>。</p><p>而 <a href="https://django-ninja.dev/">Django Ninja</a> 則沒有這個問題（不需要用到<code>GET</code>屬性），以後介紹 Django Ninja 再詳談。</p><hr><h2 id="三、HttpRequest-POST"><a href="#三、HttpRequest-POST" class="headerlink" title="三、HttpRequest.POST"></a>三、HttpRequest.POST</h2><blockquote><p>A dictionary-like object containing all given HTTP <strong>POST</strong> parameters, providing that the request contains <strong>form data</strong>.</p></blockquote><blockquote><p>See the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.QueryDict"><code>QueryDict</code></a> documentation below.</p></blockquote><blockquote><p>If you need to access raw or non-form data posted in the request, access this through the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.body"><code>HttpRequest.body</code></a> attribute instead.</p></blockquote><blockquote><p><code>POST</code> does <strong>not</strong> include file-upload information. See <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.FILES"><code>FILES</code></a>.</p></blockquote><p>我故意把一段原文分 4 段引用，因為它有下列重點：</p><ol><li>這個<code>POST</code>屬性，必須你的 HTTP 請求是 POST 方法。（對應第一段）</li><li>內容是 POST 請求中附帶的「表單資訊（form data）」。（對應第一段，這是最重要的一點！）</li><li>值的型別也是<code>QueryDict</code>。如前所述，值必為字串。（對應第二段）</li><li>如果想取得 form data 以外的內容，要使用<code>HttpRequest.body</code>。（對應第三段）</li><li>不包含上傳的檔案。因為已經有<code>FILES</code>屬性。（對應第四段）</li></ol><h3 id="只限-form-data"><a href="#只限-form-data" class="headerlink" title="只限 form data"></a>只限 form data</h3><p>簡單來說，這個屬性值對應 POST 請求中的 body，但 header 的<code>Content-Type</code>必須為<code>application/x-www-form-urlencoded</code>才行。</p><p>即 body <strong>必須是 form data</strong>，否則<code>POST</code>屬性不會有值。</p><p>不得不說，這屬性名稱也一樣<strong>有點誤導</strong>，因為它<strong>只限於 form data。</strong></p><p>當<code>Content-Type</code>是<code>application/json</code>或其他非表單的類型時，<code>HttpRequest.POST</code> 將會是<strong>空的</strong>，因為 Django 不會自動解析這些類型的資訊到 <code>POST</code> 屬性中。</p><h3 id="只限-POST-方法"><a href="#只限-POST-方法" class="headerlink" title="只限 POST 方法"></a>只限 POST 方法</h3><p>和<code>GET</code>屬性不同，<code>POST</code>屬性「<strong>只限</strong>」使用 POST 方法，這點要特別注意。</p><p>可是，其餘帶有 body 的方法，比如 PUT、PATCH、DELETE，<strong>也可能有 form data</strong>，但 Django 也不會自動解析到<code>POST</code>屬性中。此時該怎麼辦？</p><p>答案是：使用<code>request.body</code>屬性，自行解析。</p><h3 id="HttpRequest-body"><a href="#HttpRequest-body" class="headerlink" title="HttpRequest.body"></a>HttpRequest.body</h3><p>上述的<code>request.POST</code>有一定的限制，而<code>body</code>屬性更加全面。它也是代表 HTTP 請求 body 資料，不限於 POST 方法，且不限於 form data。</p><p>不過，<strong>它的屬性值型別是 bytestring：</strong></p><blockquote><p>The raw HTTP request body as a bytestring.</p></blockquote><p>你需要<strong>手動處理</strong>這個 bytestring，比如使用<code>json.loads()</code>解析 JSON 格式 body。</p><p>所以，實際上我們比較少用到<code>request.body</code>，而是用 DRF 的 <a href="https://www.django-rest-framework.org/api-guide/requests/#data">request.data</a> 屬性，或 Django Ninja 的 <a href="https://django-ninja.dev/guides/input/body/">Schema</a>。</p><p>它們會自動解析 body 資料，並轉換成 Python 物件。</p><h3 id="程式碼實例"><a href="#程式碼實例" class="headerlink" title="程式碼實例"></a>程式碼實例</h3><p>想像一個申請表單：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">submit_form</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        email = request.POST.get(<span class="string">&#x27;email&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其中要注意的是，HTTP POST 方法才會有<code>request.POST</code>屬性值，所以一定要先檢查方法：<code>if request.method == &#39;POST&#39;</code>。</p><p>並且如上所述，即使是 POST 方法，如果請求 body 不是 form data，<code>request.POST</code>依舊是空的。</p><h3 id="實務使用建議"><a href="#實務使用建議" class="headerlink" title="實務使用建議"></a>實務使用建議</h3><p>上述細節可能會新手有點眼花撩亂，不過別擔心，我們從一個更 high level 的角度看。</p><p>如果你寫的是「全端」Django，也就是包括了 Django Form 和模板，那這個<code>POST</code>屬性應該會<strong>很常用</strong>。因為前端（也就是 Django 模板）會傳來大量的 form data。</p><p>但如果你是寫 API，則這個屬性基本上不會用到。因為 API 的前端請求，往往是 JSON 格式，即<code>Content-Type</code>為<code>application/json</code>，而不會是 form data。</p><p>簡言之：</p><ul><li>寫全端 Django 用<code>request.POST</code>屬性。</li><li>寫 API 則是用<strong>別的屬性</strong>，比如 DRF 的<code>request.data</code>。</li></ul><hr><h2 id="四、HttpRequest-FILES"><a href="#四、HttpRequest-FILES" class="headerlink" title="四、HttpRequest.FILES"></a>四、HttpRequest.FILES</h2><blockquote><p>A dictionary-like object containing all uploaded files. Each key in <code>FILES</code> is the <code>name</code> from the <code>&lt;input type=&quot;file&quot; name=&quot;&quot;&gt;</code>. Each value in <code>FILES</code> is an <a href="https://docs.djangoproject.com/en/5.0/ref/files/uploads/#django.core.files.uploadedfile.UploadedFile"><code>UploadedFile</code></a>.</p></blockquote><p>上傳檔案必備！</p><p>注意，這個<code>FILES</code>只是一個類字典，字典的每一個 key 的<strong>值</strong>才是你上傳的檔案。</p><blockquote><p><code>FILES</code> will only contain data if the request method was POST and the <code>&lt;form&gt;</code> that posted to the request had <code>enctype=&quot;multipart/form-data&quot;</code>. Otherwise, <code>FILES</code> will be a blank dictionary-like object.</p></blockquote><p>重點：</p><ol><li>必須使用 POST 方法。</li><li>而且<code>Content-Type</code>為<code>multipart/form-data</code>。</li></ol><p>至於在 view 函式中的操作與使用，較為複雜（牽涉到 <a href="https://docs.djangoproject.com/en/5.0/ref/models/fields/#filefield">FileField</a>），可自行參考<a href="https://docs.djangoproject.com/en/5.0/topics/files/">文件</a>，在此先略不介紹。</p><hr><h2 id="五、關於-Headers"><a href="#五、關於-Headers" class="headerlink" title="五、關於 Headers"></a>五、關於 Headers</h2><p><code>HttpRequest.META</code><a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.META">¶</a></p><blockquote><p>A dictionary containing all available HTTP headers.</p></blockquote><p><code>HttpRequest.headers</code><a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.headers">¶</a></p><blockquote><p>A case insensitive, dict-like object that provides access to all HTTP-prefixed headers (plus <code>Content-Length</code> and <code>Content-Type</code>) from the request.</p></blockquote><p>這部分我們已經有過專文介紹，可直接參考：</p><ul><li><a href="https://blog.kyomind.tw/django-request-headers/">Django：以 request.headers 而非 META 獲取 HTTP header 資訊</a></li></ul><h2 id="六、Attributes-set-by-middleware"><a href="#六、Attributes-set-by-middleware" class="headerlink" title="六、Attributes set by middleware"></a>六、Attributes set by middleware</h2><p>從 Django 的 middleware 整合而獲得的屬性，這些屬性的值「不屬於」HTTP 請求中的資料，而是 Django 基於方便開發，自動幫你加上去的。</p><p>比較重要且常用的是這兩個：</p><ul><li><code>HttpRequest.session</code></li><li><code>HttpRequest.user</code></li></ul><p>這些可以等用到相關 Django 模組時，再深入了解即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 系列連載的第 3 篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;https://blog.kyomind.tw/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如〈&lt;a href=&quot;https://blog.kyomind.tw/django-tutorial/&quot;&gt;Django Tutorial：系列介紹與導讀&lt;/a&gt;〉所言，這個系列主要是圍繞著「Django API」教學展開的。&lt;/p&gt;
&lt;p&gt;但無論是用 Django 建立全端網站，還是開發 API，Django 的 &lt;a href=&quot;https://docs.djangoproject.com/en/5.0/ref/request-response/&quot;&gt;HttpRequest&lt;/a&gt;——也就是我們熟悉的&lt;code&gt;request&lt;/code&gt;參數——都是必不可少的元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HttpRequest&lt;/code&gt;封裝了來自前端的 HTTP 請求，而 Django 會將&lt;code&gt;HttpRequest&lt;/code&gt;物件自動帶入 view 函式的&lt;strong&gt;第一位置參數&lt;/strong&gt;（通常就叫&lt;code&gt;request&lt;/code&gt;），讓我們可以直接使用。&lt;/p&gt;
&lt;h2 id=&quot;為何需要了解-HttpRequest-物件&quot;&gt;&lt;a href=&quot;#為何需要了解-HttpRequest-物件&quot; class=&quot;headerlink&quot; title=&quot;為何需要了解 HttpRequest 物件&quot;&gt;&lt;/a&gt;為何需要了解 &lt;code&gt;HttpRequest&lt;/code&gt; 物件&lt;/h2&gt;&lt;p&gt;在我剛開始寫 Django 的時候，根本不太清楚&lt;code&gt;HttpRequest&lt;/code&gt;具體有哪些屬性。&lt;/p&gt;
&lt;p&gt;通常是看教學或為了實作某個功能而 Google 的時候，看到範例程式碼使用某個屬性，然後才知道這個屬性的存在。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; request.method == &lt;span class=&quot;string&quot;&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do_something()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; request.method == &lt;span class=&quot;string&quot;&gt;&amp;quot;POST&amp;quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do_something_else()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;看到這段，才知道&lt;code&gt;request&lt;/code&gt;有一個&lt;code&gt;method&lt;/code&gt;屬性。&lt;/p&gt;
&lt;p&gt;這樣學當然可以，但如果一開始就對常用的&lt;code&gt;HttpRequest&lt;/code&gt;屬性有&lt;strong&gt;基本了解&lt;/strong&gt;，會讓你在學習 Django 的路上&lt;strong&gt;更加踏實&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="HTTP" scheme="https://blog.kyomind.tw/tags/HTTP/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
  </entry>
  
</feed>
