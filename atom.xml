<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2023-06-25T04:12:54.799Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</title>
    <link href="https://blog.kyomind.tw/django-models/"/>
    <id>https://blog.kyomind.tw/django-models/</id>
    <published>2023-06-24T17:31:49.000Z</published>
    <updated>2023-06-25T04:12:54.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/yK0Us6a.jpg" alt="by Léo Alexandre"><span class="cap">by Léo Alexandre</span></p><p>工作上使用 Django 近 2 年，卻很少發表關於 Django 主題的文章，是時候該來補一補了。</p><p>就從 Django ORM 開始吧！因為 Django ORM 可以說是無論你怎麼使用 Django（全端或前後端分離），都不得不學的核心部分。</p><p>怎麼說？我們先來看看，在「前後端分離」的開發趨勢下，Django 的三大核心——MTV——的重要性有哪些變動。</p><span id="more"></span><h2 id="前後端分離下的-Django-MTV"><a href="#前後端分離下的-Django-MTV" class="headerlink" title="前後端分離下的 Django MTV"></a>前後端分離下的 Django MTV</h2><p>在 Django 中，MTV 是指 Model-Template-View 的架構模式。這是 Django 框架的核心設計模式，用於組織和分離應用程式的不同部分。</p><ul><li><strong>Model（模型）：</strong> 模型負責處理與資料庫相關的操作，它是定義數據結構、資料表和資料庫查詢的地方。</li><li><strong>Template（模板）：</strong> 模板用於前端。它是一個包含 HTML、CSS 和一些額外標記語言（例如 Django 的模板語言）的文件，用於定義網頁的外觀和內容。</li><li><strong>View（視圖）：</strong> 視圖是應用程式處理邏輯的地方。它接收用戶的請求，從模型獲取數據，並使用模板來生成適當的回應。視圖處理用戶的 HTTP 請求，並根據需要調用相應的模型和模板來生成回應。</li></ul><h3 id="前後端分離對三大元件的重要性影響"><a href="#前後端分離對三大元件的重要性影響" class="headerlink" title="前後端分離對三大元件的重要性影響"></a>前後端分離對三大元件的重要性影響</h3><p>我們假設你是一個前後端分離下的 Django 工程師，你那通常就是負責後端的 API 開發。</p><p>首先，顯然 Template 不需要了，因為這是前端的範疇，而 View 呢？相當程度會被 <a href="https://www.django-rest-framework.org/">Django REST framework</a>（以下皆簡稱為 DRF）所取代。說「取代」不太正確，應該說「升級」。</p><p>帶來的影響是 View 中相當部分操作細節與學習重點會遷移到 DRF 本身，而非 Django 原生提供的功能。</p><p>比如<code>request.data</code>，重新封裝了 Django 中的<code>request.POST</code>和<code>request.FILES</code>兩個屬性，類似的情況還有<code>APIView</code>或<code>@api_view</code>等等。</p><p>既然 Template 被前端取代，而 View 的功能則被 DRF 重新封裝。可想而知，三大元件中重要性唯一不變的，就是 Model——Django ORM。</p><p>可見，作為一個 Django 開發者，學好 ORM 是絕對不虧的！</p><h2 id="範例程式碼專案介紹"><a href="#範例程式碼專案介紹" class="headerlink" title="範例程式碼專案介紹"></a>範例程式碼專案介紹</h2><p>如前所述，我打算寫一系列的 Django 教學文章，如果有範例程式碼，必然更方便讀者學習、參考。於是我建了一個 GitHub Repo 名為「<a href="https://github.com/kyomind/kyo-django-tutorial">kyo-django-tutorial</a>」，把文章中使用的程式碼同步更新於此。</p><p>這是一個典型的 Django 專案，而且有著完整的 Python 環境設定，各種細節都和我個人開發一致，有 Poetry、pre-commit 與基本的 linter、formatter 設定等，方便讀者複製環境並跟著操作。</p><p>以下是簡單的介紹。</p><h3 id="專案環境介紹"><a href="#專案環境介紹" class="headerlink" title="專案環境介紹"></a>專案環境介紹</h3><p>支援 Poetry，方便重建專案所需的 Python 虛擬環境。但你也可以不使用它，我有另外準備<code>requirements.txt</code>供<code>pip</code>安裝。</p><p>pre-commit 完全可選，基本上用不到，除非你有打算變更程式碼的內容。只要不使用指令<code>pre-commit install</code>，它相當於不存在。但如果你想用的話，整個<code>.pre-commit-config.yaml</code>設定檔都寫好了。</p><p>隨著文章更新，未來還會支援 Docker，敬請期待。</p><h3 id="工具版本說明"><a href="#工具版本說明" class="headerlink" title="工具版本說明"></a>工具版本說明</h3><p>Django 版本為 4.2.x LTS，對 Python 的版本有一定要求，不能太舊，必須在 3.8 以上。</p><p>Python 版本使用 3.10.11，建議至少使用 3.8.1，雖然剛剛說 Django 只要求 3.8，但因為 Flake8 版本是 6.0.0，要求 Python 至少要 3.8.1 XD。建議直接還是安裝 3.10 或更新的版本。</p><hr><p>基本的介紹就到這裡，我們趕緊進入本篇的重點。</p><h2 id="本文重點：Django-ORM-外鍵關聯設定"><a href="#本文重點：Django-ORM-外鍵關聯設定" class="headerlink" title="本文重點：Django ORM 外鍵關聯設定"></a>本文重點：Django ORM 外鍵關聯設定</h2><p><a href="https://docs.djangoproject.com/en/4.2/topics/db/models/">Django Models</a>，也就是 db table 的 <a href="https://zh.wikipedia.org/zh-tw/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84">OOP</a> 程式型態，透過 ORM 來實現兩者的對應關係——從 db table 到 Python class。</p><p>如果說 ORM 是 Django 的核心之一，而 ORM 的核心會是什麼呢？我相信其中一個答案，就是「（外鍵）關聯」（relationships）。若是少了關聯性，資料表就像孤立的島嶼，根本無法真實模擬世界。</p><p>剛開始寫 Django ORM 時，疑問最多的就是外鍵關聯了！因為它不止重要，而且常用。外鍵關聯又分一對一、一對多（多對一）與多對多，我們會先著重在前兩者的介紹——因為它們最常用。讓你一接觸 Django ORM 就快速上手。</p><p><strong>本文為上篇，主要是系列前言與外鍵設定教學，查詢部分則留到下篇。</strong></p><h2 id="專案模型介紹"><a href="#專案模型介紹" class="headerlink" title="專案模型介紹"></a>專案模型介紹</h2><p>學習 Django 模型和外鍵關係的最佳方法，是透過具體的例子。在上述專案中，我準備了一個最常見的範例：<a href="https://github.com/kyomind/kyo-django-tutorial/blob/01-django-models/post/models.py">文章模型</a>。</p><p>選這個例子主要出於兩個原因：</p><ol><li>它很容易想像。</li><li>它同時包括了一對一、一對多、多對多等不同情境。</li></ol><p>模型對應的情境大致是這樣：你有一個個人的部落格網站，只有你可以發表文章，而讀者可以留言。</p><p>因為只有一個作者，也就是你，所以模型省略了作者的部分。這些設計都是為了方便介紹而已，不必對它們的真實性太過認真。</p><p>以下我們一一介紹這 3 個模型。</p><h3 id="Title：文章標題"><a href="#Title：文章標題" class="headerlink" title="Title：文章標題"></a>Title：文章標題</h3><p>通常標題只會是文章模型的一個欄位，很少獨立出來。我這樣設計是為了呈現一對一關係，而且這裡有分主、副標題，多少為獨立出來增加了一點合理性，就一點XD。</p><h3 id="Post：文章"><a href="#Post：文章" class="headerlink" title="Post：文章"></a>Post：文章</h3><p>最主要的模型，其餘兩個模型都和它有關。</p><p>與標題是一對一關係，直接有一個<code>title</code>外鍵欄位關聯到 Title 模型，另一個欄位則是<code>content</code>。</p><h3 id="Comment：留言"><a href="#Comment：留言" class="headerlink" title="Comment：留言"></a>Comment：留言</h3><p>用來說明對一多關係的模型，有一個外鍵欄位<code>post</code>關聯到 Post。對 Post 來說，則會建立一個「反向關聯（<a href="https://allwin-raju-12.medium.com/reverse-relationship-in-django-f016d34e2c68">reverse relationship</a>）」屬性，下面會詳細介紹。</p><p>三者的關係可以畫成簡單的實體關聯圖（ERD） 如下：</p><p><img src="https://i.imgur.com/5qO8q8E.png"></p><p>Django 會自動幫你在外鍵屬性名稱加上<code>_id</code>，轉換成 db 中 table 欄位的名稱，所以上面圖中的欄位名稱是<code>title_id</code>與<code>post_id</code>。</p><hr><h2 id="在-Model-中建立外鍵欄位"><a href="#在-Model-中建立外鍵欄位" class="headerlink" title="在 Model 中建立外鍵欄位"></a>在 Model 中建立外鍵欄位</h2><p>我們知道，ORM 所對應的 table 欄位，都是用 Python 類別中的類別屬性來定義與規範的。而 db 欄位的 schema 則對應 model 屬性的「參數」。</p><p>尤其是外鍵屬性，因為要建立關聯，使用的參數通常比較多，格式上也和一般欄位屬性有所差別。</p><p>無論如何，了解外鍵欄位常用的參數與其代表的意義，相當必要，這也是本篇的重心。</p><p>以下介紹一對一和一對多的外鍵關聯設定，讀者可適時參考深獲開發者好評的 <a href="https://docs.djangoproject.com/en/4.2/">Django 文件</a>，我們只就重點進行說明。</p><h2 id="一對一關係"><a href="#一對一關係" class="headerlink" title="一對一關係"></a>一對一關係</h2><blockquote><p>class <code>OneToOneField</code>(to, on_delete, parent_link&#x3D;False, **<strong>options</strong>) <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.OneToOneField">¶</a></p></blockquote><p>只有兩個必填的位置參數，即<code>to</code>和<code>on_delete</code>。</p><p>先看一下專案中存在一對一關係的兩個 model（為了網頁呈現，我縮減了單行字元上限與空行數、省略了無關部分，所以和原始碼有所不同）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Title</span>(models.Model):</span><br><span class="line">    main = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    subtitle = models.CharField(max_length=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><code>OneToOneField</code>即外鍵中的一對一關係欄位，第一個參數是<code>to</code>，為目標關聯的 model，有兩種格式：</p><ol><li>model class 本身。</li><li>字串。用於無法直接引用的情境，比如本例中的 title 欄位，Title 類別定義在 Post 之後。</li></ol><p>第二個參數是<code>on_delete</code>，用來定義「關聯物件被刪除時」當前物件該如何處理的行為。有多揰模式，最常用的不外乎<code>CASCADE</code>、<code>PROTECT</code>、<code>SET_NULL</code>這 3 種，其餘所有選項與行為定義，可以參考<a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.CASCADE">文件</a>。</p><p>除了<code>to</code>和<code>on_delete</code>兩個必要參數，剩下的都是 optional，不過還有一個參數也非常重要，那就是<code>related_name</code>。</p><h2 id="related-name-與反向關聯"><a href="#related-name-與反向關聯" class="headerlink" title="related_name 與反向關聯"></a>related_name 與反向關聯</h2><p><code>related_name</code>用於指定關聯<strong>目標 model</strong>（本例為 Title）的「反向關聯」<strong>屬性名稱</strong>。這個屬性對查詢很實用，所以<code>related_name</code>也是外鍵屬性中重要的參數之一。</p><p>我們從 model 角度來看外鍵建立後的效果，以及<code>related_name</code>所扮演的角色。</p><h3 id="Post-model-角度"><a href="#Post-model-角度" class="headerlink" title="Post model 角度"></a>Post model 角度</h3><p>Post 有一個屬性為<code>title</code>，也就是我們所建立的外鍵，這個屬性在 model 中是明示的，意味著它在 db table 中也會有對應的欄位——<code>title_id</code>。其中<code>_id</code>是 Django 幫你加的，你可以透過<code>class Meta</code>自行定義這個欄位的名稱。</p><p>事實上，建立關聯不一定只能指向目標 model 的「主鍵」，只要是 model 中的  unique 欄位都可以，可參考 <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey.to_field">to_field 文件</a>。</p><h3 id="Title-角度"><a href="#Title-角度" class="headerlink" title="Title 角度"></a>Title 角度</h3><p>一對一關係建立後，對 Title model 或它的實例而言，它得到了什麼？——反向關聯屬性。</p><p>這個屬性在 model 中沒有明示，你從 model 中看不出 Title 有什麼屬性可以指向 Post。但實際上 Title 確實有一個反向關聯屬性指向 Post。</p><p>這就是反向關聯的特性，它是「隱式」的，這個屬性確實存在。而<strong>反向關聯屬性的名稱就是前述</strong><code>related_name</code><strong>所定義的名稱</strong>，在本例中即<code>post</code>。</p><p>所以，Title 的所有實例，比如有一個實例叫<code>title_1</code>，實際上「一定有」一個屬性<code>post</code>，而它的返回值依不同情況有兩種可能：</p><ol><li><code>title_1</code>已經被關聯到某個 Post 實例比如<code>post_1</code>，那<code>title_1.post</code>的值就是該<code>post_1</code>實例。</li><li><code>RelatedObjectDoesNotExist</code>物件。當<strong>實例之間的關聯還不存在</strong>，試圖取得關聯實例將會出現這樣的錯誤。</li></ol><h3 id="反向關聯屬性"><a href="#反向關聯屬性" class="headerlink" title="反向關聯屬性"></a>反向關聯屬性</h3><p>這個<code>post</code>屬性不在 model 中明示，資料表中也<strong>不存在相對應的欄位</strong>——它本質上只是查詢的「捷徑」。</p><p>這種隱式的設計讓我們更容易識別在外鍵關係中，哪個屬性是正向關聯，哪個則是反向關聯。</p><p>反向關聯允許我們透過簡單的屬性呼叫，就能夠輕鬆地獲取相關資料，而不需要額外的操作和查詢語句。</p><hr><h2 id="一對多關係"><a href="#一對多關係" class="headerlink" title="一對多關係"></a>一對多關係</h2><blockquote><p>class <code>ForeignKey</code>(to, on_delete, **<strong>options</strong>) <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey">¶</a></p></blockquote><blockquote><p>A <strong>many-to-one</strong> relationship. <strong>Requires two positional arguments</strong>: the class to which the model is related and the <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey.on_delete"><code>on_delete</code></a> option.</p></blockquote><p>我們在前述一對一關係費了很大的功夫將關聯的細節詳加說明，有了上述基礎，理解一對多關係也會容易得多。</p><p>Django 稱<code>ForeignKey</code>為「<strong>many-to-one</strong>」，即多對一關係，從 model 角度看，確實更合理。因為建立這個<code>ForeignKey</code>屬性的 model，必然屬於關係中的「<strong>多方</strong>」。所以是「多對一」。</p><p>不過無論一對多或多對一，主要區別是視角不同，都是同一種關係。下面我還是用「一對多」這個詞進行說明。</p><p>我選擇先講一對一是因為它相對單純，不需要一次理解太多事情。而一對多（或多對一），即 Django 中的 ForeignKey，則有更多參數和變化，但我們依舊只關注其中最重要的部分。</p><h3 id="專案程式碼說明"><a href="#專案程式碼說明" class="headerlink" title="專案程式碼說明"></a>專案程式碼說明</h3><p>毫無疑問，文章和它的留言是一對多關係，一篇文章可以有「0 到多個」留言，注意這個 0 還滿重要的！這也是它和一對一關係很不同的地方。</p><p>回到程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 留言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br></pre></td></tr></table></figure><p>我們可以看到，Comment 有一個欄位叫<code>post</code>，是一個<code>ForeignKey</code>。這個<code>ForeignKey</code>欄位，最常用的參數還是那 3 個，前 2 個前面已經有介紹，在此不贅。</p><p>第 3 個參數仍是<code>related_name</code>，但它的引數值<code>&#39;comments&#39;</code>看起來，和一對一的<code>related_name</code>在命名上有所不同——它是複數！</p><h2 id="related-name-在一對多關係中的重點"><a href="#related-name-在一對多關係中的重點" class="headerlink" title="related_name 在一對多關係中的重點"></a>related_name 在一對多關係中的重點</h2><p>前提已經提過，<code>related_name</code>實際上是為「反向關聯屬性」進行命名。</p><p><code>post</code>屬性的<code>related_name=&#39;comments&#39;</code>意味著，Post model 將得到一個名為「comments」反向關聯屬性。</p><p>一個 Post 實例，假設為<code>post_1</code>，可以透過<code>post_1.comments</code>取得所有和它關聯的 Comment 實例。可能有 1 個、多個，甚至沒有。</p><blockquote><p>這裡有一個細節是，<code>post_1.comments</code>只會先取得「<a href="https://docs.djangoproject.com/en/4.2/topics/db/managers/#django.db.models.Manager">關係管理器</a>」物件，再透過該物件取得「由 Comment 關聯實例組成的<code>QuerySet</code>」，比如：<code>post_1.comments.all()</code>。</p></blockquote><p>這和一對一時，反向關聯或者得到一個特定關聯實例，或者得到（拋出）RelatedObjectDoesNotExist 有明顯不同。</p><h3 id="related-name-的預設名稱"><a href="#related-name-的預設名稱" class="headerlink" title="related_name 的預設名稱"></a>related_name 的預設名稱</h3><p>如果你在建立欄位時沒有給定<code>related_name</code>引數，那 Django 會自動給你預設名稱。</p><p>在一對一中，預設名稱為外鍵欄位所屬 Model 名稱的小寫。</p><p>參考 Post 的一對一外鍵程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>related_name</code>的預設值就是 Post 的小寫——<code>post</code>。顯然我定義的其實就是預設值而已。一對一時，是否定義<code>related_name</code>影響不大，<strong>因為它的預設值往往就已足夠</strong>。</p><p>在一對多，預設名稱為外鍵欄位所屬 Model 名稱的小寫再加上<code>_set</code>後綴。你可能就未必喜歡這樣的命名了。</p><p>一樣看一下相關程式片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果沒有定義<code>related_name</code>，則被關聯的 Post 將獲得 Django 預設的反向關聯屬性名稱「<code>comment_set</code>」。</p><p>無論是自定義的<code>comments</code>或預設的<code>comment_set</code>，都表達它的內涵是一個「複數」，這是一對多的特色（多對多也是如此）。</p><p>實務中，把這個<code>related_name</code>命名好還是很重要的，雖然大部分時候用單純的複數就可以搞定，就像上面的<code>comments</code>，但也有需要你花費巧思的時候，我們日後再談。</p><hr><h2 id="小結：關聯是-model-核心"><a href="#小結：關聯是-model-核心" class="headerlink" title="小結：關聯是 model 核心"></a>小結：關聯是 model 核心</h2><p>耗費了如此多的幅篇，詳細講述關聯設定，都是為了強調一個重點：關聯是 Django ORM 的核心之一。</p><p>通過關聯，我們能夠模擬真實世界中的關係，使資料表之間建立起有意義的連結。</p><p>了解一對一和一對多的關聯設定，以及反向關聯屬性的使用，我們能夠更好地應用 Django ORM，建構出高效且具有關聯性的資料模型。</p><p>而辛苦建立這些模型與關聯，就是為了能夠充分利用它們！</p><p>下篇文章將探討，如何有效對這些關聯模型進行查詢，輕鬆地從模型中檢索和篩選所需的資料。</p><p>請敬期待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/yK0Us6a.jpg&quot; alt=&quot;by Léo Alexandre&quot;&gt;&lt;/p&gt;
&lt;p&gt;工作上使用 Django 近 2 年，卻很少發表關於 Django 主題的文章，是時候該來補一補了。&lt;/p&gt;
&lt;p&gt;就從 Django ORM 開始吧！因為 Django ORM 可以說是無論你怎麼使用 Django（全端或前後端分離），都不得不學的核心部分。&lt;/p&gt;
&lt;p&gt;怎麼說？我們先來看看，在「前後端分離」的開發趨勢下，Django 的三大核心——MTV——的重要性有哪些變動。&lt;/p&gt;</summary>
    
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="ORM" scheme="https://blog.kyomind.tw/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>19，AI 時代的生存指南（二）：數位斷捨離</title>
    <link href="https://blog.kyomind.tw/weekly-review-19/"/>
    <id>https://blog.kyomind.tw/weekly-review-19/</id>
    <published>2023-06-10T11:27:31.000Z</published>
    <updated>2023-06-22T06:05:00.872Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>上一篇〈<a href="https://blog.kyomind.tw/weekly-review-17/">17，AI 時代的生存指南（一）：我對 AI 工具的投入與觀望</a>〉並沒有真正進入「生存指南」這個核心主題，只能算是整個系列的前言。</p><p>為避免你忘記，我們再來回顧一下，前一篇所提出的，本系列的宗旨：</p><blockquote><p>我期望這系列和一般談論 AI 文章的一個核心差別是：<strong>它們主要用來「降低」AI 資訊焦慮，而非增加。</strong></p></blockquote><blockquote><p>更具體地說，這個系列是「<strong>我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄</strong>」，這樣才有趣。</p></blockquote><p>而本篇要探討的，就是這系列最核心的「生存手段」：數位斷捨離。</p><p>數位斷捨離（Digital Declutter）作家卡爾．紐波特（Cal Newport）在其著作《<a href="https://www.books.com.tw/products/0010843512">深度數位大掃除</a>》一書中所提出。</p><p>數位斷捨離是一種整理和簡化數位世界的方法，旨在<strong>減少干擾並提升專注力</strong>。通過過濾數位訊息和限制使用數位工具（尤其是社交平台），我們可以節省時間和精力，更好地專注於重要的事情。</p><p>這種方法有助於建立一個更有意義和平衡的數位生活。所以它不止是方法，也是一種「<strong>價值觀與實踐</strong>」。</p><p>概念理解上沒什麼困難，但實踐起來可遠遠不是如此。</p><span id="more"></span><h2 id="本篇重點"><a href="#本篇重點" class="headerlink" title="本篇重點"></a>本篇重點</h2><p>這篇不會有太多關於「數位斷捨離」的具體做法與細節探討。而是<strong>試圖推論與強調，它在 AI 時代的重要性，以及在現實世界中所面臨的困難。</strong></p><p>此外，我也並非「極簡主義」的愛好者，而是屬於「<a href="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/">簡潔主義</a>」的信徒。雖然它們都有一個「簡」字，但後者更強調「<strong>過猶不及、適可而止</strong>」，更重視「均衡」。</p><p>理解了上述前提後，讓我們進入正文。</p><hr><h2 id="我的兩篇《深度數位大掃除》心得"><a href="#我的兩篇《深度數位大掃除》心得" class="headerlink" title="我的兩篇《深度數位大掃除》心得"></a>我的兩篇《深度數位大掃除》心得</h2><p>早在 3 年前，還在 <a href="https://medium.com/">Medium</a> 平台創作時期，我就寫過關於《深度數位大掃除》一書的「實踐心得」，即<strong>個人版的數位斷捨離</strong>，前後總共 2 篇：</p><ol><li><a href="https://medium.com/code-and-me/my-digital-declutter-216d472f8251">每天都是一種練習：我的數位斷捨離</a></li><li><a href="https://medium.com/code-and-me/31%E5%A4%A9-%E6%88%91%E7%9A%84%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2%E5%BF%83%E5%BE%97-51289e99ff96">31天：我的數位斷捨離心得</a></li></ol><p>這是個有趣的嘗試，尤其讓我印象深刻的，是第二篇中的這段與這個規則：</p><ul><li><strong>在捷運或公車的「刷卡範圍」內，不得使用手機通話以外的功能</strong></li></ul><blockquote><p>簡單講就是不能滑手機，而且也不能聽音樂。</p></blockquote><blockquote><p>這是一條我無法明確告訴你為什麼值得這麼做，但實踐後仍然建議你嘗試看看的規則。</p></blockquote><blockquote><p>如果真的需要一個理由，或許可以說，在這個我們都自願或被迫保持「連線狀態」的智慧手機時代。在一個人坐捷運無聊難耐，讓你有充分的動機與理由拿出手機消磨（或善加利用）的時候，你卻沒有這麼做，這是沉默而自覺的戰鬥。</p></blockquote><blockquote><p>你靜靜地坐著或站著，看著周圍的人，沉浸在網路的世界裡。而至少在此刻，你選擇不要這麼做。</p></blockquote><p>真的，那幾個月，我上下班坐捷運時，就是這樣傻傻地看著別人滑手機，心癢難耐，甚至不禁想問：「為什麼要制定這種規則來為難自己？我得到了什麼？」</p><p>「我得到了什麼？」不是一個容易回答的問題——因為它的好處並非立竿見影。這也是為何「數位斷捨離」通常很難持續。</p><p>網路上你可以找到不少實踐心得，遵從書中的建議，貫徹為期 1 個月的數位斷捨離。但你很難找到持續超過 3 個月甚至半年的實踐心得，連我自己，最後也大概只堅持了 3 個月，就差不多「<strong>打回原形</strong>」了。</p><h2 id="數位斷捨離常常只是一場短暫的狂歡"><a href="#數位斷捨離常常只是一場短暫的狂歡" class="headerlink" title="數位斷捨離常常只是一場短暫的狂歡"></a>數位斷捨離常常只是一場短暫的狂歡</h2><p>用「<strong>狂歡</strong>」來形容<strong>充滿限制且帶有自律意味</strong>的數位斷捨離，可能有點詭異，卻也不失真實，為什麼？</p><p>因為它富含一種「我將擺脫數位工具成癮並重獲新生」的<strong>期待</strong>。和一般狂歡通常以大鳴大放的形式不同，這種期待蘊含了一股內持、蓄勢待發的力量。它暗潮湧動，使人從情感上，<strong>將其視為達成目標和恢復精神自由的萬靈藥</strong>。</p><p>因此，在實踐數位斷捨離的初期，雖然辛苦，但我們會暫時感到一陣<strong>自由和解脫</strong>。儘管這種過程伴隨著一定的自我限制，但也對於能夠重新獲得對自己時間和注意力的<strong>掌控感</strong>到興奮甚至滿足。</p><p>這類「狂歡」形式雖然不常見，但它真實地反映了我們對於解放自己的數位束縛的期待與渴望。</p><p>我承認這種感覺確實「很好」，但這樣的動機是<strong>不健康</strong>的，因為它和所有的狂歡一樣，都有一個<strong>「致命問題」——很難持續。</strong></p><h2 id="為什麼數位斷捨離很難超過-3-個月？"><a href="#為什麼數位斷捨離很難超過-3-個月？" class="headerlink" title="為什麼數位斷捨離很難超過 3 個月？"></a>為什麼數位斷捨離很難超過 3 個月？</h2><p>把數位斷捨離當成是一場狂歡、救贖，或所謂的「數位排毒」，往往註定要失敗。</p><p>試想，數位斷捨離所要對抗的，都是什麼樣的洪水猛獸？</p><p>沒錯，就是那些精心設計，讓你容易非常數位成癮的社交平台與內容平台，比如臉書、Instagram、YouTube、TikTok……等等。</p><p>最關鍵的是，獲取它們的門檻可謂低之又低，近在眼前，唾手可得。因此，社交平台和內容平台所提供的即時滿足感和快樂，往往讓人很難抗拒。</p><h3 id="長路漫漫的數位斷捨離"><a href="#長路漫漫的數位斷捨離" class="headerlink" title="長路漫漫的數位斷捨離"></a>長路漫漫的數位斷捨離</h3><p>相較之下，數位斷捨離就不那麼討喜。它要你自制、找尋替代活動（書中稱之為「<strong>優質的休閒活動</strong>」），還要反思數位工具你對的意義。</p><p>要求還真多。</p><p>前期，你確實可以藉由上述的「<strong>期待</strong>」來支持，但這樣的期待也是種<strong>有限資源</strong>。把數位斷捨離當作是一種「<strong>自我救贖</strong>」，確實可以成為堅持的動力——最多持續 1 個月。</p><p>1 個月以後，期待帶來的初始動力散去，我們就很容易陷入「<strong>我得到了什麼？</strong>」茫然。</p><h3 id="數位斷捨離的意義與價值"><a href="#數位斷捨離的意義與價值" class="headerlink" title="數位斷捨離的意義與價值"></a>數位斷捨離的意義與價值</h3><p>如果「我得到了什麼？」的答案，對你來說<strong>還不夠清晰</strong>，那麼<strong>放棄</strong>恐怕是<strong>遲早的事情</strong>，因為回到原點比茫然堅持，可要容易得太多。</p><p>然而，我更想<strong>強調</strong>：這個問題的答案，<strong>幾乎不可能一開始就很清晰</strong>。因為，數位斷捨離的意義，往往是需要你<strong>透過實踐</strong>才能<strong>慢慢體會</strong>的。</p><p>不止實踐，你還需要<strong>時間</strong>與<strong>自我理解</strong>。</p><p>所以我們可以看到，網路確實上有不少篇心得，講述自己如何實踐了為期 30 天的數位斷捨離，那感覺，是多麼地讓人神清氣爽、重獲新生。</p><p><strong>然後，就沒有然後了。</strong></p><hr><h2 id="我為何重拾數位斷捨離？"><a href="#我為何重拾數位斷捨離？" class="headerlink" title="我為何重拾數位斷捨離？"></a>我為何重拾數位斷捨離？</h2><p>說了那麼多，都是在唱衰數位斷捨離，難道真的沒救了嗎？</p><p>我想其中的奇妙之處正在於，本來我也覺得「算了，就這樣吧！要持續貫徹，需要長期的嘗試與不斷改善規則」。</p><p>對我來說這也不是不可能，作為曾經全職準備國考與軟體工程師轉職的人（就是待業時間很長的意思），有很多「建立個人長期制度」的經驗（包括很多失敗經驗），我知道怎麼做能更接近「<strong>可持續性</strong>」。</p><p>換言之，我對一件事情「能否持續」的<strong>敏感度</strong>，還是比較高的。</p><p>所以我才會猶豫不前，因為我知道這件事的難度。</p><h3 id="值得嗎？"><a href="#值得嗎？" class="headerlink" title="值得嗎？"></a>值得嗎？</h3><p>還是那個問題「值得嗎？」——這是個大哉問。</p><p>對我而言，以往是的答案是「<strong>我不確定</strong>」。而現在或許值得了，因為 AI 時代到來。</p><p>AI 帶給我的「<strong>資訊煩躁感（資訊焦慮）</strong>」，讓我感到「<strong>必須要做些什麼</strong>」應對。</p><p>這不是因為資訊量隨 AI 的爆發而再度遽增（我覺得這反而是相對無關緊要的部分），而是「<strong>做事的方法</strong>」因為 AI 而改變了。</p><p>所以，作為渺小的人類，對抗資訊焦慮的「<strong>防禦手段</strong>」也得跟著升級才行。那麼，什麼才是真正有效的手段？</p><p>思來想去，我最終的答案<strong>還是——數位斷捨離</strong>。</p><h2 id="內心的平靜"><a href="#內心的平靜" class="headerlink" title="內心的平靜"></a>內心的平靜</h2><p>說了那麼多，其實我們所求的，不過就是「<strong>內心的平靜</strong>」而已。</p><p>然而內心的平靜卻也是世上最易失又難得的珍貴體驗，我們只能一步一步靠近。</p><h3 id="目前的具體做法"><a href="#目前的具體做法" class="headerlink" title="目前的具體做法"></a>目前的具體做法</h3><p>一開始說不會講太多做法，但還是要提一下，才好想像我的數位斷捨離的具體內容。</p><p>目前我實踐中的數位斷捨離規則大致如下：</p><ol><li>每天早上 9 點到下午 6 點，不登入 Line 桌面版。</li><li>身體接觸床面時，存取手機不得超過一分鐘！（防止睡前滑手機行為）</li><li>半夜 1 點到早上 6 點，不聽任何多媒體的聲音。</li><li>河濱散步時，不存取、使用手機。（培養發散思維模式）</li><li>少用臉書。</li></ol><p>咦？怎麼沒有搭公車、捷運不能用手機那條？本來有的，但太難了，只好暫時捨棄🫡</p><p>規則的組成與細節，會一直變動，達到「有效且可持續」的部分，才會漸漸確定下來。</p><p>毫無疑問，這會是一個<strong>不算短的過程</strong>，1 個月是絕對不夠的。因為能堅持 1 個月的事，未必能堅持 3 個月。</p><hr><h2 id="結語：3-個月只是開端"><a href="#結語：3-個月只是開端" class="headerlink" title="結語：3 個月只是開端"></a>結語：3 個月只是開端</h2><p>1 個月也好，3 個月也罷，它們都只是漫長人生中的一小部分。僅僅在這麼短的時間內達成數位斷捨離，很難帶來本質上的改變。</p><p>數位斷捨離的目的不僅僅是在短期內達成某個特定的目標，而是<strong>要在局部，永久地建立有別於以往的生活方式。</strong></p><p>在開始之前，我們要先嚴肅地認知到：<strong>這真的很難</strong>——凡是改變都很難。</p><p>數位斷捨離是<strong>習慣的養成</strong>，從更高的角度看，更是一種「<strong>價值取捨</strong>」。</p><p>有些東西——哪怕是好東西——你必須<strong>捨棄</strong>，才能換得幾分<strong>心靈上的平靜</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-17/&quot;&gt;17，AI 時代的生存指南（一）：我對 AI 工具的投入與觀望&lt;/a&gt;〉並沒有真正進入「生存指南」這個核心主題，只能算是整個系列的前言。&lt;/p&gt;
&lt;p&gt;為避免你忘記，我們再來回顧一下，前一篇所提出的，本系列的宗旨：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我期望這系列和一般談論 AI 文章的一個核心差別是：&lt;strong&gt;它們主要用來「降低」AI 資訊焦慮，而非增加。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;更具體地說，這個系列是「&lt;strong&gt;我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄&lt;/strong&gt;」，這樣才有趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而本篇要探討的，就是這系列最核心的「生存手段」：數位斷捨離。&lt;/p&gt;
&lt;p&gt;數位斷捨離（Digital Declutter）作家卡爾．紐波特（Cal Newport）在其著作《&lt;a href=&quot;https://www.books.com.tw/products/0010843512&quot;&gt;深度數位大掃除&lt;/a&gt;》一書中所提出。&lt;/p&gt;
&lt;p&gt;數位斷捨離是一種整理和簡化數位世界的方法，旨在&lt;strong&gt;減少干擾並提升專注力&lt;/strong&gt;。通過過濾數位訊息和限制使用數位工具（尤其是社交平台），我們可以節省時間和精力，更好地專注於重要的事情。&lt;/p&gt;
&lt;p&gt;這種方法有助於建立一個更有意義和平衡的數位生活。所以它不止是方法，也是一種「&lt;strong&gt;價值觀與實踐&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;概念理解上沒什麼困難，但實踐起來可遠遠不是如此。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="簡潔主義" scheme="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/"/>
    
    <category term="資訊焦慮" scheme="https://blog.kyomind.tw/tags/%E8%B3%87%E8%A8%8A%E7%84%A6%E6%85%AE/"/>
    
    <category term="數位斷捨離" scheme="https://blog.kyomind.tw/tags/%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
  </entry>
  
  <entry>
    <title>Poetry + pyenv 實戰心得：常用指令與注意事項</title>
    <link href="https://blog.kyomind.tw/poetry-pyenv-practical-tips/"/>
    <id>https://blog.kyomind.tw/poetry-pyenv-practical-tips/</id>
    <published>2023-06-05T15:01:08.000Z</published>
    <updated>2023-06-22T05:39:39.761Z</updated>
    
    <content type="html"><![CDATA[<!-- ![from Pixabay](https://i.imgur.com/yODxmxJ.jpg) --><p><img src="https://i.imgur.com/npnmhFE.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>〈<a href="https://blog.kyomind.tw/python-poetry/">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a>〉發表至今，已過了 1 年多，這意味我也用了一年多的 Poetry。</p><p>感覺如何？——我覺得還不錯！可見不是三分鐘熱度而已。</p><p>對現在的我而言，Poetry 已成為專案開發不可或缺的元素。它不僅提供了更加便捷的專案套件管理和版本控制，同時，Poetry 支援 pyproject.toml 作為設定檔的特性，也使得我更容易使用其他也採用 pyproject.toml 的工具。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pyproject-toml/">pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學</a></p></blockquote><h3 id="系列：Python-Poetry-三部曲"><a href="#系列：Python-Poetry-三部曲" class="headerlink" title="系列：Python Poetry 三部曲"></a>系列：Python Poetry 三部曲</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/python-poetry/">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a></li><li><strong>Poetry + pyenv 實戰心得：常用指令與注意事項</strong></li><li>終結 requirements.txt：Dockerfile 多階段建構 Poetry 虛擬環境（待發表）</li></ol></blockquote><span id="more"></span><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文將補充系列第一篇中在「<a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E5%B8%B8%E8%A6%8B%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%83%E8%88%87%E6%93%8D%E4%BD%9C-QA">情境使用</a>」方面的不足之處，尤其是針對 Poetry 和 pyenv 同時使用時可能出現的問題進行討論。這是第一篇所遺漏的內容。</p><p>透過本文，我希望能夠提供更全面、更實用的 Poetry 使用建議，讓讀者在使用 Poetry 和 pyenv 時能夠充分發揮它們的優勢，並減少不必要的困惑。</p><h3 id="以-poetry-demo-為例"><a href="#以-poetry-demo-為例" class="headerlink" title="以 poetry-demo 為例"></a>以 poetry-demo 為例</h3><p>poetry-demo 是本文作為例示的專案模版，但我們不會安裝太多套件，僅各取一個作為示範之用。</p><p>有一個簡單的具體實例，還是比抽象的描述容易理解得多。</p><p>我們會從一台全新的 Linux VM（Ubuntu 20.04）開始，先安裝 pyenv，再安裝 Poetry，然後再一起使用它們，建立 Python 專案與虛擬環境。</p><h3 id="使用的-Poetry-版本：1-5-1"><a href="#使用的-Poetry-版本：1-5-1" class="headerlink" title="使用的 Poetry 版本：1.5.1"></a>使用的 Poetry 版本：1.5.1</h3><p>Poetry 在 1.2 版後，對於部分指令進行有較大的改動與擴張，導致舊指令使用上不完全相容，這次會採用當前的最新版——<a href="https://github.com/python-poetry/poetry/releases/tag/1.5.1">1.5.1</a>——來進行示範。</p><h3 id="使用的-pyenv-版本：2-3-18"><a href="#使用的-pyenv-版本：2-3-18" class="headerlink" title="使用的 pyenv 版本：2.3.18"></a>使用的 pyenv 版本：2.3.18</h3><p>pyenv 在 v2.3.0 以後，已經<a href="https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv">大幅簡化了設定操作</a>，所以這裡也有必要強調一下使用的版本：<a href="https://github.com/pyenv/pyenv/releases/tag/v2.3.18">v2.3.18</a>。</p><p>相關文章也有就新版設定內容進行更新，可參考〈<a href="https://blog.kyomind.tw/ubuntu-pyenv/#%E8%A8%AD%E5%AE%9A-pyenv">Ubuntu 安裝使用 pyenv + pyenv-virtualenv</a>〉。</p><h2 id="安裝-Poetry、pyenv、Python-3-10"><a href="#安裝-Poetry、pyenv、Python-3-10" class="headerlink" title="安裝 Poetry、pyenv、Python 3.10"></a>安裝 Poetry、pyenv、Python 3.10</h2><p>請直接參考〈<a href="https://blog.kyomind.tw/linux-dev-setup/">Linux Python 開發環境設定：zsh、zinit、pyenv、poetry、docker</a>〉中的「<a href="https://blog.kyomind.tw/linux-dev-setup/#%E4%B8%89%E3%80%81%E8%A8%AD%E5%AE%9A-pyenv">三、設定 pyenv</a>」、「<a href="https://blog.kyomind.tw/linux-dev-setup/#%E5%9B%9B%E3%80%81%E8%A8%AD%E5%AE%9A-Poetry">四、設定 Poetry</a>」部分。</p><p>不只是安裝，還包括設定 PATH 等環節，這些步驟都是必要的。完成這些步驟後，我們就擁有了 Poetry 和 pyenv。</p><h3 id="透過-pyenv-安裝-Python-3-10-11"><a href="#透過-pyenv-安裝-Python-3-10-11" class="headerlink" title="透過 pyenv 安裝 Python 3.10.11"></a>透過 pyenv 安裝 Python 3.10.11</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.10.11</span><br></pre></td></tr></table></figure><p>pyenv 是為了方便我們管理多個 Python 版本，下面我們會探討不同專案分別使用多個 Python 版本時的 Poetry + pyenv 操作注意事項。</p><p>這裡至少要先有一個 Python 版本，才能順利安裝我們的專案，在此以 <a href="https://www.python.org/downloads/release/python-31011/">Python 3.10.11</a> 為例。</p><h2 id="Poetry-與-pyenv-的部分功能重疊"><a href="#Poetry-與-pyenv-的部分功能重疊" class="headerlink" title="Poetry 與 pyenv 的部分功能重疊"></a>Poetry 與 pyenv 的部分功能重疊</h2><p>安裝完後，是否要設定<code>pyenv local 3.10.11</code>或<code>pyenv global 3.10.11</code>，取決於你是否有「多專案且多種 Python 版本」需求。</p><p>如果只需要一種 Python 版本，那將其設定為<code>global</code>已足：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global 3.10.11</span><br></pre></td></tr></table></figure><p>如<a href="https://blog.kyomind.tw/linux-dev-setup/">前述文章</a>所言：</p><blockquote><p>因為 Poetry 自帶了虛擬環境管理功能，容易和 pyenv-virtualenv <strong>疊床架屋</strong>，徒增<strong>管理上的混淆</strong>，所以<strong>我現在一律只使用 Poetry + venv 來管理 Python 虛擬環境</strong>。</p></blockquote><p>即使在不同專案需要多版本 Python 情況下，pyenv-virtualenv 也不是必須。只要善用<code>pyenv local</code>和<code>poetry env use</code>兩大指令即可。</p><p>綜上所述，這也是為什麼我認為 Poetry 的教學<strong>應該涵蓋對 pyenv 的整合</strong>，因為在「虛擬環境管理」方面，兩者的功能有一定重疊。</p><hr><p>前置作業總算大功告成，我們開始建立 poetry-demo 吧！</p><h2 id="一、初始化-Poetry-專案"><a href="#一、初始化-Poetry-專案" class="headerlink" title="一、初始化 Poetry 專案"></a>一、初始化 Poetry 專案</h2><p>先確認一下當前的 Poetry 版本，使用<code>poetry --version</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry --version</span><br><span class="line">Poetry (version 1.4.2)</span><br></pre></td></tr></table></figure><p>我的 Poetry 是一段時間前安裝的 1.4.2，需要更新一下，以符合本文使用的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry self update</span><br><span class="line"></span><br><span class="line">Using version ^1.5.1 <span class="keyword">for</span> poetry</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (2.6s)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Package operations: 0 installs, 5 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Updating platformdirs (2.6.2 -&gt; 3.5.1)</span><br><span class="line">  • Updating poetry-core (1.5.2 -&gt; 1.6.1)</span><br><span class="line">  • Updating poetry-plugin-export (1.3.1 -&gt; 1.4.0)</span><br><span class="line">  • Updating virtualenv (20.21.1 -&gt; 20.23.0)</span><br><span class="line">  • Updating poetry (1.4.2 -&gt; 1.5.1)</span><br></pre></td></tr></table></figure><p>因為是使用全域安裝 Poetry，上面的套件更新訊息和專案的虛擬環境無關——畢竟我們根本都還沒有為專案建立專屬的 Python 虛擬環境！</p><p>也可以指定要升級的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry self update 1.5.1</span><br></pre></td></tr></table></figure><h3 id="使用poetry-init初始化專案"><a href="#使用poetry-init初始化專案" class="headerlink" title="使用poetry init初始化專案"></a>使用<code>poetry init</code>初始化專案</h3><p>確認完 Poetry 版本，開始建立專案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> poetry-demo</span><br><span class="line"><span class="built_in">cd</span> poetry-demo</span><br><span class="line">poetry init</span><br></pre></td></tr></table></figure><p><code>poetry init</code>會出現下列互動式訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">This <span class="built_in">command</span> will guide you through creating your pyproject.toml config.</span><br><span class="line"></span><br><span class="line">Package name [poetry-demo]:</span><br><span class="line">Version [0.1.0]:</span><br><span class="line">Description []:</span><br><span class="line">Author [kyo &lt;odinxp@gmail.com&gt;, n to skip]:</span><br><span class="line">License []:</span><br><span class="line">Compatible Python versions [^3.8]:</span><br><span class="line"></span><br><span class="line">Would you like to define your main dependencies interactively? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>] no</span><br><span class="line">Would you like to define your development dependencies interactively? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>] no</span><br><span class="line">Generated file</span><br><span class="line"></span><br><span class="line">[tool.poetry]</span><br><span class="line">name = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">description = <span class="string">&quot;&quot;</span></span><br><span class="line">authors = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line">readme = <span class="string">&quot;README.md&quot;</span></span><br><span class="line">packages = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line">build-backend = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br><span class="line"></span><br><span class="line">Do you confirm generation? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>]</span><br></pre></td></tr></table></figure><p>中間的「Would you like to define your <strong>main&#x2F;development</strong> dependencies interactively?」兩個問句，我都回答「no」，最後一個則是「yes」。</p><p>初始化後的<code>pyproject.toml</code>內容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">readme</span> = <span class="string">&quot;README.md&quot;</span></span><br><span class="line"><span class="attr">packages</span> = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到其中有一行「<code>readme = &quot;README.md&quot;</code>」，此時專案必須有<code>README.md</code>，否則會找不到檔案。我都直接刪除該行，比較省事。</p><h3 id="使用poetry-new快速初始化"><a href="#使用poetry-new快速初始化" class="headerlink" title="使用poetry new快速初始化"></a>使用<code>poetry new</code>快速初始化</h3><p>要達到專案初始化的效果，你也可以直接用<code>poetry new poetry-demo</code>指令，更快速！不過它也會幫你做「更多事」，細節請參考<a href="https://python-poetry.org/docs/basic-usage/#project-setup">文件</a>。</p><h2 id="二、為專案建立-Python-虛擬環境"><a href="#二、為專案建立-Python-虛擬環境" class="headerlink" title="二、為專案建立 Python 虛擬環境"></a>二、為專案建立 Python 虛擬環境</h2><p>這裡是「重頭戲」之一，但做法上並不是那麼「直觀」，常常容易讓人混淆。僅使用 pyenv 的前提下，再安裝<code>pyenv-virtualenv</code>來建立虛擬環境，確實不難。</p><p>但現在有了 Poetry，兩者的搭配使用方式就很重要，這也是為什麼我一再強調，有了 Poetry，乾脆就不要再裝<code>pyenv-virtualenv</code>了。</p><h3 id="使用-Poetry-建立虛擬環境"><a href="#使用-Poetry-建立虛擬環境" class="headerlink" title="使用 Poetry 建立虛擬環境"></a>使用 Poetry 建立虛擬環境</h3><p>在第一篇文章中，雖然我提過<code>poetry shell</code>有時候可以替代<code>poetry env use</code>，作為快速建立虛擬環境的便捷手段。</p><p>但是，當你還沒有為專案建立虛擬環境，且作業系統中包含了不止一個 Python 版本時，建議就不要用<code>poetry shell</code>來建立虛擬環境——因為它很可能會選擇不是你要的 Python 版本。</p><p>儘管我們使用 pyenv 來管理 Python，但完整的 Linux 發行版往往都自帶了系統的 Python。比如我的 Ubuntu 就自帶了 3.8.x，這正是為何上面<code>pyproject.toml</code>會有一行「<code>python = &quot;^3.8&quot;</code>」而不是<code>^3.10</code>——因為 Poetry 偵測到的是系統預設的 Python，而不是 pyenv 的 Poetry。</p><p>換句話說，無論透過 pyenv 安裝了幾個 Python 版本，<strong>這些資訊對 Poetry 而言，仍可能是陌生的。</strong></p><p>為了讓 Poetry 在建立虛擬環境時，能確實使用<strong>你想要的 Python 版本</strong>，我們必須善用<code>poetry env use</code>指令才行。</p><h2 id="三、確定專案使用的-Python-版本"><a href="#三、確定專案使用的-Python-版本" class="headerlink" title="三、確定專案使用的 Python 版本"></a>三、確定專案使用的 Python 版本</h2><p>第一篇文章中也提到：</p><blockquote><p>我覺得學習 Poetry 的<strong>第一道關卡</strong>，就是它對於<strong>虛擬環境</strong>的管理。</p></blockquote><p>現在看來一點也沒錯！</p><h3 id="指定虛擬環境-Python-版本的標準做法"><a href="#指定虛擬環境-Python-版本的標準做法" class="headerlink" title="指定虛擬環境 Python 版本的標準做法"></a>指定虛擬環境 Python 版本的標準做法</h3><p>在使用 pyenv 的情況下，<a href="https://python-poetry.org/docs/managing-environments/">Poetry 官方文件</a>有補充一個讓你能「確定」虛擬環境會使用的 Python 版本的做法：</p><blockquote><p>If you use a tool like <strong><a href="https://github.com/pyenv/pyenv">pyenv</a></strong> to manage different Python versions, you can set the <strong>experimental</strong> <code>virtualenvs.prefer-active-python</code> option to <code>true</code>. Poetry will then try to find the current <code>python</code> of your shell.</p></blockquote><p>其中的「experimental」表示這是一個實驗性功能。所以我不偏好這個做法。</p><blockquote><p>For instance, if your project requires a newer Python than is available with your system, a standard workflow would be:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.9.8</span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.8  <span class="comment"># Activate Python 3.9 for the current project</span></span><br><span class="line">poetry install</span><br></pre></td></tr></table></figure><p>主要分成兩個步驟：</p><ol><li>將<code>virtualenvs.prefer-active-python</code>設為<code>true</code>。</li><li>使用 pyenv 的<code>pyenv local</code>指令。</li></ol><h3 id="我偏好的做法：poetry-env-use"><a href="#我偏好的做法：poetry-env-use" class="headerlink" title="我偏好的做法：poetry env use"></a>我偏好的做法：<code>poetry env use</code></h3><p>如果你只確定需要「<strong>一個</strong>」Python 版本，且已經將其設定為<code>global</code>，那麼前述的<code>virtualenvs.prefer-active-python</code>設定，或可省略。</p><p><code>poetry env use</code>有下列幾種用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use /full/path/to/python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use python3.7</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use 3.7</span><br></pre></td></tr></table></figure><p>後三者的<code>python</code>、<code>python3.7</code>或<code>3.7</code>，都和你的<code>PATH</code>有關。</p><p>換句話說，如果你在終端機打<code>python3.7</code>，有成功進入「<a href="https://learn.microsoft.com/zh-tw/visualstudio/python/python-interactive-repl-in-visual-studio?view=vs-2022">Python 互動式視窗</a>」，那就表示這個版本的 Python 確實存在<code>PATH</code>中。</p><h3 id="使用which指令確認-Python-版本是否存在PATH中"><a href="#使用which指令確認-Python-版本是否存在PATH中" class="headerlink" title="使用which指令確認 Python 版本是否存在PATH中"></a>使用<code>which</code>指令確認 Python 版本是否存在<code>PATH</code>中</h3><p>不想進入 REPL，只想確認 Python 版本是否存在<code>PATH</code>中，可以使用<code>which</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">which</span> python3.9</span><br><span class="line">/home/kyo/.pyenv/shims/python3.9</span><br><span class="line">❯ <span class="built_in">which</span> python3.10</span><br><span class="line">/home/kyo/.pyenv/shims/python3.10</span><br><span class="line">❯ <span class="built_in">which</span> python</span><br><span class="line">/home/kyo/.pyenv/shims/python</span><br></pre></td></tr></table></figure><p>聰明的你應該猜到了，我們只要確保 Python 版本已存在於<code>PATH</code>，透過<code>poetry env use &lt;指定的python版本&gt;</code>即可確定專案使用的 Python 版本。</p><p>不過，這個<code>&lt;指定的python版本&gt;</code>必須要先透過 pyenv 安裝好，<strong>而且你通常要將其設定為<code>global</code>或<code>local</code>，系統才找得到。</strong></p><h3 id="poetry-demo-操作"><a href="#poetry-demo-操作" class="headerlink" title="poetry-demo 操作"></a>poetry-demo 操作</h3><p>回到案例，這裡我們已經將 3.10.11 設為<code>global</code>。所以輸入<code>python3.10</code>指令時，會進入互動式視窗。</p><p>此時只要使用下列指令，基本上可以確定使用的 Python 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use 3.10.11</span><br></pre></td></tr></table></figure><p>因為已經有設定<code>global</code>，單純使用<code>poetry env use python</code>應該也是可以成功套用 3.10。但保險起見，使用指令時還是建議輸入<strong>完整的版本號</strong>，包括尾綴的<code>.11</code></p><h2 id="四、不同專案使用不同-Python-版本"><a href="#四、不同專案使用不同-Python-版本" class="headerlink" title="四、不同專案使用不同 Python 版本"></a>四、不同專案使用不同 Python 版本</h2><p>即使有「多專案多 Python 版本」需求，也未必要變更前述的<code>virtualenvs.prefer-active-python</code>設定。</p><p>透過<code>pyenv local</code>+<code>poetry env use</code>，可以為不同專案設定不同的 Python 版本。</p><p>假設你有 a、b、c 三個專案，分別要使用 Python 3.7.11、3.9.12、3.10.11，依照前段介紹，我們可以這麼做。</p><p>首先，<code>pyenv versions</code>確認這三個版本的 Python 都已經由 pyenv 安裝完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ pyenv versions</span><br><span class="line">  system</span><br><span class="line">  3.7.11</span><br><span class="line">  3.9.12</span><br><span class="line">* 3.10.11 (<span class="built_in">set</span> by /home/kyo/.pyenv/version)</span><br></pre></td></tr></table></figure><p>接下來就很簡單了，為各專案設定好<code>pyenv local</code>（好讓<code>PATH</code>可以成功找到對應的 Python 執行檔），然後再<code>poetry env use &lt;指定的python版本&gt;</code>。</p><p>假設 b 專案要使用 3.9.12，則做法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> b</span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.12</span><br><span class="line">poetry <span class="built_in">env</span> use 3.9.12</span><br></pre></td></tr></table></figure><p>其餘專案以此類推。</p><h2 id="五、如何移除-Poetry-虛擬環境？"><a href="#五、如何移除-Poetry-虛擬環境？" class="headerlink" title="五、如何移除 Poetry 虛擬環境？"></a>五、如何移除 Poetry 虛擬環境？</h2><p>參考<a href="https://python-poetry.org/docs/managing-environments/#deleting-the-environments">文件</a>，標準做法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> remove /full/path/to/python</span><br><span class="line">poetry <span class="built_in">env</span> remove python3.7</span><br><span class="line">poetry <span class="built_in">env</span> remove 3.7</span><br><span class="line">poetry <span class="built_in">env</span> remove test-O3eWbxRl-py3.7</span><br></pre></td></tr></table></figure><p>然而，因為我們已經將<code>virtualenvs.in-project</code>改設為<code>true</code>，也就是直接在專案中建立名為<code>.venv</code>的虛擬環境。</p><p>上述的指令基本都沒有作用了。</p><blockquote><p>但我就真的需要砍掉重練啊！怎麼辦？</p></blockquote><h3 id="兩個方法"><a href="#兩個方法" class="headerlink" title="兩個方法"></a>兩個方法</h3><p>此時還有兩個簡單的方法可用。</p><p>方法一，就是直接砍掉<code>.venv</code>，簡單有效！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .venv</span><br></pre></td></tr></table></figure><p>方法二，我們依舊可以使用下列指令，優雅地移除它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry <span class="built_in">env</span> remove --all</span><br><span class="line">Deleted virtualenv: /home/kyo/poetry-demo/.venv</span><br></pre></td></tr></table></figure><hr><p>光專案初始化與虛擬環境管理就用掉了 5 個 h2 標題，可見其複雜。現在，我們進入第二部分——套件的安裝與管理。</p><h2 id="六、安裝套件至-main-dependencies"><a href="#六、安裝套件至-main-dependencies" class="headerlink" title="六、安裝套件至 main dependencies"></a>六、安裝套件至 main dependencies</h2><p>使用<code>poetry add</code>指令。</p><p>參考<a href="https://python-poetry.org/docs/cli/#add">文件</a>，可以發現<code>add</code>指令的用法還挺多元的！</p><p>我覺得對一般使用者而言，<code>poetry add</code>有兩個重點：</p><ol><li>了解<code>poetry add</code>的「多階段行為」。</li><li>了解<code>--group</code>參數用法。</li></ol><h3 id="重點一：poetry-add多階段行為"><a href="#重點一：poetry-add多階段行為" class="headerlink" title="重點一：poetry add多階段行為"></a>重點一：<code>poetry add</code>多階段行為</h3><p>如上篇文章所言，<code>poetry add</code>實際上會做 3 件事，依序為：</p><ol><li>更新<code>pyproject.toml</code>。</li><li>依照<code>pyproject.toml</code>的內容，更新<code>poetry.lock</code>。（相當於<code>poetry lock</code>）</li><li>依照<code>poetry.lock</code>的內容，更新虛擬環境。（相當於<code>poetry install</code>）</li></ol><blockquote><p>為什麼知道這個很重要？</p></blockquote><p>因為當你不是使用<code>poetry add</code>指令，而是直接修改<code>pyproject.toml</code>時，此時上述的第 2、3 步<strong>都不會自動執行</strong>。</p><p>但通常你手動修改 toml 檔最終都是為了變更虛擬環境，所以更新完<code>pyproject.toml</code>後，我們還要再使用<code>poetry lock</code>與<code>poetry install</code>指令才行！</p><p>對於不熟悉上述流程的初學者，很容易遺漏，並感到困惑。</p><h3 id="重點二：-group"><a href="#重點二：-group" class="headerlink" title="重點二：--group"></a>重點二：<code>--group</code></h3><p><strong>舊版</strong>（1.1）只有 main 和 dev 兩種依賴環境設定，<strong>新版</strong>（1.2）增加了<code>--group</code>參數，讓你可以除了 main 和 dev 外，還有能自訂多種 group，增加使用上的彈性。</p><p>比如可以命名不同的群組如下：</p><ul><li>test</li><li>dev</li><li>prod</li></ul><p>基本語法（後續還會提及）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add pytest --group <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>在新版（1.2）的<code>pyproject.toml</code>中會如此記載：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.group.test.dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;^6.0.0&quot;</span></span><br><span class="line"><span class="attr">pytest-mock</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>而舊版則是：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Poetry pre-1.2.x style, understood by Poetry 1.0–1.2</span></span><br><span class="line"><span class="section">[tool.poetry.dev-dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;^6.0.0&quot;</span></span><br><span class="line"><span class="attr">pytest-mock</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>兩者的<strong>差異</strong>，是版本過渡時要特別注意的。</p><p>雖然彈性變大，但我個人目前還是只有使用 main 和 dev 而已。</p><h3 id="poetry-demo-操作-1"><a href="#poetry-demo-操作-1" class="headerlink" title="poetry-demo 操作"></a>poetry-demo 操作</h3><p>至此，我們也安裝 Django 3.2.x 至 main dependencies 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry add django@^3.2</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (0.5s)</span><br><span class="line"></span><br><span class="line">Package operations: 5 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing typing-extensions (4.6.3)</span><br><span class="line">  • Installing asgiref (3.7.2)</span><br><span class="line">  • Installing pytz (2023.3)</span><br><span class="line">  • Installing sqlparse (0.4.4)</span><br><span class="line">  • Installing django (3.2.19)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br></pre></td></tr></table></figure><p>這個<code>@</code>符號（運算子）要怎麼用，請參考<a href="https://python-poetry.org/docs/dependency-specification/#using-the--operator">文件</a>。</p><h2 id="七、安裝套件至-dev-dependencies"><a href="#七、安裝套件至-dev-dependencies" class="headerlink" title="七、安裝套件至 dev dependencies"></a>七、安裝套件至 dev dependencies</h2><p>上篇文章中，我們已經探討過「<a href="https://blog.kyomind.tw/python-poetry/#%E6%96%B0%E5%A2%9E%E5%A5%97%E4%BB%B6%E8%87%B3-dev-dependencies">明確區分開發環境專用的套件</a>」的重要性。</p><p>舊版的指令是這樣的，以<code>black</code>為例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry add black --dev</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">poetry add black -D</span><br></pre></td></tr></table></figure><p>然而<code>--dev (-D)</code>在新版<a href="https://python-poetry.org/docs/cli/#options-4">已棄用</a>：</p><blockquote><p>• <code>--dev (-D)</code>: Add package as development dependency. (Deprecated, use <code>-G dev</code> instead)</p></blockquote><p>因為加入了 group 機制，新版的指令略有不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry add black --group dev</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">poetry add black -G dev</span><br></pre></td></tr></table></figure><p>講白了就是變囉嗦了一點。</p><p>此時的 toml 檔內容如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">packages</span> = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"><span class="attr">django</span> = <span class="string">&quot;^3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.group.dev.dependencies]</span></span><br><span class="line"><span class="attr">black</span> = <span class="string">&quot;^23.3.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure><h2 id="八、poetry-install-sync"><a href="#八、poetry-install-sync" class="headerlink" title="八、poetry install --sync"></a>八、<code>poetry install --sync</code></h2><p>不久前才發現，虛擬環境用久了，安裝的套件似乎和 lock 檔不完全一致！我一直以為兩者是一定同步的🐸，顯然不是。</p><p>參考<a href="https://python-poetry.org/docs/managing-dependencies/#synchronizing-dependencies">文件</a>，可用下列指令確保同步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry install --<span class="built_in">sync</span></span><br></pre></td></tr></table></figure><h2 id="九、Docker-環境中使用-Poetry"><a href="#九、Docker-環境中使用-Poetry" class="headerlink" title="九、Docker 環境中使用 Poetry"></a>九、Docker 環境中使用 Poetry</h2><p>前文中有<a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%94%E3%80%81%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E4%B8%8D%E5%9C%A8-Docker-%E7%92%B0%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Poetry%EF%BC%9F">這麼一段</a>，闡述我不在 Docker 中使用 Poetry 的<strong>理由</strong>與<strong>替代方案</strong>：</p><blockquote><p>所幸 Poetry 依舊可以輸出<code>requirements.txt</code>，Docker 部署環境就繼續使用這個舊方案即可，而且 Poetry 本來主要就是用於「開發」時的套件管理，對部署差別不大。</p></blockquote><p>說是這樣說，但一年多用下來，我發現這個做法也<strong>不盡理想</strong>，它至少存在兩個問題：</p><ol><li>套件有變動時，常常會<strong>忘記匯出</strong><code>requirements.txt</code>：你可以說這是人的問題，但這個 export <code>requirements.txt</code>做法，就真的很容易讓人忘記。</li><li>由 Poetry 匯出的<code>requirements.txt</code>，不一定能透過 pip 正常安裝套件——兩者存在<strong>輕微的相容性問題</strong>。</li></ol><p>怎麼解？我在原文也已經補充了：</p><blockquote><p>使用 <strong><a href="https://docs.docker.com/build/building/multi-stage/">multi-stage builds</a></strong> 的 Dockerfile，可以在第一階段安裝 Poetry，第二階段再把 Poetry 捨棄，這樣就不會有多餘的耦合與依賴了。日後會專文介紹。</p></blockquote><p>對，所以系列的第三篇會把這部分補完。</p>]]></content>
    
    
    <summary type="html">&lt;!-- ![from Pixabay](https://i.imgur.com/yODxmxJ.jpg) --&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/npnmhFE.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;https://blog.kyomind.tw/python-poetry/&quot;&gt;再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;〉發表至今，已過了 1 年多，這意味我也用了一年多的 Poetry。&lt;/p&gt;
&lt;p&gt;感覺如何？——我覺得還不錯！可見不是三分鐘熱度而已。&lt;/p&gt;
&lt;p&gt;對現在的我而言，Poetry 已成為專案開發不可或缺的元素。它不僅提供了更加便捷的專案套件管理和版本控制，同時，Poetry 支援 pyproject.toml 作為設定檔的特性，也使得我更容易使用其他也採用 pyproject.toml 的工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/pyproject-toml/&quot;&gt;pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系列：Python-Poetry-三部曲&quot;&gt;&lt;a href=&quot;#系列：Python-Poetry-三部曲&quot; class=&quot;headerlink&quot; title=&quot;系列：Python Poetry 三部曲&quot;&gt;&lt;/a&gt;系列：Python Poetry 三部曲&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/python-poetry/&quot;&gt;再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Poetry + pyenv 實戰心得：常用指令與注意事項&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;終結 requirements.txt：Dockerfile 多階段建構 Poetry 虛擬環境（待發表）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="pip" scheme="https://blog.kyomind.tw/tags/pip/"/>
    
    <category term="pyenv" scheme="https://blog.kyomind.tw/tags/pyenv/"/>
    
    <category term="virtualenv" scheme="https://blog.kyomind.tw/tags/virtualenv/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>18，論軟體工程師常見的「路徑依賴」問題（上）</title>
    <link href="https://blog.kyomind.tw/weekly-review-18/"/>
    <id>https://blog.kyomind.tw/weekly-review-18/</id>
    <published>2023-05-13T20:01:00.000Z</published>
    <updated>2023-05-23T09:29:13.218Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>我常常覺得，軟體工程師可能是最能體現「<a href="https://zh.wikipedia.org/zh-tw/%E5%B7%A5%E5%85%B7%E8%A7%84%E5%BE%8B">當你手裡只有鎚子，看什麼都會像釘子</a>」的一群人😂</p><p>我們在工作中，有時會陷入一種被稱為「<a href="https://zh.wikipedia.org/zh-tw/%E8%B7%AF%E5%BE%84%E4%BE%9D%E8%B5%96">路徑依賴</a>」的困境。本文將探討「路徑依賴」在軟體工程師的工作與職涯發展中，所造成的各種影響和受困者會有的具體表現。</p><p>或許會讓你感到有點熟悉。</p><h2 id="前言：何謂路徑依賴？"><a href="#前言：何謂路徑依賴？" class="headerlink" title="前言：何謂路徑依賴？"></a>前言：何謂路徑依賴？</h2><p>「<strong>路徑依賴</strong>」是個社會科學的概念，用來描述一種現象，即一旦人們在某一方面選擇了特定的路徑或方式，他們就可能變得<strong>過度依賴這條路徑，並且可能難以改變。</strong></p><p>這種依賴性可能源於各種因素，包括習慣、成本、學習曲線等，並可能在多個層面上產生影響，包括個人的行為、團隊的運作，甚至是整個社會的結構和制度。</p><p>在這裡，我們將專注於討論「<strong>軟體工程師常見的路徑依賴</strong>」。以下的內容主要是基於我個人在工作上的觀察，可能會帶有一點偏見，但絕大部分都是基於事實。</p><span id="more"></span><h2 id="何謂軟體工程師的路徑依賴？"><a href="#何謂軟體工程師的路徑依賴？" class="headerlink" title="何謂軟體工程師的路徑依賴？"></a><strong>何謂軟體工程師的路徑依賴？</strong></h2><p>文章標題與開頭把「路徑依賴」稱為一種「<strong>困境</strong>」，這樣的說法可能<strong>有失公允</strong>。</p><p>事實上，在大部分情況下，遵循既定的路徑可以顯著提高效率、增加確定性，同時也是我們發展專業的基礎。</p><p>所以嚴格來說，本文要討論的，是軟體工程師在工作與職涯中，那些「<strong>造成不良影響</strong>」的路徑依賴。</p><p>這類依賴帶來了<strong>一系列問題</strong>，例如<strong>低效率產出、溝通不順暢，甚至限制了我們的視野</strong>。因此，對於軟體工程師來說，了解這些路徑依賴的存在，確實有其必要。</p><p>接下來，我將從我自己以及我曾接觸和共事過的軟體工程師身上，舉出四個常見的路徑依賴觀察實例。</p><p>而且它們會是「<strong>層層遞進</strong>」的關係，從底層的工作細節，到上層的個人職涯選擇，我們無不受到「<strong>軟體工程師</strong>」這個角色的影響（或說「<strong>限制</strong>」）。</p><p>不過礙於篇幅，我們這期<strong>只先講前兩個</strong>。</p><hr><h2 id="一、程式註解的路徑依賴"><a href="#一、程式註解的路徑依賴" class="headerlink" title="一、程式註解的路徑依賴"></a>一、程式註解的路徑依賴</h2><p>首先，讓我們以「程式註解」為例，看看軟體工程師在<strong>為程式碼寫註解</strong>時，如何表現出「<strong>不良的路徑依賴</strong>」。</p><p>所謂的「<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%BB%E8%A7%A3_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">程式註解</a>」，指的是在程式碼中<strong>以特定格式或符號添加的文字或說明</strong>，用於解釋程式碼的功能、邏輯或用途。</p><p>程式註解是為了提供給開發人員或其他讀者（通常是一起開發的工程師）更容易理解和閱讀本段程式碼的<strong>附加資訊</strong>。它們<strong>不會影響程式的執行</strong>，但對於增進開發上的溝通與協作效率，有著重要地位，尤其是程式中<strong>特別複雜</strong>的部分。</p><p>註解通常使用<strong>自然語言</strong>（例如英文、中文）撰寫，而且要力求<strong>好讀、好理解</strong>。</p><h3 id="「程式晶晶體」註解"><a href="#「程式晶晶體」註解" class="headerlink" title="「程式晶晶體」註解"></a>「程式晶晶體」註解</h3><blockquote><p><a href="https://zh.wikipedia.org/zh-tw/%E6%99%B6%E6%99%B6%E9%AB%94">晶晶體</a>是一種流行於臺灣以中文為基底，夾雜英語不成句的單字或片語的表達方式。</p></blockquote><p>某些人在撰寫註解時，容易過度依賴程式碼的「<strong>實作細節</strong>」表達（比如<code>用 excutemany 大量插入資料至 User Table</code>、<code>以 bulk_create 批次建立 obj</code>），而非使用<strong>簡潔清晰的自然語言</strong>（比如<code>將用戶資料存入資料庫</code>、<code>一次性建立大量用戶資料</code>）。</p><p>在中文夾雜大量的程式碼片語，堪稱「<strong>程式晶晶體</strong>」，語意不清、主詞不明，常常讓人無法一望即知。</p><p>其實也有完全用自然語言書寫的註解，但你讀起來並不覺得那是「<strong>通順</strong>」的句子，比較像 10 歲小學生寫的作文。</p><p>為什麼會這樣？因為開發者普遍「<strong>比較擅長</strong>」寫程式，而非文字表達。所以乾脆用寫程式的思路來寫註解——毫無疑問，這樣真的比較輕鬆。</p><p>這種在思考與陳述上，<strong>嚴重依賴程式碼邏輯</strong>的敘事方式，常常導致註解<strong>難以理解</strong>、重複程式碼的內容（即<strong>冗餘的註解</strong>），甚至可能<strong>產生混淆</strong>。</p><h3 id="從他人角度自我審視：為什麼作者都需要好的編輯？"><a href="#從他人角度自我審視：為什麼作者都需要好的編輯？" class="headerlink" title="從他人角度自我審視：為什麼作者都需要好的編輯？"></a>從他人角度自我審視：為什麼作者都需要好的編輯？</h3><p>你可能會認為：「只要提醒對方注意一下，問題就解決了吧？自己的文字是否易懂，應該很容易看得出來吧！」可惜，事實往往不是如此。</p><p>對於開發程式的「當事人」而言，即使註解中夾雜了大量不必要的程式細節，自己也常常會<strong>深陷其中，難以察覺</strong>，甚至覺得看起來<strong>很合理</strong>！——這就是為什麼作者都需要好的編輯，因為<strong>自身的盲點是很難完全發現並避免的</strong>。</p><p>少部分工程師甚至會覺得「我的程式能跑且執行結果正確」就算稱職了。至於註解有沒有寫、寫得好不好，不能算是評價我工作品質的範圍與指標。</p><p>這想法不能說毫無道理，只不過，寫程式若只顧自己，終究難登大雅之堂。這些程式碼看起來就像是<strong>一個人的自言自語</strong>（只要自己有完成任務就好）——<strong>它並沒有在溝通</strong>。</p><h3 id="註解只是冰山一角"><a href="#註解只是冰山一角" class="headerlink" title="註解只是冰山一角"></a>註解只是冰山一角</h3><p>本段以「程式註解」為例，試圖說明工程師在「撰寫易讀程式碼」的路上常見的路徑依賴（可以說是一種協作上的「阻礙」）。</p><p>然而，這種「<strong>缺乏溝通意識</strong>」所帶來的影響，不僅存在於註解中，<strong>也往往貫穿整個程式寫作過程</strong>。</p><p>這種心態的影響實際上<strong>遠遠超越了程式碼的範疇</strong>，接下來，我們將繼續探討這種心態在「<strong>工作表達方式</strong>」上所展現的路徑依賴特徵。</p><h2 id="二、工作表達方式上的路徑依賴"><a href="#二、工作表達方式上的路徑依賴" class="headerlink" title="二、工作表達方式上的路徑依賴"></a>二、工作表達方式上的路徑依賴</h2><p>看完第一個路徑依賴，我想你已經能猜到，這第二個會是什麼模樣了。</p><p>很多軟體 PM 在會議中常常會覺得，聽不太懂工程師在說些什麼。而我想說的是，你的感覺是對的！其實我也聽不懂。</p><p>既然寫註解、<a href="https://en.wikipedia.org/wiki/Docstring">docstring</a> 這種應該要用「簡潔清晰的自然語言」表達的場合，都容易<strong>藉由程式邏輯與實作細節含混帶過</strong>。那麼軟體工程師在會議中的表達，自然也會受到此「<strong>慣性</strong>」影響。</p><p>以我個人的經驗，工程師在描述自己工作上的要解決的問題、解決方式、可能的方向、已完成的任務等等，非常容易陷入類似的路徑依賴。</p><p>其結果就跟前面提到的程式註解一樣，你不會覺得對方是在講「人話」，而像是一種對技術方案、程式邏輯的「<strong>輪廓描述</strong>」。</p><p>至於所要解決的問題、背後的痛點究竟是什麼？選擇的依據為何？常常會直接予以忽略——因為他們滿腦子都是技術思維。</p><p>導致重點還沒說清楚，相關細節卻講了一堆，本末倒置。</p><h3 id="請說人話"><a href="#請說人話" class="headerlink" title="請說人話"></a>請說人話</h3><p>前面提到，不好的程式註解，就像一個人的自言自語。而這樣的表達方式，又何嘗不是如此？導致我們常常需要提醒對方「等等！我想要先知道的是……」</p><p>不過平心而論，良好的溝通、表達，對任何人都不容易，都需要一定的練習。</p><p>換句話說，要把一件事情講好，絕對需要先構思、自我反芻、察覺他人容易產生的疑問，並且<strong>以他人的角度去思考</strong>，才能真正做到「<strong>說人話</strong>」。</p><p>只不過軟體工程師基於職業上的特性，在感到<strong>表達困難</strong>的當下，<strong>容易反射性地躲回自己熟悉的技術與專業領域，以求得一定的自適與安全感。</strong></p><p>這無疑會讓沒有技術背景的人，感到困惑和隔閡。</p><hr><h2 id="小結：讀者意識的欠缺"><a href="#小結：讀者意識的欠缺" class="headerlink" title="小結：讀者意識的欠缺"></a>小結：讀者意識的欠缺</h2><p>講完前兩項，本篇要收尾了，我們作個小結。</p><p>前兩個路徑依賴凸顯的都是當事人對於「<strong>他人很可能會不理解</strong>」這個意識的強烈欠缺，以至於常常用一種旁人看來近乎「<strong>自言自語</strong>」的方式在表達自我。</p><p>如果是一個作者，那就是「<strong>讀者意識不足</strong>」——寫出來的文章<strong>只有自己看得懂</strong>。</p><blockquote><p>所謂的「<strong>讀者意識</strong>」，指的是作者在寫作時預見到讀者的理解困難，並通過語言表達和組織結構來幫助讀者，使讀者更容易理解的能力。</p></blockquote><p>我很想說「本文只是指出少數軟體工程師在工作上……」，但你我都知道（這裡的「你我」指的是工程師群體），說「少」恐怕是騙人的。</p><p>「<strong>讀者意識的欠缺</strong>」在軟體工程師中確實是一個<strong>普遍存在的問題</strong>。有時候，我們可能過於專注於自己的程式碼和技術細節，而忽略了將這些複雜的概念和思維以易於理解的方式傳達給他人。</p><p>我也不敢說自己已經完全擺脫了上述的困境，在「讓自己與自己的工作產出容易被他人理解」這個面向上，我們還可以不斷努力，一直努力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我常常覺得，軟體工程師可能是最能體現「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%B7%A5%E5%85%B7%E8%A7%84%E5%BE%8B&quot;&gt;當你手裡只有鎚子，看什麼都會像釘子&lt;/a&gt;」的一群人😂&lt;/p&gt;
&lt;p&gt;我們在工作中，有時會陷入一種被稱為「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E8%B7%AF%E5%BE%84%E4%BE%9D%E8%B5%96&quot;&gt;路徑依賴&lt;/a&gt;」的困境。本文將探討「路徑依賴」在軟體工程師的工作與職涯發展中，所造成的各種影響和受困者會有的具體表現。&lt;/p&gt;
&lt;p&gt;或許會讓你感到有點熟悉。&lt;/p&gt;
&lt;h2 id=&quot;前言：何謂路徑依賴？&quot;&gt;&lt;a href=&quot;#前言：何謂路徑依賴？&quot; class=&quot;headerlink&quot; title=&quot;前言：何謂路徑依賴？&quot;&gt;&lt;/a&gt;前言：何謂路徑依賴？&lt;/h2&gt;&lt;p&gt;「&lt;strong&gt;路徑依賴&lt;/strong&gt;」是個社會科學的概念，用來描述一種現象，即一旦人們在某一方面選擇了特定的路徑或方式，他們就可能變得&lt;strong&gt;過度依賴這條路徑，並且可能難以改變。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這種依賴性可能源於各種因素，包括習慣、成本、學習曲線等，並可能在多個層面上產生影響，包括個人的行為、團隊的運作，甚至是整個社會的結構和制度。&lt;/p&gt;
&lt;p&gt;在這裡，我們將專注於討論「&lt;strong&gt;軟體工程師常見的路徑依賴&lt;/strong&gt;」。以下的內容主要是基於我個人在工作上的觀察，可能會帶有一點偏見，但絕大部分都是基於事實。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>確保 isort 正確排序本地模組：pyproject.toml 與 pre-commit 設定</title>
    <link href="https://blog.kyomind.tw/isort-local-module-sorting/"/>
    <id>https://blog.kyomind.tw/isort-local-module-sorting/</id>
    <published>2023-05-08T16:15:08.000Z</published>
    <updated>2023-05-10T05:41:40.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/M6eKHe9.png"></p><p><a href="https://pycqa.github.io/isort/">isort</a> 是一個 Python 套件兼命令列工具，可以幫開發者自動排序 Python imports，以符合 <a href="https://peps.python.org/pep-0008/#imports">PEP 8 規範</a>。這種排序也可以讓程式碼更加易讀且易於維護。</p><p>之前已有數篇文章介紹過，可參考本站的「<a href="/tags/isort/">isort 標籤頁</a>」。</p><p>isort 會自動將 import 分為「<strong>Python 標準函式庫</strong>」、「<strong>第三方套件</strong>」、「<strong>本地模組</strong>」等三大區塊，並依<strong>字母順序</strong>排列，同時為你在三個區塊之間<strong>空一行</strong>。</p><h2 id="isort-本地模組排序錯誤"><a href="#isort-本地模組排序錯誤" class="headerlink" title="isort 本地模組排序錯誤"></a>isort 本地模組排序錯誤</h2><p>isort 有一個 bug（我也不確定是不是 bug），就是<strong>對於本地模組的「排序判斷」，有可能發生錯誤。</strong></p><p>這會造成什麼結果？通常的影響是，<strong>本來應該排在第三區塊的 import，排到第二區塊去了。</strong>總之就是 import 放錯了區塊。</p><p>這樣除了不符合 PEP 8 規範，更重要的是，它還可能對開發者造成「<strong>誤導</strong>」。而且會使用 isort 的人，往往就是在乎 import 排序的人，當然不能接受這樣的錯誤。</p><span id="more"></span><h2 id="VS-Code-解法"><a href="#VS-Code-解法" class="headerlink" title="VS Code 解法"></a>VS Code 解法</h2><p>我第一次發現這個問題是在 VS Code 的整合界面，在自動格式化時，發現<strong>本地模組被錯誤地分類到了第三方模組</strong>。</p><p>很自然的輸入關鍵字，比如「<a href="https://www.google.com/search?q=isort+wrong+order">isort wrong order</a>」，你能找到這篇 issue：</p><ul><li><a href="https://github.com/microsoft/vscode-python/issues/14254">Wrong order in import when using sort imports in vscode</a></li></ul><p>往下滑，很快你就得到了答案，在<code>settings.json</code>加入以下設定：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;python.sortImports.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;--src=$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>不過上面是以前的做法，<a href="https://blog.kyomind.tw/isort/">現在 isort 有獨立套件</a>，所以應該用下面的設定：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;isort.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;--src=$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><hr><h2 id="pyproject-toml-與-pre-commit-設定"><a href="#pyproject-toml-與-pre-commit-設定" class="headerlink" title="pyproject.toml 與 pre-commit 設定"></a>pyproject.toml 與 pre-commit 設定</h2><p>在有了 pre-commit 以後，僅設定 VS Code 是不夠的。因為即使 IDE 格式化的結果正確，若未設定 pre-commit 的 isort hook，仍可能受到阻擋，造成衝突。</p><p>另外，在團隊開發時，使用<code>pyproject.toml</code>來設定 isort 參數，明顯比所有成員各自設定其自己的 VS Code 更加可行。</p><p>所以我們需要設定前述二者的 isort 參數。</p><p>不過，仔細想想，顯然<code>pyproject.toml</code>和 pre-commit 的 isort 設定，不會是上述的<code>settings.json</code>的照抄。因為它們根本不知道<code>$&#123;workspaceFolder&#125;</code>是什麼。</p><p>想必有別的做法。</p><h3 id="pyproject-toml"><a href="#pyproject-toml" class="headerlink" title="pyproject.toml"></a>pyproject.toml</h3><p>設定如下，使用<code>src_paths = [&quot;.&quot;]</code>。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.isort]</span></span><br><span class="line"><span class="attr">line_length</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">src_paths</span> = [<span class="string">&quot;.&quot;</span>] <span class="comment"># &lt;--- 這裡</span></span><br></pre></td></tr></table></figure><h3 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h3><p><code>.pre-commit-config.yaml</code>設定如下，使用<code>--src=.</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/isort</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.11</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--line-length=100</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--src=.</span> <span class="comment"># &lt;--- 這裡</span></span><br></pre></td></tr></table></figure><p>基本上都是用「<code>.</code>」來代表專案根目錄。</p><h2 id="附帶一提"><a href="#附帶一提" class="headerlink" title="附帶一提"></a>附帶一提</h2><p>值得注意的是，如果 VS Code 有設定 isort，那這個設定將<strong>優先於<code>pyproject.toml</code>。</strong>這樣的邏輯我不太能理解，因為理論上愈小範圍應該要優先適用才對。讀者使用時，可留意一下兩者的設定是否存在衝突。</p><p>我自己平常都是透過<code>settings.json</code>設定 isort，至於<code>pyproject.toml</code>，則是給團隊其餘沒有設定 VS Code 的人使用的。</p><p>不過，總的來說，團隊協作還是盡可能透過「<strong>專案設定檔</strong>」如<code>pyproject.toml</code>來設定這些工具的參數會比較妥當。一旦有變動，也能在 Git 同步後，全體立即適用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/M6eKHe9.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pycqa.github.io/isort/&quot;&gt;isort&lt;/a&gt; 是一個 Python 套件兼命令列工具，可以幫開發者自動排序 Python imports，以符合 &lt;a href=&quot;https://peps.python.org/pep-0008/#imports&quot;&gt;PEP 8 規範&lt;/a&gt;。這種排序也可以讓程式碼更加易讀且易於維護。&lt;/p&gt;
&lt;p&gt;之前已有數篇文章介紹過，可參考本站的「&lt;a href=&quot;/tags/isort/&quot;&gt;isort 標籤頁&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;isort 會自動將 import 分為「&lt;strong&gt;Python 標準函式庫&lt;/strong&gt;」、「&lt;strong&gt;第三方套件&lt;/strong&gt;」、「&lt;strong&gt;本地模組&lt;/strong&gt;」等三大區塊，並依&lt;strong&gt;字母順序&lt;/strong&gt;排列，同時為你在三個區塊之間&lt;strong&gt;空一行&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;isort-本地模組排序錯誤&quot;&gt;&lt;a href=&quot;#isort-本地模組排序錯誤&quot; class=&quot;headerlink&quot; title=&quot;isort 本地模組排序錯誤&quot;&gt;&lt;/a&gt;isort 本地模組排序錯誤&lt;/h2&gt;&lt;p&gt;isort 有一個 bug（我也不確定是不是 bug），就是&lt;strong&gt;對於本地模組的「排序判斷」，有可能發生錯誤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這會造成什麼結果？通常的影響是，&lt;strong&gt;本來應該排在第三區塊的 import，排到第二區塊去了。&lt;/strong&gt;總之就是 import 放錯了區塊。&lt;/p&gt;
&lt;p&gt;這樣除了不符合 PEP 8 規範，更重要的是，它還可能對開發者造成「&lt;strong&gt;誤導&lt;/strong&gt;」。而且會使用 isort 的人，往往就是在乎 import 排序的人，當然不能接受這樣的錯誤。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="VS Code" scheme="https://blog.kyomind.tw/tags/VS-Code/"/>
    
    <category term="isort" scheme="https://blog.kyomind.tw/tags/isort/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>17，AI 時代的生存指南（一）：我對 AI 工具的投入與觀望</title>
    <link href="https://blog.kyomind.tw/weekly-review-17/"/>
    <id>https://blog.kyomind.tw/weekly-review-17/</id>
    <published>2023-05-06T21:03:18.000Z</published>
    <updated>2023-06-22T05:50:06.357Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>相信大家在 2023 的上半年都被 AI 相關資訊狂轟濫炸到有點厭世了。</p><p>從去年 11 月底 ChatGPT 發布以來，我們都知道，這個世界發生了天翻地覆的改變。</p><p>有人因此賺到快錢，有人想法得到了實現，而更多人如你我，則是在這波浪潮的後方，苦苦追趕，擔心跟不上時代，或失去了自身價值。</p><p>藉著大眾對於 AI 資訊的焦慮與渴求，線上知識平台紛紛推出了相關課程。有些你我從未聽聞的人，也說要開課教你學 AI。甚至連 3C 產品評測網站、信用卡優惠資訊部落格等等，也開始發表 AI 工具介紹文章。</p><p>此時此刻，AI 就是風口，就是流量密碼。</p><p>「<strong>資訊焦慮</strong>」一詞並非 ChatGPT 時代所獨有，早在此前就已存在。但隨著 GPT 時代的到來，焦慮感無疑加劇了，因為我們面對的資訊量比以往更加龐大、更加複雜。</p><p>太辛苦了。</p><span id="more"></span><h3 id="系列：AI-時代的生存指南"><a href="#系列：AI-時代的生存指南" class="headerlink" title="系列：AI 時代的生存指南"></a>系列：AI 時代的生存指南</h3><blockquote><ol><li><strong>AI 時代的生存指南（一）：我對 AI 工具的投入與觀望</strong></li><li><a href="https://blog.kyomind.tw/weekly-review-19/">AI 時代的生存指南（二）：數位斷捨離</a></li></ol></blockquote><hr><h2 id="AI-時代的生存指南"><a href="#AI-時代的生存指南" class="headerlink" title="AI 時代的生存指南"></a>AI 時代的生存指南</h2><p>從標題的「一」可知，這又是一個系列，和其它系列不同的是：它是「不定期」的，我也不知道會寫到第幾回，但從目前的規劃來看，至少會有 5 回。</p><p>我期望這系列和一般談論 AI 文章的一個核心差別是：<strong>它們主要用來「降低」AI 資訊焦慮，而非增加。</strong></p><p>更具體地說，這個系列是「<strong>我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄</strong>」，這樣才有趣。</p><p>我曾在<a href="https://www.facebook.com/kyomind/posts/pfbid06EdjLvXpAgNhKrRK3K7KHabAtm5vHa5AFJNqximxcNBVmrSF4gMMpkTSU5CMAqUGl">這篇臉書貼文</a>中如此說道：</p><blockquote><p>平心而論，ChatGPT 等大批 AI 工具到目前為止，仍只是讓我覺得：以前重要的事，現在更重要了；以前不重要的事，現在「真的」一點也不重要了——跟 AI 比「<a href="https://zh.wikipedia.org/zh-tw/%E5%B0%9D%E8%AF%95%E9%94%99%E8%AF%AF%E6%B3%95">試誤</a>」，猶如跟車子比速度</p></blockquote><p>雖然沒有言明，但這段文字的其中一個立場是：<strong>努力追趕這些 AI 浪潮（新工具、新資訊），恐怕不是特別有效的做法</strong>。至少就降低資訊焦慮而言，往往<strong>適得其反</strong>。</p><p>追趕？這不是我喜歡的方式，更不是我擅長的手段。</p><p>而這個系列，一言以蔽之，就是要談談：「<strong>不追趕，那我打算怎麼辦？</strong>」——這是我寫給自己的「<strong>AI 時代的生存指南</strong>」。</p><h2 id="本期重點：AI-工具"><a href="#本期重點：AI-工具" class="headerlink" title="本期重點：AI 工具"></a>本期重點：AI 工具</h2><p>雖然是和 AI 有關的系列，<strong>但我並不會每篇都緊扣著 AI 這個主題</strong>——這類內容我們看得還不夠多嗎？相反地，我會從自己的經驗出發，分享我在 AI 時代的「<strong>對策與行動</strong>」。</p><p>所以重點是這些「<strong>行動</strong>」，而不是 AI 本身。</p><p>儘管如此，第一期我們仍然需要先談談 AI 工具，以及我對這些工具的基本看法，因為這是所有 AI 焦慮的根源。直接跳過的話，未免顯得有點不食人間煙火。</p><p>好，了解這些已經足夠，讓我們開始吧！</p><hr><h2 id="作為一個軟體工程師，我別無選擇要關注-AI"><a href="#作為一個軟體工程師，我別無選擇要關注-AI" class="headerlink" title="作為一個軟體工程師，我別無選擇要關注 AI"></a>作為一個軟體工程師，我別無選擇要關注 AI</h2><p>早在 ChatGPT 問世前，微軟的 <a href="https://github.com/features/copilot">GitHub Copilot</a> 就已經秀過一波「AI 寫扣」的威力與潛力，引起了相當的討論，更帶出了 AI 悲觀派和樂觀派。</p><p>悲觀派認為 AI 將取代人類的工作，但樂觀派則相信 AI 將為我們帶來更多的創造力和效率。</p><p>我算是偏悲觀的那一方XD，而且我覺得，AI 也真的很適合寫 code。程式碼有大量的訓練資源（姑且不論資料品質），而且在大多程式開發的情境，關於「怎麼做才對」這件事，往往都有答案——儘管答案很可能不止一個。</p><p>因此，作為一個軟體工程師，我別無選擇地，必須關注 AI 技術的發展和應用——我擔心自己中年失業。</p><p>而第 6 期的〈<a href="https://blog.kyomind.tw/weekly-review-06/">06，十年後，還能繼續當軟體工程師嗎？</a>〉，正是對這份焦慮的記錄與回應。</p><h2 id="AI-工具確實很有幫助"><a href="#AI-工具確實很有幫助" class="headerlink" title="AI 工具確實很有幫助"></a>AI 工具確實很有幫助</h2><p>前陣子去健身的時候，我突然想到：「健身教練這份工作好像不太受到 ChatGPT 的衝擊耶！」對此，不禁有點羨慕🥹</p><p>可是，反過來思考：受到的影響很小，其實就意味著，該技術的出現，對於這個行業，<strong>並沒有顯著與實質的改變</strong>——沒有加速從業者工作上的效率。</p><blockquote><p>那就太可惜了！</p></blockquote><p>畢竟，我們這些上班族、打工仔，這麼擔心被 AI 取代，正是因為它在很多方面都大大地加速了我們原本做事的效率——讓人感覺自己好像不再重要。</p><p>作為受雇者，心情上可能是既高興（省下好多時間）又擔心（失業）。但作為一個人，我是覺得超讚的啦！難道有誰喜歡做那些重複又枯燥的工作？</p><h2 id="我目前使用中的-AI-工具"><a href="#我目前使用中的-AI-工具" class="headerlink" title="我目前使用中的 AI 工具"></a>我目前使用中的 AI 工具</h2><p>其實就只有 ChatGPT 和 GitHub Copilot——兩者的<strong>大目標</strong>都是為了<strong>寫好程式</strong>！🤗</p><p>Notion AI 用過又退了，理由已如前述：〈<a href="https://blog.kyomind.tw/weekly-review-15/">15，付費一個月後，我還是退訂了 Notion AI</a>〉。</p><p>另一個本來很有興趣但一直沒有投入時間的，是 <a href="https://www.midjourney.com/">Midjourney</a>。主要的學習動機是幫文章製作封面圖，但顯然這個需求還算不上十分強烈。</p><p>而且，自己下提示詞產生封面圖片，固然很有成就感，也稱得上獨一無二。但花費的時間，未必比去 Pixabay 找一張美美的照片來得少。</p><p>考慮到<strong>文章的本質還是文字本身</strong>，加上我寫作的速度已經很慢了，不適合再花額外時間去掙扎封面的創作美感與切題與否，想想還是暫時擱置一旁。</p><p>除了以上提到的 4 項 AI 工具，其餘的我都是看看而已。即便是吸收新知，也是圍繞在「如何更好地使用 ChatGPT」這個主軸上。</p><h2 id="我怎麼面對海量的-AI-資訊？"><a href="#我怎麼面對海量的-AI-資訊？" class="headerlink" title="我怎麼面對海量的 AI 資訊？"></a>我怎麼面對海量的 AI 資訊？</h2><p>好，哪怕你跟我一樣，平常只用 ChatGPT，可能依舊很容易感到<strong>資訊過載</strong>——因為還是很多啊！</p><p>OpenAI 動不動就宣布 ChatGPT 新功能，加上各種民間外掛、各種提示詞大全，甚至研究論文和技術文獻等等，真的好煩XD。</p><p>作為一個 ChatGPT 重度使用者，我也難免汲汲營營、眼花撩亂。</p><p>我目前歸納出的「<strong>減壓</strong>」做法是——<strong>主動減少接觸這些資訊</strong>！當然，「主動減少接觸相關資訊」這類手段，都有一個共同的擔憂：<strong>害怕錯失</strong>，也就是 <strong>FOMO</strong>。</p><p>類似的情況也出現在〈<a href="https://blog.kyomind.tw/weekly-review-11/">11，我絕不當資訊的聚合者</a>〉所討論的「<strong>資訊聚合</strong>」議題。</p><h3 id="事可過三"><a href="#事可過三" class="headerlink" title="事可過三"></a>事可過三</h3><p>我的看法是，真正重要且實用的功能，你在上述「 3C 產品評測網站、信用卡優惠資訊部落格」其實都會一再看到喔XD！因為有話題、有流量嘛！</p><p>意思就是說，如果一個東西（比如某個 ChatGPT 的新 Chrome Extension）在這些網站<strong>反覆出現達 3 次</strong>，我才可能會開始關注它。</p><blockquote><p>這樣真的好嗎？</p></blockquote><p>事實證明，ChatGPT 瀏覽器外掛百百款，我自己也試過好些。<strong>但目前為止，唯一留下且持續在使用的，只有一個</strong>：<a href="https://sharegpt.com/">ShareGPT</a>。</p><p>那些宣稱能夠讓 ChatGPT 變得十倍、百倍強大的瀏覽器外掛，對我而言，<strong>其價值都遠遠不如能幫我輕鬆留下「和 ChatGPT 重要對話」的 ShareGPT</strong>。</p><p>在我的 Logseq 筆記裡，有超多與 ChatGPT 的對話XD——女友看了都要吃醋🤣</p><p><img src="https://i.imgur.com/5ysqLCT.png" alt="與 ChatGPT 的對話集"><span class="cap">與 ChatGPT 的對話集</span></p><hr><h2 id="結語：拼命追趕，也是枉然"><a href="#結語：拼命追趕，也是枉然" class="headerlink" title="結語：拼命追趕，也是枉然"></a>結語：拼命追趕，也是枉然</h2><p>最後，我想再次強調我在<a href="https://www.facebook.com/kyomind/posts/pfbid0mkCP8W1XRG1226wVqi7FaPrB7URTJQS88mw1U2FtbJ2tu4FKfZx1o9fLiAwkutJcl?fbclid=IwAR0rHgVsKY0AzSAiZVmatU-A2MHcZscyvuk7mORauRlRg4LChlz06u1UK_k">這篇臉書貼文</a>中所表達的：<strong>我對 AI 工具的整體看法</strong>。</p><p>提示詞也好，瀏覽器外掛也罷，都是很容易產品化的東西。<strong>不用太在意</strong>自己是否已精通了各類提示詞技巧，凡此種種，在不久的將來，都會由機器為你服務。</p><p>作為一個人，我們不需要拼命追趕，因為追不上，也趕不及。</p><p>我使用 ChatGPT <strong>最滿足的時刻</strong>，莫過於對它提出了深刻的問題（通常也很尖銳、帶有挑戰與批判意味），然後它回了我一個出乎意料或令人讚嘆的答案。</p><p>當下真的只能用「<strong>感動</strong>」來形容——好慶幸自己活在有 GPT 的時代。</p><p>這些問題的<strong>核心價值</strong>不在於高超的提示詞技巧，而在於<strong>激發我們進行更深層次的思考</strong>。</p><p>在 AI 時代，這或許是我身為平凡人類，少數擁有的不平凡時刻。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;相信大家在 2023 的上半年都被 AI 相關資訊狂轟濫炸到有點厭世了。&lt;/p&gt;
&lt;p&gt;從去年 11 月底 ChatGPT 發布以來，我們都知道，這個世界發生了天翻地覆的改變。&lt;/p&gt;
&lt;p&gt;有人因此賺到快錢，有人想法得到了實現，而更多人如你我，則是在這波浪潮的後方，苦苦追趕，擔心跟不上時代，或失去了自身價值。&lt;/p&gt;
&lt;p&gt;藉著大眾對於 AI 資訊的焦慮與渴求，線上知識平台紛紛推出了相關課程。有些你我從未聽聞的人，也說要開課教你學 AI。甚至連 3C 產品評測網站、信用卡優惠資訊部落格等等，也開始發表 AI 工具介紹文章。&lt;/p&gt;
&lt;p&gt;此時此刻，AI 就是風口，就是流量密碼。&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;資訊焦慮&lt;/strong&gt;」一詞並非 ChatGPT 時代所獨有，早在此前就已存在。但隨著 GPT 時代的到來，焦慮感無疑加劇了，因為我們面對的資訊量比以往更加龐大、更加複雜。&lt;/p&gt;
&lt;p&gt;太辛苦了。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Notion AI" scheme="https://blog.kyomind.tw/tags/Notion-AI/"/>
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
    <category term="資訊焦慮" scheme="https://blog.kyomind.tw/tags/%E8%B3%87%E8%A8%8A%E7%84%A6%E6%85%AE/"/>
    
  </entry>
  
  <entry>
    <title>pre-commit 設定 Git Hooks 教學：以 Flake8、isort、yapf 為例</title>
    <link href="https://blog.kyomind.tw/pre-commit/"/>
    <id>https://blog.kyomind.tw/pre-commit/</id>
    <published>2023-04-29T07:53:17.000Z</published>
    <updated>2023-05-11T17:14:58.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/HdNTdXP.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>這篇應該算是 Python Linter、Formatter 系列（嚴格來說並沒有這個系列，它們只是彼此相關）的最後一篇，有關「<a href="/tags/Code-Formatting/">Code Formatting</a>」這一主題的文章，之前已經寫了不少，依時間順序如下：</p><ol><li><a href="https://blog.kyomind.tw/flake8-and-isort/">Flake8 與 isort in VS Code</a></li><li><a href="https://blog.kyomind.tw/flake8-yapf-setting/">VS Code 設定 Python linter 與 formatter：以 Flake8、yapf 為例</a>（主要）</li><li><a href="https://blog.kyomind.tw/black-and-isort/">試用從 VS Code Python extension 拆分的 Black、isort 套件</a></li><li><a href="https://blog.kyomind.tw/pyproject-toml/">pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學</a></li><li><a href="https://blog.kyomind.tw/isort/">VS Code：Python isort 擴充套件介紹與簡易設定教學</a></li><li><a href="https://blog.kyomind.tw/flake8-and-black/">VS Code：Python Flake8 與 Black Formatter 擴充套件快速上手</a></li></ol><p>仔細一看，其實不就是 Flake8、yapf、isort、Black Formatter 這 4 項工具的排列組合而已嗎XD。</p><p>是的！我自己整理到都覺得有點不好意思了🫣。</p><p>但是，為什麼要寫這麼多？還是那句老話：「<strong>我認為這些工具的重要性，再怎麼強調也不為過——更別說它們常常被低估了。</strong>」</p><p>我曾在上述文章中的開頭或結尾處，不厭其煩地表達自己對它們的重視，這裡就不再贅述，直接進入重點。</p><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>在這篇文章中，我們將講述如何使用 pre-commit 設定 Git Hooks，並以 Flake8、isort、yapf 為例來進行演示，同時提醒一些注意事項。</p><p>如同 Poetry，pre-commit 也是我在工作上，強烈希望導入的工具——畢竟它可以有效降低我 code review 時血壓升高的次數☺️</p><span id="more"></span><h2 id="本文架構"><a href="#本文架構" class="headerlink" title="本文架構"></a>本文架構</h2><p>我們會先講一下什麼是 Git Hooks 和 pre-commit，因為不是論述上的重點，所以只需簡單帶過，讀者心中有個輪廓即可。</p><p>接著探討「<strong>為什麼要使用 pre-commit 工具？</strong>」。和我過去的許多文章一樣，對動機與場景將有一定程度的著墨，我們會探討 pre-commit 的價值所在，包括我從團隊使用經驗得到的看法。</p><p>最後是具體設定——這或許是最不重要的部分，因為它很簡單，但還是有一些值得留意的部分。以 Flake8、isort、yapf 為例，則是為了貫徹前述所有文章的一貫精神：<strong>有了 pre-commit，這一切才算圓滿。</strong></p><p>附帶一提，考慮到「pre-commit」這個主題已經有數篇文章珠玉在前（參考文章我會放在文末），我下筆前都已拜讀完。本文的論述重點會<strong>盡可能與這些文章錯開，或乾脆直接引用</strong>，以降低不必要的重複感。</p><hr><h2 id="Git-Hooks-介紹"><a href="#Git-Hooks-介紹" class="headerlink" title="Git Hooks 介紹"></a>Git Hooks 介紹</h2><p>Git Hooks 是 Git 提供的一個功能，允許開發者在特定的 Git 事件（如 commit、push 等）觸發時，自動執行自定義的腳本，這樣可以在提交程式碼之前進行一些檢查，以確保程式碼的交付品質。</p><p><a href="https://git-scm.com/book/zh-tw/v2/Customizing-Git-Git-Hooks">Git Hooks 有很多種</a>，不同的 Git Hooks 可以幫助開發者在不同的場景下進行自動化操作，這裡我們只要知曉<strong>最常用的 pre-commit hook</strong> 已足。</p><p>顧名思義，pre-commit hook 會在你使用<code>git commit</code>命令時觸發，讓機器依照你的 hook 腳本內容，在 commit 前對程式碼進行檢查。</p><p>事實上，你可以用任何語言來撰寫 hook 腳本，只要編寫的腳本能夠在系統上被執行，而且符合 Git hook 的腳本格式，就可以使用。</p><p>開發者只需要在<code>.git/hooks</code>目錄下建立相對應的 hook（命名必須遵守規則），依照 Git Hooks 的 API 規範，編寫自己需要的處理邏輯即可。</p><p>但我們才不會這麼做！因為我們有工具嘛！</p><h2 id="Git-Hooks-管理工具介紹"><a href="#Git-Hooks-管理工具介紹" class="headerlink" title="Git Hooks 管理工具介紹"></a>Git Hooks 管理工具介紹</h2><p>即使你會寫 shell script，也不一定想自己手刻一個 hook 腳本，所幸這麼常見的需求，自然有許多開源的工具可以使用，而 pre-commit 就是其中的佼佼者——只能說這個套件的命名非常簡單暴力！🤣</p><p><a href="https://pre-commit.com/">pre-commit</a> 是由 Python 所寫成的 Git Hooks 管理工具，但可以適用於各類程式語言專案，包括 Python、JavaScript、Ruby、Java、Go 等。使用者可以根據自己的需求，選擇要使用的 hook。</p><p>類似的工具還有 <a href="https://github.com/typicode/husky">husky</a>、<a href="https://github.com/sds/overcommit">overcommit</a> 等等。不過作為 Python 開發者，我們當然還是選擇 pre-commit 囉！</p><p>雖然叫 pre-commit，但實際上它可以管理全部種類的 Git Hooks，比如<code>pre-push</code>、<code>post-merge</code>等等，管理 pre-commit hook 只是其中最常見的用途而已，我想這應該不至於造成誤會。</p><hr><h2 id="為什麼要使用-pre-commit？"><a href="#為什麼要使用-pre-commit？" class="headerlink" title="為什麼要使用 pre-commit？"></a>為什麼要使用 pre-commit？</h2><p>這個問題可以分為<strong>兩個層次</strong>：</p><ol><li>為什麼要使用 pre-commit hook？</li><li>為什麼要使用 Git Hooks 自動化工具？</li></ol><p>這兩個問題有先後關係，先有 1 才有 2。不過 2 的理由比較簡單，所以我們先講 2 再講 1。</p><h3 id="為什麼要使用自動化工具來管理-Git-Hooks？"><a href="#為什麼要使用自動化工具來管理-Git-Hooks？" class="headerlink" title="為什麼要使用自動化工具來管理 Git Hooks？"></a>為什麼要使用自動化工具來管理 Git Hooks？</h3><p>除了和〈<a href="https://blog.kyomind.tw/yadm/">是時候同步你的 dotfiles 了——我選擇 yadm</a>〉一樣：<strong>因為這個方式更加輕鬆</strong>以外。更關鍵的是，透過工具你可以像堆樂高積木般，輕鬆組合各式套件所提供的現成 hook，比如本文的 Flake8，這顯然比自己寫 shell 要高效得多。</p><p>所以比起管理 dotfiles，直接透過工具來管理 Git Hooks，應該是絕大多數人<strong>自然而然的選擇</strong>。</p><h3 id="為什麼要使用-pre-commit-hook？"><a href="#為什麼要使用-pre-commit-hook？" class="headerlink" title="為什麼要使用 pre-commit hook？"></a>為什麼要使用 pre-commit hook？</h3><p>在〈<a href="https://www.mropengate.com/2019/08/pre-commit-git-hooks_4.html?m=1">提升程式碼品質：使用 Pre-Commit (Git Hooks)</a>〉一文中，作者提出了三點，闡述為何要使用 pre-commit hook，理由充分且令人信服，請容我直接引用：</p><blockquote><ul><li>自動化檢查程式碼排版規範快速又有效率（如 python PEP8）</li><li>低級的問題不會進到 code review<ul><li>多一點時間檢查程式邏輯，而不是基本錯誤（如排版）。</li><li>人工檢查程式碼的時間很寶貴，減少人工即是增進效率。</li></ul></li><li>低級的問題不會進到 CI&#x2F;CD pipeline<ul><li>pipeline 應該多一點綠勾勾，而不是滿滿 debug 的痕跡。</li></ul></li></ul></blockquote><h3 id="我的關注點"><a href="#我的關注點" class="headerlink" title="我的關注點"></a>我的關注點</h3><p>此外，我在臉書社團「Backend 台灣 (Backend Tw)」<a href="https://www.facebook.com/groups/backendtw/permalink/2934392300027960">這篇文章</a>的回應中，也表達了自己的看法，這裡只節錄最後兩段：</p><blockquote><p>上面的情況其實都在說：「linter已經提醒有問題，但formatter無法正常格式化」，細心的人會停下來排除問題或討論，但人難免都有粗心的時候，偶爾還是忽略且commit了</p></blockquote><blockquote><p>負責 review 的人看到這種格式類的錯誤，心裡難免會有點無言，但又不好直接怪隊友，畢竟對方也不是「故意」的，此時有機器幫彼此擋一下，也算是團隊協作的潤化劑</p></blockquote><p>是的，我最大的著眼點在於：「<strong>減少團隊協作時，不必要的磨擦（精神消耗）。</strong>」</p><p>個人認為這真的很重要，畢竟我們不是機器，都有情緒，而情緒應該要用在更有價值的地方。</p><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>總的來說，如果你問我「為何要使用 pre-commit？」從個人角度看，我已視之為理所當然，畢竟我都寫了 6 篇相關文章了。</p><p>而 pre-commit 則是我們的<strong>最後一塊拼圖</strong>，它更進一步確保了 linter 和 formatter 的檢查，在 commit 之際，能被<strong>完全落實</strong>。</p><p>而從團隊的角度，則是因為「這樣對大家都好！」</p><hr><h2 id="pre-commit-基本設定"><a href="#pre-commit-基本設定" class="headerlink" title="pre-commit 基本設定"></a>pre-commit 基本設定</h2><p>安裝 pre-commit 應該不必解釋，<code>poetry add pre-commit</code>或<code>pip install pre-commit</code>任君挑選。macOS 也可以用<code>brew install pre-commit</code>全域安裝，但如此一來它就不會在專案虛擬環境中。</p><h3 id="pre-commit-config-yaml"><a href="#pre-commit-config-yaml" class="headerlink" title=".pre-commit-config.yaml"></a>.pre-commit-config.yaml</h3><p>接著是關於<code>.pre-commit-config.yaml</code>的編輯，請將此檔案建立於專案的根目錄，pre-commit 就是透過這份設定檔，實現各項 hook 內容。</p><p>一般而言，<code>.pre-commit-config.yaml</code>會長這樣：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pre-commit/pre-commit-hooks</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v4.3.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trailing-whitespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-added-large-files</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/flake8</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.0</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">flake8</span></span><br></pre></td></tr></table></figure><p>最上面是<a href="https://github.com/pre-commit/pre-commit-hooks#hooks-available">由 pre-commit 專案提供的基本 hooks</a>。剩下的部分則是其它開源專案所提供的 hook。</p><p><code>yaml</code>檔中的<code>repo</code>、<code>rev</code>、<code>hooks</code>、<code>id</code>等設定，直接看<a href="https://pre-commit.com/#pre-commit-configyaml---repos">文件</a>就知道意思了。</p><h3 id="設定上重點"><a href="#設定上重點" class="headerlink" title="設定上重點"></a>設定上重點</h3><p>對於第一次接觸 pre-commit 的人而言，這裡會有的<strong>最大疑問</strong>應該是：「啊我怎麼知道我可以用哪些 hook？我又怎麼知道這些 hook 的 repo 網址？」</p><p>沒錯，這是關鍵所在，<a href="https://pre-commit.com/hooks.html">這個網頁</a>有目前全部可用的 hook 清單，上面如果沒有列出你想用的工具，那就是暫不支援囉！</p><p>至於<code>rev</code>的具體版本號（總不能自己瞎編一個），repo 網頁的「tags」頁面就會有，比如這是 <a href="https://github.com/PyCQA/flake8/tags">Flake8 的 tags 頁面</a>。</p><p>值得留意的是：有些 hook 的 tag 有「<code>v</code>」開頭，有些則否（上述 Flake8 就沒有）。這主要取決於各專案開發者的 tag 命名習慣，我們只要留意一下即可。</p><p>知道這些，基本上就能設定好<code>.pre-commit-config.yaml</code>了。</p><h2 id="pre-commit-設定-Flake8、isort、yapf"><a href="#pre-commit-設定-Flake8、isort、yapf" class="headerlink" title="pre-commit 設定 Flake8、isort、yapf"></a>pre-commit 設定 Flake8、isort、yapf</h2><p>又到了整個「系列」都不斷重複、重複、再重複的幾樣工具😎</p><h3 id="Flake8"><a href="#Flake8" class="headerlink" title="Flake8"></a>Flake8</h3><p>直接看設定檔：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/flake8</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.0</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">flake8</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--max-line-length=100</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--ignore=E131,E126,E402</span></span><br></pre></td></tr></table></figure><p><code>hooks</code>設定下所有可以用的子項目，<a href="https://pre-commit.com/#pre-commit-configyaml---hooks">上述的頁面</a>已有說明。</p><p>這只需要提醒一件事：那就是<code>args</code>的設定內容<strong>務必和編輯器（比如 VS Code）的設定一致。</strong></p><p>換句話說，我 VS Code 的<code>settings.py</code>也有一樣的設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;flake8.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;--max-line-length=100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--ignore=E131,E126,E402&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>如果兩者的設定有衝突，會造成適用上的<strong>混淆</strong>，這是我們不想看到的。</p><h3 id="isort"><a href="#isort" class="headerlink" title="isort"></a>isort</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/isort</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.11</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--line-length=100</span></span><br></pre></td></tr></table></figure><p>一樣特別注意<code>args</code>，尤其像 isort、yapf 這類「<strong>formatter</strong>」，設定不一致會直接造成「在編輯器中格式化符合規範，但 commit 時卻被 hook 擋下來」的<strong>窘境</strong>。</p><h3 id="yapf"><a href="#yapf" class="headerlink" title="yapf"></a>yapf</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pre-commit/mirrors-yapf</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v0.32.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">yapf</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">column_limit</span> <span class="string">=</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">additional_dependencies:</span> [<span class="string">toml</span>]</span><br></pre></td></tr></table></figure><p>yapf 有一個<a href="https://blog.kyomind.tw/pyproject-toml/#VS-Code-%E6%95%B4%E5%90%88%E6%99%82%E5%8F%AF%E8%83%BD%E7%9A%84-bug">很常見的問題</a>，之前在〈<a href="https://blog.kyomind.tw/pyproject-toml/">pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學</a>〉中已提過。</p><p>簡言之，只要你的專案中有<code>pyproject.toml</code>，無論裡面是否有關於 yapf 的設定項，yapf 都會試圖去解析（parse）它，此時<code>toml</code>套件就成了必不可少的一環。如果沒有<code>toml</code>，將進一步導致 yapf 無法正常運作。</p><p>這個問題在 pre-commit 同樣會發生，所以如果專案中有<code>pyproject.toml</code>，就要額外設定<code>additional_dependencies: [toml]</code>，方能功德圓滿🙏</p><hr><h2 id="最後一哩"><a href="#最後一哩" class="headerlink" title="最後一哩"></a>最後一哩</h2><p>附上完整的<code>.pre-commit-config.yaml</code>供參：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pre-commit/pre-commit-hooks</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v4.3.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trailing-whitespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-added-large-files</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-ast</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-case-conflict</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-toml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-yaml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">end-of-file-fixer</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/flake8</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.0</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">flake8</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--max-line-length=100</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--ignore=E131</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/isort</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.11</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--line-length=100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pre-commit/mirrors-yapf</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v0.32.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">yapf</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">column_limit</span> <span class="string">=</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">additional_dependencies:</span> [<span class="string">toml</span>]</span><br></pre></td></tr></table></figure><p>還有一件想當然爾但依舊必須提醒的事，即 hook 使用的<code>rev</code>版本，要和你專案裡使用的工具的版本一致。比如上述設定檔中我的 Flake8 是<code>5.0.4</code>版，那虛擬環境裡安裝的<code>flake8</code>自然也是<code>5.0.4</code>，而不會是其它版本。</p><p>安裝完 pre-commit 並建立好<code>.pre-commit-config.yaml</code>後，<strong>事情還沒有結束！</strong>此時專案中的<code>.git/hooks</code>目錄下，依舊是預設時的模樣：只有一大堆 sample 檔。</p><h3 id="pre-commit-install"><a href="#pre-commit-install" class="headerlink" title="pre-commit install"></a>pre-commit install</h3><p>我們還差一個動作——將<code>.pre-commit-config.yaml</code>轉譯為 hook 腳本，才能真正發揮它的功用。當然，這會由工具代勞，我們只需要下指令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-commit install</span><br></pre></td></tr></table></figure><p>下指令前<strong>請先確定虛擬環境已經開啟</strong>，不然可能會找不到<code>pre-commit</code>這個執行檔——除非你是全域安裝。</p><p>這個指令還有相關參數可以使用，有興趣可參考<a href="https://pre-commit.com/#pre-commit-install">文件</a>。不過在絕大多數情況下，這樣就已經足夠。</p><h3 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h3><ul><li><a href="https://myapollo.com.tw/blog/pre-commit-the-best-friend-before-commit/">用 pre-commit 輕鬆提升程式碼品質</a></li><li><a href="https://www.mropengate.com/2019/08/pre-commit-git-hooks_4.html?m=1">提升程式碼品質：使用 Pre-Commit (Git Hooks)</a></li><li><a href="https://matthung0807.blogspot.com/2021/08/pre-commit-code-check.html">使用pre-commit做commit前檢查</a></li><li><a href="https://www.freecodecamp.org/chinese/news/git-hooks-script/">手寫 git hooks 腳本（pre-commit、commit-msg）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/HdNTdXP.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;這篇應該算是 Python Linter、Formatter 系列（嚴格來說並沒有這個系列，它們只是彼此相關）的最後一篇，有關「&lt;a href=&quot;/tags/Code-Formatting/&quot;&gt;Code Formatting&lt;/a&gt;」這一主題的文章，之前已經寫了不少，依時間順序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/flake8-and-isort/&quot;&gt;Flake8 與 isort in VS Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/flake8-yapf-setting/&quot;&gt;VS Code 設定 Python linter 與 formatter：以 Flake8、yapf 為例&lt;/a&gt;（主要）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/black-and-isort/&quot;&gt;試用從 VS Code Python extension 拆分的 Black、isort 套件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/pyproject-toml/&quot;&gt;pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/isort/&quot;&gt;VS Code：Python isort 擴充套件介紹與簡易設定教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/flake8-and-black/&quot;&gt;VS Code：Python Flake8 與 Black Formatter 擴充套件快速上手&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;仔細一看，其實不就是 Flake8、yapf、isort、Black Formatter 這 4 項工具的排列組合而已嗎XD。&lt;/p&gt;
&lt;p&gt;是的！我自己整理到都覺得有點不好意思了🫣。&lt;/p&gt;
&lt;p&gt;但是，為什麼要寫這麼多？還是那句老話：「&lt;strong&gt;我認為這些工具的重要性，再怎麼強調也不為過——更別說它們常常被低估了。&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;我曾在上述文章中的開頭或結尾處，不厭其煩地表達自己對它們的重視，這裡就不再贅述，直接進入重點。&lt;/p&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;在這篇文章中，我們將講述如何使用 pre-commit 設定 Git Hooks，並以 Flake8、isort、yapf 為例來進行演示，同時提醒一些注意事項。&lt;/p&gt;
&lt;p&gt;如同 Poetry，pre-commit 也是我在工作上，強烈希望導入的工具——畢竟它可以有效降低我 code review 時血壓升高的次數☺️&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="isort" scheme="https://blog.kyomind.tw/tags/isort/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Flake8" scheme="https://blog.kyomind.tw/tags/Flake8/"/>
    
    <category term="yapf" scheme="https://blog.kyomind.tw/tags/yapf/"/>
    
    <category term="Git" scheme="https://blog.kyomind.tw/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>16，我的「價值觀層級」器物清單</title>
    <link href="https://blog.kyomind.tw/weekly-review-16/"/>
    <id>https://blog.kyomind.tw/weekly-review-16/</id>
    <published>2023-04-16T14:46:53.000Z</published>
    <updated>2023-04-18T09:06:18.555Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>〈<a href="https://blog.kyomind.tw/weekly-review-14/">14，小米 13 的兩大關鍵亮點，與那些「價值觀層級」的器物們</a>〉點出了所謂「價值觀層級」的「器物」，這期就來補完這個部分。</p><p>當然，無論是定義還是清單都是非常個人化的產物，僅供參考。</p><hr><h2 id="何謂「價值觀層級」？"><a href="#何謂「價值觀層級」？" class="headerlink" title="何謂「價值觀層級」？"></a>何謂「價值觀層級」？</h2><p>我們或許可以把喜愛或討厭特定人事物的<strong>程度</strong>，大致區分為「<strong>偏好</strong>」與「<strong>價值觀</strong>」。</p><p>兩者在好惡上，肯定具有「<strong>量</strong>」的差異，但顯然不止如此而己。</p><p>如果要再加上一個<strong>根本的區別</strong>，那或許是「<strong>難以忍受</strong>」——那些你難以忍受它不存在、存在的人事物，可能就稱得上價值觀層級的事物。而其餘的，就只能說是偏好。</p><p>比如，我就完全不能忍受，<a href="https://zh.wikipedia.org/zh-tw/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">命令列</a>（CLI，Command-Line Interface）的背景是白色的！淺色的可以，但白色就不行。</p><p>或更常見的「香菜之爭」，要說它對部分人而言，屬於價值觀層級的事物，或許也不為過。</p><span id="more"></span><h2 id="何謂價值觀層級的「器物」？"><a href="#何謂價值觀層級的「器物」？" class="headerlink" title="何謂價值觀層級的「器物」？"></a>何謂價值觀層級的「器物」？</h2><p>說是「器物」，意味著它無關人或事，而是指<strong>具體可以拿來使用的東西</strong>。</p><p>只不過這些東西，被主人賦與了強烈的偏好——即價值觀——達到了「如果失去它們，就會讓人很困擾」的程度。</p><p>當然，絕大部分的器物都是沒了可以再買，所以這裡指的「失去」，大概要限縮在「如果這東西停產了、從世界上消失了」的情況，才能凸顯它們的重要性。</p><h2 id="器物的進一步定義"><a href="#器物的進一步定義" class="headerlink" title="器物的進一步定義"></a>器物的進一步定義</h2><p>為了清晰表達，我們再為本文的「器物」一詞，描繪出更明確的輪廓。</p><p>首先，它可能是<strong>具體的產品</strong>，但也可能是一種產品的「<strong>類別</strong>」（比如「Mac 電腦」就是一個類別），有時候產品類別的重要性就已經達到價值觀層級，而具體是指該類別下的哪一項產品，則不是很緊要。</p><p>此外，我們這裡只論「產品」，而不論「<strong>特性（feature）</strong>」。</p><p>「特性」指的是產品或物品所具備的功能或屬性，例如一支筆的書寫功能、一個手機的通訊功能等等，屬性則是顏色、造型、材質等等。它們都屬於產品的一部分，所以僅論產品已足。</p><p>最後，「軟體服務」不算XD，因為算的話就太多了——望向 Notion 與 Logseq。並且這裡更想表達，那些「在現實世界佔據空間」的東西。</p><hr><h2 id="我的價觀值層級器物清單"><a href="#我的價觀值層級器物清單" class="headerlink" title="我的價觀值層級器物清單"></a>我的價觀值層級器物清單</h2><p>完整的鋪陳後，終於可以來一一介紹我目前心中的價觀值器物們，為了寫這篇，我也不得不認真思考了一下，哪些才稱得上？其實考慮的主要就兩個重點，必須兼而有之：</p><ol><li>細節做得比別人好。</li><li>有其不可替代的 feature。</li></ol><p>作為一個 3C 宅，你可能以為我要講的全都是 3C 產品，非也非也，畢竟我也是要生活的。且限於幅篇，就只講 5 項即可——它們已經有足夠的代表性。</p><p>廢話不多說，開始！</p><h2 id="一、類別：Mac-電腦"><a href="#一、類別：Mac-電腦" class="headerlink" title="一、類別：Mac 電腦"></a>一、類別：Mac 電腦</h2><p>Mac 電腦，包括 Macbook、Mac mini、iMac 等等，選擇哪一種 Mac 對我來只能算是「偏好」——在家我偏好 Mac mini，而出外偏好 Macbook Air。</p><p>那它的「不可取代性（價值觀）」在哪？我覺得有兩個方面：</p><ol><li>做工：很多人說 Mac 就像藝術品，對此我完全認同XD。昂貴的 Windows 筆電通常是透過「堆料」的結果，也就是硬體很強，但產品本身的溢價卻相對有限。</li><li>macOS：這裡特指「命令列」部分！它和 Linux 系出同源，減少了好些程式開發上的麻煩——畢竟我也用 Windows 寫過兩年程式，所以能體會其中的差距。</li></ol><p>毫無疑問，若 Mac 從世界上消失，身為一個開發者，我會很困擾。</p><h2 id="二、產品：Apple-Studio-Display"><a href="#二、產品：Apple-Studio-Display" class="headerlink" title="二、產品：Apple Studio Display"></a>二、產品：Apple Studio Display</h2><p>我使用它的時間還不到 2 個月，是否納入價值觀層級，確實有些猶豫，但我還是選了它。</p><p>很多時候，一個東西是否達到價值觀層級，要和它的競爭對手相比。</p><p>從這個角度看，在我心中，我認為它在台幣 5 萬元的範圍內，沒有對手。意思是，別的產品雖然更便宜，但體驗也因此打了折扣，而我認為它是 5 萬內，價格和體驗上的最佳平衡。</p><p>當然正常人是<strong>很難接受</strong>用這麼高的價格卻只買了一台螢幕，所以我還是補充一下，對我而言它不可或缺的特色：</p><ol><li><strong>抗反光鍍膜</strong>：如果只有一個理由，就是它了。鏡面螢幕的最佳解，誰用誰知道XD。</li><li>27 吋 5K 解析度：5K 和 4K 的像素數量還是有相當差距（比 4K 顯示器多出 67%），對於很常在螢幕上看文字（寫作）和程式碼的我而言，字體因解析度不足而產生的毛邊，是最最不可接受的一環。而 5K 的表現顯然比 4K 要好上一截。</li></ol><p>可以看出，目前提到的兩項，它們之所以可以達到「價值觀層級」，根本的原因都是因為：<a href="https://blog.kyomind.tw/weekly-review-02/#%E4%BA%8C%E3%80%81%E9%97%9C%E6%96%BC%E5%AF%AB%E7%A8%8B%E5%BC%8F%E5%88%B0-70-%E6%AD%B2%E7%9A%84%E6%83%B3%E5%83%8F">我是一個軟體工程師</a>。</p><h2 id="三、類別：升降桌"><a href="#三、類別：升降桌" class="headerlink" title="三、類別：升降桌"></a>三、類別：升降桌</h2><p>對於用過升降桌的人而言，大概不會懷疑為什麼它具有價值觀的層級。</p><p>但對於沒用過的人來說，還是有必要補充一下。</p><p>你最常聽到的可能是可以坐、站交錯類的彈性等等，但這不是最關鍵的，最關鍵的是它可以讓你選定一個最自己適合的高度（通常指的是坐著的高度）。</p><p>而要在茫茫桌海中找到一個剛好符合自己高度的桌子，難度就高非常多了。這也是為什麼我的 Studio Display 是 VESA 版——用來配合螢幕支架，自訂高度。</p><p>至於要選擇哪個品牌，在我看來只是偏好而非價值觀。</p><h2 id="四、產品：大甲乾麵麻醬口味"><a href="#四、產品：大甲乾麵麻醬口味" class="headerlink" title="四、產品：大甲乾麵麻醬口味"></a>四、產品：大甲乾麵麻醬口味</h2><p>這東西我在<a href="https://www.facebook.com/kyomind/posts/pfbid0ofMwWhhUft6fat8ut3krkwEDawovMzkPhv7ynMLE6md3E39vsdHc2rTa4R25p3kil">之前的臉書貼文</a>就已經大書特書過，再次總結一下它的重要性。</p><p>作為一個在家工作的軟體工程師，中午常常不想出門——因為要換衣服捏！而且有時候會中斷思緒。而大甲乾麵就是能讓我<strong>平日中午盡量不必出門</strong>的利器。那它的特色與不可取代性又在哪？</p><ol><li>特色：麻醬口味還挺耐吃的（其餘口味建議不要嘗試）。</li><li>不可取代性：文中有提及，就是鈉含量相對很低，這點已屬難能可貴。真要說的話，便宜也是一大特色。全聯有賣！</li></ol><p>但不知為何，從今年 2 月開始，線上購物通路的價格竟直接翻倍，毫無競爭力。所幸全聯還是以前的價格（非特價期間一袋 4 包 119 元，特價通常是 99 元）。</p><p>而且之前還有買一送一！你知道我因此囤了幾袋嗎？——12 袋🤣</p><h2 id="五、產品：詹粉"><a href="#五、產品：詹粉" class="headerlink" title="五、產品：詹粉"></a>五、產品：詹粉</h2><p>搭配前述大甲乾麵的利器！</p><p>同一樣食物，你常吃就容易膩，這是人之常情，更別說大甲乾麵麻醬口味的調味，相對也屬平淡。</p><p>我有試著買一些別的調味料，但加分的效果都很有限——直到我遇見了詹粉！愈講愈像業配了。</p><p>從結論上來說，有了詹粉以後，大甲乾麵簡直如虎添翼。上個月有 31 天，而從 Logseq 的記錄上看，我足足吃了 17 次大甲乾麵XD</p><p>這其中有一半的「功勞」要歸於詹粉，它讓它變得更好吃惹。</p><hr><h2 id="結語：器物價值反映的是人的追求"><a href="#結語：器物價值反映的是人的追求" class="headerlink" title="結語：器物價值反映的是人的追求"></a>結語：器物價值反映的是人的追求</h2><p>仔細一看，上述這 5 項，不都是為了讓我可以更常待在家裡嗎XD——好白癡。</p><p>人們所追求的事物和價值觀常常反映在他們所擁有的器物上。透過這些物品，我們可以了解一個人的生活方式、興趣，和在乎的事情。</p><p>對現在的我來說，成為出色的軟體工程師是我的主要追求，於是有了這樣的取捨。</p><p><strong>這些器物不僅反映了我的價值觀，也體現了我對未來的追求和期望</strong>——我傾向選擇那些可以讓我達成目標的物品，賦與它們<strong>精神上的重要性</strong>。</p><p>所以，哪怕是食物，也有了不同的意義。</p><p>而你的追求，又是什麼呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-14/&quot;&gt;14，小米 13 的兩大關鍵亮點，與那些「價值觀層級」的器物們&lt;/a&gt;〉點出了所謂「價值觀層級」的「器物」，這期就來補完這個部分。&lt;/p&gt;
&lt;p&gt;當然，無論是定義還是清單都是非常個人化的產物，僅供參考。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;何謂「價值觀層級」？&quot;&gt;&lt;a href=&quot;#何謂「價值觀層級」？&quot; class=&quot;headerlink&quot; title=&quot;何謂「價值觀層級」？&quot;&gt;&lt;/a&gt;何謂「價值觀層級」？&lt;/h2&gt;&lt;p&gt;我們或許可以把喜愛或討厭特定人事物的&lt;strong&gt;程度&lt;/strong&gt;，大致區分為「&lt;strong&gt;偏好&lt;/strong&gt;」與「&lt;strong&gt;價值觀&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;兩者在好惡上，肯定具有「&lt;strong&gt;量&lt;/strong&gt;」的差異，但顯然不止如此而己。&lt;/p&gt;
&lt;p&gt;如果要再加上一個&lt;strong&gt;根本的區別&lt;/strong&gt;，那或許是「&lt;strong&gt;難以忍受&lt;/strong&gt;」——那些你難以忍受它不存在、存在的人事物，可能就稱得上價值觀層級的事物。而其餘的，就只能說是偏好。&lt;/p&gt;
&lt;p&gt;比如，我就完全不能忍受，&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2&quot;&gt;命令列&lt;/a&gt;（CLI，Command-Line Interface）的背景是白色的！淺色的可以，但白色就不行。&lt;/p&gt;
&lt;p&gt;或更常見的「香菜之爭」，要說它對部分人而言，屬於價值觀層級的事物，或許也不為過。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="Studio Display" scheme="https://blog.kyomind.tw/tags/Studio-Display/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>是時候同步你的 dotfiles 了——我選擇 yadm</title>
    <link href="https://blog.kyomind.tw/yadm/"/>
    <id>https://blog.kyomind.tw/yadm/</id>
    <published>2023-04-09T06:18:57.000Z</published>
    <updated>2023-06-09T13:40:29.793Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/AGhzS0d.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>本文主要寫給軟體工程師，尤其是後端。</p><p>不過，<strong>這並不是一篇 yadm 操作教學</strong>，而是我在選擇 dotfiles 同步方案時，所做的功課與思路整理，其中的考量大概有下：</p><ol><li>靠自己簡單實作就好，還是要透過工具？</li><li>如果要用工具，<strong>工具這麼多，該如何選擇</strong>？</li><li>工具之間有什麼本質的差別嗎？（其實就是下述流派上的差別）</li></ol><hr><h2 id="場景與需求"><a href="#場景與需求" class="headerlink" title="場景與需求"></a>場景與需求</h2><p>如〈<a href="https://blog.kyomind.tw/linux-dev-setup/">Linux Python 開發環境設定：zsh、zinit、pyenv、poetry、docker</a>〉所言，因為新 VM 的建立，我又得重設一次開發環境，而重設開發環境往往是一個耗時且繁瑣的過程。</p><p>在這個過程中，需要重新建立一些設定檔，例如<code>.bashrc</code>、<code>.zshrc</code>。這些設定檔通常包含了工具設定、命令別名、環境變數等大量內容，因此特別惱人。</p><p>此外，即使不是重建環境，平時要在不同 VM 包括本機電腦間「<strong>手動同步</strong>」這些檔案，也是一件讓人很想逃避的事。</p><p>以<code>.zshrc</code>為例，如果它很少變動，那可能還好。但很不幸的，我又是一個很愛為命令列工具建立 <a href="https://dywang.csie.cyut.edu.tw/dywang/linuxSystem/node88.html">alias</a>（別名）的人，光憑這點，就使我不時會修改<code>.zshrc</code>。</p><span id="more"></span><h2 id="不同-VM-間的-dotfiles-手動同步讓人想逃避"><a href="#不同-VM-間的-dotfiles-手動同步讓人想逃避" class="headerlink" title="不同 VM 間的 dotfiles 手動同步讓人想逃避"></a>不同 VM 間的 dotfiles 手動同步讓人想逃避</h2><p>而當你有 1 台、2 台……甚至更多 VM 時，<code>.zshrc</code>修改後的「<strong>內容同步</strong>」問題，足以讓你非常痛苦。</p><p>以我自己為例，我工作上「只有」2 台 VM，哪怕是兩台，<strong>在很長一段時間裡</strong>，這兩台 VM 的 alias 設定都<strong>沒有完全一致</strong>——因為我在其中一台新增了 alias 後，就懶得手動為另一台更新相同內容。</p><p>這聽起來有點愚蠢，卻是人之常情……但這次我不忍了！為了解決這個問題，我打算使用「更先進的手段」，來同步和管理這些設定檔。</p><p>如此一來，無論「重設開發環境」或「在多個 VM 之間同步設定」，我的 dotfiles 都可以輕鬆保持一致，提高工作效率。</p><h2 id="什麼是-dotfiles？"><a href="#什麼是-dotfiles？" class="headerlink" title="什麼是 dotfiles？"></a>什麼是 dotfiles？</h2><p>前面已經提了幾次 dotfiles，卻還沒有解釋它。不過相信對於很多人來說，應該一點也不陌生：舉凡在<code>$HOME</code>目錄底下的各種<strong>工具設定檔</strong>，常常都是以一個點「<code>.</code>」開頭，所以它們被稱為 dotfiles。</p><p>當然，它們未必<strong>全都</strong>放在<code>$HOME</code>目錄底下，甚至也未必皆以「<code>.</code>」開頭，只是在多數時候如此而已。</p><p>一些常見的 dotfiles 包括：</p><ol><li><code>.bashrc</code>和<code>.bash_profile</code>：最常見的 dotfiles。</li><li><code>.vimrc</code>：Vim 編輯器的設定檔，包含了一些編輯器偏好、快捷鍵綁定等。</li><li><code>.gitconfig</code>：Git 版控系統的設定檔，最基本的功能是儲存使用者的 name 和 email。而我個人也習慣把 Git「子命令」相關的 alias 放在這裡，而非放在<code>.zshrc</code>，像下面這樣：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = kyo</span><br><span class="line">    email = odinxp@gmail.com</span><br><span class="line"></span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    st = status</span><br><span class="line">    br = branch</span><br><span class="line">    co = checkout</span><br><span class="line">    brs = branch -a</span><br></pre></td></tr></table></figure><hr><h2 id="管理-dotfiles-的兩大流派：Symbolic-Link-vs-Bare-Git"><a href="#管理-dotfiles-的兩大流派：Symbolic-Link-vs-Bare-Git" class="headerlink" title="管理 dotfiles 的兩大流派：Symbolic Link vs Bare Git"></a>管理 dotfiles 的兩大流派：Symbolic Link vs Bare Git</h2><p>做過一番功課以後，我認為同步 dotfiles 所使用的手段，大致可分為兩個流派：</p><ol><li>Symbolic Link。</li><li>Bare Git。</li></ol><p>而且各有各的工具方便你使用。</p><p>如果想要自己摸索，嘗試，這篇 Reddit 討論串我覺得頗值參考：</p><ul><li><a href="https://www.reddit.com/r/linux4noobs/comments/sk5fm5/how_do_you_manage_your_dotfiles/">how do you manage your dotfiles?</a></li></ul><p>我對 dotfiles 管理工具的理解，也大致是從這篇討論延伸而來。</p><h2 id="方案一：Symbolic-Link"><a href="#方案一：Symbolic-Link" class="headerlink" title="方案一：Symbolic Link"></a>方案一：Symbolic Link</h2><p>事實上，想要輕鬆同步你的 dotfiles，未必要使用別人寫的工具。最常見的做法，就是透過<strong>軟連結</strong>（Symbolic Link）。</p><p>在此不細論具體的做法為何，可以隨意 Google 一下「<a href="https://www.google.com/search?q=symbolic%20link%20dotfiles">symbolic link dotfiles</a>」就有滿坑滿谷的資訊。</p><p>意即，自己弄一個 dotfiles repo 並手動建立軟連結，就是一個簡單暴力的方式。</p><p>但這樣做的主要缺點是：「軟連結」部分需要你<strong>手動建立</strong>，也還是不太輕鬆，所以並不推薦使用——但適合<strong>不想靠工具</strong>，又希望比「複製貼上」更有效的<strong>極簡主義者</strong>。</p><p>再「聰明」一點，則是配合 <a href="https://www.gnu.org/software/stow/manual/stow.html">stow</a>，可參考這篇〈<a href="https://farseerfc.me/using-gnu-stow-to-manage-your-dotfiles.html">【譯】使用 GNU stow 管理你的點文件</a>〉，我想這樣已經足夠優雅了。</p><h2 id="方案二：Bare-Git"><a href="#方案二：Bare-Git" class="headerlink" title="方案二：Bare Git"></a>方案二：Bare Git</h2><p>既然如此，那為什麼還需要寫這篇文章呢？當然是為了那些——包括我——不想在本機建立一個獨立的 dotfiles repo 的人！</p><p>申言之，軟連結方案通常會改變 dotfiles 的實際存放路徑——因為它們必須集中到 dotfiles repo 底下。而 stow 等工具的通常用途把你手動建立連結部分變成自動。</p><p>至於不想要變動 dotfiles 路徑的人（這無疑也是一種偏執呀，哈哈哈！），則需要第二種的「Bare Git」方案。</p><p>雖說是第二種方案，但其實<strong>兩者都需要在遠端維護一個 dotfiles repo</strong>，只不過 Git 方案在「本地」並沒有建立一個獨立的 dotfiles repo——所以也不必變動原來 dotfiles 的存放路徑。</p><h2 id="何謂-Bare-Git-方案？"><a href="#何謂-Bare-Git-方案？" class="headerlink" title="何謂 Bare Git 方案？"></a>何謂 Bare Git 方案？</h2><p>具體而言，就是指這篇〈<a href="https://www.atlassian.com/git/tutorials/dotfiles">Dotfiles: Best Way to Store in a Bare Git Repository</a>〉中的做法。因為文章就稱它為「Bare Git」，所以我也這麼稱呼。</p><p>講白了，就是利用 Git 本身的進階功能（但不是一般我們常用的那種）來達到同步 dotfiles 的目的。</p><p>這種做法的<strong>特色和優點</strong>在於，<strong>無須在本機建立額外的 dotfiles repo</strong>，而是直接將你的「<strong>家目錄</strong>」作為 dotfiles repo。此外，<strong>你需要主動選擇並加入想要同步的檔案</strong>，而不像我們平常使用 Git 時，工作目錄中未被 gitignore 的檔案都會自動被同步。</p><p>這篇文章不長，但我實際試著一步步照做後，發現其中的「坑」還真是不少——畢竟這不是我們平常使用 Git 的方式。</p><p>經歷一小時的嘗試與挫敗後，我放棄了！決定直接使用工具即可。</p><hr><h2 id="同步-dotfiles-的自動化工具選項"><a href="#同步-dotfiles-的自動化工具選項" class="headerlink" title="同步 dotfiles 的自動化工具選項"></a>同步 dotfiles 的自動化工具選項</h2><p>管理、同步 dotfiles 究竟有哪些工具可以選擇呢？說真的，非常多！</p><p>可以參考<a href="https://dotfiles.github.io/utilities/">這個清單</a>，它依照 GitHub 星星數量排序列出，並附上了言簡意賅的介紹。</p><p>如果想要知道工具間的更多細節與比較，則可以參考<a href="https://www.chezmoi.io/comparison-table/">這個對照表</a>。</p><p>作為一個 Python 工程師，我偏好選擇由 Python 開發而成的工具。上述頁面中提到的 <a href="https://github.com/anishathalye/dotbot">Dotbot</a> 和 <a href="https://github.com/TheLocehiliosan/yadm">yadm</a> 都是不錯的選項——它們主要都是使用 Python 語言開發的。</p><h2 id="我選擇-yadm"><a href="#我選擇-yadm" class="headerlink" title="我選擇 yadm"></a>我選擇 yadm</h2><p>老實說，Dotbot 和 yadm 我一開始也不知道要選哪個，所以乾脆直接先挑其中一個來試試，看看稱不稱手、合不合用。</p><p>如果是，就可以結束這回合；如果否，就換另一個。</p><p>我先試了 yadm，因為已經自己實作過〈<a href="https://www.atlassian.com/git/tutorials/dotfiles">Dotfiles: Best Way to Store in a Bare Git Repository</a>〉的內容，我不禁訝異：<strong>這不就是自動化的 Bare Git 方案嗎！</strong></p><p>流程可以說非常類似，重要的是：它把那些<strong>複雜且容易出錯</strong>的地方「封裝並隱藏起來了」——顯然這就是我要的！</p><p>附帶一提，從 <a href="https://github.com/anishathalye/dotbot#getting-started">Dotbot 的 GitHub 介紹</a>看來，它更偏向於使用 Symbolic Link：</p><blockquote><p>Dotbot only supports Python 3.8+, and <strong>it requires that your account is allowed to create symbolic links.</strong></p></blockquote><h2 id="開始使用-yadm"><a href="#開始使用-yadm" class="headerlink" title="開始使用 yadm"></a>開始使用 yadm</h2><p>教學什麼的就不獻醜了，而且步驟也非常簡單，尤其在我親身「折騰」過〈<a href="https://www.atlassian.com/git/tutorials/dotfiles">Dotfiles: Best Way to Store in a Bare Git Repository</a>〉以後，更是覺得：靠工具通常還是會讓你輕鬆不少，所以也不再堅持要「自己來」了。</p><p>建議直接<a href="https://yadm.io/docs/install">安裝</a>，並參考官網的「<a href="https://yadm.io/docs/getting_started">Getting Started</a>」操作。</p><p>只要親身實踐過〈<a href="https://www.atlassian.com/git/tutorials/dotfiles">Dotfiles: Best Way to Store in a Bare Git Repository</a>〉就會發現：兩者大同小異，只是 yadm 隱藏了更多容易出錯的細節，讓人更容易上手。</p><p>安裝好 yadm 後，它就變成了一種「特殊的 Git」指令——但只會影響你的 dotfiles repo。</p><h2 id="yadm-常用指令"><a href="#yadm-常用指令" class="headerlink" title="yadm 常用指令"></a>yadm 常用指令</h2><p>常用的指令可參考<a href="https://yadm.io/docs/common_commands#">這個頁面</a>。</p><p>就跟 Git 非常類似——畢竟它本質上就是 Git。只是增加了一些<strong>額外的指令</strong>方便你查看目前 dotfiles repo 狀態，比如<code>yadm list</code>。</p><p>這些區別，頁面中也都有說明：</p><blockquote><p>Most of these operations will look like Git commands; <strong>because they are. yadm wraps Git</strong>, allowing it to perform all of Git’s operations. <strong>The difference is your $HOME directory becomes the working directory</strong>, and you can run the commands from any directory.</p></blockquote><blockquote><p>Commands below which are special to yadm are denoted with <code>*</code>, and those which are passed directly through to Git are denoted with <code>git</code>.</p></blockquote><p>所以使用上，幾乎與操作 Git 一致，如下圖：</p><p><img src="https://i.imgur.com/WDwriPv.png"></p><p>解說：</p><ul><li>我把<code>yadm</code>設 alias 為「<code>y</code>」了。</li><li><code>pull</code>、<code>push</code>這些常見 Git 操作，在使用 yadm 時也一樣，所以如果發生「檔案狀態衝突」，也是要依照與 Git 相同方式去處理。</li><li>為了滿足同步需求，在遠端（比如 GitHub）還是要建立一個「收集這些 dotfiles 清單與狀態」的倉庫，通常我們也會命名為「dotfiles」。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/AGhzS0d.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要寫給軟體工程師，尤其是後端。&lt;/p&gt;
&lt;p&gt;不過，&lt;strong&gt;這並不是一篇 yadm 操作教學&lt;/strong&gt;，而是我在選擇 dotfiles 同步方案時，所做的功課與思路整理，其中的考量大概有下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;靠自己簡單實作就好，還是要透過工具？&lt;/li&gt;
&lt;li&gt;如果要用工具，&lt;strong&gt;工具這麼多，該如何選擇&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;工具之間有什麼本質的差別嗎？（其實就是下述流派上的差別）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;場景與需求&quot;&gt;&lt;a href=&quot;#場景與需求&quot; class=&quot;headerlink&quot; title=&quot;場景與需求&quot;&gt;&lt;/a&gt;場景與需求&lt;/h2&gt;&lt;p&gt;如〈&lt;a href=&quot;https://blog.kyomind.tw/linux-dev-setup/&quot;&gt;Linux Python 開發環境設定：zsh、zinit、pyenv、poetry、docker&lt;/a&gt;〉所言，因為新 VM 的建立，我又得重設一次開發環境，而重設開發環境往往是一個耗時且繁瑣的過程。&lt;/p&gt;
&lt;p&gt;在這個過程中，需要重新建立一些設定檔，例如&lt;code&gt;.bashrc&lt;/code&gt;、&lt;code&gt;.zshrc&lt;/code&gt;。這些設定檔通常包含了工具設定、命令別名、環境變數等大量內容，因此特別惱人。&lt;/p&gt;
&lt;p&gt;此外，即使不是重建環境，平時要在不同 VM 包括本機電腦間「&lt;strong&gt;手動同步&lt;/strong&gt;」這些檔案，也是一件讓人很想逃避的事。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;.zshrc&lt;/code&gt;為例，如果它很少變動，那可能還好。但很不幸的，我又是一個很愛為命令列工具建立 &lt;a href=&quot;https://dywang.csie.cyut.edu.tw/dywang/linuxSystem/node88.html&quot;&gt;alias&lt;/a&gt;（別名）的人，光憑這點，就使我不時會修改&lt;code&gt;.zshrc&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Linux" scheme="https://blog.kyomind.tw/tags/Linux/"/>
    
    <category term="zsh" scheme="https://blog.kyomind.tw/tags/zsh/"/>
    
    <category term="yadm" scheme="https://blog.kyomind.tw/tags/yadm/"/>
    
  </entry>
  
  <entry>
    <title>15，付費一個月後，我還是退訂了 Notion AI</title>
    <link href="https://blog.kyomind.tw/weekly-review-15/"/>
    <id>https://blog.kyomind.tw/weekly-review-15/</id>
    <published>2023-04-08T15:17:04.000Z</published>
    <updated>2023-06-05T05:24:56.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-17/">17，AI 時代的生存指南（一）：我對 AI 工具的投入與觀望</a></p></blockquote><blockquote><p><code>2023/06/04</code>重新編輯全文並<strong>新增段落</strong>：</p><ul><li><a href="#%E5%BE%8C%E8%A8%98%EF%BC%9A%E6%88%91%E4%BE%9D%E8%88%8A%E4%BD%BF%E7%94%A8-ChatGPT-%E8%BC%94%E5%8A%A9%E5%AF%AB%E4%BD%9C">後記：我依舊使用 ChatGPT 輔助寫作</a></li><li><a href="#%E6%88%91%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84-2-%E5%80%8B%E5%AF%AB%E4%BD%9C-prompt">我最常用的 2 個寫作 prompt</a></li></ul></blockquote><p>前陣子 <a href="https://www.notion.so/product/ai">Notion AI</a> 剛公布時，我並沒有在第一時間就申請試用。仔細想想，可能作為一個文字創作者，我還是<strong>「本能地」不太願意讓 AI 來干涉這塊「最後的淨土」</strong>。</p><p>這與「<a href="https://blog.kyomind.tw/github-copilot/#%E5%B0%8F%E7%B5%90%EF%BC%9A%E6%88%91%E5%B0%8D%E3%80%8C%E6%A9%9F%E5%99%A8%E8%BC%94%E5%8A%A9%E3%80%8D%E7%9A%84%E6%9C%9F%E5%BE%85">我對 AI 輔助寫 code 的態度</a>」，有著很大的差別。</p><p>但在看到一些人開始分享 Notion AI 使用心得，無論基於興奮還是焦慮，我還是不得不加入了排隊清單。結果排到我以後才沒過多久，Notion 就宣告測試結束，要開始全面收費了！</p><p>然而，到底要不要付這每月 10 美元？我掙扎了許久，從我臉書上的多次發文，就能看出其中的反覆與猶豫。</p><p>接下來就帶各位回顧，我對 Notion AI 的態度，是如何以「起、承、轉、合」四個階段持續演進——可謂<strong>從期待到放棄</strong>。</p><span id="more"></span><hr><h2 id="起：震憾與期待"><a href="#起：震憾與期待" class="headerlink" title="起：震憾與期待"></a>起：震憾與期待</h2><p><a href="https://www.facebook.com/kyomind/posts/pfbid02LUFdBAdpRLifWdjGaSd1FCopkaqAoWdtAzYUK5S81bzBNFet1qHYQztSBNqwbYxrl">第一篇發文。</a></p><p>首先，我得承認，作為一個大型寫作工具箱，Notion AI 確實有不少吸引人的地方。它整合了大量寫作專用的功能，包括總結、列大綱等等常見需求。讓你不必再「事事問 ChatGPT」。這些功能，不但可以省下時間，更可能讓我專注於創作本身。</p><p>所以一開始我是這麼說的：</p><blockquote><p>現在我不得不相信，在不久的將來，部分內容產出很可能會是以 AI 為主，人類則退居輔助，負擔起編輯、引導的角色<br>　<br>仔細想想，真不知道該高興還是害怕，因為這確實有點恐怖——我感覺，想要突顯甚至保留個人的寫作風格，更加不容易了<br>　<br>我將失去自己</p></blockquote><p>可見在第一時間，我內心的震動！</p><p>震憾、難以置信，但同時也<strong>有點期待</strong>。我甚至不禁想像：如果 AI 能夠幫我寫出一篇文章（至少是一部分或大部分），那麼我就可以專注於「<strong>編輯</strong>」，讓它更加完美。</p><p>對我這種<strong>文字偏執狂</strong>來說，這是無疑一個非常吸引人的<strong>願景</strong>☺️</p><h2 id="承：難以重複的奇蹟"><a href="#承：難以重複的奇蹟" class="headerlink" title="承：難以重複的奇蹟"></a>承：難以重複的奇蹟</h2><p><a href="https://www.facebook.com/kyomind/posts/pfbid02WDdhxNu4b5DZygwun9Uo1W5sQQLrHoWLhPPkdmA5FGHPdWSAqhYsv1h6W6dxvMsnl">第二篇發文。</a></p><p>與<a href="https://blog.kyomind.tw/github-copilot/#%E6%84%8F%E6%96%99%E4%B9%8B%E5%A4%96%EF%BC%9A%E5%AF%AB%E4%BD%9C%E8%BC%94%E5%8A%A9">使用 GitHub Copilot 輔助寫作</a>的經驗非常類似——「<strong>超常發揮</strong>」需要機緣巧合才有機會出現。</p><p>但很憾遺，這樣的「<strong>機緣巧合</strong>」，在實際上<strong>並不常發生</strong>。</p><p>於是我又不禁有了這樣的感嘆：</p><blockquote><p>但是！後來我就再也試不出類似的效果了<br>　<br>顯然那次只是「純屬偶然」，也就是剛好某個天時地利人和，因而 Notion AI 產出了幾乎完美符合我當下需求的文章段落</p></blockquote><p>而且，更讓人失落的是，即使不期待奇蹟，它在寫作輔助部分的「<strong>日常發揮</strong>」，也往往<strong>差強人意</strong>：</p><blockquote><p>後來，我嘗試著給它段落大標題，甚至已經前面寫了好一段，才下標讓它試著繼續寫，而它對於該標題的內容產出品質，依舊是「乏善可陳」<br>　<br>講白了就是沒有「個性」，也沒有亮點<br>　<br>以至於我可能用它生了 500-1000 字作為素材，結果最後只用了 50 個字，而且是用在比較無關緊要的地方</p></blockquote><p>可以說，在「<strong>測試</strong>」階段，它的效果並不符合我的期待。</p><h2 id="轉：正式付費"><a href="#轉：正式付費" class="headerlink" title="轉：正式付費"></a>轉：正式付費</h2><p><a href="https://www.facebook.com/kyomind/posts/pfbid0fTrdNt78uwSFB89jaG7RbweCzgszEnm4sEK2jmy1eZSvYZANhUwu9MrLMHBgD2vl">第三篇發文。</a></p><p>你以為我就此放棄了嗎？沒有！我還想繼續努力（掙扎），誓言「Make Notion AI Great Again！」</p><p>好啦，如文中所言，其實是因為 <a href="https://miula.tw/">miula</a> 也訂了它！讓我不禁懷疑自己：「難道是我沒有善用 Notion AI，所以才覺得不需要它？」</p><p>此時 Notion AI 已經正式收費，基於繼續嘗試與探索的必要性，在發表這篇臉書貼文後的不久，我正式付費了 Notion AI——不然我也無法再試了。</p><h2 id="合：暫別-Notion-AI"><a href="#合：暫別-Notion-AI" class="headerlink" title="合：暫別 Notion AI"></a>合：暫別 Notion AI</h2><p><a href="https://www.facebook.com/kyomind/posts/pfbid027FpL65YaxpQgcDc98vVvV9AZVowkv5mozx9uBSDb9KAXZ5ZowQUeTfZfnWyNefNcl">第四篇發文。</a></p><p>這篇和上一篇，剛好相距一個月。</p><p>雖然其間我在 blog 只發表了 3 篇文章（其實還有半篇已完成的心得文草稿），但我還是盡可能透過不同方式，讓 Notion AI 來加速或簡化我的寫作。</p><p>但事與願違——而且它不時會答非所問🤣。</p><p>它的表現仍然未脫我在測試階段的感受，尤其在 <a href="https://openai.com/product/gpt-4">GPT-4</a> 推出且我也實際付費使用後，更深深讓我感受到兩者的差距之大。</p><p>同時我也明白了 Notion AI 表現不佳的根本原因——<a href="https://dataconomy.com/2022/11/what-is-notion-ai-waitlist-features-how-use/#What_is_Notion_AI">它是基於 GPT-3</a>。</p><hr><h2 id="指數級的差距"><a href="#指數級的差距" class="headerlink" title="指數級的差距"></a>指數級的差距</h2><p>GPT-3、3.5（ChatGPT 免費版）、4，這三者的差距，究竟有多大？</p><p>在實際使用後，如果僅就「<strong>個人主觀角度</strong>」來評分，我會依序給出：<strong>50 分、100 分、500 分</strong>。</p><p>注意，這個分數是我「<strong>主觀上的最大值</strong>」，在簡單的情境下，GPT-3.5 和 GPT-4 差異有限。但在面對複雜的問題時，GPT-4 的表現就「<strong>有機會</strong>」大幅超越 GPT-3.5。</p><p>而且我覺得，<strong>寫作輔助</strong>（這裡可不是指整理會議紀錄或發一封簡短的工作 email 這樣的寫作）這類「<strong>精緻使用方式</strong>」，可能還是需要 3.5 以上會比較適合。</p><p>GPT-3（Notion AI）寫出來的內容，哪怕只是拿來參考，都稍嫌太模板化了。不僅不夠深刻，而且看多了還會讓我煩躁！</p><h2 id="結語：指日仍可待"><a href="#結語：指日仍可待" class="headerlink" title="結語：指日仍可待"></a>結語：指日仍可待</h2><p>說了這麼多，最後還是要為 Notion AI 平反一下：如果只是簡單的使用，比如列大綱、做總結，雖然我覺得產出品質普通——曾經滄海難為水啊！——但也尚稱堪用。</p><p>但是，Notion 對現在的我而言，<strong>就僅僅是拿來寫作</strong>！如果對寫作幫不上忙，那便稱 AI 也枉然。</p><p>對此，我表示遺憾，而且這也不是它的錯，畢竟它還只是個孩子啊！（GPT-3）</p><p>基於<strong>運算成本</strong>考量，它今年之內應該還無緣長大（升級模型），不過我相信這只是時間問題而已。不過考慮到目前<strong>算力資源短缺</strong>，或許還要再等個兩年？</p><p>Notion AI 直接整合在創作界面中，讓我們不必再搬運文字去問 ChatGPT，對於直接透過 Notion 創作的人如我，仍有其不可替代性。</p><p>因此，我依然期待，那一天，可以趕快到來。</p><hr><h2 id="後記：我依舊使用-ChatGPT-輔助寫作"><a href="#後記：我依舊使用-ChatGPT-輔助寫作" class="headerlink" title="後記：我依舊使用 ChatGPT 輔助寫作"></a>後記：我依舊使用 ChatGPT 輔助寫作</h2><p>在退訂了 Notion AI 以後，我的寫作是否又回到了原點？回到那個「純手工藝」的時代？</p><p>並沒有——最多是回到了<strong>半手工藝</strong>而已。</p><p>畢竟我們都已嘗過了「<strong>AI 輔助</strong>」的甜頭，AI 也確實能夠讓我的文章品質更上一層樓，我們當然不會輕易放棄它。</p><p>失去了 Notion AI 確實有些不便，但我仍然可以透過 ChatGPT 來輔助寫作，只是需要花一些額外的時間進行「複製貼上」。</p><p>此外，在「<strong>AI 加速寫作</strong>」方面，我還沒找到適合自己的做法——我仍然寫得很慢。</p><h2 id="我最常用的-2-個寫作-prompt"><a href="#我最常用的-2-個寫作-prompt" class="headerlink" title="我最常用的 2 個寫作 prompt"></a>我最常用的 2 個寫作 prompt</h2><p>雖然我目前還沒找到能夠讓 AI「<strong>加速</strong>」我寫作的方法，但使用 AI「<strong>輔助</strong>」寫作的效果已稱得上略有小成。</p><p>現階段，我還是採用<strong>「傳統」方式</strong>：將文字貼到 ChatGPT，讓它充當我的<strong>寫作助理</strong>和<strong>編輯</strong>。</p><p>我最常用的兩個寫作 prompt（提示詞），分別如下。</p><h3 id="文句編輯-prompt"><a href="#文句編輯-prompt" class="headerlink" title="文句編輯 prompt"></a>文句編輯 prompt</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面我會給你一段文句，help me improve writing and give me 3 revised versions，文句如下：</span><br></pre></td></tr></table></figure><p>中英夾雜有點傷眼，但有些部分用英文還是比較好精確表達。</p><p>3 個修改版本，是我自己設定的，你可以自行調整。但我覺得 3 個版本是一個<strong>相對合適的數量</strong>——多了看得眼花，少了又不夠參考。</p><p>提示詞用起來的效果像這樣：</p><!-- ![](https://i.imgur.com/ONzB7AH.png) --><p><img src="https://i.imgur.com/YtkORIE.png"></p><blockquote><p>是不是真的很像編輯在幫你潤飾、修改文章呢？</p></blockquote><p>這個例子或許讓你覺得「它們看起來都<strong>大同小異</strong>啊！」，確實，就這個例子而言，用不用 AI 可能沒有太大差別。</p><p>但有些時候（對我來說很常見），<strong>一段文句你怎麼寫就是不順</strong>，此時 AI 的幫助就顯得尤為重要了。畢竟它可是「<strong>語言模型</strong>」，它對任何語言的了解都比我們深刻得多。</p><p>不過話說回來，我很少直接將 AI 的回答照搬到文章中，而是會根據上下文進行調整，並加入自己的想法。</p><h3 id="繼續寫作-prompt"><a href="#繼續寫作-prompt" class="headerlink" title="繼續寫作 prompt"></a>繼續寫作 prompt</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面我會提供一段文句，請幫我繼續寫作文章內容(注意，是「繼續寫作」而不是回答)，但不要超過兩段，文句如下：</span><br></pre></td></tr></table></figure><p>「<strong>繼續寫作</strong>」正是 Notion AI 的強項，沒有了它，我們只能自己去 ChatGPT 下提示詞了——真的好原始啊！😂</p><p>這段提示詞有兩個小技巧：</p><ol><li>「<strong>不要超過兩段</strong>」：避免 ChatGPT 給出過長的回應，讓人看得眼花撩亂。少了這個限制，ChatGPT 往往會自動生成一大段文字，包括結論。</li><li>「<strong>注意，是『繼續寫作』而不是回答</strong>」：ChatGPT 是為了「<strong>對話</strong>」而開發的，因此<strong>它常常傾向於回答問題</strong>。然而，此刻我們並不需要它回答問題，只需要它繼續寫作。因此，我們得提醒它「不要回答問題」。</li></ol><p>以此方式讓 ChatGPT 幫我繼續寫作，而不用更加方便的 Notion AI，理由只有一個：<strong>ChatGPT 的創作品質比 Notion AI 更好、更有參考價值</strong>。</p><p>這才是我要的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-17/&quot;&gt;17，AI 時代的生存指南（一）：我對 AI 工具的投入與觀望&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;2023/06/04&lt;/code&gt;重新編輯全文並&lt;strong&gt;新增段落&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BE%8C%E8%A8%98%EF%BC%9A%E6%88%91%E4%BE%9D%E8%88%8A%E4%BD%BF%E7%94%A8-ChatGPT-%E8%BC%94%E5%8A%A9%E5%AF%AB%E4%BD%9C&quot;&gt;後記：我依舊使用 ChatGPT 輔助寫作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%88%91%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84-2-%E5%80%8B%E5%AF%AB%E4%BD%9C-prompt&quot;&gt;我最常用的 2 個寫作 prompt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;前陣子 &lt;a href=&quot;https://www.notion.so/product/ai&quot;&gt;Notion AI&lt;/a&gt; 剛公布時，我並沒有在第一時間就申請試用。仔細想想，可能作為一個文字創作者，我還是&lt;strong&gt;「本能地」不太願意讓 AI 來干涉這塊「最後的淨土」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這與「&lt;a href=&quot;https://blog.kyomind.tw/github-copilot/#%E5%B0%8F%E7%B5%90%EF%BC%9A%E6%88%91%E5%B0%8D%E3%80%8C%E6%A9%9F%E5%99%A8%E8%BC%94%E5%8A%A9%E3%80%8D%E7%9A%84%E6%9C%9F%E5%BE%85&quot;&gt;我對 AI 輔助寫 code 的態度&lt;/a&gt;」，有著很大的差別。&lt;/p&gt;
&lt;p&gt;但在看到一些人開始分享 Notion AI 使用心得，無論基於興奮還是焦慮，我還是不得不加入了排隊清單。結果排到我以後才沒過多久，Notion 就宣告測試結束，要開始全面收費了！&lt;/p&gt;
&lt;p&gt;然而，到底要不要付這每月 10 美元？我掙扎了許久，從我臉書上的多次發文，就能看出其中的反覆與猶豫。&lt;/p&gt;
&lt;p&gt;接下來就帶各位回顧，我對 Notion AI 的態度，是如何以「起、承、轉、合」四個階段持續演進——可謂&lt;strong&gt;從期待到放棄&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Notion AI" scheme="https://blog.kyomind.tw/tags/Notion-AI/"/>
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
  </entry>
  
</feed>
