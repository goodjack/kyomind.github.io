<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2023-07-16T20:49:14.729Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Evernote 最佳替代方案——筆記軟體 Bear 2 升級心得</title>
    <link href="https://blog.kyomind.tw/bear/"/>
    <id>https://blog.kyomind.tw/bear/</id>
    <published>2023-07-16T20:12:36.000Z</published>
    <updated>2023-07-16T20:49:14.729Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/CkddA67.png" alt="bear.app"><span class="cap">bear.app</span></p><p>在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉一文中，我曾提到：</p><blockquote><p>如果你正在尋找一款和 Evernote 界面相似、使用邏輯相仿，且<strong>符合現代潮流</strong>的 app，那麼我誠摯推薦自己也有在用的 **<a href="https://bear.app/">Bear</a>**。（可惜它只限 macOS 與 iOS 平台）</p></blockquote><p>Bear、Notion、Logseq 三者，都是我目前有持續在使用的筆記軟體，雖然在使用量上，它們呈現一個非常不均勻的分布：</p><ul><li>Logseq：80%</li><li>Notion：15%</li><li>Bear：5%</li></ul><p>對，你沒看錯，Bear 的使用量只佔我全部筆記的 5% 而已。</p><p>儘管如此，我依舊是一個忠實的 Bear 付費用戶，原因無他，因為無論是 Notion 還是 Logseq，它們都太「重」了！</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a></p></blockquote><span id="more"></span><h2 id="簡易型筆記軟體"><a href="#簡易型筆記軟體" class="headerlink" title="簡易型筆記軟體"></a>簡易型筆記軟體</h2><p>當我要想存一些簡單內容，比如常用資訊（地址、帳號、手機）；或完全不想歸類的獨立筆記，比如臉書文章摘要，我需要更簡單、輕量的筆記工具。</p><p>這些內容的特色是：當我需要它們的時候，我要快速獲取！或者我並不想為它們進行有系統的架構、組織，但又希望稍加整理。</p><p>因此，我不想動用 Notion、Logseq 這兩把「牛刀」，造成心理上的負擔。</p><p>我相信，這樣的「簡單需求」始終存在，所以我還是需要第三個筆記軟體。</p><h3 id="Bear-2"><a href="#Bear-2" class="headerlink" title="Bear 2"></a>Bear 2</h3><p>很多人會選擇 <a href="https://apps.apple.com/us/app/notes/id1110145109">Apple Notes</a>，畢竟對 Mac 用戶而言，它不止免費，而且還不需要額外安裝。同時也完全符合訴求。</p><p>Bear 則是另一個有力選項，以流暢的操作手感與簡潔優雅的使用者介面聞名。和大多數筆記軟體相同，它可以免費使用，然後付費解鎖額外功能。</p><p>就在本月，Bear 迎來了許多人等待數年之久的重大更新——<a href="https://blog.bear.app/2023/07/bear-2-is-here/">Bear 2</a>。</p><p>這篇，我們就來聊聊，Bear 2 帶給我的感受。</p><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>文章首先會講一下我對 Bear 這個筆記工具的整體看法，以及為何它是 Evernote 的優秀替代方案。</p><p>其次則是介紹這次 Bear 2 總計 20-30 項更新中，我個人比較有感的 4 項。最後下一個簡單的結論。</p><p>請注意，因為 Bear 只是我的「第三」筆記軟體，所以我對它的要求與第一筆記軟體——也就是 Logseq——有很大的不同！</p><p>換句話說，它對我而言，只要「方便」就好，不求功能強大或面面俱到。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>目標讀者有三。不用說，你得先是一個 macOS 或 iOS 用戶才行唷！</p><ol><li>屬於這波 <a href="https://www.bnext.com.tw/article/72698/evernote-join-bending-spoons">Evernote 逃難潮</a>，正在考慮下一個筆記軟體的人。</li><li>已用過 <a href="https://www.notion.so/">Notion</a>、<a href="https://obsidian.md/">Obsidian</a>、<a href="https://logseq.com/">Logseq、</a><a href="https://heptabase.com/">Heptabase</a> 等筆記軟體，<strong>覺得這些東西實在太複雜</strong>的人——它們確實都很複雜😷</li><li>不想用 Apple Notes 的人。</li></ol><hr><h2 id="為什麼說-Bear-是-Evernote-最佳替代？"><a href="#為什麼說-Bear-是-Evernote-最佳替代？" class="headerlink" title="為什麼說 Bear 是 Evernote 最佳替代？"></a>為什麼說 Bear 是 Evernote 最佳替代？</h2><p>當然是因為它們的「排版格局」和使用方式都相對類似，如圖：</p><p><img src="https://i.imgur.com/5vlTatc.png" alt="Bear 2"><span class="cap">Bear 2</span></p><p>從右至左都是：分類選單、分類文章摘要、本文——只是 Bear 美得多☺️</p><p>你不得不承認，這種排版就是最簡潔有力的排版，難怪 Apple Notes 也一樣遵守了這個傳統。</p><h3 id="標籤-VS-記事本"><a href="#標籤-VS-記事本" class="headerlink" title="標籤 VS 記事本"></a>標籤 VS 記事本</h3><p>真要說不同的話，早期的 Evernote 採用的是很傳統的分類資料夾，稱為「記事本」，而且只限一層。加上堆疊，也不過兩層。</p><p>就像我在〈<a href="https://medium.com/code-and-me/why-evernote-7cd2abbfbafd">心得 |《曼無止盡》第40期：Evernote 的重生之路</a>〉一文說的：</p><ul><li>只允許「記事本堆疊&gt;記事本&gt;記事」最多共 3 個層級的目錄結構，不像 Notion 或 WorkFlowy 可以無限層級</li><li>承上，層級很少，所以你無法進行太複雜的「專案架構」規劃，只能以簡單分類的方式來歸納記事而已，這顯然不太符合時代潮流</li></ul><p>相對的，Bear 則是用「標籤」來形成分類，彈性更大，而且支援無階層級。</p><p>但老實說，<strong>現在的我已經不覺得層級少是個問題</strong>，我在 Notion 或 Logseq 中也只用兩個層級而已。</p><blockquote><p>為什麼？</p></blockquote><h3 id="過度分類-x3D-自找麻煩"><a href="#過度分類-x3D-自找麻煩" class="headerlink" title="過度分類 &#x3D; 自找麻煩"></a>過度分類 &#x3D; 自找麻煩</h3><p>因為「多層級」是一種由上而下，有著強烈「中心化精神」的筆記方式，它的優點是層次井然、有條理，但缺點就是笨重、缺乏彈性。</p><p>「笨重、缺乏彈性」在這裡的意思是：你常常得對任意一則筆記進行詳細的分類，才能夠安置好它們該存放的知識體系——我認為這是在自找麻煩。</p><p>後來 Evernote 也加入了標籤功能，所以兩者的區別也相對小了。真要說的話，主要差異還是產品的給人的感覺，尤其是整體感與美感。</p><p>Evernote 畢竟是 2008 年的產物，受限於時空與古老的軟體架構，而且還要跨平台。它落後於時代，我覺得情有可原。</p><p>但就讓它安息吧。</p><hr><p>好，簡單的比較結束，我們來看看這次 Bear 2 更新對我來說有哪些亮點。所有更新項目請參考<a href="https://blog.bear.app/2023/07/bear-2-is-here/">網頁</a>，這裡只提其中一部分。</p><h2 id="一、隱藏-Markdown-符號"><a href="#一、隱藏-Markdown-符號" class="headerlink" title="一、隱藏 Markdown 符號"></a>一、隱藏 Markdown 符號</h2><p><img src="https://i.imgur.com/sjJb6cX.png"></p><p>這是一段沒有隱藏 Markdown 符號的 Bear 文本，說真的看起來就是有點煩。而且以前沒有開關，它一定會顯示。</p><p>我相信不是每個人都討厭這樣的設計，因為它的好處是<strong>文本的長度會完全固定</strong>，不會因為 Markdown 符號的顯示、隱藏而有區別。</p><p>但缺點當然就是，略嫌妨礙閱讀。</p><p>現在總算有開關了，讓使用者可以自由選擇。</p><h2 id="二、可調整圖片大小"><a href="#二、可調整圖片大小" class="headerlink" title="二、可調整圖片大小"></a>二、可調整圖片大小</h2><p><img src="https://i.imgur.com/TNj2LeB.png"></p><p>這個真的很重要！</p><p>雖然這功能 Notion、Logseq 都有，但呈現上各有優劣。</p><p>首先 Logseq 的最爛，調整也是在右下角但相對沒那麼好操作，而且調完後，前後的文本不會跟著移動，要重新讀取區塊才行。差評！</p><p>Notion 就好多了，使用圖片左右兩側的判定區來調整大小。</p><p>Bear 的也很不錯！調整的判定區做得很美，拉起來也很順。和 Logseq 相同，圖片都會靠左，而 Notion 則是置中。我個人偏好靠左，與文字一致。</p><h2 id="三、超連結編輯器"><a href="#三、超連結編輯器" class="headerlink" title="三、超連結編輯器"></a>三、超連結編輯器</h2><p><img src="https://i.imgur.com/8yPlckm.png"></p><p>在 Markdown 文件中要編輯超連結，真的不太方便，所以很多支援 Markdown 的軟體會有類似上圖的超連結編輯器，比如 Notion 就有。</p><p>我覺得 Bear 的貼心之處在於，每個超連結末端都加了「鉛筆」圖示，按下去就可以編輯，確實方便。</p><p>相較之下，Notion 則需要滑鼠短暫停留，我感覺稍為麻煩一點。</p><p>但是 Bear 的不足則是無法直接取消超連結，只能透過清空下面的連結內容來達成，這個就太不直觀了。</p><h2 id="四、聊勝於無的摺疊功能"><a href="#四、聊勝於無的摺疊功能" class="headerlink" title="四、聊勝於無的摺疊功能"></a>四、聊勝於無的摺疊功能</h2><p><img src="https://i.imgur.com/SFdsEJJ.png"></p><p>相當於 Notion 中的 Toggle，但要透過呼叫選單才能操作，有點不便。</p><p>效果是把整個標題的內容都收納起來，收納後會呈現上面那個 H3 標題樣式。收納功能在「<a href="https://blog.kyomind.tw/silver-bullets/#%E4%BA%8C%E3%80%81%E6%94%B6%E5%90%88">清單式筆記</a>」是必備元素，而且自然得多。</p><p>簡評就是，收起來很麻煩，展開相對容易，只能算是個<strong>半成品</strong>。</p><h2 id="五、其它更新項目簡評"><a href="#五、其它更新項目簡評" class="headerlink" title="五、其它更新項目簡評"></a>五、其它更新項目簡評</h2><p>其餘比較值得一提的更新：</p><ul><li>Table of Contents：不是在文本中，是在資訊欄的第二分頁，可以快速跳轉同頁內容，對長文本比較有用。</li><li>表格：偶爾需要，而且用起來比 Notion 的順手。</li><li>自訂字型：雖然我覺得這是現代筆記工具的基本，但很多軟體都沒有！</li><li>雙向連結？如果筆記需要雙向連結，我就不會放在 Bear 了🐸。但聊勝於無，只是要建立雙向連結相當麻煩。</li></ul><hr><h2 id="結語：保持清醒"><a href="#結語：保持清醒" class="headerlink" title="結語：保持清醒"></a>結語：保持清醒</h2><p>Bear 2 在力求維持原本簡潔的基礎上，盡可能加入一些常用的便捷功能。</p><p>在這個筆記軟體的戰國時代，「功能的多樣化與複雜化」幾乎是現代筆記軟體都會遇到的<strong>兩難困境</strong>，可以說就是一場「軍備競賽」。</p><p>別人有的功能你沒有，難免會流失一些客群。</p><p>在這種情況下要堅持簡潔，我認為很不容易。這是為什麼我依舊欣賞 Bear，因為它有一定的——被嫌棄的勇氣。</p><p>當然，某些功能的更新也讓我覺得，它感受到一定的壓力，不得不加入。</p><p>如何<strong>保持清醒</strong>，對目標用戶有一定清晰的認知，是開發方需要不斷思考的問題。</p><p>其實對使用者而言，也是如此。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CkddA67.png&quot; alt=&quot;bear.app&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉一文中，我曾提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你正在尋找一款和 Evernote 界面相似、使用邏輯相仿，且&lt;strong&gt;符合現代潮流&lt;/strong&gt;的 app，那麼我誠摯推薦自己也有在用的 **&lt;a href=&quot;https://bear.app/&quot;&gt;Bear&lt;/a&gt;**。（可惜它只限 macOS 與 iOS 平台）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bear、Notion、Logseq 三者，都是我目前有持續在使用的筆記軟體，雖然在使用量上，它們呈現一個非常不均勻的分布：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logseq：80%&lt;/li&gt;
&lt;li&gt;Notion：15%&lt;/li&gt;
&lt;li&gt;Bear：5%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對，你沒看錯，Bear 的使用量只佔我全部筆記的 5% 而已。&lt;/p&gt;
&lt;p&gt;儘管如此，我依舊是一個忠實的 Bear 付費用戶，原因無他，因為無論是 Notion 還是 Logseq，它們都太「重」了！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/logseq/&quot;&gt;Logseq 心得：一顆冉冉升起的「卡片筆記」新星&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Bear" scheme="https://blog.kyomind.tw/tags/Bear/"/>
    
    <category term="Evernote" scheme="https://blog.kyomind.tw/tags/Evernote/"/>
    
  </entry>
  
  <entry>
    <title>淺談我對蘋果 M 系列晶片的看法——超新星爆發</title>
    <link href="https://blog.kyomind.tw/apple-silicon/"/>
    <id>https://blog.kyomind.tw/apple-silicon/</id>
    <published>2023-07-02T09:23:58.000Z</published>
    <updated>2023-07-11T16:23:09.478Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/fGGona2.jpg" alt="apple.com"><span class="cap">apple.com</span></p><p>昨天寫了這篇〈<a href="https://blog.kyomind.tw/mac-mini/">M2 Pro Mac mini：寫程式最佳選擇！我的心得與選購指南</a>〉後，我發現，我對蘋果 M 系列晶片的讚揚，還遠遠沒有寫夠！</p><p>因此，我續寫了這篇，補充我對 M 系列晶片的看法——解釋為什麼我對它的評價如此之高，甚至接近「信仰」的程度。</p><p>這不僅僅因為它的高效能、低功耗，更重要的是，它讓我深刻理解到：原來（處理器）<strong>世界真的能夠被顛覆</strong>！</p><p>而要充分表達其中的「感動」，還得從採用 Intel 處理器時代的 Mac 說起。</p><span id="more"></span><hr><h2 id="從-Core-系列開始擠牙膏的-Intel"><a href="#從-Core-系列開始擠牙膏的-Intel" class="headerlink" title="從 Core 系列開始擠牙膏的 Intel"></a>從 Core 系列開始擠牙膏的 Intel</h2><p>Apple Mac 早期用的是 IBM <a href="https://zh.wikipedia.org/zh-tw/PowerPC">PowerPC</a> 架構的處理器，但因為效能不足，於 2005 年宣布轉向使用 Intel 處理器。</p><p>Intel 從 2006 的 <a href="https://zh.wikipedia.org/zh-tw/%E9%85%B7%E7%9D%BF#Core%E5%BE%AE%E6%9E%B6%E6%A7%8B%EF%BC%8864%E4%BD%8D%E5%85%83%EF%BC%89">Core</a> 架構開始，與競爭對手 AMD 漸漸拉開了技術差距，造就了其長達 10 年的獨大地位。</p><p>同時也開啟了 Intel 長達 10 年的「<a href="https://youtu.be/4bhHPeCZu0w">擠牙膏之旅</a>」——fuxk。</p><p>直到 2017 年，AMD 推出了全新的 <a href="https://zh.wikipedia.org/zh-tw/AMD_Ryzen">Ryzen</a> 處理器，重新點燃戰火，才正式打破了 Intel 的絕對優勢地位。</p><h2 id="處理器發展的黑暗時代"><a href="#處理器發展的黑暗時代" class="headerlink" title="處理器發展的黑暗時代"></a>處理器發展的黑暗時代</h2><p>維基百科是這麼描述中古黑暗時期：</p><blockquote><p><strong>歐洲黑暗時代</strong>（<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E8%AF%AD">英語</a>：<strong>Dark Ages</strong> 或 <strong>Dark Age</strong>）在編史工作上是指在<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E6%AC%A7">西歐</a>歷史上，從<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD">西羅馬帝國</a>的滅亡到<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E8%89%BA%E5%A4%8D%E5%85%B4">文藝復興</a>開始，一段文化層次下降或者社會崩潰的時期。 在 19 世紀，隨著對<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%B8%96%E7%BA%AA">中世紀</a>更多的了解，整個時代都被描述成「黑暗」的說法受到了挑戰。</p></blockquote><p>如文中所言，中世紀這段時期，是否真的該稱為「黑暗」時代，容有不同看法。</p><p>然而，Intel 獨大的這 10 年，它的壟斷地位對個人電腦發展的影響，就是一片黑暗！</p><p>從 Core 1 代到 7 代，每次更新的效能提升幅度，從前期的 10-15%，到後期甚至降到了 10% 以下，真是充分利用了自身的優勢，令人火大。</p><hr><h2 id="終於有「誠意」的-8-代"><a href="#終於有「誠意」的-8-代" class="headerlink" title="終於有「誠意」的 8 代"></a>終於有「誠意」的 8 代</h2><p>再看維基百科對第 8 代 Core——<a href="https://zh.wikipedia.org/zh-tw/Coffee_Lake">Coffee Lake</a>——的評價：</p><blockquote><p>Coffee Lake 標誌著個人電腦中處理器核心數的一次大升級，<strong>而上一次這樣的升級還是十年前的 Core 2 Duo</strong>。這次的升級主要是因為 AMD 的 Ryzen 系列處理器。</p></blockquote><p>平心而論，8 代 Core 的效能提升絕對是有目共睹的——早該如此了好嗎？</p><p>和前代 Kaby Lake 相比，效能幾乎翻倍！因為筆電處理器的核心數量，從雙核升級到了 4 核，所以確實很有感。</p><p>導致我曾一度以為，擁有 4 核心處理器的 Macbook，應該接近「完全體」了。因此，在 2020 年，我換了<a href="https://blog.kyomind.tw/weekly-review-09/#%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%8F%B0-Macbook%EF%BC%9AMacbook-Air-2020-Intel-%E7%89%88">新的 Macbook Air</a>。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-09/">09，我的 Macbook 之旅 + 新的野心</a></p></blockquote><p>雖然這台 Mac 配備了 Intel 更新的<a href="https://www.intel.com.tw/content/www/tw/zh/products/sku/196589/intel-core-i51030ng7-processor-6m-cache-up-to-3-50-ghz/specifications.html">第 10 代 CPU</a>，但因為屬於<strong>超低功耗系列</strong>，整體效能尚不及採用第 8 代 CPU——<a href="https://www.intel.com.tw/content/www/tw/zh/products/sku/135935/intel-core-i58259u-processor-6m-cache-up-to-3-80-ghz/specifications.html">i5-8259U</a>——的 13 吋 Macbook Pro。</p><p>但考慮它 <a href="https://browser.geekbench.com/processors/intel-core-i5-1030ng7">Geekbench 多核跑分</a>也有 [i5-8259U 跑分</p><p>然而事實是：這台 Mac 的效能<strong>明顯達不到我的要求——它離「完全體」還很遠！</strong></p><hr><h2 id="超新星爆發：Apple-Silicon-M1-降臨"><a href="#超新星爆發：Apple-Silicon-M1-降臨" class="headerlink" title="超新星爆發：Apple Silicon M1 降臨"></a>超新星爆發：Apple Silicon M1 降臨</h2><p>所謂<a href="https://zh.wikipedia.org/zh-tw/%E8%B6%85%E6%96%B0%E6%98%9F">超新星爆發</a>，實際上是大質量恆星生命週期的<strong>終點</strong>，而不是開始或誕生的象徵。</p><p>但因為爆發產生的亮度極高，能量巨大，當我們談論新事物或新概念時，有時我們會用「超新星爆發」來形容它們帶來的顯著變革和影響。</p><p>這種比喻意味著該新事物的出現，伴隨極大的能量和劇烈的變動，<strong>且很可能改變現有的狀態和平衡。</strong></p><p>2020 年底，專為 Mac 設計的 Apple Silicon 晶片正式發表，它的名字叫 <a href="https://zh.wikipedia.org/zh-tw/Apple_M1">M1</a>。</p><p>和我原有的 Macbook Air 相比，它的效能是誇張的 3 倍，而續航力竟然也是 3 倍——<strong>不可思議</strong>。這顯然超越了我們對「進化」的理解——這是「<strong>超新星爆發</strong>」。</p><h2 id="小結：Way-to-Go"><a href="#小結：Way-to-Go" class="headerlink" title="小結：Way to Go"></a>小結：Way to Go</h2><p>革命不可能常常發生，在 M1 帶給我們如此深刻的印象之後，後續的 M2 自然很難複製同樣的衝擊。</p><p>但對我來說，配備 M 系列晶片的 Mac，已經可以稱為「<strong>完全體</strong>」。</p><p>意即，這台機器要用上十年、八年，我相信完全不是問題。這是舊 Intel 時代處理器，所無法帶給我的想望。</p><p>這也是為什麼我願意為 M2 Pro Mac mini 加購那麼多「不一定必要」的升級——因為我對它的<strong>長期價值</strong>，有著相當的信心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fGGona2.jpg&quot; alt=&quot;apple.com&quot;&gt;&lt;/p&gt;
&lt;p&gt;昨天寫了這篇〈&lt;a href=&quot;https://blog.kyomind.tw/mac-mini/&quot;&gt;M2 Pro Mac mini：寫程式最佳選擇！我的心得與選購指南&lt;/a&gt;〉後，我發現，我對蘋果 M 系列晶片的讚揚，還遠遠沒有寫夠！&lt;/p&gt;
&lt;p&gt;因此，我續寫了這篇，補充我對 M 系列晶片的看法——解釋為什麼我對它的評價如此之高，甚至接近「信仰」的程度。&lt;/p&gt;
&lt;p&gt;這不僅僅因為它的高效能、低功耗，更重要的是，它讓我深刻理解到：原來（處理器）&lt;strong&gt;世界真的能夠被顛覆&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;而要充分表達其中的「感動」，還得從採用 Intel 處理器時代的 Mac 說起。&lt;/p&gt;</summary>
    
    
    
    <category term="隨筆雜談" scheme="https://blog.kyomind.tw/categories/%E9%9A%A8%E7%AD%86%E9%9B%9C%E8%AB%87/"/>
    
    
    <category term="Apple Silicon" scheme="https://blog.kyomind.tw/tags/Apple-Silicon/"/>
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>M2 Pro Mac mini：寫程式最佳選擇！我的心得與選購指南</title>
    <link href="https://blog.kyomind.tw/mac-mini/"/>
    <id>https://blog.kyomind.tw/mac-mini/</id>
    <published>2023-07-01T13:12:39.000Z</published>
    <updated>2023-07-16T16:01:09.706Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/h8Mebn5.jpg" alt="Cassiopeia A 超新星殘骸，直徑約 10 光年"><span class="cap">Cassiopeia A 超新星殘骸，直徑約 10 光年</span></p><p>今年 4 月，我入手了 M2 Pro 版的 <a href="https://www.apple.com/tw/mac-mini/">Mac mini</a>，至今已使用了快 3 個月。隨著配備 M2 Max 的 <a href="https://www.apple.com/tw/mac-studio/">Mac Studio</a> 發表，我認為是時候分享一下我的心得和選購指南——雖然這只是一個粗略的指南。</p><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文主要寫給那些<strong>「想買 Mac mini 但還有所遲疑的人」</strong>作為參考，我不會特別鼓吹要買哪一款，這是一篇「平靜」的心得。</p><p>此外，這篇文章是以<strong>我的核心需求</strong>——<a href="/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/">軟體開發</a>——為出發點，對同為軟體工程師的讀者而言，可能更具參考價值。</p><span id="more"></span><h2 id="我的-Mac-mini-規格"><a href="#我的-Mac-mini-規格" class="headerlink" title="我的 Mac mini 規格"></a>我的 Mac mini 規格</h2><p>先講規格，如開頭所言，這是一台 M2 Pro 版的 Mac mini，並做了一些升級：</p><ul><li>升級 CPU 晶片：10C&#x2F;16C（CPU 和 GPU 核心數）升級為 12C&#x2F;19C。</li><li>升級 32 GB RAM。</li><li>升級 1 TB SSD。</li><li>升級 10 Gigabit 乙太網卡。</li></ul><p>總計 69900 元，但我<strong>並不推薦</strong>這樣的配置，文末會推薦我認為 <strong>CP 值較高</strong>的選項。</p><hr><h2 id="為什麼-Mac-mini-才是我寫程式最佳選擇？"><a href="#為什麼-Mac-mini-才是我寫程式最佳選擇？" class="headerlink" title="為什麼 Mac mini 才是我寫程式最佳選擇？"></a>為什麼 Mac mini 才是我寫程式最佳選擇？</h2><p>對於大部分工程師來說，14 或 16 吋的 Macbook Pro 應該是首選。即使在家中使用，也可以透過外接大螢幕來提供更好的工作體驗。</p><p>確實如此，我以前也是這樣想的。</p><p>直到〈<a href="https://blog.kyomind.tw/weekly-review-09/">09，我的 Macbook 之旅 + 新的野心</a>〉，重新思考了自己的需求後，<strong>我發現我真正需要的，是 Mac mini——也許你也是。</strong></p><p>我主要的考慮有三：</p><ol><li>我很少把筆電帶出門使用，雖然是遠端工作但我從不去咖啡廳，所以機動性需求非常小。</li><li>即使真的要帶筆電出門，我也不想帶 14 吋甚至 16 吋的 Macbook Pro——它們都太重也太厚了。</li><li>家中使用，外接<a href="https://blog.kyomind.tw/weekly-review-13/">大螢幕</a>後，筆電<strong>只剩下主機功能</strong>，繼續放在桌上<strong>顯得很佔空間</strong>，不符合我的簡潔美學。很多人會把它立起來或當小螢幕使用，但我不喜歡。</li></ol><p>由此可知，在絕大部分時候，Mac mini 才是我的首選。</p><h2 id="新-Mac-都有的-SSD-降速問題"><a href="#新-Mac-都有的-SSD-降速問題" class="headerlink" title="新 Mac 都有的 SSD 降速問題"></a>新 Mac 都有的 SSD 降速問題</h2><p>現在要買 M2 晶片的 Mac，無論桌機還是筆電，我們都不得不接受一個現實：只要是該系列的「<strong>最低規格</strong>」，那 SSD 就一定是<strong>單晶片</strong>——這意味著<strong>速度較慢</strong>，而且還<strong>慢上不少</strong>。</p><p>哪怕是 M2 Pro 入門起跳的 512 GB SSD，一樣有這個問題，著實令人不快。因為通常最低階的規格，對多數人而言，就是 CP 值最高的選擇。</p><p>而蘋果想必也深知這一點，讓你陷入兩難，真的很討厭！</p><blockquote><p>蘋果你贏了。</p></blockquote><h2 id="為什麼我選擇-M2-Pro？"><a href="#為什麼我選擇-M2-Pro？" class="headerlink" title="為什麼我選擇 M2 Pro？"></a>為什麼我選擇 M2 Pro？</h2><p>作為一個靠電腦吃飯的軟體工程師，我買電腦比較沒那麼重視 CP 值。所以原本一直都把目光放向 Max 而非 Pro。</p><p>原因也非常直接簡單：「因為它叫 Max，作為一個工程師，我應該要 Max！」，即使我明白 Max 和 Pro 在 CPU 效能上是相同的。</p><p>不過在做了更多功課後，我還是得承認，如果用不到 Max 多出來的 GPU 核心，那買 Max 的機型就完完全全是一種浪費。</p><p>而現實中的我，連 Pro 版 GPU 核心都用不太到🐸</p><hr><h2 id="Mac-mini-的選購考量"><a href="#Mac-mini-的選購考量" class="headerlink" title="Mac mini 的選購考量"></a>Mac mini 的選購考量</h2><p>好，捨棄 Max！這是好事，因為 Mac mini 也沒有 Max 版本。如果我堅持要 Max，就只能購買 Mac Studio。</p><p>但我才不想買「體積龐大（相對於 mini😷）」的 Studio！我想這也是促成我堅定選擇 M2 Pro 的<strong>另一大考量</strong>——mini 最多只有 Pro，而我要 mini。</p><p>但問題又來了，如果要買 mini，是要買 M2 版還是 M2 Pro 版呢？</p><blockquote><p>平心而論，我覺得都可以。</p></blockquote><p>這不是開玩笑，因為 M2（或說 M1 及以後）的 Mac，相較於以前的 Intel CPU，效能實在強太多了，而且功耗也低得多。</p><p>以至於我不禁感到，選購 M2 或 M2 Pro，也許只是一個「心情」議題——我真心這麼認為。意即，好一點的規格，很多時候只是為了心安而已。</p><h2 id="M2-和-M2-Pro-差異"><a href="#M2-和-M2-Pro-差異" class="headerlink" title="M2 和 M2 Pro 差異"></a>M2 和 M2 Pro 差異</h2><p>不過話又說回來，哪怕只是為了心安，我們也得先知道 M2 和 M2 Pro 有什麼差異。</p><p>兩者的差異可參考這個影片〈<a href="https://www.youtube.com/watch?v=szBpbSMhe_s">The TRUTH about New Mac Mini after 1 Month - M2 vs M2 Pro!</a>〉，有著相當完整的比較。</p><p>對我而言，大概有這幾個主要差別：</p><ol><li>相較於 M2，Pro 是更強的 CPU 與 GPU。提升幅度依不同場景，約落在 40-80% 之間。</li><li>M2 Pro 的記憶體上限是 32 GB，而 M2 則是 24 GB。對於需要大量記憶體的人，這是一個重要考量。</li><li>M2 Pro 的記憶體頻寬從 100 GB 提升至 200 GB。這個好評！</li><li>SSD 的速度也有差別（而且差滿多的XD），可參考下圖：</li></ol><p><img src="https://i.imgur.com/bSiCE1t.png" alt="來源：Max Tech"><span class="cap">來源：Max Tech</span></p><p>雖然 SSD 速度上差很多，但實際感受上，可能沒有多大差異。</p><p>我的看法是，除非你能「榨乾」GPU，比如全職影像工作者，否則 M2 或 M2 Pro 的「<strong>體感差異</strong>」終究是有限的。</p><p>而且退萬步言，哪怕是 M2，要剪輯多軌 4K 影片，也是沒問題的。</p><p><strong>真正需要嚴肅考慮的，或許是 RAM 的大小！</strong>因為在某些單次就要載入大檔案的情境（比如載入機器學習資料集），RAM 的不足真的會讓效率大幅下降。</p><p>除了上述兩種情況，其它時候，兩者大同小異。所以我才說，這是一個心情議題。</p><hr><h2 id="Mac-mini-與-Mac-Studio-的選購考量"><a href="#Mac-mini-與-Mac-Studio-的選購考量" class="headerlink" title="Mac mini 與 Mac Studio 的選購考量"></a>Mac mini 與 Mac Studio 的選購考量</h2><p>最近 M2 Max 版的 <a href="https://www.apple.com/tw/shop/buy-mac/mac-studio">Mac Studio</a> 發表了，這會一定程度影響「<strong>高階 Mac mini</strong>」的<strong>選購合理性</strong>，值得一提。</p><p>怎麼說？講白了就是，如果你選了 M2 Pro 版的 Mac mini，而且像我一樣，對它進行了若干升級，那它的 CP 值很可能就會<strong>明顯不如</strong> M2 Max 的 Mac Studio。</p><p>以我的 Mac mini 為例，足足升級了 4 個項目，而 Mac Studio 只要升級 SSD，規格上就幾乎就完勝。差別如下：</p><ol><li>升級後，Mac Studio 僅貴了 1000 左右（69900 VS 70999）。</li><li>Mac Studio 的 GPU 從 mini 的 19 核變成 30 核！</li><li>Mac Studio 機體正面多了兩個 USB-C 埠和讀卡機——對某些人可謂愛不釋手。</li><li>Mac Studio 的記憶體頻寬從每秒 200 GB 提升到 400 GB。</li></ol><p>其它暫且不論，光多花 1000 元就足足多了 11 核心的 GPU，這道計算題……似乎不是太困難😎——想想 M2 Macbook Air 僅從 8 核 GPU 升到 10 核，就要 3000 元。</p><p>總之，如果你想買「<strong>升級版</strong>」M2 Pro Mac mini，不妨先看一下 Mac Studio <strong>是否更符合自己的需求</strong>，再決定也不遲。</p><h2 id="我依舊選擇-Mac-mini"><a href="#我依舊選擇-Mac-mini" class="headerlink" title="我依舊選擇 Mac mini"></a>我依舊選擇 Mac mini</h2><p>說了這麼多，主要是為讀者——也就是螢幕前的你——考慮。若此時此刻，讓我再重新選擇，我還是會選 Mac mini，而且一樣會升級。</p><p>現在我們已經知道，這樣的升級，相較於直接購買 Mac Studio，多少是不太划算的，那我<strong>鍾情於 Mac mini 的理由</strong>又是如何呢？主要有三：</p><ol><li>Mac Studio 的體積太大了！足足有 3 台 Mac mini 這麼大，我不能接受XD。</li><li>Mac Studio 多出來的 GPU 效能，我用不太到，畢竟連 M2 Pro 的 GPU 對我都屬效能過剩。<ol><li>附帶一提，我升級 M2 Pro 的 CPU 晶片，主要是為了 <strong>CPU 部分的提升</strong>——大概 20%，對一些<strong>計算密集</strong>的任務仍有大用。</li><li>比如我很常用 <a href="https://goodsnooze.gumroad.com/l/macwhisper">MacWhisper</a> 將聲音轉成文字，<a href="https://github.com/openai/whisper/pull/382">受限於模型</a>，目前在 macOS 上只能靠 CPU 運算，快個 20% 總是好的。</li></ol></li><li>值得欣慰的是，根據<a href="https://youtu.be/fkhkm1wQS18">這則影片</a>的測試，Mac Studio 採用的新一批 SSD，在跑分上甚至還略遜於 mini，如圖（僅供參考）：</li></ol><p><img src="https://i.imgur.com/745De6H.png" alt="來源：Max Tech"><span class="cap">來源：Max Tech</span></p><p>Mac Studio 是一台強大的性能怪獸，只是我目前還用不上。有朝一日，會再考慮。</p><hr><h2 id="總結與選購建議"><a href="#總結與選購建議" class="headerlink" title="總結與選購建議"></a>總結與選購建議</h2><p>身為一個軟體工程師，在選購「吃飯工具」時，我不會太在乎 CP 值，所以加了一些讓自己「<strong>心情更好</strong>」的升級，儘管我知道這些升級<strong>對於實際體驗的影響有限</strong>。</p><p>這樣的心態很像散文〈<a href="https://medium.com/code-and-me/%E7%AC%AC%E4%B9%9D%E5%91%B3-453d14626ed7">第九味</a>〉中的那句話：「喫是為己，穿是為人。」</p><blockquote><p><strong>但我並不推薦你這麼做。</strong></p></blockquote><h3 id="Mac-選購建議"><a href="#Mac-選購建議" class="headerlink" title="Mac 選購建議"></a>Mac 選購建議</h3><p>如前所述，在蘋果的精心設計下，<strong>通常系列的入門款，就是 CP 值最高的選擇</strong>。因此，如果你是 Mac 新手且只有文書需求，我推薦入門款的 M2 Mac mini。</p><p>如果你也是軟體工程師，則 M2 Pro 無疑是<strong>更加均衡的選擇</strong>。而入門款的 M2 Pro Mac mini，恰恰是<strong>效能與價格競爭力兼具</strong>的不敗選項。</p><p>如果你影像工作者，且需要<strong>非常強大的 GPU 運算力</strong>，那麼從 Mac Studio 開始考慮，或許會比較快。</p><h3 id="Macbook-選購建議"><a href="#Macbook-選購建議" class="headerlink" title="Macbook 選購建議"></a>Macbook 選購建議</h3><p>2020 舊款、2022 新款的 Macbook Air 我都有，M1 Pro 的 Macbook Pro 也曾短暫入手過，說說我對它們的看法。</p><p>如果<strong>只能擁有一台 Macbook</strong>，我會毫不猶豫地選擇 <strong>M2 Macbook Air</strong>。因為它的外觀設計幾乎完美符合我對於輕薄筆電的想像——圓潤的邊角及線條，太美了。</p><p>但如果是推薦身邊的人買，我八成還是會選舊款 M1 Macbook Air，因為它的價格更加親民、性能足夠好。不到 3 萬就能擁有這樣一台機器，<strong>這是以前所無法想像的。</strong></p><p>至於 Macbook Pro，顯然更適合<strong>對效能有要求</strong>，並希望透過一台 Macbook，一次滿足在家與外出使用的人。</p><p>附帶一提，<strong>盡量避免在 14 吋的 Macbook Pro 上選用 Max 版的 CPU</strong>，因為它的<strong>散熱能力相對有限</strong>。在持續高負載下，CPU 容易因過熱而降頻，造成<strong>性能瓶頸</strong>。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>整體而言，我對於手上這台 Mac mini 可謂<strong>相當滿意</strong>。它以極低功耗提供了十分優秀的效能和穩定性，充分滿足了我在工作、學習上的需求。</p><p>我不得不佩服蘋果 M 系列晶片之強大，猶如<strong>超新星爆發</strong>。而你，也值得擁有。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/apple-silicon/">淺談我對蘋果 M 系列晶片的看法——超新星爆發</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/h8Mebn5.jpg&quot; alt=&quot;Cassiopeia A 超新星殘骸，直徑約 10 光年&quot;&gt;&lt;/p&gt;
&lt;p&gt;今年 4 月，我入手了 M2 Pro 版的 &lt;a href=&quot;https://www.apple.com/tw/mac-mini/&quot;&gt;Mac mini&lt;/a&gt;，至今已使用了快 3 個月。隨著配備 M2 Max 的 &lt;a href=&quot;https://www.apple.com/tw/mac-studio/&quot;&gt;Mac Studio&lt;/a&gt; 發表，我認為是時候分享一下我的心得和選購指南——雖然這只是一個粗略的指南。&lt;/p&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;本文主要寫給那些&lt;strong&gt;「想買 Mac mini 但還有所遲疑的人」&lt;/strong&gt;作為參考，我不會特別鼓吹要買哪一款，這是一篇「平靜」的心得。&lt;/p&gt;
&lt;p&gt;此外，這篇文章是以&lt;strong&gt;我的核心需求&lt;/strong&gt;——&lt;a href=&quot;/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/&quot;&gt;軟體開發&lt;/a&gt;——為出發點，對同為軟體工程師的讀者而言，可能更具參考價值。&lt;/p&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="產品評論" scheme="https://blog.kyomind.tw/tags/%E7%94%A2%E5%93%81%E8%A9%95%E8%AB%96/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</title>
    <link href="https://blog.kyomind.tw/django-models/"/>
    <id>https://blog.kyomind.tw/django-models/</id>
    <published>2023-06-24T17:31:49.000Z</published>
    <updated>2023-07-14T17:36:38.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/yK0Us6a.jpg" alt="by Léo Alexandre"><span class="cap">by Léo Alexandre</span></p><p>工作上使用 Django 近 2 年，卻很少發表關於 Django 主題的文章，是時候該來補一補了。</p><p>就從 Django ORM 開始吧！因為 Django ORM 可以說是無論你怎麼使用 Django（全端或前後端分離），都不得不學的核心部分。</p><p>怎麼說？我們先來看看，在「前後端分離」的開發趨勢下，Django 的三大核心——MTV——的重要性有哪些變動。</p><span id="more"></span><h2 id="前後端分離下的-Django-MTV"><a href="#前後端分離下的-Django-MTV" class="headerlink" title="前後端分離下的 Django MTV"></a>前後端分離下的 Django MTV</h2><p>在 Django 中，MTV 是指 Model-Template-View 的架構模式。這是 Django 框架的核心設計模式，用於組織和分離應用程式的不同部分。</p><ul><li><strong>Model（模型）：</strong> 模型負責處理與資料庫相關的操作，它是定義數據結構、資料表和資料庫查詢的地方。</li><li><strong>Template（模板）：</strong> 模板用於前端。它是一個包含 HTML、CSS 和一些額外標記語言（例如 Django 的模板語言）的文件，用於定義網頁的外觀和內容。</li><li><strong>View（視圖）：</strong> 視圖是應用程式處理邏輯的地方。它接收用戶的請求，從模型獲取數據，並使用模板來生成適當的回應。視圖處理用戶的 HTTP 請求，並根據需要調用相應的模型和模板來生成回應。</li></ul><h3 id="前後端分離對三大元件的重要性影響"><a href="#前後端分離對三大元件的重要性影響" class="headerlink" title="前後端分離對三大元件的重要性影響"></a>前後端分離對三大元件的重要性影響</h3><p>假設你是一個前後端分離下的 Django 工程師，那通常就是負責後端的 API 開發。</p><p>首先，顯然 Template 不需要了，因為這是前端的範疇，而 View 呢？相當程度會被 <a href="https://www.django-rest-framework.org/">Django REST framework</a>（以下皆簡稱為 DRF）所取代。說「取代」不太正確，應該說「升級」。</p><p>帶來的影響是 View 中相當部分操作細節與學習重點會遷移到 DRF 本身，而非 Django 原生提供的功能。</p><p>比如<code>request.data</code>，重新封裝了 Django 中的<code>request.POST</code>和<code>request.FILES</code>兩個屬性，類似的情況還有<code>APIView</code>或<code>@api_view</code>等等。</p><p>既然 Template 被前端取代，而 View 的功能則被 DRF 重新封裝。可想而知，三大元件中重要性唯一不變的，就是 Model——Django ORM。</p><p>可見，作為一個 Django 開發者，學好 ORM 是絕對不虧的！</p><h2 id="範例程式碼專案介紹"><a href="#範例程式碼專案介紹" class="headerlink" title="範例程式碼專案介紹"></a>範例程式碼專案介紹</h2><p>如前所述，我打算寫一系列的 Django 教學文章，如果有範例程式碼，必然更方便讀者學習、參考。於是我建了一個 GitHub Repo 名為「<a href="https://github.com/kyomind/kyo-django-tutorial">kyo-django-tutorial</a>」，把文章中使用的程式碼同步更新於此。</p><p>這是一個典型的 Django 專案，而且有著完整的 Python 環境設定，各種細節都和我個人開發一致，有 Poetry、pre-commit 與基本的 linter、formatter 設定等，方便讀者複製環境並跟著操作。</p><p>以下是簡單的介紹。</p><h3 id="專案環境介紹"><a href="#專案環境介紹" class="headerlink" title="專案環境介紹"></a>專案環境介紹</h3><p>支援 Poetry，方便重建專案所需的 Python 虛擬環境。但你也可以不使用它，我有另外準備<code>requirements.txt</code>供<code>pip</code>安裝。</p><p>pre-commit 完全可選，基本上用不到，除非你有打算變更程式碼的內容。只要不使用指令<code>pre-commit install</code>，它相當於不存在。但如果你想用的話，整個<code>.pre-commit-config.yaml</code>設定檔都寫好了。</p><p>隨著文章更新，未來還會支援 Docker，敬請期待。</p><h3 id="工具版本說明"><a href="#工具版本說明" class="headerlink" title="工具版本說明"></a>工具版本說明</h3><p>Django 版本為 4.2.x LTS，對 Python 的版本有一定要求，不能太舊，必須在 3.8 以上。</p><p>Python 版本使用 3.10.11，建議至少使用 3.8.1，雖然剛剛說 Django 只要求 3.8，但因為 Flake8 版本是 6.0.0，要求 Python 至少要 3.8.1 XD。建議直接還是安裝 3.10 或更新的版本。</p><hr><p>基本的介紹就到這裡，我們趕緊進入本篇的重點。</p><h2 id="本文重點：Django-ORM-外鍵關聯設定"><a href="#本文重點：Django-ORM-外鍵關聯設定" class="headerlink" title="本文重點：Django ORM 外鍵關聯設定"></a>本文重點：Django ORM 外鍵關聯設定</h2><p><a href="https://docs.djangoproject.com/en/4.2/topics/db/models/">Django Models</a>，也就是 db table 的 <a href="https://zh.wikipedia.org/zh-tw/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84">OOP</a> 程式型態，透過 ORM 來實現兩者的對應關係——從 db table 到 Python class。</p><p>如果說 ORM 是 Django 的核心之一，而 ORM 的核心會是什麼呢？我相信其中一個答案，就是「（外鍵）關聯」（relationships）。若是少了關聯性，資料表就像孤立的島嶼，根本無法真實模擬世界。</p><p>剛開始寫 Django ORM 時，疑問最多的就是外鍵關聯了！因為它不止重要，而且常用。外鍵關聯又分一對一、一對多（多對一）與多對多，我們會先著重在前兩者的介紹——因為它們最常用。讓你一接觸 Django ORM 就快速上手。</p><p><strong>本文為上篇，主要是系列前言與外鍵設定教學，查詢部分則留到下篇。</strong></p><h2 id="專案模型介紹"><a href="#專案模型介紹" class="headerlink" title="專案模型介紹"></a>專案模型介紹</h2><p>學習 Django 模型和外鍵關係的最佳方法，是透過具體的例子。在上述專案中，我準備了一個最常見的範例：<a href="https://github.com/kyomind/kyo-django-tutorial/blob/01-django-models/post/models.py">文章模型</a>。</p><p>選這個例子主要出於兩個原因：</p><ol><li>它很容易想像。</li><li>它同時包括了一對一、一對多、多對多等不同情境。</li></ol><p>模型對應的情境大致是這樣：你有一個個人的部落格網站，只有你可以發表文章，而讀者可以留言。</p><p>因為只有一個作者，也就是你，所以模型省略了作者的部分。這些設計都是為了方便介紹而已，不必對它們的真實性太過認真。</p><p>以下我們一一介紹這 3 個模型。</p><h3 id="Title：文章標題"><a href="#Title：文章標題" class="headerlink" title="Title：文章標題"></a>Title：文章標題</h3><p>通常標題只會是文章模型的一個欄位，很少獨立出來。我這樣設計是為了呈現一對一關係，而且這裡有分主、副標題，多少為獨立出來增加了一點合理性，就一點XD。</p><h3 id="Post：文章"><a href="#Post：文章" class="headerlink" title="Post：文章"></a>Post：文章</h3><p>最主要的模型，其餘兩個模型都和它有關。</p><p>與標題是一對一關係，直接有一個<code>title</code>外鍵欄位關聯到 Title 模型，另一個欄位則是<code>content</code>。</p><h3 id="Comment：留言"><a href="#Comment：留言" class="headerlink" title="Comment：留言"></a>Comment：留言</h3><p>用來說明對一多關係的模型，有一個外鍵欄位<code>post</code>關聯到 Post。對 Post 來說，則會建立一個「反向關聯（<a href="https://allwin-raju-12.medium.com/reverse-relationship-in-django-f016d34e2c68">reverse relationship</a>）」屬性，下面會詳細介紹。</p><p>三者的關係可以畫成簡單的實體關聯圖（ERD） 如下：</p><p><img src="https://i.imgur.com/5qO8q8E.png"></p><p>Django 會自動幫你在外鍵屬性名稱加上<code>_id</code>，轉換成 db 中 table 欄位的名稱，所以上面圖中的欄位名稱是<code>title_id</code>與<code>post_id</code>。</p><hr><h2 id="在-Model-中建立外鍵欄位"><a href="#在-Model-中建立外鍵欄位" class="headerlink" title="在 Model 中建立外鍵欄位"></a>在 Model 中建立外鍵欄位</h2><p>我們知道，ORM 所對應的 table 欄位，都是用 Python 類別中的類別屬性來定義與規範的。而 db 欄位的 schema 則對應 model 屬性的「參數」。</p><p>尤其是外鍵屬性，因為要建立關聯，使用的參數通常比較多，格式上也和一般欄位屬性有所差別。</p><p>無論如何，了解外鍵欄位常用的參數與其代表的意義，相當必要，這也是本篇的重心。</p><p>以下介紹一對一和一對多的外鍵關聯設定，讀者可適時參考深獲開發者好評的 <a href="https://docs.djangoproject.com/en/4.2/">Django 文件</a>，我們只就重點進行說明。</p><h2 id="一對一關係"><a href="#一對一關係" class="headerlink" title="一對一關係"></a>一對一關係</h2><p>參考<code>OneToOneField</code><a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#onetoonefield">文件</a>，只有兩個必填的<strong>位置參數</strong>，即<code>to</code>和<code>on_delete</code>。</p><p>先看一下專案中存在一對一關係的兩個 model（為了網頁呈現，我縮減了單行字元上限與空行數、省略了無關部分，所以和原始碼有所不同）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Title</span>(models.Model):</span><br><span class="line">    main = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    subtitle = models.CharField(max_length=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><code>OneToOneField</code>即外鍵中的一對一關係欄位，第一個參數是<code>to</code>，為目標關聯的 model，有兩種格式：</p><ol><li>model class 本身。</li><li>字串。用於無法直接引用的情境，比如本例中的 title 欄位，Title 類別定義在 Post 之後。</li></ol><p>第二個參數是<code>on_delete</code>，用來定義「關聯物件被刪除時」當前物件該如何處理的行為。有多揰模式，最常用的不外乎<code>CASCADE</code>、<code>PROTECT</code>、<code>SET_NULL</code>這 3 種，其餘所有選項與行為定義，可以參考<a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.CASCADE">文件</a>。</p><p>除了<code>to</code>和<code>on_delete</code>兩個必要參數，剩下的都是 optional，不過還有一個參數也非常重要，那就是<code>related_name</code>。</p><h2 id="related-name-與反向關聯"><a href="#related-name-與反向關聯" class="headerlink" title="related_name 與反向關聯"></a>related_name 與反向關聯</h2><p><code>related_name</code>用於指定關聯<strong>目標 model</strong>（本例為 Title）的「反向關聯」<strong>屬性名稱</strong>。這個屬性對查詢很實用，所以<code>related_name</code>也是外鍵屬性中重要的參數之一。</p><p>我們從 model 角度來看外鍵建立後的效果，以及<code>related_name</code>所扮演的角色。</p><h3 id="Post-角度"><a href="#Post-角度" class="headerlink" title="Post 角度"></a>Post 角度</h3><p>Post 有一個屬性為<code>title</code>，也就是我們所建立的外鍵，這個屬性在 model 中是明示的，意味著它在 db table 中也會有對應的欄位——<code>title_id</code>。其中<code>_id</code>是 Django 幫你加的，你可以透過<code>class Meta</code>自行定義這個欄位的名稱。</p><p>事實上，建立關聯不一定只能指向目標 model 的「主鍵」，只要是 model 中的  unique 欄位都可以，可參考 <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey.to_field">to_field 文件</a>。</p><h3 id="Title-角度"><a href="#Title-角度" class="headerlink" title="Title 角度"></a>Title 角度</h3><p>一對一關係建立後，對 Title model 或它的實例而言，它得到了什麼？——反向關聯屬性。</p><p>這個屬性在 model 中沒有明示，你從 model 中看不出 Title 有什麼屬性可以指向 Post。但實際上 Title 確實有一個反向關聯屬性指向 Post。</p><p>這就是反向關聯的特性，它是「<strong>隱式</strong>」的，這個屬性確實存在。而<strong>反向關聯屬性的名稱就是前述</strong><code>related_name</code><strong>所定義的名稱</strong>，即<code>post</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> title = models.OneToOneField(</span><br><span class="line">     <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure><p>所以，Title 的所有實例，比如有一個實例叫<code>title_1</code>，一定會有一個<strong>反向關聯屬性</strong><code>post</code>，而它的返回值依不同情況有兩種可能：</p><ol><li><code>title_1</code>已經被關聯到某個 Post 實例比如<code>post_1</code>，那<code>title_1.post</code>的值就是該<code>post_1</code>實例。</li><li><code>RelatedObjectDoesNotExist</code>物件。當<strong>實例之間的關聯還不存在</strong>，試圖取得關聯實例將會出現這樣的錯誤。</li></ol><h3 id="反向關聯屬性"><a href="#反向關聯屬性" class="headerlink" title="反向關聯屬性"></a>反向關聯屬性</h3><p>這個<code>post</code>屬性不在 model 中明示，資料表中也<strong>不存在相對應的欄位</strong>——它本質上只是查詢的「捷徑」。</p><p>這種隱式的設計讓我們更容易識別在外鍵關係中，哪個屬性是正向關聯，哪個則是反向關聯。</p><p>反向關聯允許我們透過簡單的屬性呼叫，就能夠輕鬆地獲取相關資料，而不需要額外的操作和查詢語句。</p><hr><h2 id="一對多關係"><a href="#一對多關係" class="headerlink" title="一對多關係"></a>一對多關係</h2><blockquote><p>class <code>ForeignKey</code>(to, on_delete, **<strong>options</strong>) <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey">¶</a></p></blockquote><blockquote><p>A <strong>many-to-one</strong> relationship. <strong>Requires two positional arguments</strong>: the class to which the model is related and the <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey.on_delete"><code>on_delete</code></a> option.</p></blockquote><p>我們在前述一對一關係費了很大的功夫將關聯的細節詳加說明，有了上述基礎，理解一對多關係也會容易得多。</p><p>Django 稱<code>ForeignKey</code>為「<strong>many-to-one</strong>」，即多對一關係，從 model 角度看，確實更合理。因為建立這個<code>ForeignKey</code>屬性的 model，必然屬於關係中的「<strong>多方</strong>」。所以是「多對一」。</p><p>不過無論一對多或多對一，主要區別是視角不同，都是同一種關係。下面我還是用「一對多」這個詞進行說明。</p><p>我選擇先講一對一是因為它相對單純，不需要一次理解太多事情。而一對多（或多對一），即 Django 中的 ForeignKey，則有更多參數和變化，但我們依舊只關注其中最重要的部分。</p><h3 id="專案程式碼說明"><a href="#專案程式碼說明" class="headerlink" title="專案程式碼說明"></a>專案程式碼說明</h3><p>毫無疑問，文章和它的留言是一對多關係，一篇文章可以有「0 到多個」留言，注意這個 0 還滿重要的！這也是它和一對一關係很不同的地方。</p><p>回到程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 留言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br></pre></td></tr></table></figure><p>我們可以看到，Comment 有一個欄位叫<code>post</code>，是一個<code>ForeignKey</code>。這個<code>ForeignKey</code>欄位，最常用的參數還是那 3 個，前 2 個前面已經有介紹，在此不贅。</p><p>第 3 個參數仍是<code>related_name</code>，但它的引數值<code>&#39;comments&#39;</code>看起來，和一對一的<code>related_name</code>在命名上有所不同——它是複數！</p><h2 id="related-name-在一對多關係中的重點"><a href="#related-name-在一對多關係中的重點" class="headerlink" title="related_name 在一對多關係中的重點"></a>related_name 在一對多關係中的重點</h2><p>前提已經提過，<code>related_name</code>實際上是為「反向關聯屬性」進行命名。</p><p><code>post</code>屬性的<code>related_name=&#39;comments&#39;</code>意味著，Post model 將得到一個名為「comments」反向關聯屬性。</p><p>一個 Post 實例，假設為<code>post_1</code>，可以透過<code>post_1.comments</code>取得所有和它關聯的 Comment 實例。可能有 1 個、多個，甚至沒有。</p><blockquote><p>這裡有一個細節是，<code>post_1.comments</code>只會先取得「<a href="https://docs.djangoproject.com/en/4.2/ref/models/relations/#django.db.models.fields.related.RelatedManager">關係管理器</a>」物件，再透過該物件取得「由 Comment 關聯實例組成的<code>QuerySet</code>」，比如：<code>post_1.comments.all()</code>。</p></blockquote><p>這和一對一關係中，你呼叫反向關聯屬性時，可能得到一個<strong>關聯實例</strong>或拋出<code>RelatedObjectDoesNotExist</code>有明顯不同。</p><h3 id="related-name-的預設名稱"><a href="#related-name-的預設名稱" class="headerlink" title="related_name 的預設名稱"></a>related_name 的預設名稱</h3><p>如果你在建立欄位時沒有給定<code>related_name</code>引數，那 Django 會自動給你預設名稱。</p><p>在一對一中，預設名稱為外鍵欄位所屬 Model 名稱的小寫。</p><p>參考 Post 的一對一外鍵程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>related_name</code>的預設值就是 Post 的小寫——<code>post</code>。顯然我定義的其實就是預設值而已。一對一時，是否定義<code>related_name</code>影響不大，<strong>因為它的預設值往往就已足夠</strong>。</p><p>在一對多，預設名稱為外鍵欄位所屬 Model 名稱的小寫再加上<code>_set</code>後綴。你可能就未必喜歡這樣的命名了。</p><p>一樣看一下相關程式片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果沒有定義<code>related_name</code>，則被關聯的 Post 將獲得 Django 預設的反向關聯屬性名稱「<code>comment_set</code>」。</p><p>無論是自定義的<code>comments</code>或預設的<code>comment_set</code>，都表達它的內涵是一個「複數」，這是一對多的特色（多對多也是如此）。</p><h3 id="良好的-related-name-命名"><a href="#良好的-related-name-命名" class="headerlink" title="良好的 related_name 命名"></a>良好的 related_name 命名</h3><p>實務中，把這個<code>related_name</code>命名好還是很重要的，雖然大部分時候用單純的複數就可以搞定，就像上面的<code>comments</code>，但為了<strong>增進程式的可讀性</strong>，也有需要你花費巧思的時候，比如下面這段程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Project</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    certificate = models.ForeignKey(<span class="string">&#x27;Certificate&#x27;</span>,</span><br><span class="line">                                    on_delete=models.PROTECT,</span><br><span class="line">                                    related_name=<span class="string">&#x27;used_by_projects&#x27;</span>)</span><br></pre></td></tr></table></figure><p>這裡不再用死板<code>projects</code>來命名，因為當你透過<code>Certificate</code>物件要訪問「<strong>使用該憑證的專案</strong>」時，<code>certificate.used_by_projects</code>顯然會比<code>certificate.projects</code><strong>更具描述性</strong>，其他開發者也能迅速理解這個欄位的意義與用途。</p><hr><h2 id="小結：關聯是-model-核心"><a href="#小結：關聯是-model-核心" class="headerlink" title="小結：關聯是 model 核心"></a>小結：關聯是 model 核心</h2><p>耗費了如此多的幅篇，詳細講述關聯設定，都是為了強調一個重點：關聯是 Django ORM 的核心之一。</p><p>通過關聯，我們能夠模擬真實世界中的關係，使資料表之間建立起有意義的連結。</p><p>了解一對一和一對多的關聯設定，以及反向關聯屬性的使用，我們能夠更好地應用 Django ORM，建構出高效且具有關聯性的資料模型。</p><p>而辛苦建立這些模型與關聯，就是為了能夠充分利用它們！</p><p>下篇文章將探討，如何有效對這些關聯模型進行查詢，輕鬆地從模型中檢索和篩選所需的資料。</p><p>請敬期待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/yK0Us6a.jpg&quot; alt=&quot;by Léo Alexandre&quot;&gt;&lt;/p&gt;
&lt;p&gt;工作上使用 Django 近 2 年，卻很少發表關於 Django 主題的文章，是時候該來補一補了。&lt;/p&gt;
&lt;p&gt;就從 Django ORM 開始吧！因為 Django ORM 可以說是無論你怎麼使用 Django（全端或前後端分離），都不得不學的核心部分。&lt;/p&gt;
&lt;p&gt;怎麼說？我們先來看看，在「前後端分離」的開發趨勢下，Django 的三大核心——MTV——的重要性有哪些變動。&lt;/p&gt;</summary>
    
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="ORM" scheme="https://blog.kyomind.tw/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>19，AI 時代的生存指南（二）數位斷捨離</title>
    <link href="https://blog.kyomind.tw/weekly-review-19/"/>
    <id>https://blog.kyomind.tw/weekly-review-19/</id>
    <published>2023-06-10T11:27:31.000Z</published>
    <updated>2023-07-11T18:27:35.067Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>上一篇〈<a href="https://blog.kyomind.tw/weekly-review-17/">17，AI 時代的生存指南（一）我對 AI 工具的投入與觀望</a>〉並沒有真正進入「生存指南」這個核心主題，只能算是整個系列的前言。</p><p>為避免你忘記，我們再來回顧一下，前一篇所提出的，本系列的宗旨：</p><blockquote><p>我期望這系列和一般談論 AI 文章的一個核心差別是：<strong>它們主要用來「降低」AI 資訊焦慮，而非增加。</strong></p></blockquote><blockquote><p>更具體地說，這個系列是「<strong>我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄</strong>」，這樣才有趣。</p></blockquote><p>而本篇要探討的，就是這系列最核心的「生存手段」：數位斷捨離。</p><p>數位斷捨離（Digital Declutter）作家卡爾．紐波特（Cal Newport）在其著作《<a href="https://www.books.com.tw/products/0010843512">深度數位大掃除</a>》一書中所提出。</p><p>數位斷捨離是一種整理和簡化數位世界的方法，旨在<strong>減少干擾並提升專注力</strong>。通過過濾數位訊息和限制使用數位工具（尤其是社交平台），我們可以節省時間和精力，更好地專注於重要的事情。</p><p>這種方法有助於建立一個更有意義和平衡的數位生活。所以它不止是方法，也是一種「<strong>價值觀與實踐</strong>」。</p><p>概念理解上沒什麼困難，但實踐起來可遠遠不是如此。</p><span id="more"></span><h2 id="本文重點"><a href="#本文重點" class="headerlink" title="本文重點"></a>本文重點</h2><p>這篇文章不會有太多關於「數位斷捨離」的做法與細節討論。而是<strong>試圖推論與強調，它在 AI 時代的重要性，以及在現實世界中所面臨的困難。</strong></p><p>此外，我並非「<a href="https://zh.wikipedia.org/zh-tw/%E6%A5%B5%E7%B0%A1%E4%B8%BB%E7%BE%A9">極簡主義</a>」愛好者，而是屬於「<a href="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/">簡潔主義</a>」的信徒。雖然它們都有一個「簡」字，但後者更強調「<strong>過猶不及、適可而止</strong>」的精神——更重視「<strong>均衡</strong>」。</p><p>理解了上述前提後，讓我們進入正文。</p><hr><h2 id="我的兩篇《深度數位大掃除》心得"><a href="#我的兩篇《深度數位大掃除》心得" class="headerlink" title="我的兩篇《深度數位大掃除》心得"></a>我的兩篇《深度數位大掃除》心得</h2><p>早在 3 年前，還在 <a href="https://medium.com/">Medium</a> 平台創作時期，我就寫過關於《深度數位大掃除》一書的「實踐心得」，即<strong>個人版的數位斷捨離</strong>，前後總共 2 篇：</p><ol><li><a href="https://medium.com/code-and-me/my-digital-declutter-216d472f8251">每天都是一種練習：我的數位斷捨離</a></li><li><a href="https://medium.com/code-and-me/31%E5%A4%A9-%E6%88%91%E7%9A%84%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2%E5%BF%83%E5%BE%97-51289e99ff96">31天：我的數位斷捨離心得</a></li></ol><p>這是個有趣的嘗試，尤其讓我印象深刻的，是第二篇中的這段與這個規則：</p><ul><li><strong>在捷運或公車的「刷卡範圍」內，不得使用手機通話以外的功能</strong></li></ul><blockquote><p>簡單講就是不能滑手機，而且也不能聽音樂。</p></blockquote><blockquote><p>這是一條我無法明確告訴你為什麼值得這麼做，但實踐後仍然建議你嘗試看看的規則。</p></blockquote><blockquote><p>如果真的需要一個理由，或許可以說，在這個我們都自願或被迫保持「連線狀態」的智慧手機時代。在一個人坐捷運無聊難耐，讓你有充分的動機與理由拿出手機消磨（或善加利用）的時候，你卻沒有這麼做，這是沉默而自覺的戰鬥。</p></blockquote><blockquote><p>你靜靜地坐著或站著，看著周圍的人，沉浸在網路的世界裡。而至少在此刻，你選擇不要這麼做。</p></blockquote><p>真的，那幾個月，我上下班坐捷運時，就是這樣傻傻地看著別人滑手機，心癢難耐，甚至不禁想問：「為什麼要制定這種規則來為難自己？我得到了什麼？」</p><p>「我得到了什麼？」不是一個容易回答的問題——因為它的好處並非立竿見影。這也是為何「數位斷捨離」通常很難持續。</p><p>網路上你可以找到不少實踐心得，遵從書中的建議，貫徹為期 1 個月的數位斷捨離。但你很難找到持續超過 3 個月甚至半年的實踐心得，連我自己，最後也大概只堅持了 3 個月，就差不多「<strong>打回原形</strong>」了。</p><h2 id="數位斷捨離常常只是一場短暫的狂歡"><a href="#數位斷捨離常常只是一場短暫的狂歡" class="headerlink" title="數位斷捨離常常只是一場短暫的狂歡"></a>數位斷捨離常常只是一場短暫的狂歡</h2><p>用「<strong>狂歡</strong>」來形容<strong>充滿限制且帶有自律意味</strong>的數位斷捨離，可能有點詭異，卻也不失真實，為什麼？</p><p>因為它富含一種「我將擺脫數位工具成癮並重獲新生」的<strong>期待</strong>。和一般狂歡通常以大鳴大放的形式不同，這種期待蘊含了一股內持、蓄勢待發的力量。它暗潮湧動，使人從情感上，<strong>將其視為達成目標和恢復精神自由的萬靈藥</strong>。</p><p>因此，在實踐數位斷捨離的初期，雖然辛苦，但我們會暫時感到一陣<strong>自由和解脫</strong>。儘管這種過程伴隨著一定的自我限制，但也對於能夠重新獲得對自己時間和注意力的<strong>掌控感</strong>到興奮甚至滿足。</p><p>這類「狂歡」形式雖然不常見，但它真實地反映了我們對於解放自己的數位束縛的期待與渴望。</p><p>我承認這種感覺確實「很好」，但這樣的動機是<strong>不健康</strong>的，因為它和所有的狂歡一樣，都有一個<strong>「致命問題」——很難持續。</strong></p><h2 id="為什麼數位斷捨離很難超過-3-個月？"><a href="#為什麼數位斷捨離很難超過-3-個月？" class="headerlink" title="為什麼數位斷捨離很難超過 3 個月？"></a>為什麼數位斷捨離很難超過 3 個月？</h2><p>把數位斷捨離當成是一場狂歡、救贖，或所謂的「數位排毒」，往往註定要失敗。</p><p>試想，數位斷捨離所要對抗的，都是什麼樣的洪水猛獸？</p><p>沒錯，就是那些精心設計，讓你容易非常數位成癮的社交平台與內容平台，比如臉書、Instagram、YouTube、TikTok……等等。</p><p>最關鍵的是，獲取它們的門檻可謂低之又低，近在眼前，唾手可得。因此，社交平台和內容平台所提供的即時滿足感和快樂，往往讓人很難抗拒。</p><h3 id="長路漫漫的數位斷捨離"><a href="#長路漫漫的數位斷捨離" class="headerlink" title="長路漫漫的數位斷捨離"></a>長路漫漫的數位斷捨離</h3><p>相較之下，數位斷捨離就不那麼討喜。它要你自制、找尋替代活動（書中稱之為「<strong>優質的休閒活動</strong>」），還要反思數位工具你對的意義。</p><p>要求還真多。</p><p>前期，你確實可以藉由上述的「<strong>期待</strong>」來支持，但這樣的期待也是種<strong>有限資源</strong>。把數位斷捨離當作是一種「<strong>自我救贖</strong>」，確實可以成為堅持的動力——最多持續 1 個月。</p><p>1 個月以後，期待帶來的初始動力散去，我們就很容易陷入「<strong>我得到了什麼？</strong>」茫然。</p><h3 id="數位斷捨離的意義與價值"><a href="#數位斷捨離的意義與價值" class="headerlink" title="數位斷捨離的意義與價值"></a>數位斷捨離的意義與價值</h3><p>如果「我得到了什麼？」的答案，對你來說<strong>還不夠清晰</strong>，那麼<strong>放棄</strong>恐怕是<strong>遲早的事情</strong>，因為回到原點比茫然堅持，可要容易得太多。</p><p>然而，我更想<strong>強調</strong>：這個問題的答案，<strong>幾乎不可能一開始就很清晰</strong>。因為，數位斷捨離的意義，往往是需要你<strong>透過實踐</strong>才能<strong>慢慢體會</strong>的。</p><p>不止實踐，你還需要<strong>時間</strong>與<strong>自我理解</strong>。</p><p>所以我們可以看到，網路確實上有不少篇心得，講述自己如何實踐了為期 30 天的數位斷捨離，那感覺，是多麼地讓人神清氣爽、重獲新生。</p><p><strong>然後，就沒有然後了。</strong></p><hr><h2 id="我為何重拾數位斷捨離？"><a href="#我為何重拾數位斷捨離？" class="headerlink" title="我為何重拾數位斷捨離？"></a>我為何重拾數位斷捨離？</h2><p>說了那麼多，都是在唱衰數位斷捨離，難道真的沒救了嗎？</p><p>我想其中的奇妙之處正在於，本來我也覺得「算了，就這樣吧！要持續貫徹，需要長期的嘗試與不斷改善規則」。</p><p>對我來說這也不是不可能，作為曾經全職準備國考與軟體工程師轉職的人（就是待業時間很長的意思），有很多「建立個人長期制度」的經驗（包括很多失敗經驗），我知道怎麼做能更接近「<strong>可持續性</strong>」。</p><p>換言之，我對一件事情「能否持續」的<strong>敏感度</strong>，還是比較高的。</p><p>所以我才會猶豫不前，因為我知道這件事的難度。</p><h3 id="值得嗎？"><a href="#值得嗎？" class="headerlink" title="值得嗎？"></a>值得嗎？</h3><p>還是那個問題「值得嗎？」——這是個大哉問。</p><p>對我而言，以往是的答案是「<strong>我不確定</strong>」。而現在或許值得了，因為 AI 時代到來。</p><p>AI 帶給我的「<strong>資訊煩躁感（資訊焦慮）</strong>」，讓我感到「<strong>必須要做些什麼</strong>」應對。</p><p>這不是因為資訊量隨 AI 的爆發而再度遽增（我覺得這反而是相對無關緊要的部分），而是「<strong>做事的方法</strong>」因為 AI 而改變了。</p><p>所以，作為渺小的人類，對抗資訊焦慮的「<strong>防禦手段</strong>」也得跟著升級才行。那麼，什麼才是真正有效的手段？</p><p>思來想去，我最終的答案<strong>還是——數位斷捨離</strong>。</p><h2 id="內心的平靜"><a href="#內心的平靜" class="headerlink" title="內心的平靜"></a>內心的平靜</h2><p>說了那麼多，其實我們所求的，不過就是「<strong>內心的平靜</strong>」而已。</p><p>然而內心的平靜卻也是世上最易失又難得的珍貴體驗，我們只能一步一步靠近。</p><h3 id="目前的具體做法"><a href="#目前的具體做法" class="headerlink" title="目前的具體做法"></a>目前的具體做法</h3><p>一開始說不會講太多做法，但還是要提一下，才好想像我的數位斷捨離的具體內容。</p><p>目前我實踐中的數位斷捨離規則大致如下：</p><ol><li>每天早上 9 點到下午 6 點，不登入 Line 桌面版。</li><li>身體接觸床面時，存取手機不得超過一分鐘！（防止睡前滑手機行為）</li><li>半夜 1 點到早上 6 點，不聽任何多媒體的聲音。</li><li>河濱散步時，不存取、使用手機。（培養發散思維模式）</li><li>少用臉書。</li></ol><p>咦？怎麼沒有搭公車、捷運不能用手機那條？本來有的，但太難了，只好暫時捨棄🫡</p><p>規則的組成與細節，會一直變動，達到「有效且可持續」的部分，才會漸漸確定下來。</p><p>毫無疑問，這會是一個<strong>不算短的過程</strong>，1 個月是絕對不夠的。因為能堅持 1 個月的事，未必能堅持 3 個月。</p><hr><h2 id="結語：3-個月只是開端"><a href="#結語：3-個月只是開端" class="headerlink" title="結語：3 個月只是開端"></a>結語：3 個月只是開端</h2><p>1 個月也好，3 個月也罷，它們都只是漫長人生中的一小部分。僅僅在這麼短的時間內達成數位斷捨離，很難帶來本質上的改變。</p><p>數位斷捨離的目的不僅僅是在短期內達成某個特定的目標，而是<strong>要在局部，永久地建立有別於以往的生活方式。</strong></p><p>在開始之前，我們要先嚴肅地認知到：<strong>這真的很難</strong>——凡是改變都很難。</p><p>數位斷捨離是<strong>習慣的養成</strong>，從更高的角度看，更是一種「<strong>價值取捨</strong>」。</p><p>有些東西——哪怕是好東西——你必須<strong>捨棄</strong>，才能換得幾分<strong>心靈上的平靜</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-17/&quot;&gt;17，AI 時代的生存指南（一）我對 AI 工具的投入與觀望&lt;/a&gt;〉並沒有真正進入「生存指南」這個核心主題，只能算是整個系列的前言。&lt;/p&gt;
&lt;p&gt;為避免你忘記，我們再來回顧一下，前一篇所提出的，本系列的宗旨：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我期望這系列和一般談論 AI 文章的一個核心差別是：&lt;strong&gt;它們主要用來「降低」AI 資訊焦慮，而非增加。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;更具體地說，這個系列是「&lt;strong&gt;我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄&lt;/strong&gt;」，這樣才有趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而本篇要探討的，就是這系列最核心的「生存手段」：數位斷捨離。&lt;/p&gt;
&lt;p&gt;數位斷捨離（Digital Declutter）作家卡爾．紐波特（Cal Newport）在其著作《&lt;a href=&quot;https://www.books.com.tw/products/0010843512&quot;&gt;深度數位大掃除&lt;/a&gt;》一書中所提出。&lt;/p&gt;
&lt;p&gt;數位斷捨離是一種整理和簡化數位世界的方法，旨在&lt;strong&gt;減少干擾並提升專注力&lt;/strong&gt;。通過過濾數位訊息和限制使用數位工具（尤其是社交平台），我們可以節省時間和精力，更好地專注於重要的事情。&lt;/p&gt;
&lt;p&gt;這種方法有助於建立一個更有意義和平衡的數位生活。所以它不止是方法，也是一種「&lt;strong&gt;價值觀與實踐&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;概念理解上沒什麼困難，但實踐起來可遠遠不是如此。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="簡潔主義" scheme="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/"/>
    
    <category term="資訊焦慮" scheme="https://blog.kyomind.tw/tags/%E8%B3%87%E8%A8%8A%E7%84%A6%E6%85%AE/"/>
    
    <category term="數位斷捨離" scheme="https://blog.kyomind.tw/tags/%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
  </entry>
  
  <entry>
    <title>Poetry + pyenv 實戰心得：常用指令與注意事項</title>
    <link href="https://blog.kyomind.tw/poetry-pyenv-practical-tips/"/>
    <id>https://blog.kyomind.tw/poetry-pyenv-practical-tips/</id>
    <published>2023-06-05T15:01:08.000Z</published>
    <updated>2023-06-22T05:39:39.761Z</updated>
    
    <content type="html"><![CDATA[<!-- ![from Pixabay](https://i.imgur.com/yODxmxJ.jpg) --><p><img src="https://i.imgur.com/npnmhFE.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>〈<a href="https://blog.kyomind.tw/python-poetry/">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a>〉發表至今，已過了 1 年多，這意味我也用了一年多的 Poetry。</p><p>感覺如何？——我覺得還不錯！可見不是三分鐘熱度而已。</p><p>對現在的我而言，Poetry 已成為專案開發不可或缺的元素。它不僅提供了更加便捷的專案套件管理和版本控制，同時，Poetry 支援 pyproject.toml 作為設定檔的特性，也使得我更容易使用其他也採用 pyproject.toml 的工具。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pyproject-toml/">pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學</a></p></blockquote><h3 id="系列：Python-Poetry-三部曲"><a href="#系列：Python-Poetry-三部曲" class="headerlink" title="系列：Python Poetry 三部曲"></a>系列：Python Poetry 三部曲</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/python-poetry/">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a></li><li><strong>Poetry + pyenv 實戰心得：常用指令與注意事項</strong></li><li>終結 requirements.txt：Dockerfile 多階段建構 Poetry 虛擬環境（待發表）</li></ol></blockquote><span id="more"></span><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文將補充系列第一篇中在「<a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E5%B8%B8%E8%A6%8B%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%83%E8%88%87%E6%93%8D%E4%BD%9C-QA">情境使用</a>」方面的不足之處，尤其是針對 Poetry 和 pyenv 同時使用時可能出現的問題進行討論。這是第一篇所遺漏的內容。</p><p>透過本文，我希望能夠提供更全面、更實用的 Poetry 使用建議，讓讀者在使用 Poetry 和 pyenv 時能夠充分發揮它們的優勢，並減少不必要的困惑。</p><h3 id="以-poetry-demo-為例"><a href="#以-poetry-demo-為例" class="headerlink" title="以 poetry-demo 為例"></a>以 poetry-demo 為例</h3><p>poetry-demo 是本文作為例示的專案模版，但我們不會安裝太多套件，僅各取一個作為示範之用。</p><p>有一個簡單的具體實例，還是比抽象的描述容易理解得多。</p><p>我們會從一台全新的 Linux VM（Ubuntu 20.04）開始，先安裝 pyenv，再安裝 Poetry，然後再一起使用它們，建立 Python 專案與虛擬環境。</p><h3 id="使用的-Poetry-版本：1-5-1"><a href="#使用的-Poetry-版本：1-5-1" class="headerlink" title="使用的 Poetry 版本：1.5.1"></a>使用的 Poetry 版本：1.5.1</h3><p>Poetry 在 1.2 版後，對於部分指令進行有較大的改動與擴張，導致舊指令使用上不完全相容，這次會採用當前的最新版——<a href="https://github.com/python-poetry/poetry/releases/tag/1.5.1">1.5.1</a>——來進行示範。</p><h3 id="使用的-pyenv-版本：2-3-18"><a href="#使用的-pyenv-版本：2-3-18" class="headerlink" title="使用的 pyenv 版本：2.3.18"></a>使用的 pyenv 版本：2.3.18</h3><p>pyenv 在 v2.3.0 以後，已經<a href="https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv">大幅簡化了設定操作</a>，所以這裡也有必要強調一下使用的版本：<a href="https://github.com/pyenv/pyenv/releases/tag/v2.3.18">v2.3.18</a>。</p><p>相關文章也有就新版設定內容進行更新，可參考〈<a href="https://blog.kyomind.tw/ubuntu-pyenv/#%E8%A8%AD%E5%AE%9A-pyenv">Ubuntu 安裝使用 pyenv + pyenv-virtualenv</a>〉。</p><h2 id="安裝-Poetry、pyenv、Python-3-10"><a href="#安裝-Poetry、pyenv、Python-3-10" class="headerlink" title="安裝 Poetry、pyenv、Python 3.10"></a>安裝 Poetry、pyenv、Python 3.10</h2><p>請直接參考〈<a href="https://blog.kyomind.tw/linux-dev-setup/">Linux Python 開發環境設定：zsh、zinit、pyenv、poetry、docker</a>〉中的「<a href="https://blog.kyomind.tw/linux-dev-setup/#%E4%B8%89%E3%80%81%E8%A8%AD%E5%AE%9A-pyenv">三、設定 pyenv</a>」、「<a href="https://blog.kyomind.tw/linux-dev-setup/#%E5%9B%9B%E3%80%81%E8%A8%AD%E5%AE%9A-Poetry">四、設定 Poetry</a>」部分。</p><p>不只是安裝，還包括設定 PATH 等環節，這些步驟都是必要的。完成這些步驟後，我們就擁有了 Poetry 和 pyenv。</p><h3 id="透過-pyenv-安裝-Python-3-10-11"><a href="#透過-pyenv-安裝-Python-3-10-11" class="headerlink" title="透過 pyenv 安裝 Python 3.10.11"></a>透過 pyenv 安裝 Python 3.10.11</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.10.11</span><br></pre></td></tr></table></figure><p>pyenv 是為了方便我們管理多個 Python 版本，下面我們會探討不同專案分別使用多個 Python 版本時的 Poetry + pyenv 操作注意事項。</p><p>這裡至少要先有一個 Python 版本，才能順利安裝我們的專案，在此以 <a href="https://www.python.org/downloads/release/python-31011/">Python 3.10.11</a> 為例。</p><h2 id="Poetry-與-pyenv-的部分功能重疊"><a href="#Poetry-與-pyenv-的部分功能重疊" class="headerlink" title="Poetry 與 pyenv 的部分功能重疊"></a>Poetry 與 pyenv 的部分功能重疊</h2><p>安裝完後，是否要設定<code>pyenv local 3.10.11</code>或<code>pyenv global 3.10.11</code>，取決於你是否有「多專案且多種 Python 版本」需求。</p><p>如果只需要一種 Python 版本，那將其設定為<code>global</code>已足：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global 3.10.11</span><br></pre></td></tr></table></figure><p>如<a href="https://blog.kyomind.tw/linux-dev-setup/">前述文章</a>所言：</p><blockquote><p>因為 Poetry 自帶了虛擬環境管理功能，容易和 pyenv-virtualenv <strong>疊床架屋</strong>，徒增<strong>管理上的混淆</strong>，所以<strong>我現在一律只使用 Poetry + venv 來管理 Python 虛擬環境</strong>。</p></blockquote><p>即使在不同專案需要多版本 Python 情況下，pyenv-virtualenv 也不是必須。只要善用<code>pyenv local</code>和<code>poetry env use</code>兩大指令即可。</p><p>綜上所述，這也是為什麼我認為 Poetry 的教學<strong>應該涵蓋對 pyenv 的整合</strong>，因為在「虛擬環境管理」方面，兩者的功能有一定重疊。</p><hr><p>前置作業總算大功告成，我們開始建立 poetry-demo 吧！</p><h2 id="一、初始化-Poetry-專案"><a href="#一、初始化-Poetry-專案" class="headerlink" title="一、初始化 Poetry 專案"></a>一、初始化 Poetry 專案</h2><p>先確認一下當前的 Poetry 版本，使用<code>poetry --version</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry --version</span><br><span class="line">Poetry (version 1.4.2)</span><br></pre></td></tr></table></figure><p>我的 Poetry 是一段時間前安裝的 1.4.2，需要更新一下，以符合本文使用的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry self update</span><br><span class="line"></span><br><span class="line">Using version ^1.5.1 <span class="keyword">for</span> poetry</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (2.6s)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Package operations: 0 installs, 5 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Updating platformdirs (2.6.2 -&gt; 3.5.1)</span><br><span class="line">  • Updating poetry-core (1.5.2 -&gt; 1.6.1)</span><br><span class="line">  • Updating poetry-plugin-export (1.3.1 -&gt; 1.4.0)</span><br><span class="line">  • Updating virtualenv (20.21.1 -&gt; 20.23.0)</span><br><span class="line">  • Updating poetry (1.4.2 -&gt; 1.5.1)</span><br></pre></td></tr></table></figure><p>因為是使用全域安裝 Poetry，上面的套件更新訊息和專案的虛擬環境無關——畢竟我們根本都還沒有為專案建立專屬的 Python 虛擬環境！</p><p>也可以指定要升級的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry self update 1.5.1</span><br></pre></td></tr></table></figure><h3 id="使用poetry-init初始化專案"><a href="#使用poetry-init初始化專案" class="headerlink" title="使用poetry init初始化專案"></a>使用<code>poetry init</code>初始化專案</h3><p>確認完 Poetry 版本，開始建立專案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> poetry-demo</span><br><span class="line"><span class="built_in">cd</span> poetry-demo</span><br><span class="line">poetry init</span><br></pre></td></tr></table></figure><p><code>poetry init</code>會出現下列互動式訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">This <span class="built_in">command</span> will guide you through creating your pyproject.toml config.</span><br><span class="line"></span><br><span class="line">Package name [poetry-demo]:</span><br><span class="line">Version [0.1.0]:</span><br><span class="line">Description []:</span><br><span class="line">Author [kyo &lt;odinxp@gmail.com&gt;, n to skip]:</span><br><span class="line">License []:</span><br><span class="line">Compatible Python versions [^3.8]:</span><br><span class="line"></span><br><span class="line">Would you like to define your main dependencies interactively? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>] no</span><br><span class="line">Would you like to define your development dependencies interactively? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>] no</span><br><span class="line">Generated file</span><br><span class="line"></span><br><span class="line">[tool.poetry]</span><br><span class="line">name = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">description = <span class="string">&quot;&quot;</span></span><br><span class="line">authors = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line">readme = <span class="string">&quot;README.md&quot;</span></span><br><span class="line">packages = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line">build-backend = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br><span class="line"></span><br><span class="line">Do you confirm generation? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>]</span><br></pre></td></tr></table></figure><p>中間的「Would you like to define your <strong>main&#x2F;development</strong> dependencies interactively?」兩個問句，我都回答「no」，最後一個則是「yes」。</p><p>初始化後的<code>pyproject.toml</code>內容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">readme</span> = <span class="string">&quot;README.md&quot;</span></span><br><span class="line"><span class="attr">packages</span> = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到其中有一行「<code>readme = &quot;README.md&quot;</code>」，此時專案必須有<code>README.md</code>，否則會找不到檔案。我都直接刪除該行，比較省事。</p><h3 id="使用poetry-new快速初始化"><a href="#使用poetry-new快速初始化" class="headerlink" title="使用poetry new快速初始化"></a>使用<code>poetry new</code>快速初始化</h3><p>要達到專案初始化的效果，你也可以直接用<code>poetry new poetry-demo</code>指令，更快速！不過它也會幫你做「更多事」，細節請參考<a href="https://python-poetry.org/docs/basic-usage/#project-setup">文件</a>。</p><h2 id="二、為專案建立-Python-虛擬環境"><a href="#二、為專案建立-Python-虛擬環境" class="headerlink" title="二、為專案建立 Python 虛擬環境"></a>二、為專案建立 Python 虛擬環境</h2><p>這裡是「重頭戲」之一，但做法上並不是那麼「直觀」，常常容易讓人混淆。僅使用 pyenv 的前提下，再安裝<code>pyenv-virtualenv</code>來建立虛擬環境，確實不難。</p><p>但現在有了 Poetry，兩者的搭配使用方式就很重要，這也是為什麼我一再強調，有了 Poetry，乾脆就不要再裝<code>pyenv-virtualenv</code>了。</p><h3 id="使用-Poetry-建立虛擬環境"><a href="#使用-Poetry-建立虛擬環境" class="headerlink" title="使用 Poetry 建立虛擬環境"></a>使用 Poetry 建立虛擬環境</h3><p>在第一篇文章中，雖然我提過<code>poetry shell</code>有時候可以替代<code>poetry env use</code>，作為快速建立虛擬環境的便捷手段。</p><p>但是，當你還沒有為專案建立虛擬環境，且作業系統中包含了不止一個 Python 版本時，建議就不要用<code>poetry shell</code>來建立虛擬環境——因為它很可能會選擇不是你要的 Python 版本。</p><p>儘管我們使用 pyenv 來管理 Python，但完整的 Linux 發行版往往都自帶了系統的 Python。比如我的 Ubuntu 就自帶了 3.8.x，這正是為何上面<code>pyproject.toml</code>會有一行「<code>python = &quot;^3.8&quot;</code>」而不是<code>^3.10</code>——因為 Poetry 偵測到的是系統預設的 Python，而不是 pyenv 的 Poetry。</p><p>換句話說，無論透過 pyenv 安裝了幾個 Python 版本，<strong>這些資訊對 Poetry 而言，仍可能是陌生的。</strong></p><p>為了讓 Poetry 在建立虛擬環境時，能確實使用<strong>你想要的 Python 版本</strong>，我們必須善用<code>poetry env use</code>指令才行。</p><h2 id="三、確定專案使用的-Python-版本"><a href="#三、確定專案使用的-Python-版本" class="headerlink" title="三、確定專案使用的 Python 版本"></a>三、確定專案使用的 Python 版本</h2><p>第一篇文章中也提到：</p><blockquote><p>我覺得學習 Poetry 的<strong>第一道關卡</strong>，就是它對於<strong>虛擬環境</strong>的管理。</p></blockquote><p>現在看來一點也沒錯！</p><h3 id="指定虛擬環境-Python-版本的標準做法"><a href="#指定虛擬環境-Python-版本的標準做法" class="headerlink" title="指定虛擬環境 Python 版本的標準做法"></a>指定虛擬環境 Python 版本的標準做法</h3><p>在使用 pyenv 的情況下，<a href="https://python-poetry.org/docs/managing-environments/">Poetry 官方文件</a>有補充一個讓你能「確定」虛擬環境會使用的 Python 版本的做法：</p><blockquote><p>If you use a tool like <strong><a href="https://github.com/pyenv/pyenv">pyenv</a></strong> to manage different Python versions, you can set the <strong>experimental</strong> <code>virtualenvs.prefer-active-python</code> option to <code>true</code>. Poetry will then try to find the current <code>python</code> of your shell.</p></blockquote><p>其中的「experimental」表示這是一個實驗性功能。所以我不偏好這個做法。</p><blockquote><p>For instance, if your project requires a newer Python than is available with your system, a standard workflow would be:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.9.8</span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.8  <span class="comment"># Activate Python 3.9 for the current project</span></span><br><span class="line">poetry install</span><br></pre></td></tr></table></figure><p>主要分成兩個步驟：</p><ol><li>將<code>virtualenvs.prefer-active-python</code>設為<code>true</code>。</li><li>使用 pyenv 的<code>pyenv local</code>指令。</li></ol><h3 id="我偏好的做法：poetry-env-use"><a href="#我偏好的做法：poetry-env-use" class="headerlink" title="我偏好的做法：poetry env use"></a>我偏好的做法：<code>poetry env use</code></h3><p>如果你只確定需要「<strong>一個</strong>」Python 版本，且已經將其設定為<code>global</code>，那麼前述的<code>virtualenvs.prefer-active-python</code>設定，或可省略。</p><p><code>poetry env use</code>有下列幾種用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use /full/path/to/python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use python3.7</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use 3.7</span><br></pre></td></tr></table></figure><p>後三者的<code>python</code>、<code>python3.7</code>或<code>3.7</code>，都和你的<code>PATH</code>有關。</p><p>換句話說，如果你在終端機打<code>python3.7</code>，有成功進入「<a href="https://learn.microsoft.com/zh-tw/visualstudio/python/python-interactive-repl-in-visual-studio?view=vs-2022">Python 互動式視窗</a>」，那就表示這個版本的 Python 確實存在<code>PATH</code>中。</p><h3 id="使用which指令確認-Python-版本是否存在PATH中"><a href="#使用which指令確認-Python-版本是否存在PATH中" class="headerlink" title="使用which指令確認 Python 版本是否存在PATH中"></a>使用<code>which</code>指令確認 Python 版本是否存在<code>PATH</code>中</h3><p>不想進入 REPL，只想確認 Python 版本是否存在<code>PATH</code>中，可以使用<code>which</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">which</span> python3.9</span><br><span class="line">/home/kyo/.pyenv/shims/python3.9</span><br><span class="line">❯ <span class="built_in">which</span> python3.10</span><br><span class="line">/home/kyo/.pyenv/shims/python3.10</span><br><span class="line">❯ <span class="built_in">which</span> python</span><br><span class="line">/home/kyo/.pyenv/shims/python</span><br></pre></td></tr></table></figure><p>聰明的你應該猜到了，我們只要確保 Python 版本已存在於<code>PATH</code>，透過<code>poetry env use &lt;指定的python版本&gt;</code>即可確定專案使用的 Python 版本。</p><p>不過，這個<code>&lt;指定的python版本&gt;</code>必須要先透過 pyenv 安裝好，<strong>而且你通常要將其設定為<code>global</code>或<code>local</code>，系統才找得到。</strong></p><h3 id="poetry-demo-操作"><a href="#poetry-demo-操作" class="headerlink" title="poetry-demo 操作"></a>poetry-demo 操作</h3><p>回到案例，這裡我們已經將 3.10.11 設為<code>global</code>。所以輸入<code>python3.10</code>指令時，會進入互動式視窗。</p><p>此時只要使用下列指令，基本上可以確定使用的 Python 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use 3.10.11</span><br></pre></td></tr></table></figure><p>因為已經有設定<code>global</code>，單純使用<code>poetry env use python</code>應該也是可以成功套用 3.10。但保險起見，使用指令時還是建議輸入<strong>完整的版本號</strong>，包括尾綴的<code>.11</code></p><h2 id="四、不同專案使用不同-Python-版本"><a href="#四、不同專案使用不同-Python-版本" class="headerlink" title="四、不同專案使用不同 Python 版本"></a>四、不同專案使用不同 Python 版本</h2><p>即使有「多專案多 Python 版本」需求，也未必要變更前述的<code>virtualenvs.prefer-active-python</code>設定。</p><p>透過<code>pyenv local</code>+<code>poetry env use</code>，可以為不同專案設定不同的 Python 版本。</p><p>假設你有 a、b、c 三個專案，分別要使用 Python 3.7.11、3.9.12、3.10.11，依照前段介紹，我們可以這麼做。</p><p>首先，<code>pyenv versions</code>確認這三個版本的 Python 都已經由 pyenv 安裝完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ pyenv versions</span><br><span class="line">  system</span><br><span class="line">  3.7.11</span><br><span class="line">  3.9.12</span><br><span class="line">* 3.10.11 (<span class="built_in">set</span> by /home/kyo/.pyenv/version)</span><br></pre></td></tr></table></figure><p>接下來就很簡單了，為各專案設定好<code>pyenv local</code>（好讓<code>PATH</code>可以成功找到對應的 Python 執行檔），然後再<code>poetry env use &lt;指定的python版本&gt;</code>。</p><p>假設 b 專案要使用 3.9.12，則做法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> b</span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.12</span><br><span class="line">poetry <span class="built_in">env</span> use 3.9.12</span><br></pre></td></tr></table></figure><p>其餘專案以此類推。</p><h2 id="五、如何移除-Poetry-虛擬環境？"><a href="#五、如何移除-Poetry-虛擬環境？" class="headerlink" title="五、如何移除 Poetry 虛擬環境？"></a>五、如何移除 Poetry 虛擬環境？</h2><p>參考<a href="https://python-poetry.org/docs/managing-environments/#deleting-the-environments">文件</a>，標準做法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> remove /full/path/to/python</span><br><span class="line">poetry <span class="built_in">env</span> remove python3.7</span><br><span class="line">poetry <span class="built_in">env</span> remove 3.7</span><br><span class="line">poetry <span class="built_in">env</span> remove test-O3eWbxRl-py3.7</span><br></pre></td></tr></table></figure><p>然而，因為我們已經將<code>virtualenvs.in-project</code>改設為<code>true</code>，也就是直接在專案中建立名為<code>.venv</code>的虛擬環境。</p><p>上述的指令基本都沒有作用了。</p><blockquote><p>但我就真的需要砍掉重練啊！怎麼辦？</p></blockquote><h3 id="兩個方法"><a href="#兩個方法" class="headerlink" title="兩個方法"></a>兩個方法</h3><p>此時還有兩個簡單的方法可用。</p><p>方法一，就是直接砍掉<code>.venv</code>，簡單有效！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .venv</span><br></pre></td></tr></table></figure><p>方法二，我們依舊可以使用下列指令，優雅地移除它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry <span class="built_in">env</span> remove --all</span><br><span class="line">Deleted virtualenv: /home/kyo/poetry-demo/.venv</span><br></pre></td></tr></table></figure><hr><p>光專案初始化與虛擬環境管理就用掉了 5 個 h2 標題，可見其複雜。現在，我們進入第二部分——套件的安裝與管理。</p><h2 id="六、安裝套件至-main-dependencies"><a href="#六、安裝套件至-main-dependencies" class="headerlink" title="六、安裝套件至 main dependencies"></a>六、安裝套件至 main dependencies</h2><p>使用<code>poetry add</code>指令。</p><p>參考<a href="https://python-poetry.org/docs/cli/#add">文件</a>，可以發現<code>add</code>指令的用法還挺多元的！</p><p>我覺得對一般使用者而言，<code>poetry add</code>有兩個重點：</p><ol><li>了解<code>poetry add</code>的「多階段行為」。</li><li>了解<code>--group</code>參數用法。</li></ol><h3 id="重點一：poetry-add多階段行為"><a href="#重點一：poetry-add多階段行為" class="headerlink" title="重點一：poetry add多階段行為"></a>重點一：<code>poetry add</code>多階段行為</h3><p>如上篇文章所言，<code>poetry add</code>實際上會做 3 件事，依序為：</p><ol><li>更新<code>pyproject.toml</code>。</li><li>依照<code>pyproject.toml</code>的內容，更新<code>poetry.lock</code>。（相當於<code>poetry lock</code>）</li><li>依照<code>poetry.lock</code>的內容，更新虛擬環境。（相當於<code>poetry install</code>）</li></ol><blockquote><p>為什麼知道這個很重要？</p></blockquote><p>因為當你不是使用<code>poetry add</code>指令，而是直接修改<code>pyproject.toml</code>時，此時上述的第 2、3 步<strong>都不會自動執行</strong>。</p><p>但通常你手動修改 toml 檔最終都是為了變更虛擬環境，所以更新完<code>pyproject.toml</code>後，我們還要再使用<code>poetry lock</code>與<code>poetry install</code>指令才行！</p><p>對於不熟悉上述流程的初學者，很容易遺漏，並感到困惑。</p><h3 id="重點二：-group"><a href="#重點二：-group" class="headerlink" title="重點二：--group"></a>重點二：<code>--group</code></h3><p><strong>舊版</strong>（1.1）只有 main 和 dev 兩種依賴環境設定，<strong>新版</strong>（1.2）增加了<code>--group</code>參數，讓你可以除了 main 和 dev 外，還有能自訂多種 group，增加使用上的彈性。</p><p>比如可以命名不同的群組如下：</p><ul><li>test</li><li>dev</li><li>prod</li></ul><p>基本語法（後續還會提及）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add pytest --group <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>在新版（1.2）的<code>pyproject.toml</code>中會如此記載：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.group.test.dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;^6.0.0&quot;</span></span><br><span class="line"><span class="attr">pytest-mock</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>而舊版則是：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Poetry pre-1.2.x style, understood by Poetry 1.0–1.2</span></span><br><span class="line"><span class="section">[tool.poetry.dev-dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;^6.0.0&quot;</span></span><br><span class="line"><span class="attr">pytest-mock</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>兩者的<strong>差異</strong>，是版本過渡時要特別注意的。</p><p>雖然彈性變大，但我個人目前還是只有使用 main 和 dev 而已。</p><h3 id="poetry-demo-操作-1"><a href="#poetry-demo-操作-1" class="headerlink" title="poetry-demo 操作"></a>poetry-demo 操作</h3><p>至此，我們也安裝 Django 3.2.x 至 main dependencies 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry add django@^3.2</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (0.5s)</span><br><span class="line"></span><br><span class="line">Package operations: 5 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing typing-extensions (4.6.3)</span><br><span class="line">  • Installing asgiref (3.7.2)</span><br><span class="line">  • Installing pytz (2023.3)</span><br><span class="line">  • Installing sqlparse (0.4.4)</span><br><span class="line">  • Installing django (3.2.19)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br></pre></td></tr></table></figure><p>這個<code>@</code>符號（運算子）要怎麼用，請參考<a href="https://python-poetry.org/docs/dependency-specification/#using-the--operator">文件</a>。</p><h2 id="七、安裝套件至-dev-dependencies"><a href="#七、安裝套件至-dev-dependencies" class="headerlink" title="七、安裝套件至 dev dependencies"></a>七、安裝套件至 dev dependencies</h2><p>上篇文章中，我們已經探討過「<a href="https://blog.kyomind.tw/python-poetry/#%E6%96%B0%E5%A2%9E%E5%A5%97%E4%BB%B6%E8%87%B3-dev-dependencies">明確區分開發環境專用的套件</a>」的重要性。</p><p>舊版的指令是這樣的，以<code>black</code>為例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry add black --dev</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">poetry add black -D</span><br></pre></td></tr></table></figure><p>然而<code>--dev (-D)</code>在新版<a href="https://python-poetry.org/docs/cli/#options-4">已棄用</a>：</p><blockquote><p>• <code>--dev (-D)</code>: Add package as development dependency. (Deprecated, use <code>-G dev</code> instead)</p></blockquote><p>因為加入了 group 機制，新版的指令略有不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry add black --group dev</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">poetry add black -G dev</span><br></pre></td></tr></table></figure><p>講白了就是變囉嗦了一點。</p><p>此時的 toml 檔內容如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">packages</span> = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"><span class="attr">django</span> = <span class="string">&quot;^3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.group.dev.dependencies]</span></span><br><span class="line"><span class="attr">black</span> = <span class="string">&quot;^23.3.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure><h2 id="八、poetry-install-sync"><a href="#八、poetry-install-sync" class="headerlink" title="八、poetry install --sync"></a>八、<code>poetry install --sync</code></h2><p>不久前才發現，虛擬環境用久了，安裝的套件似乎和 lock 檔不完全一致！我一直以為兩者是一定同步的🐸，顯然不是。</p><p>參考<a href="https://python-poetry.org/docs/managing-dependencies/#synchronizing-dependencies">文件</a>，可用下列指令確保同步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry install --<span class="built_in">sync</span></span><br></pre></td></tr></table></figure><h2 id="九、Docker-環境中使用-Poetry"><a href="#九、Docker-環境中使用-Poetry" class="headerlink" title="九、Docker 環境中使用 Poetry"></a>九、Docker 環境中使用 Poetry</h2><p>前文中有<a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%94%E3%80%81%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E4%B8%8D%E5%9C%A8-Docker-%E7%92%B0%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Poetry%EF%BC%9F">這麼一段</a>，闡述我不在 Docker 中使用 Poetry 的<strong>理由</strong>與<strong>替代方案</strong>：</p><blockquote><p>所幸 Poetry 依舊可以輸出<code>requirements.txt</code>，Docker 部署環境就繼續使用這個舊方案即可，而且 Poetry 本來主要就是用於「開發」時的套件管理，對部署差別不大。</p></blockquote><p>說是這樣說，但一年多用下來，我發現這個做法也<strong>不盡理想</strong>，它至少存在兩個問題：</p><ol><li>套件有變動時，常常會<strong>忘記匯出</strong><code>requirements.txt</code>：你可以說這是人的問題，但這個 export <code>requirements.txt</code>做法，就真的很容易讓人忘記。</li><li>由 Poetry 匯出的<code>requirements.txt</code>，不一定能透過 pip 正常安裝套件——兩者存在<strong>輕微的相容性問題</strong>。</li></ol><p>怎麼解？我在原文也已經補充了：</p><blockquote><p>使用 <strong><a href="https://docs.docker.com/build/building/multi-stage/">multi-stage builds</a></strong> 的 Dockerfile，可以在第一階段安裝 Poetry，第二階段再把 Poetry 捨棄，這樣就不會有多餘的耦合與依賴了。日後會專文介紹。</p></blockquote><p>對，所以系列的第三篇會把這部分補完。</p>]]></content>
    
    
    <summary type="html">&lt;!-- ![from Pixabay](https://i.imgur.com/yODxmxJ.jpg) --&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/npnmhFE.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;https://blog.kyomind.tw/python-poetry/&quot;&gt;再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;〉發表至今，已過了 1 年多，這意味我也用了一年多的 Poetry。&lt;/p&gt;
&lt;p&gt;感覺如何？——我覺得還不錯！可見不是三分鐘熱度而已。&lt;/p&gt;
&lt;p&gt;對現在的我而言，Poetry 已成為專案開發不可或缺的元素。它不僅提供了更加便捷的專案套件管理和版本控制，同時，Poetry 支援 pyproject.toml 作為設定檔的特性，也使得我更容易使用其他也採用 pyproject.toml 的工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/pyproject-toml/&quot;&gt;pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系列：Python-Poetry-三部曲&quot;&gt;&lt;a href=&quot;#系列：Python-Poetry-三部曲&quot; class=&quot;headerlink&quot; title=&quot;系列：Python Poetry 三部曲&quot;&gt;&lt;/a&gt;系列：Python Poetry 三部曲&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/python-poetry/&quot;&gt;再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Poetry + pyenv 實戰心得：常用指令與注意事項&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;終結 requirements.txt：Dockerfile 多階段建構 Poetry 虛擬環境（待發表）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="pyenv" scheme="https://blog.kyomind.tw/tags/pyenv/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
    <category term="pip" scheme="https://blog.kyomind.tw/tags/pip/"/>
    
    <category term="virtualenv" scheme="https://blog.kyomind.tw/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>18，論軟體工程師常見的「路徑依賴」問題（上）</title>
    <link href="https://blog.kyomind.tw/weekly-review-18/"/>
    <id>https://blog.kyomind.tw/weekly-review-18/</id>
    <published>2023-05-13T20:01:00.000Z</published>
    <updated>2023-05-23T09:29:13.218Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>我常常覺得，軟體工程師可能是最能體現「<a href="https://zh.wikipedia.org/zh-tw/%E5%B7%A5%E5%85%B7%E8%A7%84%E5%BE%8B">當你手裡只有鎚子，看什麼都會像釘子</a>」的一群人😂</p><p>我們在工作中，有時會陷入一種被稱為「<a href="https://zh.wikipedia.org/zh-tw/%E8%B7%AF%E5%BE%84%E4%BE%9D%E8%B5%96">路徑依賴</a>」的困境。本文將探討「路徑依賴」在軟體工程師的工作與職涯發展中，所造成的各種影響和受困者會有的具體表現。</p><p>或許會讓你感到有點熟悉。</p><h2 id="前言：何謂路徑依賴？"><a href="#前言：何謂路徑依賴？" class="headerlink" title="前言：何謂路徑依賴？"></a>前言：何謂路徑依賴？</h2><p>「<strong>路徑依賴</strong>」是個社會科學的概念，用來描述一種現象，即一旦人們在某一方面選擇了特定的路徑或方式，他們就可能變得<strong>過度依賴這條路徑，並且可能難以改變。</strong></p><p>這種依賴性可能源於各種因素，包括習慣、成本、學習曲線等，並可能在多個層面上產生影響，包括個人的行為、團隊的運作，甚至是整個社會的結構和制度。</p><p>在這裡，我們將專注於討論「<strong>軟體工程師常見的路徑依賴</strong>」。以下的內容主要是基於我個人在工作上的觀察，可能會帶有一點偏見，但絕大部分都是基於事實。</p><span id="more"></span><h2 id="何謂軟體工程師的路徑依賴？"><a href="#何謂軟體工程師的路徑依賴？" class="headerlink" title="何謂軟體工程師的路徑依賴？"></a><strong>何謂軟體工程師的路徑依賴？</strong></h2><p>文章標題與開頭把「路徑依賴」稱為一種「<strong>困境</strong>」，這樣的說法可能<strong>有失公允</strong>。</p><p>事實上，在大部分情況下，遵循既定的路徑可以顯著提高效率、增加確定性，同時也是我們發展專業的基礎。</p><p>所以嚴格來說，本文要討論的，是軟體工程師在工作與職涯中，那些「<strong>造成不良影響</strong>」的路徑依賴。</p><p>這類依賴帶來了<strong>一系列問題</strong>，例如<strong>低效率產出、溝通不順暢，甚至限制了我們的視野</strong>。因此，對於軟體工程師來說，了解這些路徑依賴的存在，確實有其必要。</p><p>接下來，我將從我自己以及我曾接觸和共事過的軟體工程師身上，舉出四個常見的路徑依賴觀察實例。</p><p>而且它們會是「<strong>層層遞進</strong>」的關係，從底層的工作細節，到上層的個人職涯選擇，我們無不受到「<strong>軟體工程師</strong>」這個角色的影響（或說「<strong>限制</strong>」）。</p><p>不過礙於篇幅，我們這期<strong>只先講前兩個</strong>。</p><hr><h2 id="一、程式註解的路徑依賴"><a href="#一、程式註解的路徑依賴" class="headerlink" title="一、程式註解的路徑依賴"></a>一、程式註解的路徑依賴</h2><p>首先，讓我們以「程式註解」為例，看看軟體工程師在<strong>為程式碼寫註解</strong>時，如何表現出「<strong>不良的路徑依賴</strong>」。</p><p>所謂的「<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%BB%E8%A7%A3_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">程式註解</a>」，指的是在程式碼中<strong>以特定格式或符號添加的文字或說明</strong>，用於解釋程式碼的功能、邏輯或用途。</p><p>程式註解是為了提供給開發人員或其他讀者（通常是一起開發的工程師）更容易理解和閱讀本段程式碼的<strong>附加資訊</strong>。它們<strong>不會影響程式的執行</strong>，但對於增進開發上的溝通與協作效率，有著重要地位，尤其是程式中<strong>特別複雜</strong>的部分。</p><p>註解通常使用<strong>自然語言</strong>（例如英文、中文）撰寫，而且要力求<strong>好讀、好理解</strong>。</p><h3 id="「程式晶晶體」註解"><a href="#「程式晶晶體」註解" class="headerlink" title="「程式晶晶體」註解"></a>「程式晶晶體」註解</h3><blockquote><p><a href="https://zh.wikipedia.org/zh-tw/%E6%99%B6%E6%99%B6%E9%AB%94">晶晶體</a>是一種流行於臺灣以中文為基底，夾雜英語不成句的單字或片語的表達方式。</p></blockquote><p>某些人在撰寫註解時，容易過度依賴程式碼的「<strong>實作細節</strong>」表達（比如<code>用 excutemany 大量插入資料至 User Table</code>、<code>以 bulk_create 批次建立 obj</code>），而非使用<strong>簡潔清晰的自然語言</strong>（比如<code>將用戶資料存入資料庫</code>、<code>一次性建立大量用戶資料</code>）。</p><p>在中文夾雜大量的程式碼片語，堪稱「<strong>程式晶晶體</strong>」，語意不清、主詞不明，常常讓人無法一望即知。</p><p>其實也有完全用自然語言書寫的註解，但你讀起來並不覺得那是「<strong>通順</strong>」的句子，比較像 10 歲小學生寫的作文。</p><p>為什麼會這樣？因為開發者普遍「<strong>比較擅長</strong>」寫程式，而非文字表達。所以乾脆用寫程式的思路來寫註解——毫無疑問，這樣真的比較輕鬆。</p><p>這種在思考與陳述上，<strong>嚴重依賴程式碼邏輯</strong>的敘事方式，常常導致註解<strong>難以理解</strong>、重複程式碼的內容（即<strong>冗餘的註解</strong>），甚至可能<strong>產生混淆</strong>。</p><h3 id="從他人角度自我審視：為什麼作者都需要好的編輯？"><a href="#從他人角度自我審視：為什麼作者都需要好的編輯？" class="headerlink" title="從他人角度自我審視：為什麼作者都需要好的編輯？"></a>從他人角度自我審視：為什麼作者都需要好的編輯？</h3><p>你可能會認為：「只要提醒對方注意一下，問題就解決了吧？自己的文字是否易懂，應該很容易看得出來吧！」可惜，事實往往不是如此。</p><p>對於開發程式的「當事人」而言，即使註解中夾雜了大量不必要的程式細節，自己也常常會<strong>深陷其中，難以察覺</strong>，甚至覺得看起來<strong>很合理</strong>！——這就是為什麼作者都需要好的編輯，因為<strong>自身的盲點是很難完全發現並避免的</strong>。</p><p>少部分工程師甚至會覺得「我的程式能跑且執行結果正確」就算稱職了。至於註解有沒有寫、寫得好不好，不能算是評價我工作品質的範圍與指標。</p><p>這想法不能說毫無道理，只不過，寫程式若只顧自己，終究難登大雅之堂。這些程式碼看起來就像是<strong>一個人的自言自語</strong>（只要自己有完成任務就好）——<strong>它並沒有在溝通</strong>。</p><h3 id="註解只是冰山一角"><a href="#註解只是冰山一角" class="headerlink" title="註解只是冰山一角"></a>註解只是冰山一角</h3><p>本段以「程式註解」為例，試圖說明工程師在「撰寫易讀程式碼」的路上常見的路徑依賴（可以說是一種協作上的「阻礙」）。</p><p>然而，這種「<strong>缺乏溝通意識</strong>」所帶來的影響，不僅存在於註解中，<strong>也往往貫穿整個程式寫作過程</strong>。</p><p>這種心態的影響實際上<strong>遠遠超越了程式碼的範疇</strong>，接下來，我們將繼續探討這種心態在「<strong>工作表達方式</strong>」上所展現的路徑依賴特徵。</p><h2 id="二、工作表達方式上的路徑依賴"><a href="#二、工作表達方式上的路徑依賴" class="headerlink" title="二、工作表達方式上的路徑依賴"></a>二、工作表達方式上的路徑依賴</h2><p>看完第一個路徑依賴，我想你已經能猜到，這第二個會是什麼模樣了。</p><p>很多軟體 PM 在會議中常常會覺得，聽不太懂工程師在說些什麼。而我想說的是，你的感覺是對的！其實我也聽不懂。</p><p>既然寫註解、<a href="https://en.wikipedia.org/wiki/Docstring">docstring</a> 這種應該要用「簡潔清晰的自然語言」表達的場合，都容易<strong>藉由程式邏輯與實作細節含混帶過</strong>。那麼軟體工程師在會議中的表達，自然也會受到此「<strong>慣性</strong>」影響。</p><p>以我個人的經驗，工程師在描述自己工作上的要解決的問題、解決方式、可能的方向、已完成的任務等等，非常容易陷入類似的路徑依賴。</p><p>其結果就跟前面提到的程式註解一樣，你不會覺得對方是在講「人話」，而像是一種對技術方案、程式邏輯的「<strong>輪廓描述</strong>」。</p><p>至於所要解決的問題、背後的痛點究竟是什麼？選擇的依據為何？常常會直接予以忽略——因為他們滿腦子都是技術思維。</p><p>導致重點還沒說清楚，相關細節卻講了一堆，本末倒置。</p><h3 id="請說人話"><a href="#請說人話" class="headerlink" title="請說人話"></a>請說人話</h3><p>前面提到，不好的程式註解，就像一個人的自言自語。而這樣的表達方式，又何嘗不是如此？導致我們常常需要提醒對方「等等！我想要先知道的是……」</p><p>不過平心而論，良好的溝通、表達，對任何人都不容易，都需要一定的練習。</p><p>換句話說，要把一件事情講好，絕對需要先構思、自我反芻、察覺他人容易產生的疑問，並且<strong>以他人的角度去思考</strong>，才能真正做到「<strong>說人話</strong>」。</p><p>只不過軟體工程師基於職業上的特性，在感到<strong>表達困難</strong>的當下，<strong>容易反射性地躲回自己熟悉的技術與專業領域，以求得一定的自適與安全感。</strong></p><p>這無疑會讓沒有技術背景的人，感到困惑和隔閡。</p><hr><h2 id="小結：讀者意識的欠缺"><a href="#小結：讀者意識的欠缺" class="headerlink" title="小結：讀者意識的欠缺"></a>小結：讀者意識的欠缺</h2><p>講完前兩項，本篇要收尾了，我們作個小結。</p><p>前兩個路徑依賴凸顯的都是當事人對於「<strong>他人很可能會不理解</strong>」這個意識的強烈欠缺，以至於常常用一種旁人看來近乎「<strong>自言自語</strong>」的方式在表達自我。</p><p>如果是一個作者，那就是「<strong>讀者意識不足</strong>」——寫出來的文章<strong>只有自己看得懂</strong>。</p><blockquote><p>所謂的「<strong>讀者意識</strong>」，指的是作者在寫作時預見到讀者的理解困難，並通過語言表達和組織結構來幫助讀者，使讀者更容易理解的能力。</p></blockquote><p>我很想說「本文只是指出少數軟體工程師在工作上……」，但你我都知道（這裡的「你我」指的是工程師群體），說「少」恐怕是騙人的。</p><p>「<strong>讀者意識的欠缺</strong>」在軟體工程師中確實是一個<strong>普遍存在的問題</strong>。有時候，我們可能過於專注於自己的程式碼和技術細節，而忽略了將這些複雜的概念和思維以易於理解的方式傳達給他人。</p><p>我也不敢說自己已經完全擺脫了上述的困境，在「讓自己與自己的工作產出容易被他人理解」這個面向上，我們還可以不斷努力，一直努力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我常常覺得，軟體工程師可能是最能體現「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%B7%A5%E5%85%B7%E8%A7%84%E5%BE%8B&quot;&gt;當你手裡只有鎚子，看什麼都會像釘子&lt;/a&gt;」的一群人😂&lt;/p&gt;
&lt;p&gt;我們在工作中，有時會陷入一種被稱為「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E8%B7%AF%E5%BE%84%E4%BE%9D%E8%B5%96&quot;&gt;路徑依賴&lt;/a&gt;」的困境。本文將探討「路徑依賴」在軟體工程師的工作與職涯發展中，所造成的各種影響和受困者會有的具體表現。&lt;/p&gt;
&lt;p&gt;或許會讓你感到有點熟悉。&lt;/p&gt;
&lt;h2 id=&quot;前言：何謂路徑依賴？&quot;&gt;&lt;a href=&quot;#前言：何謂路徑依賴？&quot; class=&quot;headerlink&quot; title=&quot;前言：何謂路徑依賴？&quot;&gt;&lt;/a&gt;前言：何謂路徑依賴？&lt;/h2&gt;&lt;p&gt;「&lt;strong&gt;路徑依賴&lt;/strong&gt;」是個社會科學的概念，用來描述一種現象，即一旦人們在某一方面選擇了特定的路徑或方式，他們就可能變得&lt;strong&gt;過度依賴這條路徑，並且可能難以改變。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這種依賴性可能源於各種因素，包括習慣、成本、學習曲線等，並可能在多個層面上產生影響，包括個人的行為、團隊的運作，甚至是整個社會的結構和制度。&lt;/p&gt;
&lt;p&gt;在這裡，我們將專注於討論「&lt;strong&gt;軟體工程師常見的路徑依賴&lt;/strong&gt;」。以下的內容主要是基於我個人在工作上的觀察，可能會帶有一點偏見，但絕大部分都是基於事實。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
  <entry>
    <title>確保 isort 正確排序本地模組：pyproject.toml 與 pre-commit 設定</title>
    <link href="https://blog.kyomind.tw/isort-local-module-sorting/"/>
    <id>https://blog.kyomind.tw/isort-local-module-sorting/</id>
    <published>2023-05-08T16:15:08.000Z</published>
    <updated>2023-05-10T05:41:40.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/M6eKHe9.png"></p><p><a href="https://pycqa.github.io/isort/">isort</a> 是一個 Python 套件兼命令列工具，可以幫開發者自動排序 Python imports，以符合 <a href="https://peps.python.org/pep-0008/#imports">PEP 8 規範</a>。這種排序也可以讓程式碼更加易讀且易於維護。</p><p>之前已有數篇文章介紹過，可參考本站的「<a href="/tags/isort/">isort 標籤頁</a>」。</p><p>isort 會自動將 import 分為「<strong>Python 標準函式庫</strong>」、「<strong>第三方套件</strong>」、「<strong>本地模組</strong>」等三大區塊，並依<strong>字母順序</strong>排列，同時為你在三個區塊之間<strong>空一行</strong>。</p><h2 id="isort-本地模組排序錯誤"><a href="#isort-本地模組排序錯誤" class="headerlink" title="isort 本地模組排序錯誤"></a>isort 本地模組排序錯誤</h2><p>isort 有一個 bug（我也不確定是不是 bug），就是<strong>對於本地模組的「排序判斷」，有可能發生錯誤。</strong></p><p>這會造成什麼結果？通常的影響是，<strong>本來應該排在第三區塊的 import，排到第二區塊去了。</strong>總之就是 import 放錯了區塊。</p><p>這樣除了不符合 PEP 8 規範，更重要的是，它還可能對開發者造成「<strong>誤導</strong>」。而且會使用 isort 的人，往往就是在乎 import 排序的人，當然不能接受這樣的錯誤。</p><span id="more"></span><h2 id="VS-Code-解法"><a href="#VS-Code-解法" class="headerlink" title="VS Code 解法"></a>VS Code 解法</h2><p>我第一次發現這個問題是在 VS Code 的整合界面，在自動格式化時，發現<strong>本地模組被錯誤地分類到了第三方模組</strong>。</p><p>很自然的輸入關鍵字，比如「<a href="https://www.google.com/search?q=isort+wrong+order">isort wrong order</a>」，你能找到這篇 issue：</p><ul><li><a href="https://github.com/microsoft/vscode-python/issues/14254">Wrong order in import when using sort imports in vscode</a></li></ul><p>往下滑，很快你就得到了答案，在<code>settings.json</code>加入以下設定：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;python.sortImports.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;--src=$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>不過上面是以前的做法，<a href="https://blog.kyomind.tw/isort/">現在 isort 有獨立套件</a>，所以應該用下面的設定：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;isort.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;--src=$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><hr><h2 id="pyproject-toml-與-pre-commit-設定"><a href="#pyproject-toml-與-pre-commit-設定" class="headerlink" title="pyproject.toml 與 pre-commit 設定"></a>pyproject.toml 與 pre-commit 設定</h2><p>在有了 pre-commit 以後，僅設定 VS Code 是不夠的。因為即使 IDE 格式化的結果正確，若未設定 pre-commit 的 isort hook，仍可能受到阻擋，造成衝突。</p><p>另外，在團隊開發時，使用<code>pyproject.toml</code>來設定 isort 參數，明顯比所有成員各自設定其自己的 VS Code 更加可行。</p><p>所以我們需要設定前述二者的 isort 參數。</p><p>不過，仔細想想，顯然<code>pyproject.toml</code>和 pre-commit 的 isort 設定，不會是上述的<code>settings.json</code>的照抄。因為它們根本不知道<code>$&#123;workspaceFolder&#125;</code>是什麼。</p><p>想必有別的做法。</p><h3 id="pyproject-toml"><a href="#pyproject-toml" class="headerlink" title="pyproject.toml"></a>pyproject.toml</h3><p>設定如下，使用<code>src_paths = [&quot;.&quot;]</code>。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.isort]</span></span><br><span class="line"><span class="attr">line_length</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">src_paths</span> = [<span class="string">&quot;.&quot;</span>] <span class="comment"># &lt;--- 這裡</span></span><br></pre></td></tr></table></figure><h3 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h3><p><code>.pre-commit-config.yaml</code>設定如下，使用<code>--src=.</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/isort</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.11</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--line-length=100</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--src=.</span> <span class="comment"># &lt;--- 這裡</span></span><br></pre></td></tr></table></figure><p>基本上都是用「<code>.</code>」來代表專案根目錄。</p><h2 id="附帶一提"><a href="#附帶一提" class="headerlink" title="附帶一提"></a>附帶一提</h2><p>值得注意的是，如果 VS Code 有設定 isort，那這個設定將<strong>優先於<code>pyproject.toml</code>。</strong>這樣的邏輯我不太能理解，因為理論上愈小範圍應該要優先適用才對。讀者使用時，可留意一下兩者的設定是否存在衝突。</p><p>我自己平常都是透過<code>settings.json</code>設定 isort，至於<code>pyproject.toml</code>，則是給團隊其餘沒有設定 VS Code 的人使用的。</p><p>不過，總的來說，團隊協作還是盡可能透過「<strong>專案設定檔</strong>」如<code>pyproject.toml</code>來設定這些工具的參數會比較妥當。一旦有變動，也能在 Git 同步後，全體立即適用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/M6eKHe9.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pycqa.github.io/isort/&quot;&gt;isort&lt;/a&gt; 是一個 Python 套件兼命令列工具，可以幫開發者自動排序 Python imports，以符合 &lt;a href=&quot;https://peps.python.org/pep-0008/#imports&quot;&gt;PEP 8 規範&lt;/a&gt;。這種排序也可以讓程式碼更加易讀且易於維護。&lt;/p&gt;
&lt;p&gt;之前已有數篇文章介紹過，可參考本站的「&lt;a href=&quot;/tags/isort/&quot;&gt;isort 標籤頁&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;isort 會自動將 import 分為「&lt;strong&gt;Python 標準函式庫&lt;/strong&gt;」、「&lt;strong&gt;第三方套件&lt;/strong&gt;」、「&lt;strong&gt;本地模組&lt;/strong&gt;」等三大區塊，並依&lt;strong&gt;字母順序&lt;/strong&gt;排列，同時為你在三個區塊之間&lt;strong&gt;空一行&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;isort-本地模組排序錯誤&quot;&gt;&lt;a href=&quot;#isort-本地模組排序錯誤&quot; class=&quot;headerlink&quot; title=&quot;isort 本地模組排序錯誤&quot;&gt;&lt;/a&gt;isort 本地模組排序錯誤&lt;/h2&gt;&lt;p&gt;isort 有一個 bug（我也不確定是不是 bug），就是&lt;strong&gt;對於本地模組的「排序判斷」，有可能發生錯誤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這會造成什麼結果？通常的影響是，&lt;strong&gt;本來應該排在第三區塊的 import，排到第二區塊去了。&lt;/strong&gt;總之就是 import 放錯了區塊。&lt;/p&gt;
&lt;p&gt;這樣除了不符合 PEP 8 規範，更重要的是，它還可能對開發者造成「&lt;strong&gt;誤導&lt;/strong&gt;」。而且會使用 isort 的人，往往就是在乎 import 排序的人，當然不能接受這樣的錯誤。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
    <category term="VS Code" scheme="https://blog.kyomind.tw/tags/VS-Code/"/>
    
    <category term="isort" scheme="https://blog.kyomind.tw/tags/isort/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
  </entry>
  
  <entry>
    <title>17，AI 時代的生存指南（一）我對 AI 工具的投入與觀望</title>
    <link href="https://blog.kyomind.tw/weekly-review-17/"/>
    <id>https://blog.kyomind.tw/weekly-review-17/</id>
    <published>2023-05-06T21:03:18.000Z</published>
    <updated>2023-07-07T17:30:31.084Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>相信大家在 2023 的上半年都被 AI 相關資訊狂轟濫炸到有點厭世了。</p><p>從去年 11 月底 ChatGPT 發布以來，我們都知道，這個世界發生了天翻地覆的改變。</p><p>有人因此賺到快錢，有人想法得到了實現，而更多人如你我，則是在這波浪潮的後方，苦苦追趕，擔心跟不上時代，或失去了自身價值。</p><p>藉著大眾對於 AI 資訊的焦慮與渴求，線上知識平台紛紛推出了相關課程。有些你我從未聽聞的人，也說要開課教你學 AI。甚至連 3C 產品評測網站、信用卡優惠資訊部落格等等，也開始發表 AI 工具介紹文章。</p><p>此時此刻，AI 就是風口，就是流量密碼。</p><p>「<strong>資訊焦慮</strong>」一詞並非 ChatGPT 時代所獨有，早在此前就已存在。但隨著 GPT 時代的到來，焦慮感無疑加劇了，因為我們面對的資訊量比以往更加龐大、更加複雜。</p><p>太辛苦了。</p><span id="more"></span><h3 id="系列：AI-時代的生存指南"><a href="#系列：AI-時代的生存指南" class="headerlink" title="系列：AI 時代的生存指南"></a>系列：AI 時代的生存指南</h3><blockquote><ol><li><strong>AI 時代的生存指南（一）我對 AI 工具的投入與觀望</strong></li><li><a href="https://blog.kyomind.tw/weekly-review-19/">AI 時代的生存指南（二）數位斷捨離</a></li></ol></blockquote><hr><h2 id="AI-時代的生存指南"><a href="#AI-時代的生存指南" class="headerlink" title="AI 時代的生存指南"></a>AI 時代的生存指南</h2><p>從標題的「一」可知，這又是一個系列，和其它系列不同的是：它是「不定期」的，我也不知道會寫到第幾回，但從目前的規劃來看，至少會有 5 回。</p><p>我期望這系列和一般談論 AI 文章的一個核心差別是：<strong>它們主要用來「降低」AI 資訊焦慮，而非增加。</strong></p><p>更具體地說，這個系列是「<strong>我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄</strong>」，這樣才有趣。</p><p>我曾在<a href="https://www.facebook.com/kyomind/posts/pfbid06EdjLvXpAgNhKrRK3K7KHabAtm5vHa5AFJNqximxcNBVmrSF4gMMpkTSU5CMAqUGl">這篇臉書貼文</a>中如此說道：</p><blockquote><p>平心而論，ChatGPT 等大批 AI 工具到目前為止，仍只是讓我覺得：以前重要的事，現在更重要了；以前不重要的事，現在「真的」一點也不重要了——跟 AI 比「<a href="https://zh.wikipedia.org/zh-tw/%E5%B0%9D%E8%AF%95%E9%94%99%E8%AF%AF%E6%B3%95">試誤</a>」，猶如跟車子比速度</p></blockquote><p>雖然沒有言明，但這段文字的其中一個立場是：<strong>努力追趕這些 AI 浪潮（新工具、新資訊），恐怕不是特別有效的做法</strong>。至少就降低資訊焦慮而言，往往<strong>適得其反</strong>。</p><p>追趕？這不是我喜歡的方式，更不是我擅長的手段。</p><p>而這個系列，一言以蔽之，就是要談談：「<strong>不追趕，那我打算怎麼辦？</strong>」——這是我寫給自己的「<strong>AI 時代的生存指南</strong>」。</p><h2 id="本期重點：AI-工具"><a href="#本期重點：AI-工具" class="headerlink" title="本期重點：AI 工具"></a>本期重點：AI 工具</h2><p>雖然是和 AI 有關的系列，<strong>但我並不會每篇都緊扣著 AI 這個主題</strong>——這類內容我們看得還不夠多嗎？相反地，我會從自己的經驗出發，分享我在 AI 時代的「<strong>對策與行動</strong>」。</p><p>所以重點是這些「<strong>行動</strong>」，而不是 AI 本身。</p><p>儘管如此，第一期我們仍然需要先談談 AI 工具，以及我對這些工具的基本看法，因為這是所有 AI 焦慮的根源。直接跳過的話，未免顯得有點不食人間煙火。</p><p>好，了解這些已經足夠，讓我們開始吧！</p><hr><h2 id="作為一個軟體工程師，我別無選擇要關注-AI"><a href="#作為一個軟體工程師，我別無選擇要關注-AI" class="headerlink" title="作為一個軟體工程師，我別無選擇要關注 AI"></a>作為一個軟體工程師，我別無選擇要關注 AI</h2><p>早在 ChatGPT 問世前，微軟的 <a href="https://github.com/features/copilot">GitHub Copilot</a> 就已經秀過一波「AI 寫扣」的威力與潛力，引起了相當的討論，更帶出了 AI 悲觀派和樂觀派。</p><p>悲觀派認為 AI 將取代人類的工作，但樂觀派則相信 AI 將為我們帶來更多的創造力和效率。</p><p>我算是偏悲觀的那一方XD，而且我覺得，AI 也真的很適合寫 code。程式碼有大量的訓練資源（姑且不論資料品質），而且在大多程式開發的情境，關於「怎麼做才對」這件事，往往都有答案——儘管答案很可能不止一個。</p><p>因此，作為一個軟體工程師，我別無選擇地，必須關注 AI 技術的發展和應用——我擔心自己中年失業。</p><p>而第 6 期的〈<a href="https://blog.kyomind.tw/weekly-review-06/">06，十年後，還能繼續當軟體工程師嗎？</a>〉，正是對這份焦慮的記錄與回應。</p><h2 id="AI-工具確實很有幫助"><a href="#AI-工具確實很有幫助" class="headerlink" title="AI 工具確實很有幫助"></a>AI 工具確實很有幫助</h2><p>前陣子去健身的時候，我突然想到：「健身教練這份工作好像不太受到 ChatGPT 的衝擊耶！」對此，不禁有點羨慕🥹</p><p>可是，反過來思考：受到的影響很小，其實就意味著，該技術的出現，對於這個行業，<strong>並沒有顯著與實質的改變</strong>——沒有加速從業者工作上的效率。</p><blockquote><p>那就太可惜了！</p></blockquote><p>畢竟，我們這些上班族、打工仔，這麼擔心被 AI 取代，正是因為它在很多方面都大大地加速了我們原本做事的效率——讓人感覺自己好像不再重要。</p><p>作為受雇者，心情上可能是既高興（省下好多時間）又擔心（失業）。但作為一個人，我是覺得超讚的啦！難道有誰喜歡做那些重複又枯燥的工作？</p><h2 id="我目前使用中的-AI-工具"><a href="#我目前使用中的-AI-工具" class="headerlink" title="我目前使用中的 AI 工具"></a>我目前使用中的 AI 工具</h2><p>其實就只有 ChatGPT 和 GitHub Copilot——兩者的<strong>大目標</strong>都是為了<strong>寫好程式</strong>！🤗</p><p>Notion AI 用過又退了，理由已如前述：〈<a href="https://blog.kyomind.tw/weekly-review-15/">15，付費一個月後，我還是退訂了 Notion AI</a>〉。</p><p>另一個本來很有興趣但一直沒有投入時間的，是 <a href="https://www.midjourney.com/">Midjourney</a>。主要的學習動機是幫文章製作封面圖，但顯然這個需求還算不上十分強烈。</p><p>而且，自己下提示詞產生封面圖片，固然很有成就感，也稱得上獨一無二。但花費的時間，未必比去 Pixabay 找一張美美的照片來得少。</p><p>考慮到<strong>文章的本質還是文字本身</strong>，加上我寫作的速度已經很慢了，不適合再花額外時間去掙扎封面的創作美感與切題與否，想想還是暫時擱置一旁。</p><p>除了以上提到的 4 項 AI 工具，其餘的我都是看看而已。即便是吸收新知，也是圍繞在「如何更好地使用 ChatGPT」這個主軸上。</p><h2 id="我怎麼面對海量的-AI-資訊？"><a href="#我怎麼面對海量的-AI-資訊？" class="headerlink" title="我怎麼面對海量的 AI 資訊？"></a>我怎麼面對海量的 AI 資訊？</h2><p>好，哪怕你跟我一樣，平常只用 ChatGPT，可能依舊很容易感到<strong>資訊過載</strong>——因為還是很多啊！</p><p>OpenAI 動不動就宣布 ChatGPT 新功能，加上各種民間外掛、各種提示詞大全，甚至研究論文和技術文獻等等，真的好煩XD。</p><p>作為一個 ChatGPT 重度使用者，我也難免汲汲營營、眼花撩亂。</p><p>我目前歸納出的「<strong>減壓</strong>」做法是——<strong>主動減少接觸這些資訊</strong>！當然，「主動減少接觸相關資訊」這類手段，都有一個共同的擔憂：<strong>害怕錯失</strong>，也就是 <strong>FOMO</strong>。</p><p>類似的情況也出現在〈<a href="https://blog.kyomind.tw/weekly-review-11/">11，我絕不當資訊的聚合者</a>〉所討論的「<strong>資訊聚合</strong>」議題。</p><h3 id="事可過三"><a href="#事可過三" class="headerlink" title="事可過三"></a>事可過三</h3><p>我的看法是，真正重要且實用的功能，你在上述「 3C 產品評測網站、信用卡優惠資訊部落格」其實都會一再看到喔XD！因為有話題、有流量嘛！</p><p>意思就是說，如果一個東西（比如某個 ChatGPT 的新 Chrome Extension）在這些網站<strong>反覆出現達 3 次</strong>，我才可能會開始關注它。</p><blockquote><p>這樣真的好嗎？</p></blockquote><p>事實證明，ChatGPT 瀏覽器外掛百百款，我自己也試過好些。<strong>但目前為止，唯一留下且持續在使用的，只有一個</strong>：<a href="https://sharegpt.com/">ShareGPT</a>。</p><p>那些宣稱能夠讓 ChatGPT 變得十倍、百倍強大的瀏覽器外掛，對我而言，<strong>其價值都遠遠不如能幫我輕鬆留下「和 ChatGPT 重要對話」的 ShareGPT</strong>。</p><p>在我的 Logseq 筆記裡，有超多與 ChatGPT 的對話XD——女友看了都要吃醋🤣</p><p><img src="https://i.imgur.com/5ysqLCT.png" alt="與 ChatGPT 的對話集"><span class="cap">與 ChatGPT 的對話集</span></p><hr><h2 id="結語：拼命追趕，也是枉然"><a href="#結語：拼命追趕，也是枉然" class="headerlink" title="結語：拼命追趕，也是枉然"></a>結語：拼命追趕，也是枉然</h2><p>最後，我想再次強調我在<a href="https://www.facebook.com/kyomind/posts/pfbid0mkCP8W1XRG1226wVqi7FaPrB7URTJQS88mw1U2FtbJ2tu4FKfZx1o9fLiAwkutJcl?fbclid=IwAR0rHgVsKY0AzSAiZVmatU-A2MHcZscyvuk7mORauRlRg4LChlz06u1UK_k">這篇臉書貼文</a>中所表達的：<strong>我對 AI 工具的整體看法</strong>。</p><p>提示詞也好，瀏覽器外掛也罷，都是很容易產品化的東西。<strong>不用太在意</strong>自己是否已精通了各類提示詞技巧，凡此種種，在不久的將來，都會由機器為你服務。</p><p>作為一個人，我們不需要拼命追趕，因為追不上，也趕不及。</p><p>我使用 ChatGPT <strong>最滿足的時刻</strong>，莫過於對它提出了深刻的問題（通常也很尖銳、帶有挑戰與批判意味），然後它回了我一個出乎意料或令人讚嘆的答案。</p><p>當下真的只能用「<strong>感動</strong>」來形容——好慶幸自己活在有 GPT 的時代。</p><p>這些問題的<strong>核心價值</strong>不在於高超的提示詞技巧，而在於<strong>激發我們進行更深層次的思考</strong>。</p><p>在 AI 時代，這或許是我身為平凡人類，少數擁有的不平凡時刻。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;相信大家在 2023 的上半年都被 AI 相關資訊狂轟濫炸到有點厭世了。&lt;/p&gt;
&lt;p&gt;從去年 11 月底 ChatGPT 發布以來，我們都知道，這個世界發生了天翻地覆的改變。&lt;/p&gt;
&lt;p&gt;有人因此賺到快錢，有人想法得到了實現，而更多人如你我，則是在這波浪潮的後方，苦苦追趕，擔心跟不上時代，或失去了自身價值。&lt;/p&gt;
&lt;p&gt;藉著大眾對於 AI 資訊的焦慮與渴求，線上知識平台紛紛推出了相關課程。有些你我從未聽聞的人，也說要開課教你學 AI。甚至連 3C 產品評測網站、信用卡優惠資訊部落格等等，也開始發表 AI 工具介紹文章。&lt;/p&gt;
&lt;p&gt;此時此刻，AI 就是風口，就是流量密碼。&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;資訊焦慮&lt;/strong&gt;」一詞並非 ChatGPT 時代所獨有，早在此前就已存在。但隨著 GPT 時代的到來，焦慮感無疑加劇了，因為我們面對的資訊量比以往更加龐大、更加複雜。&lt;/p&gt;
&lt;p&gt;太辛苦了。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="Notion AI" scheme="https://blog.kyomind.tw/tags/Notion-AI/"/>
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
    <category term="資訊焦慮" scheme="https://blog.kyomind.tw/tags/%E8%B3%87%E8%A8%8A%E7%84%A6%E6%85%AE/"/>
    
  </entry>
  
  <entry>
    <title>pre-commit 設定 Git Hooks 教學：以 Flake8、isort、yapf 為例</title>
    <link href="https://blog.kyomind.tw/pre-commit/"/>
    <id>https://blog.kyomind.tw/pre-commit/</id>
    <published>2023-04-29T07:53:17.000Z</published>
    <updated>2023-07-08T17:33:59.850Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/HdNTdXP.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>有關 Python「<a href="/tags/Code-Formatting/">Code Formatting</a>」（Linter、Formatter 等）這一主題的文章，之前已寫了不少：</p><ol><li><a href="https://blog.kyomind.tw/flake8-yapf-setting/">VS Code 設定 Python linter 與 formatter：以 Flake8、yapf 為例</a></li><li><a href="https://blog.kyomind.tw/pyproject-toml/">pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學</a></li><li><a href="https://blog.kyomind.tw/isort/">VS Code：Python isort 擴充套件介紹與簡易設定教學</a></li><li><a href="https://blog.kyomind.tw/flake8-and-black/">VS Code：Python Flake8 與 Black Formatter 擴充套件快速上手</a></li></ol><p>仔細一看，其實不就是 Flake8、yapf、isort、Black Formatter 這 4 項工具的排列組合而已嗎XD。</p><p>是的！我自己整理到都覺得有點不好意思了🫣。</p><p>但是，為什麼要寫這麼多？還是那句老話：「<strong>我認為這些工具的重要性，再怎麼強調也不為過——更別說它們常常被低估了。</strong>」</p><p>我曾在上述文章中的開頭或結尾處，不厭其煩地表達自己對它們的重視，這裡就不再贅述，直接進入重點。</p><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文將講述如何透過 <a href="https://pre-commit.com/">pre-commit</a> 這個工具設定 Git Hooks，並以 Flake8、isort、yapf 等 Python 開發常用套件為例，進行演示，同時提醒一些注意事項。</p><p>如同 Poetry，pre-commit 也是我在工作上，強烈希望導入的工具——畢竟它可以有效降低 code review 時血壓升高的次數☺️</p><span id="more"></span><h2 id="本文架構"><a href="#本文架構" class="headerlink" title="本文架構"></a>本文架構</h2><p>我們會先講一下什麼是 Git Hooks 和 pre-commit，因為不是論述上的重點，所以只需簡單帶過，讀者心中有個輪廓即可。</p><p>接著探討「<strong>為什麼要使用 pre-commit 工具？</strong>」。和我過去的許多文章一樣，對動機與場景將有一定程度的著墨，我們會探討 pre-commit 的價值所在，包括我從團隊使用經驗得到的看法。</p><p>最後是具體設定——這或許是最不重要的部分，因為它很簡單，但還是有一些值得留意的部分。以 Flake8、isort、yapf 為例，則是為了貫徹前述所有文章的一貫精神：<strong>有了 pre-commit，這一切才算圓滿。</strong></p><p>附帶一提，考慮到「pre-commit」這個主題已經有數篇文章珠玉在前（參考文章我會放在文末），我下筆前都已拜讀完。本文的論述重點會<strong>盡可能與這些文章錯開，或乾脆直接引用</strong>，以降低不必要的重複感。</p><hr><h2 id="Git-Hooks-介紹"><a href="#Git-Hooks-介紹" class="headerlink" title="Git Hooks 介紹"></a>Git Hooks 介紹</h2><p>Git Hooks 是 Git 提供的一個功能，允許開發者在特定的 Git 事件（如 commit、push 等）觸發時，自動執行自定義的腳本，這樣可以在提交程式碼之前進行一些檢查，以確保程式碼的交付品質。</p><p><a href="https://git-scm.com/book/zh-tw/v2/Customizing-Git-Git-Hooks">Git Hooks 有很多種</a>，不同的 Git Hooks 可以幫助開發者在不同的場景下進行自動化操作，這裡我們只要知曉<strong>最常用的 pre-commit hook</strong> 已足。</p><p>顧名思義，pre-commit hook 會在你使用<code>git commit</code>命令時觸發，讓機器依照你的 hook 腳本內容，在 commit 前對程式碼進行檢查。</p><p>事實上，你可以用任何語言來撰寫 hook 腳本，只要編寫的腳本能夠在系統上被執行，而且符合 Git hook 的腳本格式，就可以使用。</p><p>開發者只需要在<code>.git/hooks</code>目錄下建立相對應的 hook（命名必須遵守規則），依照 Git Hooks 的 API 規範，編寫自己需要的處理邏輯即可。</p><p>但我們才不會這麼做！因為我們有工具嘛！</p><h2 id="Git-Hooks-管理工具介紹"><a href="#Git-Hooks-管理工具介紹" class="headerlink" title="Git Hooks 管理工具介紹"></a>Git Hooks 管理工具介紹</h2><p>即使你會寫 shell script，也不一定想自己手刻一個 hook 腳本，所幸這麼常見的需求，自然有許多開源的工具可以使用，而 pre-commit 就是其中的佼佼者——只能說這套件的命名非常簡單暴力！🤣</p><p><a href="https://pre-commit.com/">pre-commit</a> 是由 Python 所寫成的 Git Hooks 管理工具，<strong>但可以適用於各類程式語言專案</strong>，包括 Python、JavaScript、Ruby、Java、Go 等。使用者可以根據自己的需求，選擇要使用的 hook。</p><p>類似的工具還有 <a href="https://github.com/typicode/husky">husky</a>、<a href="https://github.com/sds/overcommit">overcommit</a> 等等。不過作為 Python 開發者，我們當然還是選擇 pre-commit 囉！</p><p>雖然叫 pre-commit，但實際上它可以管理全部種類的 Git Hooks，比如<code>pre-push</code>、<code>post-merge</code>等等，管理 pre-commit hook 只是其中最常見的用途而已，我想這應該不至於造成誤會。</p><hr><h2 id="為什麼要使用-pre-commit？"><a href="#為什麼要使用-pre-commit？" class="headerlink" title="為什麼要使用 pre-commit？"></a>為什麼要使用 pre-commit？</h2><p>這個問題可以分為<strong>兩個層次</strong>：</p><ol><li>為什麼要使用 pre-commit hook？</li><li>為什麼要使用 Git Hooks 自動化工具？</li></ol><p>這兩個問題有先後關係，先有 1 才有 2。不過 2 的理由比較簡單，所以我們先講 2 再講 1。</p><h3 id="為什麼要使用自動化工具來管理-Git-Hooks？"><a href="#為什麼要使用自動化工具來管理-Git-Hooks？" class="headerlink" title="為什麼要使用自動化工具來管理 Git Hooks？"></a>為什麼要使用自動化工具來管理 Git Hooks？</h3><p>除了和〈<a href="https://blog.kyomind.tw/yadm/">是時候同步你的 dotfiles 了——我選擇 yadm</a>〉一樣：<strong>因為這個方式更加輕鬆</strong>以外。更關鍵的是，透過工具你可以像堆樂高積木般，輕鬆組合各式套件所提供的現成 hook，比如本文的 Flake8，這顯然比自己寫 shell 要高效得多。</p><p>所以，直接透過工具來管理 Git Hooks，應該是絕大多數人<strong>自然而然的選擇</strong>。</p><h3 id="為什麼要使用-pre-commit-hook？"><a href="#為什麼要使用-pre-commit-hook？" class="headerlink" title="為什麼要使用 pre-commit hook？"></a>為什麼要使用 pre-commit hook？</h3><p>在〈<a href="https://www.mropengate.com/2019/08/pre-commit-git-hooks_4.html?m=1">提升程式碼品質：使用 Pre-Commit (Git Hooks)</a>〉一文中，作者提出了三點，闡述為何要使用 pre-commit hook，理由充分且令人信服，請容我直接引用：</p><blockquote><ul><li>自動化檢查程式碼排版規範快速又有效率（如 python PEP8）</li><li>低級的問題不會進到 code review<ul><li>多一點時間檢查程式邏輯，而不是基本錯誤（如排版）。</li><li>人工檢查程式碼的時間很寶貴，減少人工即是增進效率。</li></ul></li><li>低級的問題不會進到 CI&#x2F;CD pipeline<ul><li>pipeline 應該多一點綠勾勾，而不是滿滿 debug 的痕跡。</li></ul></li></ul></blockquote><h3 id="我的關注點"><a href="#我的關注點" class="headerlink" title="我的關注點"></a>我的關注點</h3><p>此外，我在臉書社團「Backend 台灣 (Backend Tw)」<a href="https://www.facebook.com/groups/backendtw/permalink/2934392300027960">這篇文章</a>的回應中，也表達了自己的看法，這裡只節錄最後兩段：</p><blockquote><p>上面的情況其實都在說：「linter已經提醒有問題，但formatter無法正常格式化」，細心的人會停下來排除問題或討論，但人難免都有粗心的時候，偶爾還是忽略且commit了</p></blockquote><blockquote><p>負責 review 的人看到這種格式類的錯誤，心裡難免會有點無言，但又不好直接怪隊友，畢竟對方也不是「故意」的，此時有機器幫彼此擋一下，也算是團隊協作的潤化劑</p></blockquote><p>是的，我最大的著眼點在於：「<strong>減少團隊協作時，不必要的磨擦（精神消耗）。</strong>」</p><p>個人認為這真的很重要，畢竟我們不是機器，都有情緒，而情緒應該要用在更有價值的地方。</p><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>總的來說，如果你問我「為何要使用 pre-commit？」從個人角度看，我已視之為理所當然，畢竟我都寫了多篇關於「<strong>如何落實 Code Formatting</strong>」的文章了。</p><p>而 pre-commit 則是我們的<strong>最後一塊拼圖</strong>，它更進一步確保了 linter 和 formatter 的檢查，在 commit 之際，能被<strong>完全遵守</strong>。</p><p>而從團隊的角度，則是因為「這樣對大家都好！」</p><hr><h2 id="pre-commit-基本設定"><a href="#pre-commit-基本設定" class="headerlink" title="pre-commit 基本設定"></a>pre-commit 基本設定</h2><p>安裝 pre-commit 應該不必解釋，<code>poetry add pre-commit</code>或<code>pip install pre-commit</code>任君挑選。macOS 也可以用<code>brew install pre-commit</code>全域安裝，但如此一來它就不會在專案虛擬環境中。</p><h3 id="pre-commit-config-yaml"><a href="#pre-commit-config-yaml" class="headerlink" title=".pre-commit-config.yaml"></a>.pre-commit-config.yaml</h3><p>接著是關於<code>.pre-commit-config.yaml</code>的編輯，請將此檔案建立於<strong>專案的根目錄</strong>，pre-commit 就是透過這份設定檔，實現各項 hook 內容。</p><p>一般而言，<code>.pre-commit-config.yaml</code>會長這樣：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pre-commit/pre-commit-hooks</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v4.3.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trailing-whitespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-added-large-files</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/flake8</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.0</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">flake8</span></span><br></pre></td></tr></table></figure><p>最上面是<a href="https://github.com/pre-commit/pre-commit-hooks#hooks-available">由 pre-commit 專案提供的基本 hooks</a>。剩下的部分則是其它開源專案所提供的 hook。</p><p><code>yaml</code>檔中的<code>repo</code>、<code>rev</code>、<code>hooks</code>、<code>id</code>等設定，直接看<a href="https://pre-commit.com/#pre-commit-configyaml---repos">文件</a>就知道意思了。</p><h3 id="設定上重點"><a href="#設定上重點" class="headerlink" title="設定上重點"></a>設定上重點</h3><p>對於第一次接觸 pre-commit 的人而言，這裡會有的<strong>最大疑問</strong>應該是：「啊我怎麼知道我可以用哪些 hook？我又怎麼知道這些 hook 的 repo 網址？」</p><p>沒錯，這是關鍵所在，這個「<a href="https://pre-commit.com/hooks.html">Supported hooks</a>」網頁有目前全部可用的 hook 清單，上面如果沒有列出你想用的工具，那就是暫不支援囉！</p><p>至於<code>rev</code>的具體版本號（總不能自己瞎編一個），repo 網頁的「tags」頁面就會有，比如這是 <a href="https://github.com/PyCQA/flake8/tags">Flake8 的 tags 頁面</a>。</p><p>值得留意的是：有些 hook 的 tag 有「<code>v</code>」開頭，有些則否（上述 Flake8 就沒有）。這主要取決於各專案開發者的 tag 命名習慣，我們只要留意一下即可。</p><p>知道這些，基本上就能設定好<code>.pre-commit-config.yaml</code>了。</p><h2 id="pre-commit-設定-Flake8、isort、yapf"><a href="#pre-commit-設定-Flake8、isort、yapf" class="headerlink" title="pre-commit 設定 Flake8、isort、yapf"></a>pre-commit 設定 Flake8、isort、yapf</h2><p>又到了整個「系列」都不斷重複、重複、再重複的幾樣工具😎</p><h3 id="Flake8"><a href="#Flake8" class="headerlink" title="Flake8"></a>Flake8</h3><p>直接看設定檔：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/flake8</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.0</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">flake8</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--max-line-length=100</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--ignore=E131,E126,E402</span></span><br></pre></td></tr></table></figure><p><code>hooks</code>設定下所有可以用的子項目，<a href="https://pre-commit.com/#pre-commit-configyaml---hooks">上述的頁面</a>已有說明。</p><p>這只需要提醒一件事：那就是<code>args</code>的設定內容<strong>務必和編輯器（比如 VS Code）的設定一致。</strong></p><p>換句話說，我 VS Code 的<code>settings.py</code>也有一樣的設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;flake8.args&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;--max-line-length=100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--ignore=E131,E126,E402&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>如果兩者的設定有衝突，會造成適用上的<strong>混淆</strong>，這是我們不想看到的。</p><h3 id="isort"><a href="#isort" class="headerlink" title="isort"></a>isort</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/isort</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.11</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--line-length=100</span></span><br></pre></td></tr></table></figure><p>一樣特別注意<code>args</code>，尤其像 isort、yapf 這類「<strong>formatter</strong>」，設定不一致會直接造成「在編輯器中格式化符合規範，但 commit 時卻被 hook 擋下來」的<strong>窘境</strong>。</p><h3 id="yapf"><a href="#yapf" class="headerlink" title="yapf"></a>yapf</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pre-commit/mirrors-yapf</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v0.32.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">yapf</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">column_limit</span> <span class="string">=</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">additional_dependencies:</span> [<span class="string">toml</span>]</span><br></pre></td></tr></table></figure><p>yapf 有一個<a href="https://blog.kyomind.tw/pyproject-toml/#VS-Code-%E6%95%B4%E5%90%88%E6%99%82%E5%8F%AF%E8%83%BD%E7%9A%84-bug">很常見的問題</a>，之前在〈<a href="https://blog.kyomind.tw/pyproject-toml/">pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學</a>〉中已提過。</p><p>簡言之，只要你的專案中有<code>pyproject.toml</code>，無論裡面是否有關於 yapf 的設定項，yapf 都會試圖去解析（parse）它，此時<code>toml</code>套件就成了必不可少的一環。如果沒有<code>toml</code>，將進一步導致 yapf 無法正常運作。</p><p>這個問題在 pre-commit 同樣會發生，所以如果專案中有<code>pyproject.toml</code>，就要額外設定<code>additional_dependencies: [toml]</code>，方能功德圓滿🙏</p><hr><h2 id="最後一哩"><a href="#最後一哩" class="headerlink" title="最後一哩"></a>最後一哩</h2><p>附上完整的<code>.pre-commit-config.yaml</code>供參：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pre-commit/pre-commit-hooks</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v4.3.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trailing-whitespace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-added-large-files</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-ast</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-case-conflict</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-json</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-toml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">check-yaml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">end-of-file-fixer</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/flake8</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.0</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">flake8</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--max-line-length=100</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--ignore=E131</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/isort</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.11</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--line-length=100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pre-commit/mirrors-yapf</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v0.32.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">yapf</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">migrations/</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">column_limit</span> <span class="string">=</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">additional_dependencies:</span> [<span class="string">toml</span>]</span><br></pre></td></tr></table></figure><p>還有一件想當然爾但依舊必須提醒的事，即 hook 使用的<code>rev</code>版本，要和你專案裡使用的工具的版本一致。比如上述設定檔中我的 Flake8 是<code>5.0.4</code>版，那虛擬環境裡安裝的<code>flake8</code>自然也是<code>5.0.4</code>，而不會是其它版本。</p><p>安裝完 pre-commit 並建立好<code>.pre-commit-config.yaml</code>後，<strong>事情還沒有結束！</strong>此時專案中的<code>.git/hooks</code>目錄下，依舊是預設時的模樣：只有一大堆 sample 檔。</p><h3 id="pre-commit-install"><a href="#pre-commit-install" class="headerlink" title="pre-commit install"></a>pre-commit install</h3><p>我們還差一個動作——將<code>.pre-commit-config.yaml</code>轉譯為 hook 腳本，才能真正發揮它的功用。當然，這會由工具代勞，我們只需要下指令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-commit install</span><br></pre></td></tr></table></figure><p>下指令前<strong>請先確定虛擬環境已經開啟</strong>，不然可能會找不到<code>pre-commit</code>這個執行檔——除非你是全域安裝。</p><p>這個指令還有相關參數可以使用，有興趣可參考<a href="https://pre-commit.com/#pre-commit-install">文件</a>。不過在絕大多數情況下，這樣就已經足夠。</p><h3 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h3><ul><li><a href="https://myapollo.com.tw/blog/pre-commit-the-best-friend-before-commit/">用 pre-commit 輕鬆提升程式碼品質</a></li><li><a href="https://www.mropengate.com/2019/08/pre-commit-git-hooks_4.html?m=1">提升程式碼品質：使用 Pre-Commit (Git Hooks)</a></li><li><a href="https://matthung0807.blogspot.com/2021/08/pre-commit-code-check.html">使用pre-commit做commit前檢查</a></li><li><a href="https://www.freecodecamp.org/chinese/news/git-hooks-script/">手寫 git hooks 腳本（pre-commit、commit-msg）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/HdNTdXP.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;有關 Python「&lt;a href=&quot;/tags/Code-Formatting/&quot;&gt;Code Formatting&lt;/a&gt;」（Linter、Formatter 等）這一主題的文章，之前已寫了不少：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/flake8-yapf-setting/&quot;&gt;VS Code 設定 Python linter 與 formatter：以 Flake8、yapf 為例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/pyproject-toml/&quot;&gt;pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/isort/&quot;&gt;VS Code：Python isort 擴充套件介紹與簡易設定教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/flake8-and-black/&quot;&gt;VS Code：Python Flake8 與 Black Formatter 擴充套件快速上手&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;仔細一看，其實不就是 Flake8、yapf、isort、Black Formatter 這 4 項工具的排列組合而已嗎XD。&lt;/p&gt;
&lt;p&gt;是的！我自己整理到都覺得有點不好意思了🫣。&lt;/p&gt;
&lt;p&gt;但是，為什麼要寫這麼多？還是那句老話：「&lt;strong&gt;我認為這些工具的重要性，再怎麼強調也不為過——更別說它們常常被低估了。&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;我曾在上述文章中的開頭或結尾處，不厭其煩地表達自己對它們的重視，這裡就不再贅述，直接進入重點。&lt;/p&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;本文將講述如何透過 &lt;a href=&quot;https://pre-commit.com/&quot;&gt;pre-commit&lt;/a&gt; 這個工具設定 Git Hooks，並以 Flake8、isort、yapf 等 Python 開發常用套件為例，進行演示，同時提醒一些注意事項。&lt;/p&gt;
&lt;p&gt;如同 Poetry，pre-commit 也是我在工作上，強烈希望導入的工具——畢竟它可以有效降低 code review 時血壓升高的次數☺️&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="isort" scheme="https://blog.kyomind.tw/tags/isort/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Flake8" scheme="https://blog.kyomind.tw/tags/Flake8/"/>
    
    <category term="yapf" scheme="https://blog.kyomind.tw/tags/yapf/"/>
    
    <category term="Git" scheme="https://blog.kyomind.tw/tags/Git/"/>
    
  </entry>
  
</feed>
