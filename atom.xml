<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2023-08-29T06:16:22.182Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剛剛好：Notion database「反複雜」使用指南</title>
    <link href="https://blog.kyomind.tw/notion-database/"/>
    <id>https://blog.kyomind.tw/notion-database/</id>
    <published>2023-08-28T17:29:31.000Z</published>
    <updated>2023-08-29T06:16:22.182Z</updated>
    
    <content type="html"><![CDATA[<!-- ![by Tom Clohosy Cole](https://i.imgur.com/KF3B43y.jpg) --><!-- ![by Daria Kolesnikova](https://i.imgur.com/zJRTnei.jpg) --><p><img src="https://i.imgur.com/TJQDGmr.jpg" alt="by Daria Kolesnikova"><span class="cap">by Daria Kolesnikova</span></p><p>讓我們進入「Simple Notion」系列的第三篇，同時也是最後一篇。這次我們要聊聊，Notion 中<strong>最具代表性的元素</strong>。</p><p>提到 Notion 你會想到什麼？沒錯，<strong>database</strong>！</p><p>Notion 在 2016 年就誕生了（你也可以說是 2013年，請參考維基百科關於 <a href="https://zh.wikipedia.org/zh-tw/Notion">Notion 的「歷史與發展」</a>），但直到 2018 年才開始大紅，為什麼？——因為加入了 database。</p><p>儘管在 UI 加入類似 SQL database table 元素與互動操作，並非 Notion 獨創（在此之前，<a href="https://www.airtable.com/">Airtable</a> 無疑是更具代表性的服務），但我們不得不承認，<strong>Notion 確確實實把 database 玩出了新的高度</strong>。</p><h3 id="系列：Simple-Notion——我的-Notion-簡潔之道"><a href="#系列：Simple-Notion——我的-Notion-簡潔之道" class="headerlink" title="系列：Simple Notion——我的 Notion 簡潔之道"></a><strong>系列：Simple Notion——我的 Notion 簡潔之道</strong></h3><blockquote><ol><li><a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a></li><li><a href="https://blog.kyomind.tw/stumbling-on-notion/">少則得，多則惑：使用 Notion 時的兩個常見陷阱</a></li><li><strong>剛剛好：Notion database「反複雜」使用指南</strong></li></ol></blockquote><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>我希望不落俗套地，討論 Notion 的 database——它的美麗與哀愁。</p><p>既然是「Simple Notion」系列文章，主軸仍要聚焦在「簡潔」二字。而講到簡潔使用 Notion，database 絕對是<strong>一個無法繞過的核心議題</strong>。</p><span id="more"></span><h3 id="什麼叫不落俗套？"><a href="#什麼叫不落俗套？" class="headerlink" title="什麼叫不落俗套？"></a>什麼叫不落俗套？</h3><p>看過前兩篇的讀者應該能夠預見，我又要來說一說 database 的缺點了。嚴格而言，應該叫作「濫用 database 的困境」。</p><p>Notion database 是如此的強大，以至於能夠讓 Notion 在眾多筆記軟體中脫穎而出。甚至，有了 database，你簡直不能說 Notion 只是一個筆記軟體了。</p><p>說它是一個資料平台也不為過。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>這篇文章是為了「已使用過 Notion database 但<strong>覺得太複雜或心累</strong>」的讀者而寫。</p><p>因為我就是其中一員！至少曾經是。</p><p>雖然現在已經較少使用 Notion database（只拿來管理文章草稿和工作會議記錄），但我覺得這個「利器」，適度使用還是非常方便的。</p><h2 id="本文架構與主軸"><a href="#本文架構與主軸" class="headerlink" title="本文架構與主軸"></a>本文架構與主軸</h2><p>我們要先講 Notion database 為什麼強大，然後再討論與之相關的「困境」，最後則是我對這些困境的解法與心得。</p><p>本文的主軸是「<strong>Notion database 使用之道</strong>」。因此，如同前兩篇，文中不會有任何關於 Notion database 的詳細操作教學——這些是「術」。</p><p>想知道各種 database 使用技巧，可以上 YouTube，那裡有著海量的學習資源。</p><hr><p>讓我們進入正題。</p><h2 id="Notion-的核心——database"><a href="#Notion-的核心——database" class="headerlink" title="Notion 的核心——database"></a>Notion 的核心——database</h2><p>Notion database 真的很強大。可以說，光是 database 和六種 <a href="https://www.notion.so/help/guides/when-to-use-each-type-of-database-view">database view</a>，就佔據了 Notion 一半以上的重要功能——以及複雜度。</p><p>雖然 Notion database 有借鑑 Airtable 之嫌，但 <strong>view 與 view 之間的自由切換、資料的靈活呈現</strong>，則是任何剛接觸的人，都不得不讚嘆的強大應用模式。</p><h3 id="Notion-的本體就是-database"><a href="#Notion-的本體就是-database" class="headerlink" title="Notion 的本體就是 database"></a>Notion 的本體就是 database</h3><p>換句話說，我認為要用 Notion，絕對是因為它強大的 database。</p><p>這東西大大滿足了喜歡收集資料，和把它們整理得井然有序而且美觀的筆記控！我也曾經是這一份子啦☺️</p><p>不過就像前一篇說的，不建議花太多時間在「美觀」上，這會沒完沒了：</p><blockquote><p>這些元素可以讓你<strong>在視覺上感到富足</strong>，但從<strong>筆記效率</strong>與<strong>學習、實用角度</strong>來看，恐怕沒有多少幫助。光挑選這些「<strong>樣式</strong>」，就能花掉你不少時間，甚至讓人<strong>樂此不疲</strong>。</p></blockquote><h3 id="Craft——沒有-database-的-Notion？"><a href="#Craft——沒有-database-的-Notion？" class="headerlink" title="Craft——沒有 database 的 Notion？"></a>Craft——沒有 database 的 Notion？</h3><p>第一篇我們曾討論過「<a href="https://blog.kyomind.tw/simple-notion/#Notion-%E6%9B%BF%E4%BB%A3%E5%93%81%EF%BC%9F">Notion 替代品？</a>」這個議題，並提到了這篇文章〈<a href="https://matters.town/@willliu/169743-%E6%88%91%E7%94%A8%E4%BE%86%E5%8F%96%E4%BB%A3-notion-%E7%9A%84%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94-craft-bafyreibxtqjrt6yiwto5jqpogd27j6wcloj3xvq6z5w5nyhafqzpq33ydy">我用來取代 Notion 的筆記軟體：Craft</a>〉。</p><p><a href="https://www.craft.do/">Craft</a> 被部分人稱之為「<strong>沒有 database 的 Notion</strong>」，意味著它省去了 database 的複雜，但保留了其它吸引人的功能。</p><p>我自己因為有訂閱 <a href="https://setapp.com/">Setapp</a>（Craft 有收錄其中），所以有短暫嘗試過一下，但體驗不是很好。</p><p>主要是中文排版讓我覺得頗為零亂，而且字太小又沒有調整機制，這違背了我對筆記軟體的「<a href="https://blog.kyomind.tw/bear/#%E4%BA%8C%E3%80%81%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E7%9A%84%E9%81%B8%E9%A0%85%E5%A4%AA%E5%B0%91">三大基本要求</a>」。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/bear/">Evernote 最佳替代方案——筆記軟體 Bear 2 升級心得</a></p></blockquote><p>但扣除這些，我也不禁在想：「沒有 database 的 Notion，我會想用嗎？」——我深表懷疑。</p><p>簡言之，database 無庸置疑是 Notion 的一大利器。我認為，一般人想要充分感受 Notion 的魅力，學習 database 是不可或缺的一環。</p><p>但是！<strong>怎麼用，才算是「剛剛好」</strong>？</p><p>我歸納了學習使用 Notion database 時常見的三大困境。先了解它們，才好對症下藥。</p><hr><h2 id="困境一：學習門檻"><a href="#困境一：學習門檻" class="headerlink" title="困境一：學習門檻"></a>困境一：學習門檻</h2><p>如前所述，database 佔據了 Notion 一半以上的功能與<strong>複雜度</strong>。對於沒有太多時間深入研究的人而言，學習如何有效使用 database 可能是一個挑戰，甚至是一種焦慮。</p><p>而網路上的很多教學，進一步加劇了這個困境。</p><p>部分文章或 YouTube 影片，為了讓讀者、觀看者印象深刻，往往使用相對複雜或進階的技巧，藉以展現 Notion  database 的強大功能。</p><p>這些「database 技巧」印證了 Notion 的強大，但也可能增加了複雜度和學習曲線，讓部分新手感到困惑與沮喪，覺得自己無法有效應用 Notion。</p><p>這也是為什麼我會寫下〈<a href="https://blog.kyomind.tw/notion-markdown/">Notion 教學：10 個我最常用的 Markdown 語法與快捷鍵介紹</a>〉這樣的文章，讓 Notion 操作回歸基本。</p><p>毫無疑問，我認為 database 的使用，也應該回歸基本——但並不容易。</p><h2 id="困境二：不必要的複雜"><a href="#困境二：不必要的複雜" class="headerlink" title="困境二：不必要的複雜"></a>困境二：不必要的複雜</h2><p>說起「不必要的複雜」，軟體工程師可能頗有經驗，在開發上我們稱為「過度設計」。</p><p>複雜不一定是問題，少數情況就是要「複雜且有系統地處理」。但是，我們也常看到，很多時候的複雜，真的不是那麼必要。</p><p>這裡所謂的「複雜」，可以指使用 database 欄位各種進階技巧，比如把「公式」欄位玩出各種花樣，或巧妙建立 database 間的關聯（對應欄位是 Relation 和 Rollup）。或任何你看了會不禁發出「wow！」讚嘆的用法。</p><p>誠然，Notion databse 可以做很多事，但這也可能讓你不知不覺掉入了前一篇提到的「<a href="https://blog.kyomind.tw/stumbling-on-notion/#%E9%81%8E%E5%BA%A6%E8%A8%AD%E8%A8%88%EF%BC%9A%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E7%AD%86%E8%A8%98%E6%9E%B6%E6%A7%8B%E5%B8%AB">筆記架構師陷阱</a>」：</p><blockquote><p>這是一個逐漸「<strong>上癮</strong>」的過程，因為 Notion 創建新頁面與層級是<strong>如此地簡單</strong>，導致遇到<strong>新需求</strong>時，我就想要用「<strong>增加 Notion 元素、擴張筆記架構</strong>」的方式來應對，結果它愈長愈大，直到脫離了我的控制。</p></blockquote><p>「擴張筆記架構」最<strong>典型</strong>的情況，就是增加 database 的<strong>數量和欄位</strong>！甚至是它們之間的<strong>關聯</strong>。</p><p>這也就是下面要講的——過度使用。</p><hr><h2 id="困境三：過度使用"><a href="#困境三：過度使用" class="headerlink" title="困境三：過度使用"></a>困境三：過度使用</h2><blockquote><p>一有新的筆記整理、分類需求，就立刻想到新增一個 database；或為既有的 database 新增一個甚至多個欄位。</p></blockquote><p>這幾乎是所有 Notion 新手<strong>不可避免的困境</strong>，當然包括我。</p><p>這樣做有什麼問題？相信過來人都懂，讓我講講自身的經驗。</p><h3 id="使用-Notion-做程式筆記"><a href="#使用-Notion-做程式筆記" class="headerlink" title="使用 Notion 做程式筆記"></a>使用 Notion 做程式筆記</h3><p>以前大量使用 Notion，主要就是為了學程式，所以有很多程式相關的筆記。這些筆記本來只有兩個 database：</p><ol><li>學習筆記：技術類書籍、線上課程、文章的整理。</li><li>實作筆記：開發過程中遇到的問題與我的踩坑記錄。</li></ol><p>這感覺不錯，但你可能已經猜到——兩個根本不夠用！至少對我而言不夠用。</p><p>光學習，可能要區分成「程式類」和「非程式類」。而不同素材如書、線上課、文章等等，我不希望它們<strong>歸納時</strong>沒有任何區別，因為這樣找起來或複習很麻煩。</p><p>於是，為了新的「子分類」，要麻再多開一個 database，不然就是多增加一些欄位作為區別。我甚至想把程式主題再進一步細分，比 Django、Docker、Python 等等。</p><p>如此反覆，我的學習筆記類 database 在數量上增加到了 6-8 個，其中有的欄位多、有的欄位少。</p><h2 id="Database-太多了！"><a href="#Database-太多了！" class="headerlink" title="Database 太多了！"></a>Database 太多了！</h2><blockquote><p>後來，看著一堆 database，覺得自己好累，尤其在新增一則筆記時，不得不先思考：「呃……它應該放到哪個 db？」——好像已經太多了。</p></blockquote><p>如果你有很多個 database 要維護，那首先你對它們得有一個相對清晰的概念與操作體系，才不容易作繭自縛。</p><p>但我必須說，至少在「學習」這一塊，要透過清晰的體系來架構 database，恐怕相對困難。</p><p>為什麼？因為隨著學習的進展，<strong>知識體系往往也會不斷調整</strong>。以往的分類可能不再適用或滿足你，需要做出一定改變。</p><p>然而，<strong>database 是很「重」的</strong>，增加欄位可以，但想要把一部分的資料遷移到新的 database 或分配到不同層級，則麻煩很多。不僅需要你<strong>手動搬運</strong>（使用<code>Move to</code>），還需要處理搬運後<strong>新舊欄位不相容的問題</strong>。</p><p>此外，每新增一筆記錄，就要為欄位選擇各項值，也是一件「看起來有條理，但實際對學習沒有直接助益」的苦力活。</p><p>這些當然可以用模板等功能來簡化，但，你不累嗎？</p><h3 id="無解的「分類」難題"><a href="#無解的「分類」難題" class="headerlink" title="無解的「分類」難題"></a>無解的「分類」難題</h3><p>我認為<strong>分類難題</strong>（為各種事物、概念等筆記找到分類上的明確歸屬）可以說是無解的——尤其當這些分類會<strong>隨著時間不斷變動</strong>的情況下。</p><p>而大量的 database，<strong>本質上就是一層又一層的分類</strong>，容易累死自己。</p><p>還是要再強調一下，這裡我類比的情境是「學習筆記」，一個在分類上<strong>容易不斷變動</strong>的主題。但我覺得，其實現實中大部分情況都是如此——分類就是會一直變動。</p><p>當然，也有例外，比如年、月、週等計畫的 database，概念之間是相對分明的。</p><p>無論如何，只要 database 一多，新增筆記時你難免就要先思考「我要新增到哪個 db？」，複習或搜尋時也要想著「這件事應該是記在哪個 db？」</p><p>腦力成本高昂。</p><hr><h2 id="我的-database-減法"><a href="#我的-database-減法" class="headerlink" title="我的 database 減法"></a>我的 database 減法</h2><p>簡單使用 Notion database 可能比簡單使用 Notion 要來得容易，我個人會貫徹下列原則。</p><p>不過這些原則多少都會<strong>限制 database 的發揮</strong>，所以是「原則」，作為需要時的指引。</p><h3 id="一、能透過「新增欄位」達成的，就不新增-db"><a href="#一、能透過「新增欄位」達成的，就不新增-db" class="headerlink" title="一、能透過「新增欄位」達成的，就不新增 db"></a>一、能透過「新增欄位」達成的，就不新增 db</h3><p>雖然欄位管理也是一個難題，但怎麼說都比新增一個獨立 database 來得<strong>輕量</strong>。</p><p>換句話說，當筆記架構變複雜、需要更多手段來<strong>有效分類</strong>不同筆記時，建議優先選用欄位而非新增 database。</p><h3 id="二、欄位不要過多"><a href="#二、欄位不要過多" class="headerlink" title="二、欄位不要過多"></a>二、欄位不要過多</h3><p>雖然說能用欄位處理的就不要透過 db，但欄位的增加也必須適合可止，盡可能讓每一個欄位<strong>都是必要的</strong>，而不是為了「看起來井然有序」或「看起來更完整」。</p><p>畢竟填寫欄位的人是自己。即使有模板，要應付各種複雜的欄位與情況，模板可能也要很多樣，這些都不利於筆記。</p><p>就經驗看來，<strong>閱讀類的 database，最容易出現欄位過多的問題</strong>。</p><p>因為一本書有很多種屬性，非常適合透過 database 突顯與整理！比如封面、作者、出版社、出版年度、書籍分類、個人評價、名言摘錄等等，簡直沒完沒了。</p><p>但閱讀一本書，最重要的往往只有一件事——獲得最大程度的滿足與改變行動。</p><h3 id="三、減少進階功能的使用"><a href="#三、減少進階功能的使用" class="headerlink" title="三、減少進階功能的使用"></a>三、減少進階功能的使用</h3><p>關聯、公式等等比較進階的功能，讓人感覺很厲害，有時候也確有妙用。但我覺得，<strong>少知道一點或許會比較好。</strong></p><p>重劍無鋒，大巧不工。雖然不是最高竿的使用，卻可能會更加高效。</p><h3 id="四、善用-view-與-linked-database"><a href="#四、善用-view-與-linked-database" class="headerlink" title="四、善用 view 與 linked database"></a>四、善用 view 與 linked database</h3><p>至於過濾、排序、view 等功能分頁，我覺得它們是「必要之惡」。</p><p><img src="https://i.imgur.com/DLNmoEx.png" alt="view 分頁"><span class="cap">view 分頁</span></p><p>意思是，雖然太多分頁也會造成困擾，但這些分頁透過選擇不同 view、過濾條件、排序方式等，確實能<strong>讓 db 資料更加有效呈現，充分發揮看資料的視角</strong>，我認為非常值得善用它們。</p><p>如果分頁太多了，推薦再開一個 <a href="https://www.notion.so/help/guides/using-linked-databases">linked database</a>，這下又多了一個呈現資料的分身。</p><p>總之，<strong>我認為善用 view 分頁與 linked database，就是用好 Notion database 的一大關鍵！</strong></p><p>在新增 db 或新增欄位之前，我們不妨先想想：「是不是新增一個 view 就能解決？」</p><h3 id="五、固定架構"><a href="#五、固定架構" class="headerlink" title="五、固定架構"></a>五、固定架構</h3><p>我覺得 Notion database 最適合的，是那些<strong>筆記架構相對固定的場景</strong>，比如前面提到的年、月、週計畫這類的記錄。</p><p>年、月、週、天就是典型的時間劃分法，很難再生出一種全新的時間劃分。所以 database 的欄位設計與架構相對穩定。</p><p>而我們要做的，就是不斷增加筆記的「量」。這種場景，特別能發揮 database 在體系與分類上的優勢。</p><h3 id="六、架構常變動的場景，我使用卡片筆記"><a href="#六、架構常變動的場景，我使用卡片筆記" class="headerlink" title="六、架構常變動的場景，我使用卡片筆記"></a>六、架構常變動的場景，我使用卡片筆記</h3><p>前面已提及，學習筆記的架構很容易依不同階段而變動，採用 database 常常會讓我覺得過於笨重、趕不上變化。</p><p>此外，database 還有一個「複習不易」的致命傷。</p><p>所以我後來才狠心放棄了寫了 2 年的 Notion，改用 Logseq 來做我的程式學習筆記，以適應快速變動的學習，並達到更有效的複習。</p><p>畢竟卡片筆記更像是「<a href="https://blog.kyomind.tw/logseq/#%E7%84%A1%E5%9B%BA%E5%AE%9A%E4%B8%AD%E5%BF%83%E7%9A%84%E6%B8%B8%E6%93%8A%E9%9A%8A">無固定中心的游擊隊</a>」，有著更強的機動性。</p><p>關於「為什麼我改用 Logseq 做程式筆記」，我們會再另篇討論。這裡只要提醒自己：「database 不適合太過頻繁的架構遷移。」</p><hr><h2 id="題外話：Notion-並不適合做卡片筆記"><a href="#題外話：Notion-並不適合做卡片筆記" class="headerlink" title="題外話：Notion 並不適合做卡片筆記"></a>題外話：Notion 並不適合做卡片筆記</h2><p>正文已經結束，我們來講個題外話。</p><p>這部分跟本文主軸雖然沒有直接關係（但和 database 有關），我還是忍不住想說——Notion 真的不適合做卡片筆記。</p><p>我們先回顧一下〈<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a>〉提到卡片筆記的<a href="https://blog.kyomind.tw/logseq/#%E5%85%83%E7%B4%A0%E5%8C%96%E8%88%87%E9%80%A3%E7%B5%90%E5%B0%8E%E5%90%91">兩大原則</a>：</p><ol><li>元素化。</li><li>連結導向。</li></ol><p>關鍵是第二個：<strong>連結</strong>。</p><p>我知道，Notion database 有 Relation 欄位可以進行簡單的 db 間關聯，頁面開頭也有本頁的 <a href="https://www.playpcesor.com/2020/09/notion.html">backlinks</a> 可供參考。</p><p>但這些功能，相比於「<strong>原生支援雙向連結</strong>」的卡片筆記軟體如 Logseq、Obsidian，在「<strong>有效實踐卡片之間的連結</strong>」這件事上，效果相去甚遠。</p><p>用 Notion 絕對可以做卡片筆記，但很難做得好。</p><p>只要試想一下，當 Relation 欄位有著 <strong>100 個關聯</strong>的時候，這個欄位看起來會是如何？</p><p>而 100 個關聯對於 Logseq 等卡片筆記 app 而言，僅僅只是開始而已。</p>]]></content>
    
    
    <summary type="html">&lt;!-- ![by Tom Clohosy Cole](https://i.imgur.com/KF3B43y.jpg) --&gt;
&lt;!-- ![by Daria Kolesnikova](https://i.imgur.com/zJRTnei.jpg) --&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TJQDGmr.jpg&quot; alt=&quot;by Daria Kolesnikova&quot;&gt;&lt;/p&gt;
&lt;p&gt;讓我們進入「Simple Notion」系列的第三篇，同時也是最後一篇。這次我們要聊聊，Notion 中&lt;strong&gt;最具代表性的元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;提到 Notion 你會想到什麼？沒錯，&lt;strong&gt;database&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;Notion 在 2016 年就誕生了（你也可以說是 2013年，請參考維基百科關於 &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/Notion&quot;&gt;Notion 的「歷史與發展」&lt;/a&gt;），但直到 2018 年才開始大紅，為什麼？——因為加入了 database。&lt;/p&gt;
&lt;p&gt;儘管在 UI 加入類似 SQL database table 元素與互動操作，並非 Notion 獨創（在此之前，&lt;a href=&quot;https://www.airtable.com/&quot;&gt;Airtable&lt;/a&gt; 無疑是更具代表性的服務），但我們不得不承認，&lt;strong&gt;Notion 確確實實把 database 玩出了新的高度&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;系列：Simple-Notion——我的-Notion-簡潔之道&quot;&gt;&lt;a href=&quot;#系列：Simple-Notion——我的-Notion-簡潔之道&quot; class=&quot;headerlink&quot; title=&quot;系列：Simple Notion——我的 Notion 簡潔之道&quot;&gt;&lt;/a&gt;&lt;strong&gt;系列：Simple Notion——我的 Notion 簡潔之道&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/stumbling-on-notion/&quot;&gt;少則得，多則惑：使用 Notion 時的兩個常見陷阱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;剛剛好：Notion database「反複雜」使用指南&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;我希望不落俗套地，討論 Notion 的 database——它的美麗與哀愁。&lt;/p&gt;
&lt;p&gt;既然是「Simple Notion」系列文章，主軸仍要聚焦在「簡潔」二字。而講到簡潔使用 Notion，database 絕對是&lt;strong&gt;一個無法繞過的核心議題&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="卡片盒筆記法" scheme="https://blog.kyomind.tw/tags/%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%B3%95/"/>
    
    <category term="Obsidian" scheme="https://blog.kyomind.tw/tags/Obsidian/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Bear" scheme="https://blog.kyomind.tw/tags/Bear/"/>
    
    <category term="Evernote" scheme="https://blog.kyomind.tw/tags/Evernote/"/>
    
  </entry>
  
  <entry>
    <title>《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱</title>
    <link href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-02/"/>
    <id>https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-02/</id>
    <published>2023-08-19T05:14:26.000Z</published>
    <updated>2023-08-26T02:31:14.647Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/tS78Ke0.png" alt="Python 功力提升的樂趣"><span class="cap">Python 功力提升的樂趣</span></p><p>我們繼續《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務</a>》閱讀筆記，這是第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><hr><h2 id="第-6-章：寫出-Pythonic-風格的程式碼"><a href="#第-6-章：寫出-Pythonic-風格的程式碼" class="headerlink" title="第 6 章：寫出 Pythonic 風格的程式碼"></a>第 6 章：寫出 Pythonic 風格的程式碼</h2><p>我們常常聽到 Pythonic，但如果問起它究竟意味著什麼，可能一時之間也不容易回答，畢竟它沒有一個公認的標準或定義。</p><p>不過，<strong>充利分用 Python 獨有的特性、寫作風格、語法，尤其是善用標準函式庫</strong>（不重複造輪子——因為你自己造的輪子往往<strong>不會</strong>更好、更方便、更有效），顯然是大家都認同的部分。</p><p>至於遵守上篇提到的 <a href="https://peps.python.org/pep-0008/">PEP 8</a>，自然不在話下。如果你的變數命名使用了小駝峰式命名法（lower camel case），那麼在「形式上」就已經不太 Pythonic 了。</p><p>話說回來，本書雖然是一本優秀的 Clean Code in Python 入門書，但不知為何，書中的函式命名皆是採用小駝峰，讓我不甚理解。</p><p>但我們要知道：好孩子不要學。至於為什麼，不用問，問就是 PEP 8。</p><span id="more"></span><h2 id="使用enumerate-而不要用range"><a href="#使用enumerate-而不要用range" class="headerlink" title="使用enumerate()而不要用range()"></a>使用<code>enumerate()</code>而不要用<code>range()</code></h2><p>這真的很重要！當我 review 到下面這類 code 時，我會<strong>強烈要求</strong>必須改用<code>enumerate</code><strong>重構</strong>。</p><p>設想你有一個 Python list 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;moose&#x27;</span>]</span><br></pre></td></tr></table></figure><p>你想同時知道每一個元素是 list 中的<strong>第幾個</strong>與<strong>內容為何</strong>，直觀上可能會這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;moose&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(animals)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i + <span class="number">1</span>, animals[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> cat</span><br><span class="line"><span class="number">2</span> dog</span><br><span class="line"><span class="number">3</span> moose</span><br></pre></td></tr></table></figure><p>這種「<strong>手刻邏輯</strong>式的寫作風格」——要什麼就寫什麼，寫完也不重構——你是否已經屢見不鮮？我們來評論一下，這段程式碼有兩個很醜（難讀）的地方。</p><ol><li><code>i + 1</code>。這寫法顯然是為了讓<strong>計數</strong>從 1 開始——而不是預設的 0。</li><li><code>range(len(animals))</code>寫法非常不直觀，多層的<strong>嵌套式呼叫</strong>讓人看了昏昏欲睡。</li></ol><p>這兩個地方充滿了「<strong>手刻</strong>」的<strong>僵化感</strong>，只是為了<strong>最快速達到開發者「當下目的」而強行採用的一種粗糙手段</strong>——但顯然不是最好的那個。</p><p>雖然兩者都不難理解與推測，但除了寫這段程式的人，<strong>誰也無法 100% 確信作者的「意圖」</strong>——這是<a href="https://ithelp.ithome.com.tw/users/20107637/ironman/1927">糙 code</a> 的特色，它存在著<strong>大量且不必要的誤解空間</strong>。</p><p>這些<strong>不明確的誤解空間</strong>會造成別人閱讀本段程式碼時的「<strong>思考停頓</strong>」，更別說後續滋生 bug 的可能。所幸，它們是有可能被消除的。比如使用以下的<code>enumerate</code>。</p><p>一言以蔽之，你只要<strong>在<code>for</code>迴圈內</strong>，看到以下這樣的寫作模式，那就是典型的 Python <a href="https://blog.darkthread.net/blog/refactoring-notes-2-bad-smell/">壞味道</a>：</p><blockquote><p><code>iterable[index]</code>（<code>可迭代物件[物件元素的索引值]</code>）</p></blockquote><p>迭代任何<code>iterable</code>同時，又需要知道每一個元素的索引值，這毋寧是很常見的需求。</p><p>因為太常見了，所以 Python 早就幫你準備好了——就是為了這種情況而存在的——<code>enumerate</code>。</p><p>同樣的需求，我們應該要這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;moose&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals, start=<span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, animal)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> cat</span><br><span class="line"><span class="number">2</span> dog</span><br><span class="line"><span class="number">3</span> moose</span><br></pre></td></tr></table></figure><p><code>start=1</code>讓你不用再<code>i+1</code>，也不再需要<code>range</code>和<code>len</code>的疊床架屋。</p><p>兩種寫法的結果是一樣的，但後者更加善用 Python 的內建特性，<strong>且優雅</strong>。</p><p><strong>善用 Python 的自身的特性寫出優雅而簡潔的程式碼——這就是 Pythonic。</strong></p><hr><h3 id="使用with陳述式而不要手動close"><a href="#使用with陳述式而不要手動close" class="headerlink" title="使用with陳述式而不要手動close()"></a>使用<code>with</code>陳述式而不要手動<code>close()</code></h3><p>因為你很可能會忘記 close！</p><p><code>with</code>（<strong>context manager，上下文管理器</strong>）在資源管理上很有用，比如文件讀寫或資料庫連接等，可以確保即使有錯誤發生，也能正確地關閉、釋放資源。</p><p>但對於不熟悉或不常見的物件，<strong>則要注意物件是否實作了所謂的「上下文管理協定」</strong>。</p><p>這個協定要求物件必須實作以下兩個方法：<code>__enter__</code> 和 <code>__exit__</code>。這樣物件搭配<code>with</code>使用時，才能正常運作。</p><h3 id="使用is比較是否為None，而不用"><a href="#使用is比較是否為None，而不用" class="headerlink" title="使用is比較是否為None，而不用=="></a>使用<code>is</code>比較是否為<code>None</code>，而不用<code>==</code></h3><p>細節請參考書中的詳盡說明，所幸現代 linter 都會提醒你：在比較<code>None</code>、<code>True</code>、<code>False</code>這 3 種值時，請使用<code>is</code>而非<code>==</code>。</p><h3 id="以-Pythonic-風格來運用字典"><a href="#以-Pythonic-風格來運用字典" class="headerlink" title="以 Pythonic 風格來運用字典"></a>以 Pythonic 風格來運用字典</h3><ol><li>使用<code>get()</code>來處理沒有 key 值而出現<code>KeyError</code>的情況。（不過有時候缺少 key 是一個警訊，此時不宜透過 get 讓這個警訊被忽略）</li><li>使用<code>setdefault()</code>來處理沒有 key 值就要<strong>新增該 key 並給定一個預設值</strong>的情況。</li><li>使用<code>collections.defaultdict</code>來更細緻地處理預設值。</li></ol><p>前兩者你可能已經熟悉，而第 3 種在特定情境真的很好用！以前當資料工程師，進行資料清洗時，我就很喜歡用<code>defaultdict</code>。</p><p>關於<code>defaultdict</code>的用法與介紹，可直接參考這篇〈<a href="https://ithelp.ithome.com.tw/articles/10193094">collections雜談之一 ——— dict的key值存不存在乾我屁事</a>〉。</p><hr><p>上面舉的種種例子，都是常見的 <strong>Python 寫作慣例</strong>，這些慣例是 Python 在設計功能時就已經詳細考慮到的常見情況。換句話說，它們也往往是<strong>最佳實踐</strong>。</p><p>這樣寫，我們不敢說是必要的。只是你真的這麼做的話，熟悉 Python 的人會知道，你就是一個「<strong>內行人</strong>」。</p><p>還是那句〈<a href="https://zh.wikipedia.org/zh-tw/Python%E4%B9%8B%E7%A6%85">Zen of Python</a>〉中的名言：</p><blockquote><p>任何問題應有一種，且<strong>最好只有一種</strong>顯而易見的解決方法。（There should be one– and preferably only one –obvious way to do it.）</p></blockquote><p>說到內行人，下一章我們就來看看，內行人還需要知道哪些事情。</p><h2 id="第-7-章：程式設計的行話"><a href="#第-7-章：程式設計的行話" class="headerlink" title="第 7 章：程式設計的行話"></a>第 7 章：程式設計的行話</h2><p>行話，在本章的情境中，指的是程式設計中的「術語」——包括不限於 Python。</p><p>本章應該算是這些重要基礎的再次強調，有一定經驗的人，可以直接跳過。但我還是介紹一些值得重新溫習的內容。</p><h3 id="物件、值、型別、識別碼"><a href="#物件、值、型別、識別碼" class="headerlink" title="物件、值、型別、識別碼"></a>物件、值、型別、識別<strong>碼</strong></h3><p>物件（object）是<strong>資料的表示形式</strong>，例如數字、字串，或更複雜的資料結構，比如 list 或 set。</p><blockquote><p>所有的物件都具有<strong>值</strong>、<strong>識別碼</strong>（id）和<strong>資料型別</strong>。</p></blockquote><p>這句話很重要。因為我們很常把物件的「值」（比如數字 12、字串<code>&quot;hello&quot;</code>）視為物件「本身」，但實際上那只能說是物件的一個<strong>重要屬性</strong>。</p><p>而物件的其它兩個重要屬性，就是 id（代表物件在<strong>當前的程式執行期間</strong>在<strong>記憶體中的地址</strong>）和型別。</p><p>id 屬性的內容可以透過內建的<code>id</code>函式取得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(<span class="number">12345</span>)</span><br><span class="line"><span class="number">4603344144</span></span><br></pre></td></tr></table></figure><p>而型別則是透過<code>type()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">12345</span>)</span><br><span class="line"><span class="built_in">int</span></span><br></pre></td></tr></table></figure><p>了解這些細節的重要理由是，每次執行程式時，物件的 id 與型別不會改變，但物件的值是可以變動的！這是可變與不可變物件的基石。</p><p>此外，如果兩個物件的 id 相同，那麼它們就是<strong>同一個物件</strong>。這將有助於你理解關於「物件的參照」與「<a href="https://blog.kyomind.tw/the-quick-python-book/#%E4%B8%80%E3%80%81Python-%E4%B8%AD%E7%9A%84%E8%AE%8A%E6%95%B8%EF%BC%9A%E6%98%AF%E6%B0%B4%E6%A1%B6%E9%82%84%E6%98%AF%E6%A8%99%E7%B1%A4%EF%BC%9F">一、Python 中的變數：是水桶還是標籤？</a>」等議題。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/the-quick-python-book/">最佳 Python 入門書——《Python 技術者們 - 練功！》心得與導讀</a></p></blockquote><h3 id="可變與不可變"><a href="#可變與不可變" class="headerlink" title="可變與不可變"></a>可變與不可變</h3><p>剛剛提到，物件中只有「值」是可以（有可能）改變的。所以依照物件的<strong>值是否可以改變</strong>，物件也分為兩大類：</p><ol><li>可變物件。</li><li>不可變物件。</li></ol><p>這無疑是一大經典議題，但這裡就不展開了。只要知道物件的可變與不可變，對於變數的「參照」有著巨大的影響。有興趣可以再看看「<a href="https://blog.kyomind.tw/the-quick-python-book/#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6%E4%BD%9C%E7%82%BA%E5%BC%95%E6%95%B8%E6%99%82%E8%A6%81%E5%B0%8F%E5%BF%83">二、使用可變物件作為引數時要小心</a>」部分。</p><hr><p>本章還有很多術語的定義介紹，比如陳述式（statement）與表達式（expression）、iterable 與 iterator、參數與引數……等等，就請讀者自行參照書中介紹囉！</p><h2 id="第-8-章：常見的-Python-誤解和陷阱"><a href="#第-8-章：常見的-Python-誤解和陷阱" class="headerlink" title="第 8 章：常見的 Python 誤解和陷阱"></a>第 8 章：常見的 Python 誤解和陷阱</h2><p>本章介紹基於 Python 特性的一些常見錯誤——我們一定都踩過。在此只提「為什麼這樣不好」以及如何避免這些不佳實作的<strong>核心思路</strong>。</p><h3 id="不要在迴圈中新增或刪除「被迭代物件（比如-list）」中的元素"><a href="#不要在迴圈中新增或刪除「被迭代物件（比如-list）」中的元素" class="headerlink" title="不要在迴圈中新增或刪除「被迭代物件（比如 list）」中的元素"></a>不要在迴圈中新增或刪除「被迭代物件（比如 list）」中的元素</h3><p>只要遇過一、兩次就會知道這個坑，但一段時間後，很可能會一錯再錯XD。</p><p>新增可能會造成無限迴圈（因為迭代不完），而且刪除則很可能會造成<strong>索引值與你預期內容產生錯亂的問題</strong>。</p><p>大原則就是「不要在迴圈中<strong>編輯</strong>（修改）當前被迭代的<strong>可變物件</strong>」，如果必須這麼麼做，就為它們建立一個「副本」吧！</p><h3 id="一定要用copy-copy-和copy-deepcopy-來複製「可變值」"><a href="#一定要用copy-copy-和copy-deepcopy-來複製「可變值」" class="headerlink" title="一定要用copy.copy()和copy.deepcopy()來複製「可變值」"></a>一定要用<code>copy.copy()</code>和<code>copy.deepcopy()</code>來複製「可變值」</h3><p>承上，既然要建立複本，就要採用穩妥的方式，而穩妥方式就是使用內建方法。</p><p>這又又又是一個「物件參照」的相關議題。下一個也是。</p><h2 id="不要使用「可變物件」作為「預設參數」"><a href="#不要使用「可變物件」作為「預設參數」" class="headerlink" title="不要使用「可變物件」作為「預設參數」"></a>不要使用「可變物件」作為「預設參數」</h2><p>這點你可能已經很熟悉了，因為幾乎每一本書都會強調。</p><p>我們用簡單的一段話來再次回顧，<strong>為什麼不能這麼做</strong>，by ChatGPT：</p><blockquote><p>在Python 中，不應該用可變物件做預設參數（引數），因為這個可變物件在函式第一次<strong>被定義的時候</strong>就已經「<strong>固定</strong>」了。（<strong>只會建立一次</strong>）</p></blockquote><blockquote><p>以後每次呼叫這個函式但<strong>沒有提供這個引數</strong>的話，都會<strong>共用同一個物件</strong>。如果你在函式裡改變了這個物件，那麼下次呼叫時，<strong>這個改變就被保留下來了</strong>。這會讓程式的行為變得很難預測和控制。</p></blockquote><p>看一下程式碼，這個函式正常使用時，希望你帶入一個<code>fruit_list</code>作為引數——當然，從上面的「<a href="https://blog.kyomind.tw/the-quick-python-book/#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6%E4%BD%9C%E7%82%BA%E5%BC%95%E6%95%B8%E6%99%82%E8%A6%81%E5%B0%8F%E5%BF%83">二、使用可變物件作為引數時要小心</a>」我們知道，這也是一個不太健康的做法！</p><p>關於使用可變物件為引數，我們先不論，下面的呼叫我們都不給第二個引數，讓它<strong>只使用預設值</strong>。</p><p>我們預期的行為是：每次給定不同的水果，且不給<code>fruit_list</code>引數，則產出應該都要是「以該水果為單一元素的」的 list——<strong>但事實完全不是如此</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_fruit_to_list</span>(<span class="params">fruit, fruit_list=[]</span>):</span><br><span class="line">    fruit_list.append(fruit)</span><br><span class="line">    <span class="keyword">return</span> fruit_list</span><br><span class="line"></span><br><span class="line">apple_list = add_fruit_to_list(<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(apple_list)  <span class="comment"># 輸出: [&#x27;apple&#x27;]</span></span><br><span class="line"></span><br><span class="line">banana_list = add_fruit_to_list(<span class="string">&#x27;banana&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(banana_list)  <span class="comment"># 輸出: [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(apple_list)  <span class="comment"># 輸出: [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure><p>當「第二次」呼叫函式時，情況就<strong>不是我們要的</strong>了：</p><ol><li>banana_list 竟然包含了 apple！</li><li>apple_list 竟然也被改變了！</li></ol><h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>而替代方案想必你也知曉，那就是把預設值改設為<code>None</code>，然後在函式中加上一個判斷式，比如下面的<code>if fruit_list is None:</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_fruit_to_list</span>(<span class="params">fruit, fruit_list=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> fruit_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        fruit_list = []</span><br><span class="line">    fruit_list.append(fruit)</span><br><span class="line">    <span class="keyword">return</span> fruit_list</span><br><span class="line"></span><br><span class="line">apple_list = add_fruit_to_list(<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line">banana_list = add_fruit_to_list(<span class="string">&#x27;banana&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(apple_list)  <span class="comment"># 輸出: [&#x27;apple&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(banana_list)  <span class="comment"># 輸出: [&#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure><p>當沒有提供<code>fruit_list</code>參數（引數）時，<code>if fruit_list is None:</code>判斷式會成立，判斷式內通常會<strong>建立一個全新的可變物件</strong>，讓每一次呼叫都會有不同的<code>fruit_list</code>可變物件，避免前述的「狀態殘留」與意料之外的錯誤。</p><hr><h3 id="不要以字串連接來製作字串"><a href="#不要以字串連接來製作字串" class="headerlink" title="不要以字串連接來製作字串"></a>不要以字串連接來製作字串</h3><p>所謂的字串連接，就是使用<code>+</code>運算子來合併多個字串。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greeting = <span class="string">&#x27;Hello&#x27;</span> + <span class="string">&#x27;World!&#x27;</span></span><br></pre></td></tr></table></figure><p>連接兩個字串無傷大傷，但如果是這樣的話：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greeting = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    greeting += <span class="string">&#x27;one more&#x27;</span></span><br></pre></td></tr></table></figure><p>就會造成效能上的低落——和下列替代方案相比，慢了近 10 倍。</p><p>因為 Python 的<strong>字串</strong>是<strong>不可變</strong>的，所以這種拼接實際上是用舊的字串<strong>建立新的字串</strong>，for 迴圈中的每一次迭代，都會建立一個新字串。</p><p>替代方案當然就是經典的 list +<code>join</code>字串方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greeting_parts = [<span class="string">&#x27;Hello World!&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    greeting_parts.append(<span class="string">&#x27;one more&#x27;</span>)</span><br><span class="line"></span><br><span class="line">greeting = <span class="string">&#x27;&#x27;</span>.join(greeting_parts)</span><br></pre></td></tr></table></figure><h2 id="tuple-中即使只有一個元素，也不要忘記加逗號"><a href="#tuple-中即使只有一個元素，也不要忘記加逗號" class="headerlink" title="tuple 中即使只有一個元素，也不要忘記加逗號"></a>tuple 中即使只有一個元素，也不要忘記加逗號</h2><p>這個例子非常經典！因為不少人可能寫了超過一年的 Python，都未必知道這個特性，而在某些「意料之外」的事發生後，才赫然發現這個事實。</p><p>好，我承認第一次知道時我也很吃驚，還好我是看書知道的。</p><p>照標題的意思，單元素 tuple 應該要長這樣：<code>(&quot;cat&quot;,)</code>，而不是這樣<code>(&quot;cat&quot;)</code>。</p><p>為什麼？</p><p>我們先看一下 ChatGPT 怎麼說：</p><blockquote><p>這是因為在 Python 中，括號（這裡指的是「小」括號）被用於<strong>多個目的</strong>，例如分組表達式。當你寫<code>(&quot;cat&quot;)</code>時，括號會<strong>被解釋為分組符號</strong>，所以這個表達式的值<strong>就是字串</strong><code>&quot;cat&quot;</code>，而<strong>不是</strong>包含一個元素的元組（tuple）。</p></blockquote><blockquote><p>如果你想要創建一個只有一個元素的元組，你需要在那個元素後面加上逗號。所以<code>(&quot;cat&quot;,)</code><strong>才是</strong>包含一個元素的元組。逗號告訴Python你想要創建一個元組，而不僅僅是使用括號進行分組。</p></blockquote><p>非常經典的講解！</p><p>就像《<a href="https://www.tenlong.com.tw/products/9789863479116">流暢的 Python</a>》中說的，逗點才是 tuple 的本體XD。</p><p>這也是為什麼我們在函式中 return 複數值時，不需要為它們加上小括號，只要使用逗點分隔，return 自然就是一個 tuple。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiple_values</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="number">42</span></span><br><span class="line"></span><br><span class="line">result = multiple_values()</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 輸出: (&#x27;apple&#x27;, &#x27;banana&#x27;, 42)</span></span><br></pre></td></tr></table></figure><p>足見，逗點確實是定義 tuple 的關鍵。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tS78Ke0.png&quot; alt=&quot;Python 功力提升的樂趣&quot;&gt;&lt;/p&gt;
&lt;p&gt;我們繼續《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務&lt;/a&gt;》閱讀筆記，這是第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第-6-章：寫出-Pythonic-風格的程式碼&quot;&gt;&lt;a href=&quot;#第-6-章：寫出-Pythonic-風格的程式碼&quot; class=&quot;headerlink&quot; title=&quot;第 6 章：寫出 Pythonic 風格的程式碼&quot;&gt;&lt;/a&gt;第 6 章：寫出 Pythonic 風格的程式碼&lt;/h2&gt;&lt;p&gt;我們常常聽到 Pythonic，但如果問起它究竟意味著什麼，可能一時之間也不容易回答，畢竟它沒有一個公認的標準或定義。&lt;/p&gt;
&lt;p&gt;不過，&lt;strong&gt;充利分用 Python 獨有的特性、寫作風格、語法，尤其是善用標準函式庫&lt;/strong&gt;（不重複造輪子——因為你自己造的輪子往往&lt;strong&gt;不會&lt;/strong&gt;更好、更方便、更有效），顯然是大家都認同的部分。&lt;/p&gt;
&lt;p&gt;至於遵守上篇提到的 &lt;a href=&quot;https://peps.python.org/pep-0008/&quot;&gt;PEP 8&lt;/a&gt;，自然不在話下。如果你的變數命名使用了小駝峰式命名法（lower camel case），那麼在「形式上」就已經不太 Pythonic 了。&lt;/p&gt;
&lt;p&gt;話說回來，本書雖然是一本優秀的 Clean Code in Python 入門書，但不知為何，書中的函式命名皆是採用小駝峰，讓我不甚理解。&lt;/p&gt;
&lt;p&gt;但我們要知道：好孩子不要學。至於為什麼，不用問，問就是 PEP 8。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="筆記" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="閱讀心得" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>Apple Studio Display 適合你嗎？——我的心得與選購指南</title>
    <link href="https://blog.kyomind.tw/apple-studio-display/"/>
    <id>https://blog.kyomind.tw/apple-studio-display/</id>
    <published>2023-08-16T16:06:24.000Z</published>
    <updated>2023-08-26T05:19:00.432Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/H6W14Kj.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p><a href="https://www.apple.com/tw/shop/buy-mac/apple-studio-display">Apple Studio Display</a> 無疑是今年內，我所有新購入的<a href="https://blog.kyomind.tw/weekly-review-16/#%E4%BD%95%E8%AC%82%E5%83%B9%E5%80%BC%E8%A7%80%E5%B1%A4%E7%B4%9A%E7%9A%84%E3%80%8C%E5%99%A8%E7%89%A9%E3%80%8D%EF%BC%9F">器物</a>之中，<strong>最值得的選擇</strong>，且沒有之一。</p><p>但它不一定適合你，也可能不適合多數人。</p><blockquote><p>相關文章：</p><ul><li><a href="https://blog.kyomind.tw/mac-mini/">M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南</a></li><li><a href="https://blog.kyomind.tw/weekly-review-16/">16，我的「價值觀層級」器物清單</a></li></ul></blockquote><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>作為一個使用它近半年的真實用戶，我撰寫本文的目標，就是為了協助你判斷：<strong>是不是真的值得為自己購買一台 Studio Display。</strong></p><p>你也可以當作這是一篇 <strong>Studio Display 開箱文</strong>。</p><p>我們會提到它的優點——我最喜歡的部分。不過，作為一台昂貴的螢幕，在購入之前，你可能更關心「它究竟適不適合自己、值不值得？」</p><p>就像我在〈<a href="https://blog.kyomind.tw/weekly-review-13/">13，我買了 Apple Studio Display 與系列心得寫作計畫</a>〉說的：</p><blockquote><p>那些你<strong>不喜歡</strong>或<strong>可能無法接受</strong>的環節，才是做決定時最重要的考量點——<strong>那些「不」才是關鍵</strong>。</p></blockquote><span id="more"></span><h2 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h2><p>Studio Display 是 Apple 公司專為 Mac 推出的專業顯示器。</p><p>雖然 Windows 電腦也可以連接並使用 Studio Display，但存在一些限制，而且可能還有其它意料之外的問題。</p><p>所以，<strong>本文是寫給 Mac 用戶的選購指南。</strong></p><p>Windows 用戶如果真心想買，建議先參考下列兩篇文章：</p><ul><li><a href="https://www.techbang.com/posts/95066-using-the-apple-studio-display-display-on-a-windows-pc-is">網友實戰在 PC上使用蘋果Studio Display顯示器：不但功能半殘，而且接線可能會把你搞瘋</a></li><li><a href="https://applefans.today/2022-03-how-to-use-apple-studio-display-with-windows-pc/">如何在 Windows 上使用 Apple Studio Display?</a></li></ul><h2 id="兩部影片推薦"><a href="#兩部影片推薦" class="headerlink" title="兩部影片推薦"></a>兩部影片推薦</h2><p>一般的文章，參考材料肯定是放在文末，甚至直接省略。</p><p>但是像「顯示器開箱、評論」這樣的內容，我們從直觀上想像，無疑透過「<strong>影片</strong>」是最適合的，畢竟是它顯示器嘛！——我們想要看顏色、聽聲音。</p><p>因此，我在購入 Studio Display 之前，也不可免地看了大量評測影片。</p><p>但我覺得「少則得，多則惑」，大部分影片講的不夠深入，或者面向的受眾群體更廣，參考價值相對有限。</p><p>我推薦以下這兩部 Studio Display 評測影片，對我頗有幫助。而且我覺得看完文本加上這些影片，已經很足夠：</p><ul><li><a href="https://youtu.be/kdMIw9R7XrQ">最後，我還是怒刷！Apple Studio Display 開箱 &amp; 三個月真實使用心得：蘋果終究是蘋果，連螢幕也有最強生態圈體驗</a></li><li><a href="https://youtu.be/ai7Qc3hV1Xw">「黑貓」Apple Studio Display 開箱 + 評測 + 連接PC</a></li></ul><hr><p>正文開始，我們先講它的優點，再論選購前注意事項，最後給出我對 Studio Display 的總體評價。</p><h2 id="我最喜歡-Studio-Display-的部分"><a href="#我最喜歡-Studio-Display-的部分" class="headerlink" title="我最喜歡 Studio Display 的部分"></a>我最喜歡 Studio Display 的部分</h2><p>以下這幾點是我個人最喜歡 Studio Display 的地方。大部分與主流觀點相同，而最後一項則是我個人的偏好。</p><p>關於優秀的畫質，這對 Studio Display 無疑是基本，且無法用簡單文字呈現，直接參考上述影片即可。以下講述<strong>顏色之外</strong>的細節。</p><h3 id="一、出色的揚聲器"><a href="#一、出色的揚聲器" class="headerlink" title="一、出色的揚聲器"></a>一、出色的揚聲器</h3><p>誰也沒想到，一台螢幕竟然在揚聲器（喇叭）部分引發了熱烈的討論。</p><p>原因無它，如果 Studio Display 的揚聲器音質是 100 分，那其餘「螢幕附帶」的揚聲器，應該沒有一款可以得到 50 分。</p><p>和很多人一樣，買了這台螢幕後，我就把桌上型 2.0 喇叭（兩件式喇叭）丟掉了。電腦桌面空出了原先喇叭與線材佔用的空間，讓人感覺無比清爽！</p><p>無論是音質還是省下的空間，都出乎了我的意料，對此大大加分！</p><p>Studio Display 揚聲器的音質大概可以比美台幣 1500-3000 價位的桌上型 2.0 喇叭。對我而言，已然足夠。</p><p>除此之外，螢幕內建的麥克風和前鏡頭也都有一定水準，對非專業人士而言，堪稱綽綽有餘。</p><h3 id="二、5K-與-4K"><a href="#二、5K-與-4K" class="headerlink" title="二、5K 與 4K"></a>二、<strong>5K 與 4K</strong></h3><p>Studio Display 5K 解析度的 1474 萬總像素量， 比一般常見 27吋 4K 的 829 萬的像素量，<strong>足足多了 77.7%。</strong></p><p>用 PPI 比較，則是 218（5K）VS 163（4K）——差距不可謂不小。而 Studio Display  的 218 PPI，顯然是比照 Macbook 的 PPI 標準。</p><p>不過，使用 27 吋螢幕的視線距離，肯定大於使用筆電型電腦，所以對 PPI 的要求或許不需要達到 Macbook 等級。</p><p>但可以想見，兩者的<strong>細膩度</strong>，在視覺上仍會有一定落差，從文字的「毛邊」就能體現。對於常盯著程式碼與文字稿的我，依舊會很在意。</p><p>所以，5K 解析度對我而言，有其價值與必要性。</p><h3 id="三、抗反射鍍膜"><a href="#三、抗反射鍍膜" class="headerlink" title="三、抗反射鍍膜"></a>三、抗反射鍍膜</h3><p>Macbook 或非平價版 iPad 的用戶，對 Apple 這項科技肯定不陌生。</p><p>不僅保留了鏡面螢幕在觀看時的<strong>通透感</strong>（如下圖），又大幅降低了一般鏡面螢幕的最大問題——反光。</p><p>下圖截取自<a href="https://youtu.be/yiRIfoEqGxw">這部影片</a>，比較<strong>鏡面版</strong>（右，有抗反射鍍膜）和 <strong>Nano-texture 版</strong>（可以類比於一般常見的霧面螢幕，只是 Nano-texture 更高級）的視覺差距。</p><p>擁有抗反射鍍膜的 Studio Display 鏡面版，其視覺效果，無疑是肉眼可見的好。</p><p><img src="https://i.imgur.com/KE1nUaD.png" alt="來源：YouTube 鍾文澤"><span class="cap">來源：YouTube 鍾文澤</span></p><p>這也是為什麼我<strong>非買 Studio Display 不可</strong>的另一大理由。畢竟市面上絕大部分的螢幕都是<strong>霧面</strong>，即使畫質再好，實際顯示效果也會<strong>大打折扣</strong>。</p><p>附帶一提，如影片中所言，除非你<strong>很清楚自身需求</strong>，否則不建議買 Nano-texture 版，而上圖就是理由。</p><h3 id="四、4-邊等寬的螢幕邊框"><a href="#四、4-邊等寬的螢幕邊框" class="headerlink" title="四、4 邊等寬的螢幕邊框"></a>四、4 邊等寬的螢幕邊框</h3><p>這屬於我個人偏好，我非常喜歡 Studio Display 的 4 邊等寬設計。可能有人嫌它還不夠窄（相較於 <a href="https://www.apple.com/tw/pro-display-xdr/">Pro Display XDR</a>），但我覺得很可以了。</p><p>與之相對的，我非常不喜歡各式「下巴型」設計——下邊框很寬，而其餘 3 邊很窄。比如 LG 的<a href="https://www.lg.com/tw/monitors/lg-27up850n-w">很多機型</a>都是如此。</p><p>這類「<strong>不對稱</strong>」設計，其中的審美，恕我難以苟同。</p><hr><h2 id="購買前的注意事項"><a href="#購買前的注意事項" class="headerlink" title="購買前的注意事項"></a>購買前的注意事項</h2><p>前面關於 Studio Display 的優點，你可能未必有感或並不在意。不過以下的注意事項，則是作為消費者的我們，不得不事先考慮的環節。部分取自我實際使用經驗。</p><h3 id="一、固定支架的高度太低"><a href="#一、固定支架的高度太低" class="headerlink" title="一、固定支架的高度太低"></a>一、固定支架的高度太低</h3><p>Studio Display 有「<strong>固定</strong>」和「<strong>可調整高度</strong>」兩種支架——後者要多付 12000。</p><p>對大部分人來說這應該有點難以接受，畢竟我們買一般螢幕時，螢幕底座本來就可以伸縮並調整高低，如今我竟然要多花 12000 才能辦到，豈有此理？</p><p>確實！而且我相信正常人不會想花這個錢——那問題就來了。</p><p>固定支架的<strong>高度有限</strong>，我在買之前就不禁懷疑：「這高度真的夠嗎？」</p><p>仔細看了很多影片（有些影片評的是「可升降」版本，這部分沒有參考價值），並沒有哪一部對此有特別著墨。</p><p>想想我還是不放心，最後選擇了 VESA 版，再另外買了<a href="https://www.dell.com/zh-tw/shop/dell-%E5%96%AE%E4%B8%80%E9%A1%AF%E7%A4%BA%E5%99%A8%E8%87%82%E6%9E%B6-msa20/apd/482-bbdj/%E9%A1%AF%E7%A4%BA%E5%99%A8%E5%92%8C%E9%A1%AF%E7%A4%BA%E5%99%A8%E9%85%8D%E4%BB%B6">螢幕支架</a>。</p><p>事實證明，買 VESA 版是對的！至少就我而言，固定支架的高度是遠遠不夠的——因為我的桌子比較低啦😅</p><p>不過你不一定需要買 VESA 版，但可能要考慮是否具備下列兩項條件之一：</p><ol><li>相對高的桌子。</li><li>螢幕增高架。</li></ol><h3 id="二、VSEA-或支架版？"><a href="#二、VSEA-或支架版？" class="headerlink" title="二、VSEA 或支架版？"></a>二、VSEA 或支架版？</h3><p>VESA 版和其餘兩種支架只能三選一，所以這一步得謹慎，我們繼續此話題。</p><p>絕大部分的螢幕根本沒有這個問題，因為現代螢幕都是底座拆掉就是一個標準的 VESA 接口槽，而 Studio Display 的底座卻無法拆卸，需要你在選購時就決定好。</p><p>這樣的設計著實令人討厭。</p><p>對於已經有獨立螢幕支架的人來說，或許不是太大的問題，直接買 VESA 版即可。不過這裡還有一個考量點，就是萬一要賣掉螢幕，VESA 版可能比較不好賣。</p><p>我自己的思路則是：不考慮轉手問題（應該不會賣掉），但我也不想用螢幕增高架，因為高度固定，萬一使用後的高度看不習慣，又得換一個架子。</p><p>所以我選擇獨立支架 + VESA 版。而從結果看來——我很滿意。</p><h3 id="三、Windows-用戶不建議購買"><a href="#三、Windows-用戶不建議購買" class="headerlink" title="三、Windows 用戶不建議購買"></a>三、Windows 用戶不建議購買</h3><p>如前所述，Studio Display 是為 Mac 開發的螢幕，Windows 電腦可用但問題較多。</p><p>即使這些問題都能一一克服，花這麼多錢卻無法享受完整版的功能，難免讓人心理不平衡。所以我不建議購買。</p><p>當然，如果你真的很喜歡它的畫質（與音質），則另當別論。</p><h3 id="四、Intel-Mac-用戶也要三思"><a href="#四、Intel-Mac-用戶也要三思" class="headerlink" title="四、Intel Mac 用戶也要三思"></a>四、Intel Mac 用戶也要三思</h3><p>即使是 Mac，如果 CPU 是 Intel 版，而且沒有獨立顯卡，只有內顯——尤其是早期的內顯，我強烈建議不要買。</p><p>我自己的 <a href="https://blog.kyomind.tw/weekly-review-09/#%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%8F%B0-Macbook%EF%BC%9AMacbook-Air-2020-Intel-%E7%89%88">2020 Intel 版 Macbook Air</a>，接上這台螢幕，基本上<strong>跑太不動</strong>，可見 5K 解析度對於顯示晶片還是有一定要求。（也可能是硬體不夠相容）</p><p>而 Intel CPU 早期的內顯，只能說是雞肋，有跟沒有差不多！</p><p>所以，如果手上只有 Intel CPU 版的 Mac，可能不一定能夠稱心如意。</p><p>如果是 M 系列晶片，則絕對沒問題。</p><h3 id="五、要不要購買-AppleCare-？"><a href="#五、要不要購買-AppleCare-？" class="headerlink" title="五、要不要購買 AppleCare+？"></a>五、要不要購買 AppleCare+？</h3><p>像 Mac mini、Studio Display 這種「使用場景比較固定」的機器，AppleCare+ 的費用相對低廉，畢竟出保的機率也比較低。</p><p>但 Studio Display 的 AppleCare+ 還是要價 4290！怎麼也稱不上便宜。買不買依舊是一個大問題。</p><p>我最後還是買了。我的考量是，萬一螢幕真的有問題要送修，AppleCare+ 提供到府收送服務，對我比較省事。</p><p>對於沒有車的人而言，這是一個重要的考量——當然你也可以叫計程車😎</p><hr><h2 id="結語：事前功課麻煩，但值得"><a href="#結語：事前功課麻煩，但值得" class="headerlink" title="結語：事前功課麻煩，但值得"></a>結語：事前功課麻煩，但值得</h2><p>為了買這台 Studio Display，我花費了不少心思。好在從結果來看，一切是值得的。</p><p>其實，不想做功課也無妨，畢竟從 Apple 官網購買的產品都有 14 天的鑑賞期，即使完全沒做功課，也可以在使用後覺得不適合時斷然退貨。</p><p>但退貨對我來說（心理上）更麻煩！所以我寧願在事前花時間。</p><p>如果你問我給 Studio Display 的使用滿意度打幾分，我會說 100 分。縱然它真的不便宜，但它的整體表現，完全值得這個價錢，甚至可以說沒有缺點（對我而言）。</p><p>更重要的是，相比也是今年購入的 M2 Pro Mac mini，即使少了 Mac mini，我仍有其他  Macbook 可供選擇。</p><p>而 Studio Display 就這一台了！我完全想不到在同樣的價格下，有其它螢幕選項可以作為「相同滿足感」的替代選項——真的沒有。</p><p>所以在我心中，Studio Display 的地位高於 Mac mini，這也是為什麼它能得到 100 分的根本原因。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/H6W14Kj.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.apple.com/tw/shop/buy-mac/apple-studio-display&quot;&gt;Apple Studio Display&lt;/a&gt; 無疑是今年內，我所有新購入的&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-16/#%E4%BD%95%E8%AC%82%E5%83%B9%E5%80%BC%E8%A7%80%E5%B1%A4%E7%B4%9A%E7%9A%84%E3%80%8C%E5%99%A8%E7%89%A9%E3%80%8D%EF%BC%9F&quot;&gt;器物&lt;/a&gt;之中，&lt;strong&gt;最值得的選擇&lt;/strong&gt;，且沒有之一。&lt;/p&gt;
&lt;p&gt;但它不一定適合你，也可能不適合多數人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/mac-mini/&quot;&gt;M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-16/&quot;&gt;16，我的「價值觀層級」器物清單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;作為一個使用它近半年的真實用戶，我撰寫本文的目標，就是為了協助你判斷：&lt;strong&gt;是不是真的值得為自己購買一台 Studio Display。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你也可以當作這是一篇 &lt;strong&gt;Studio Display 開箱文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們會提到它的優點——我最喜歡的部分。不過，作為一台昂貴的螢幕，在購入之前，你可能更關心「它究竟適不適合自己、值不值得？」&lt;/p&gt;
&lt;p&gt;就像我在〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-13/&quot;&gt;13，我買了 Apple Studio Display 與系列心得寫作計畫&lt;/a&gt;〉說的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那些你&lt;strong&gt;不喜歡&lt;/strong&gt;或&lt;strong&gt;可能無法接受&lt;/strong&gt;的環節，才是做決定時最重要的考量點——&lt;strong&gt;那些「不」才是關鍵&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="Studio Display" scheme="https://blog.kyomind.tw/tags/Studio-Display/"/>
    
    <category term="開箱評論" scheme="https://blog.kyomind.tw/tags/%E9%96%8B%E7%AE%B1%E8%A9%95%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</title>
    <link href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/"/>
    <id>https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/</id>
    <published>2023-08-05T06:03:13.000Z</published>
    <updated>2023-08-30T13:56:18.478Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/tS78Ke0.png" alt="Python 功力提升的樂趣"><span class="cap">Python 功力提升的樂趣</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><h2 id="系列緣起"><a href="#系列緣起" class="headerlink" title="系列緣起"></a>系列緣起</h2><p>我會用數篇文章，把本書的重點一一勾勒出來。之所以願意這麼做，主要有兩個原因。</p><h3 id="要真正落實-Clean-Code，著實不易"><a href="#要真正落實-Clean-Code，著實不易" class="headerlink" title="要真正落實 Clean Code，著實不易"></a>要真正落實 Clean Code，著實不易</h3><p>雖然任何一種程式語言都能夠寫出堪稱簡潔的程式碼，但 Python 可能是最接近「自然語言」的那個，從這個角度看，Python 的 Clean Code 或許是最美的。</p><p>但因為 Python 的自由度，往往實際上的程式碼品質都不是那麼理想——你甚至希望它不要那麼自由。</p><h3 id="我認為這本書被低估了"><a href="#我認為這本書被低估了" class="headerlink" title="我認為這本書被低估了"></a>我認為這本書被低估了</h3><p>意思是它似乎不那麼有名。</p><p>當然，講 Clean Code Python 的書也不只這本，但我認為本書是<strong>最適合起手</strong>的一本。儘管它面向的是 Python 新鮮人，但不得不承認，即使已經寫了一、兩年 Python 的開發者，對於書中建議的落實，往往都還有所不足。</p><p>儘管 Python 是自由的，但 Clean Code 卻<strong>沒有那麼自由</strong>——我們需要這本書，而且要好好實踐它。</p><span id="more"></span><h2 id="只講重點"><a href="#只講重點" class="headerlink" title="只講重點"></a>只講重點</h2><p>雖然是偏筆記的形式，但我也不想重複那些基本知識，所以只講重點，視需要給予書中的細節。</p><p>重要的是，我們「知道」有這件事。這是一種「嗅覺」，你也可以說，是對於「程式碼壞味道」的嗅覺。</p><p>儘管在不久的將來，我們產出的程式碼，可能有相當部分是 AI 幫我們寫的，但那依舊不妨礙我們對於 Clean Code 的追求——畢竟你還是要審視 AI 的產出，並適時修正與完善。</p><hr><p>本文整理書中第 3-5 章重點，前 2 章我覺得重要性普通就略過了。</p><h2 id="第-3-章：使用-Black-進行程式碼格式化"><a href="#第-3-章：使用-Black-進行程式碼格式化" class="headerlink" title="第 3 章：使用 Black 進行程式碼格式化"></a>第 3 章：使用 Black 進行程式碼格式化</h2><p>Formatter——格式化器——想必大家都很熟悉了，我也有不少文章提過（雖然主要講 yapf），有興趣可以查看「<a href="https://blog.kyomind.tw/tags/Code-Formatting/">Code Formatting</a>」這個標籤。</p><p>提 formatter 肯定要提 <a href="https://peps.python.org/pep-0008/">PEP 8</a>，畢竟所有的 Python formatter 都是以 PEP 8 為基礎，再加上一些慣例或額外規則。</p><p>所以這章有一定的篇幅與範例都是在講 PEP 8，這裡只提一個我覺得比較容易被忽略（但我認為重要）的點——垂直間距（空行）。</p><p>至於要用哪個格式化器，本書推薦 Black。我認為 yapf 也不錯。</p><h3 id="垂直間距"><a href="#垂直間距" class="headerlink" title="垂直間距"></a>垂直間距</h3><p>這名稱好學術，講白了就是程式碼之間的「空行」。</p><blockquote><p>空行是一種藝術。</p></blockquote><p>就跟文章的分段一樣，程式碼的空行太多會流於鬆散，而太少則過度緊迫。如何拿捏，需要你對<strong>美感與程式可讀性</strong>有幾分「<strong>直覺</strong>」才行。</p><p>所幸，PEP 8 有基本規則：</p><ol><li>函式之間：2 行空行。</li><li>類別之間：2 行空行。</li><li>類別的方法之間：1 行空行。</li></ol><p>這 3 種空行，格式化器能幫你自動完成。另外，空 3 行或在上述情境「以外」的地方空 2 行，都是不允許的😷</p><p>格式化器會一併修正（linter 也會提醒），不會讓你自由發揮。</p><p>這麼說來，真正難的，還是<strong>什麼時候要空 1 行</strong>。我想這就是<strong>空行藝術</strong>的所在了。</p><h3 id="Why-Black？"><a href="#Why-Black？" class="headerlink" title="Why Black？"></a>Why Black？</h3><p>本書推薦 Black 的理由，就跟許多大型 Python 開源專案採用 Black 的理由一樣——因為它的<strong>規則最硬</strong>，大家只能乖乖遵守：</p><blockquote><p>如果您正在與其他人一起進行某個程式專案，只要使用 Black 工具就能立即解決所有關於格式化程式碼的許多爭論與協調。</p></blockquote><p>真的，只要協作的人愈多，我們對程式碼「<strong>一致性</strong>」的需求就愈高，<strong>優先權</strong>甚至高過了典型的<strong>慣例與規則</strong>。比如 Google 要求內部 Python 專案中的程式碼縮排為 2 個空格而不是常見的 4 個。</p><p>2 空格的縮排既不符合 PEP 8，也並非常見慣例，是基於團隊與專案的<strong>一致性要求</strong>。</p><p>而一致性的本質就是——<strong>這沒得商量</strong>。</p><p>沒得商量，就沒必要爭執，而且誰也不能怪誰，因為這是 Black 規定的！<br>不過，如同我之前的文章介紹，大多數時候我還是會變更下列兩個 Black 預設值：</p><ol><li>單行字元上限。</li><li>停用強制雙引號。</li></ol><p>「一致性」有在團隊協作中多重要？書上的這段話，無疑是很好的註解：</p><blockquote><p>Python 的語法在風格樣式上<strong>更有彈性</strong>。如果您編寫的程式別人看不到，那怎麼樣寫都可以，但是軟體開發工作大都是<strong>共同協作</strong>的，無論與其他人一起在專案上工作，或是請經驗豐富的開發專家來審查您完成的程式，<strong>把程式碼格式化為大家公認的風格樣式是很重要的。</strong></p></blockquote><p>可不是嗎？</p><hr><h2 id="第-4-章：選用易懂的命名"><a href="#第-4-章：選用易懂的命名" class="headerlink" title="第 4 章：選用易懂的命名"></a>第 4 章：選用易懂的命名</h2><p>命名之難，是因為你總是要用很心才能命出好名字。而且情境千變萬化，命名有原則，卻沒有太多捷徑。</p><p>檢查風格樣式，機器可以代勞，但命名就不行了——那是以前！</p><p>現在有了 AI，只要你願意讓它看看你的程式碼，要求它「請幫我找出不恰當的命名」並接受它的建言，我相信肯定很有幫助。</p><p>雖然我們通常不想面對批評，哪怕是來自 AI 的批評。我懂，這是人之常情。包括我自己，也會覺得有點難受。</p><h3 id="兩種不佳的命名模式"><a href="#兩種不佳的命名模式" class="headerlink" title="兩種不佳的命名模式"></a>兩種不佳的命名模式</h3><p><strong>一、prefix，命名的前綴</strong></p><p>為類別中的屬性命名，重複類別名稱作為前綴，比如在 Cat 類別中，屬性 weight 又命名為 cat_weight。這樣做是冗餘的。</p><p>先別說你不會XD，很多時候人都是健忘的。尤其當這個類別是 ORM 中的 Model 時，特別容易！</p><p>而且冗餘的前綴不一定只發生在類別，有時模組中的變數命名，也會再度重複模組名稱作為前綴。</p><p><strong>二、在名稱中以「循序數字」當作後綴</strong></p><p>比如<code>payment1</code>、<code>payment2</code>、<code>payment3</code>。</p><p>我真的很討厭！因為這樣的命名<strong>缺乏表意性</strong>。</p><p>有時候我會在 pytest 的 fixtrue 看到同事這樣寫，我會建議改成比較「<strong>能表現個體特質</strong>」的命名。</p><p>比如<code>payment1</code>改成<code>payment_with_credit_card</code>、<code>payment2</code>改成<code>invalid_payment</code>等等。除非它們之間真的沒有任何區別（通常都有區別，但懶得一一想名字），就只是需要複數個同類型的物件</p><h3 id="不要使用內建名稱"><a href="#不要使用內建名稱" class="headerlink" title="不要使用內建名稱"></a>不要使用內建名稱</h3><p>意即不要使用 Python 的<a href="https://zh.wikipedia.org/zh-tw/%E4%BF%9D%E7%95%99%E5%AD%97">保留字</a>。理由可想而知，因為它會覆蓋原來的內建物件，造成程式的錯誤與混亂。</p><p>那真的需要怎麼辦？一個常見的做法是加上<code>_</code>作為<strong>後綴</strong>。比如<code>type_</code>。</p><h3 id="史上最糟的變數名稱——data"><a href="#史上最糟的變數名稱——data" class="headerlink" title="史上最糟的變數名稱——data"></a>史上最糟的變數名稱——data</h3><p>不瞞您說，<strong>萬事萬物都是資料。</strong></p><p>在實務中，遇到把變數命名為 data 的情況還真不算罕見，往往讓人看得一頭霧水。</p><p>書中的這段話說得非常好（我稍重組了一下原句）：</p><blockquote><p>將變數命名為 data，就像把你的狗命名為 Dog。</p></blockquote><p>簡言之，執意將變數命名為 data，需要非常堅實的理由——通常不存在這樣的理由。</p><hr><h2 id="第-5-章：找出程式碼的異味"><a href="#第-5-章：找出程式碼的異味" class="headerlink" title="第 5 章：找出程式碼的異味"></a>第 5 章：找出程式碼的異味</h2><p>程式碼異味（<a href="https://zh.wikipedia.org/zh-tw/%E4%BB%A3%E7%A0%81%E5%BC%82%E5%91%B3">code smell</a>）指的就是程式中看起來「不對勁」，且有可能在後續引發問題的地方。</p><p>如果可以，我們當然要盡可能避免異味，至少要給予一定關注才行。</p><p>實務上，我會在覺得有明顯異味的地方留下<code>XXX</code>註解，闡述異味的理由，並留意後續發展。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XXX PATCH 做的事情太多了，很容易發生狀態殘留問題</span></span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;PATCH&#x27;</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>畢竟異味不一定都會造成問題，也不是所有的異味都要被修正（因為太多了），甚至隨著後續開發，原本看起來的異味可能隨之消散或減緩——但這屬於少見的情況。大部分都是愈來愈糟，不然怎麼會有「<strong>技術債</strong>」這個詞呢？</p><p>書中所舉的異味種類很多，也都很經典，值一一細讀。不過限於篇幅，我只舉其中幾個我認為比較有代表性的異味。</p><h3 id="一、重複的程式碼"><a href="#一、重複的程式碼" class="headerlink" title="一、重複的程式碼"></a>一、重複的程式碼</h3><p>重複程式碼肯定不是一個錯誤（error），卻很可能造成後續維護上的困擾。典型的困境就是改一個地方結果多處也要跟著一起改時，我稱之為程式碼的「<strong>同步</strong>」問題。</p><blockquote><p>需要手動同步，就是壞味道。</p></blockquote><p>通常我們會將這部分抽取出來，讓程式只需要改動一處，就能在所有引用處生效。</p><p>不過，書中也說了，重複一、兩次通常沒有關係；而重複三、四次時，就要好好考慮了是否重構或刪除。</p><p>而且有些時候，重複反而是比較簡潔的做法——無腦但直觀，可讀性最高。</p><p>確實，單憑形式上的「是否重複」來判斷要不要修改程式碼，往往是不足夠的。還要看<strong>使用的場景</strong>。比如前面說的那種會發生同步問題的重複，哪怕只有一次，我也會特地抽出來。</p><p>顯然，這需要一些經驗，與一次又一次的思考。</p><h3 id="二、魔術數字"><a href="#二、魔術數字" class="headerlink" title="二、魔術數字"></a>二、魔術數字</h3><p>有些數字我們很容易知曉其含意，比如 3.14，而有些則否。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expiration = time.time() + <span class="number">604800</span></span><br></pre></td></tr></table></figure><p>這 604800 究竟代表什麼？我們肯定需要停下來思考，可能需要花一些時間才能想出來。這樣的寫法顯然太不直觀。</p><p>重點是，<strong>你縱使猜得到，也無法 100% 確定</strong>。</p><p>一種改進方式是加上註解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expiration = time.time() + <span class="number">604800</span>  <span class="comment"># 一星期後失效</span></span><br></pre></td></tr></table></figure><p>原來 604800 代表的是一週的秒數！</p><p>這樣寫好很多，但書中建議我們採取更經典的做法——使用<strong>常數</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECONDS_PER_MINUTE = <span class="number">60</span></span><br><span class="line">SECONDS_PER_HOUR = <span class="number">60</span> * SECONDS_PER_MINUTE</span><br><span class="line">SECONDS_PER_DAY = <span class="number">24</span> * SECONDS_PER_HOUR</span><br><span class="line">SECONDS_PER_WEEK = <span class="number">7</span> * SECONDS_PER_DAY</span><br><span class="line"></span><br><span class="line">expiration = time.time() + SECONDS_PER_WEEK  <span class="comment"># 一星期後失效</span></span><br></pre></td></tr></table></figure><p>常數是在程式中被使用的<strong>固定值</strong>，通常是<strong>不能被改變</strong>的。在使用常數時，我們應該使用<strong>有描述性的命名</strong>，這樣有助於提高程式的可讀性和可維護性。</p><p>常數 + 有描述性的命名，就是應對魔術數字的絕佳手段。</p><p>比如 <a href="https://www.django-rest-framework.org/">Django REST Framework</a>（DRF）中的<code>status</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> JsonResponse(context, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure><p>除了 200，常見的還有：</p><ul><li><code>status.HTTP_400_BAD_REQUEST</code></li><li><code>status.HTTP_404_NOT_FOUND</code></li></ul><p>我們當然可以直接寫<code>status=200</code>、<code>400</code>、<code>404</code>，看起來也很直觀，但對於那些我們<strong>沒那麼熟悉</strong>的 HTTP 狀態碼，比如 509，則又需要陷入停頓與思考。</p><p>而使用常數的話，則所有成員都會更加一視同仁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status.HTTP_509_BANDWIDTH_LIMIT_EXCEEDED</span><br></pre></td></tr></table></figure><h3 id="三、雙層生成式"><a href="#三、雙層生成式" class="headerlink" title="三、雙層生成式"></a>三、雙層生成式</h3><p>書中的例子是，你想把一個二維 list「攤平」成一維，於是寫了<strong>雙層串列生成式</strong>（List <a href="https://steam.oxxostudio.tw/category/python/basic/comprehension.html">Comprehension</a>）進行處理，像這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nested_list = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat_list = [num <span class="keyword">for</span> sub_list <span class="keyword">in</span> nested_list <span class="keyword">for</span> num <span class="keyword">in</span> sub_list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat_list</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>這樣的寫法雖然簡短，但<strong>可讀性極差</strong>。哪怕是 Python 老手，也很難一眼就看出來這個生成式到底在做什麼。</p><p>作者建議用雙層的 for 迴圈改寫，以增加可讀性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nested_list = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat_list = []</span><br><span class="line"><span class="keyword">for</span> sub_list <span class="keyword">in</span> nested_list:</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> sub_list:</span><br><span class="line">        flat_list.append(num)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat_list</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>確實，但說真的，可以的話，也盡量不要使用雙層迴圈。</p><p>其中的原因，容我直接引用<a href="https://www.facebook.com/kyomind/posts/pfbid02KKKWxAjUxGWVep39bUDUyopBPrJcWj6Wv7tMU5wuZqF9AknA8cQT88zJQUNMS7sl">臉書舊貼文</a>：</p><blockquote><p>程式碼裡有：一層迴圈是壞味道，兩層迴圈是罪惡，三層迴圈是罪大惡極<br>　<br>因為這些都是程式中的「手工藝」，乏缺架構思維，除了當下用起來很「方便」，日後更可能是難以維護，畢竟正常人無法一眼就看出第二、三層迴圈到底在做什麼（仔細看也一樣啦！）<br>　<br>此乃典型的技術債，而且是很廉價的那種</p></blockquote><p>雙重迴圈有時是不得已——總會有這樣的時候，但我們仍必須<strong>視之為罪惡</strong>。</p><h2 id="程式碼異味的迷思"><a href="#程式碼異味的迷思" class="headerlink" title="程式碼異味的迷思"></a>程式碼異味的迷思</h2><p>這是第 5 章的最後一節，但我覺得特別精彩，值得獨立拿出來講。</p><p>書中所謂「程式碼異味的迷思」，指的是<strong>作者不認為那是異味</strong>，但常常會被視為異味的情況。</p><p>書中列舉了 5 個迷思（作者<strong>不認同</strong>的命題），分別如下：</p><ol><li>迷思：函式末尾應該只有一個 return</li><li>迷思：函式中最多應該只有一個 try 陳述句</li><li>迷思：旗標（flag）引數是不好的</li><li>迷思：全域變數是不好的</li><li>迷思：注釋是不需要的</li></ol><p>有些你可能也不覺得是迷思，沒關係，這裡我只打算討論第 5 個。</p><h2 id="註解是不需要的？"><a href="#註解是不需要的？" class="headerlink" title="註解是不需要的？"></a>註解是不需要的？</h2><p>我們可能聽過類似「好的程式碼應該透過優秀的命名與明確的意圖來自我表達、好的程式不需要註解」等等論述。</p><p>這堪稱是一種理想，乍聽也有幾分道理，但事實又如何呢？</p><p>在我看來，不寫任何註解或 <a href="https://en.wikipedia.org/wiki/Docstring">docstring</a>，卻期待程式非常好讀，幾乎是不可能的！</p><p>註解或 docstring 使用自然語言，表達能力與彈性<strong>遠遠超過</strong>受限於「用詞精簡且著重於功能面」的程式碼。</p><p>我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a>」也表述過類似的看法：</p><blockquote><p>在我看來，無論程式寫得如何簡潔易讀，對一些比較複雜的函式或類別而言，<strong>docstring 終究是不可少的</strong>。因為文字的<strong>詮釋能力</strong>和程式碼相比，<strong>絕不在同一個層次</strong>，相信這也是為何 docstring 會有屬於自己的獨立 PEP 加以規範的理由。</p></blockquote><blockquote><p>不知道你怎麼看？我相信，寫好 docstring，是簡潔程式碼<strong>不可或缺的一環</strong>，更是優秀軟體工程師的必備條件——我對此深信不疑。</p></blockquote><h3 id="註解與-docstring-的價值"><a href="#註解與-docstring-的價值" class="headerlink" title="註解與 docstring 的價值"></a>註解與 docstring 的價值</h3><p><strong>有些事很重要</strong>，開發者在維護與修改程式時<strong>必須知道</strong>，這些事往往難以直接藉由程式碼透露出來，<strong>比如函式的「使用方式」與「注意事項」</strong>，這時註解就派上用場了。</p><p>退萬步言，複雜的程式光要看懂就很不容易。而良好的註解與 docstring <strong>可以大幅縮短閱讀理解的時間</strong>，你的隊友一定會感謝你。</p><p>尤其在團隊開發時，<strong>註解與 docstring 是溝通的重要媒介</strong>，有時甚至是<strong>唯一</strong>的媒介。</p><p>當然我們也不得不承認，很多註解都寫得很爛！但這不是註解的錯，而是寫的人還不夠熟練或深思。而且寫好註解也真的很難，需要大量的練習。</p><p>顯然作者也是這麼認為的：</p><blockquote><p>要寫出簡潔有效的注釋並不容易，注釋就像程式碼一樣，需要重寫和多次修調才會更好。</p></blockquote><h3 id="寫好註解是同理心的表現"><a href="#寫好註解是同理心的表現" class="headerlink" title="寫好註解是同理心的表現"></a>寫好註解是同理心的表現</h3><p>就像我在〈<a href="https://blog.kyomind.tw/weekly-review-18/">18，論軟體工程師常見的「路徑依賴」問題（上）</a>〉中所闡述的：</p><blockquote><p>寫程式若只顧自己，終究難登大雅之堂。這些程式碼看起來就像是<strong>一個人的自言自語</strong>（只要自己有完成任務就好）——<strong>它並沒有在溝通</strong>。</p></blockquote><p>程式碼是溝通，而註解更是。它是同理心中「<strong>換位思考</strong>」的具體表現。</p><p>而且，把註解寫好，自己也會是受益者。因為我們不可能總是記得程式的所有細節，哪怕是自己寫的程式。</p><p>優秀的註解和 docstring，讓人讀程式時心曠神怡，維護的壓力也小得多。我相信任何開發者都希望自己接手的是這樣的程式碼。</p><p>在團隊協作中，這是一種任何人都會喜愛的溫柔。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tS78Ke0.png&quot; alt=&quot;Python 功力提升的樂趣&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;h2 id=&quot;系列緣起&quot;&gt;&lt;a href=&quot;#系列緣起&quot; class=&quot;headerlink&quot; title=&quot;系列緣起&quot;&gt;&lt;/a&gt;系列緣起&lt;/h2&gt;&lt;p&gt;我會用數篇文章，把本書的重點一一勾勒出來。之所以願意這麼做，主要有兩個原因。&lt;/p&gt;
&lt;h3 id=&quot;要真正落實-Clean-Code，著實不易&quot;&gt;&lt;a href=&quot;#要真正落實-Clean-Code，著實不易&quot; class=&quot;headerlink&quot; title=&quot;要真正落實 Clean Code，著實不易&quot;&gt;&lt;/a&gt;要真正落實 Clean Code，著實不易&lt;/h3&gt;&lt;p&gt;雖然任何一種程式語言都能夠寫出堪稱簡潔的程式碼，但 Python 可能是最接近「自然語言」的那個，從這個角度看，Python 的 Clean Code 或許是最美的。&lt;/p&gt;
&lt;p&gt;但因為 Python 的自由度，往往實際上的程式碼品質都不是那麼理想——你甚至希望它不要那麼自由。&lt;/p&gt;
&lt;h3 id=&quot;我認為這本書被低估了&quot;&gt;&lt;a href=&quot;#我認為這本書被低估了&quot; class=&quot;headerlink&quot; title=&quot;我認為這本書被低估了&quot;&gt;&lt;/a&gt;我認為這本書被低估了&lt;/h3&gt;&lt;p&gt;意思是它似乎不那麼有名。&lt;/p&gt;
&lt;p&gt;當然，講 Clean Code Python 的書也不只這本，但我認為本書是&lt;strong&gt;最適合起手&lt;/strong&gt;的一本。儘管它面向的是 Python 新鮮人，但不得不承認，即使已經寫了一、兩年 Python 的開發者，對於書中建議的落實，往往都還有所不足。&lt;/p&gt;
&lt;p&gt;儘管 Python 是自由的，但 Clean Code 卻&lt;strong&gt;沒有那麼自由&lt;/strong&gt;——我們需要這本書，而且要好好實踐它。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="Black Formatter" scheme="https://blog.kyomind.tw/tags/Black-Formatter/"/>
    
    <category term="筆記" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="閱讀心得" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>20，更新部落格「關於我」至 2.0</title>
    <link href="https://blog.kyomind.tw/weekly-review-20/"/>
    <id>https://blog.kyomind.tw/weekly-review-20/</id>
    <published>2023-07-29T17:27:31.000Z</published>
    <updated>2023-08-31T06:59:32.091Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/mmEzb21.png"></p><p>從〈<a href="https://blog.kyomind.tw/weekly-review-05/">05，終於寫了「關於我」頁面</a>〉至今，已經近 8 個月。這次「<a href="https://blog.kyomind.tw/about/">關於我</a>」終於迎來 2.0 版更新。</p><p>1.0 版的「關於我」，尚有參考借鑑其他作者共 3 篇自介的影子，到了 2.0，應該已經不太容易發現這些痕跡。</p><p>這也符合<strong>創作的本質</strong>——從風格模仿到慢慢演化出自己的偏好。</p><p>本篇會講述本次更新的<strong>重點思路</strong>，可以視為有關這次更新的「導讀」與補充。</p><span id="more"></span><h2 id="更新概要"><a href="#更新概要" class="headerlink" title="更新概要"></a>更新概要</h2><p>整體而言，這次新增了有關「<a href="https://en.wikipedia.org/wiki/Cal_Newport">Cal Newport</a>」的一整段內容（往後的文章中，他的名字將更常出現），以及<strong>對舊有內容的刪減與補充</strong>。</p><p>我刪掉了關於「記錄控」一節，這並不是說我不記錄了，而是我認為這部分的代表性和其它部分相比，還略有不足。</p><p>加上自介篇幅不宜過長，新增了一段，只好也刪掉一段。</p><p>此外，幾乎每一個段落都進行了字句調整，還補上了幅篇不多但<strong>極具個人價值觀色彩</strong>的表述。比如：</p><blockquote><p><strong>我相信，人不是機器，不需要知曉一切，更不需要一個「完美」的筆記系統。</strong></p></blockquote><p>這段除了呼應到新增的 Cal Newport 相關內容，也代表了我看待這些筆記工具的基本態度。</p><hr><h2 id="Cal-Newport-段落"><a href="#Cal-Newport-段落" class="headerlink" title="Cal Newport 段落"></a>Cal Newport 段落</h2><p>Cal Newport 在台灣被翻譯出版了 4 本書，其中最著名的無疑是《<a href="https://www.books.com.tw/products/0010906940">Deep Work 深度工作力：淺薄時代，個人成功的關鍵能力</a>》。</p><p>我都買了也看了，最有共鳴的一本，當然屬已經為其寫過數篇文章的《深度數位大掃除》，Weekly Review 上一期就是在探討書中的「數位斷捨離」。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-19/">19，AI 時代的生存指南（二）數位斷捨離</a></p></blockquote><p>但，必須承認，除了《深度數位大掃除》與數位斷捨離，我相當認同也實踐了一番外。他的《深度工作力》和《深度職場力》，我乍看感覺都和現實世界有好一段距離。</p><p>換句話說，我並不相信大多數人真的能實踐——因為這些理論看起來很不容易。</p><h2 id="深度工作的極限想像"><a href="#深度工作的極限想像" class="headerlink" title="深度工作的極限想像"></a>深度工作的極限想像</h2><p>Cal Newport 在其著名且廣為流傳的文章〈<a href="https://calnewport.com/fixed-schedule-productivity-how-i-accomplish-a-large-amount-of-work-in-a-small-number-of-work-hours/">Fixed-Schedule Productivity: How I Accomplish a Large Amount of Work in a Small Number of Work Hours</a>〉中，闡述了他如何在一週工作約 40 小時的「限制」內，完成許多重要的事。</p><p>文章中提到了他的一週實際工作時間如下：</p><ul><li>工作日早上 9 點到下午 5 點</li><li>星期日早上</li></ul><p>除上述時段外，他就不碰工作，而是做自己想做的事。這聽起來<strong>很不可思議</strong>，但他的確做到了。</p><p>至少在時間上，他並沒有「做更多」，但「產能」卻相當可觀。</p><p>合理推測，一般人如果要完成相同的工作量，可能需要 50、60 小時，甚至更久——<strong>這也是為何這篇文章的迴響驚人。</strong></p><p>但我認為，一般人看到這樣的內容，最強烈的感受可能不是深深佩服或想要立即效仿，而是覺得<strong>壓力很大</strong>！因為「<strong>密度</strong>」太高了。</p><p>意思是，這套模式對實踐者的「<strong>紀律與決心、面對變化的決策與彈性拿捏</strong>」等等，<strong>要求極高</strong>——我還不如老老實實加班或延長工作時間，為什麼非得在 40 小時內做完？</p><h2 id="我的折衷"><a href="#我的折衷" class="headerlink" title="我的折衷"></a>我的折衷</h2><p>然而就像更新中說的：</p><blockquote><p>直到最近接觸了他的 Podcast《<a href="https://podcasts.apple.com/us/podcast/deep-questions-with-cal-newport/id1515786216">Deep Questions with Cal Newport</a>》，有機會從書籍以外的各種角度，更深入了解他的想法。</p></blockquote><p>附帶一提，我不是真的聽了這些 Podcast，而是靠 <a href="https://goodsnooze.gumroad.com/l/macwhisper">MacWhisper</a> 語音轉文字，並使用 ChatGPT Code Interpreter 整理、Logseq 筆記。</p><p>原本我覺得「深度工作」是一個曲高和寡的理論，現在稍為改觀了——我想要實現這種可能。</p><p>儘管我認為要達到 Cal Newport 這樣的水準依舊難如登天，但我願意相信這些理論是可行的，哪怕是像我一樣的凡人。</p><p>我大概無法只用 40 小時就做到這麼多事，但我可以試著用 25 小時做出原本自己要花 30、40 小時才能達到的價值。</p><p>在我看來，這已經相當了不起。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mmEzb21.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;從〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-05/&quot;&gt;05，終於寫了「關於我」頁面&lt;/a&gt;〉至今，已經近 8 個月。這次「&lt;a href=&quot;https://blog.kyomind.tw/about/&quot;&gt;關於我&lt;/a&gt;」終於迎來 2.0 版更新。&lt;/p&gt;
&lt;p&gt;1.0 版的「關於我」，尚有參考借鑑其他作者共 3 篇自介的影子，到了 2.0，應該已經不太容易發現這些痕跡。&lt;/p&gt;
&lt;p&gt;這也符合&lt;strong&gt;創作的本質&lt;/strong&gt;——從風格模仿到慢慢演化出自己的偏好。&lt;/p&gt;
&lt;p&gt;本篇會講述本次更新的&lt;strong&gt;重點思路&lt;/strong&gt;，可以視為有關這次更新的「導讀」與補充。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
    <category term="Deep Work" scheme="https://blog.kyomind.tw/tags/Deep-Work/"/>
    
  </entry>
  
  <entry>
    <title>Evernote 最佳替代方案——筆記軟體 Bear 2 升級心得</title>
    <link href="https://blog.kyomind.tw/bear/"/>
    <id>https://blog.kyomind.tw/bear/</id>
    <published>2023-07-16T20:12:36.000Z</published>
    <updated>2023-07-29T16:36:15.119Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/CkddA67.png" alt="bear.app"><span class="cap">bear.app</span></p><p>在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉一文中，我曾提到：</p><blockquote><p>如果你正在尋找一款和 Evernote 界面相似、使用邏輯相仿，且<strong>符合現代潮流</strong>的 app，那麼我誠摯推薦自己也有在用的 <a href="https://bear.app/">Bear</a>。（可惜它只限 macOS 與 iOS 平台）</p></blockquote><p>Bear（中文名稱：<strong>熊掌記</strong>）、Notion、Logseq 這三者，都是我目前<strong>持續使用中</strong>的筆記軟體，雖然在使用量上，它們呈現一個<strong>非常不均勻</strong>的分布：</p><ul><li>Logseq：80%</li><li>Notion：15%</li><li>Bear：5%</li></ul><p>對，你沒看錯，Bear 的使用量只佔我全部筆記的 5% 而已。</p><p>儘管如此，我依舊是一個忠實的 Bear 付費用戶。原因無他，因為無論是 Notion 還是 Logseq，它們都太「<strong>重</strong>」了！</p><span id="more"></span><h2 id="簡易型筆記軟體"><a href="#簡易型筆記軟體" class="headerlink" title="簡易型筆記軟體"></a>簡易型筆記軟體</h2><p>當我只想儲存一些<strong>簡單內容</strong>，比如常用資訊（地址、帳號、手機）；或完全不想歸類的獨立筆記，比如臉書文章摘要。此時，<strong>我需要更簡單、輕量的筆記工具</strong>。</p><p>而這些筆記、內容的特色是：</p><ul><li>當我需要它們的時候，我要能<strong>快速獲取</strong>！</li><li>我不想為它們進行有系統的組織與架構，只求<strong>大概整理、排序</strong>。</li></ul><p>因此，我不願動用 Notion、Logseq 這兩把「牛刀」，徒增心理上的負擔。</p><p>我相信，這樣的「簡單需求」始終存在，所以我還是需要第三個筆記軟體。</p><h2 id="Bear-2"><a href="#Bear-2" class="headerlink" title="Bear 2"></a>Bear 2</h2><p>要說 macOS 上的簡易型筆記軟體，很多人會先想到 <a href="https://apps.apple.com/us/app/notes/id1110145109">Apple Notes</a>。</p><p>畢竟對 Mac 用戶而言，它不止免費，而且還不需要額外安裝，同時也完全符合訴求。</p><p><a href="https://bear.app/">Bear</a> 則是另一個有力選項，以流暢的操作手感與簡潔優雅的使用者介面聞名。和多數筆記軟體相同，它可以免費使用，然後付費解鎖額外功能。</p><p>3 年前，我<a href="https://blog.kyomind.tw/weekly-review-09/#%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%8F%B0-Macbook%EF%BC%9AMacbook-Air-2020-Intel-%E7%89%88">剛換新的 Macbook</a>。不同以往，我沒有再透過 <a href="https://zh.wikipedia.org/zh-tw/%E5%90%AF%E5%8A%A8%E8%BD%AC%E6%8D%A2">Boot Camp</a> 灌 Windows，而是開始試著使用 macOS。也是從那時才正式上手 Bear。</p><p>就在本月，Bear 迎來了許多人等待數年之久的重大更新——<a href="https://blog.bear.app/2023/07/bear-2-is-here/">Bear 2</a>。</p><p>這篇，我們就來聊聊，Bear 2 帶給我的感受。</p><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>文章首先會講一下我對 Bear 這個筆記工具的整體看法，以及為何它是 Evernote 的優秀替代方案。</p><p>其次是介紹這次 Bear 2 總計 20-30 項更新中，我個人比較有感的 4 項。最後給出一個簡要的結論。</p><p>值得一提的是，因為 Bear 只是我的「第三」筆記軟體，所以我對它的要求與第一筆記軟體——Logseq——有<strong>很大的不同</strong>！</p><p>換句話說，就是一個<strong>輕度用戶</strong>會有的需求。原則上只要「<strong>方便</strong>」就好，不求功能強大或面面俱到。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文目標讀者有三。但無論如何，你得先是一個 macOS 或 iOS 用戶才行🥹</p><ol><li>屬於這波 <a href="https://www.bnext.com.tw/article/72698/evernote-join-bending-spoons">Evernote 逃難潮</a>，正在考慮下一個筆記軟體的人。</li><li>已嘗試過 <a href="https://www.notion.so/">Notion</a>、<a href="https://obsidian.md/">Obsidian</a>、<a href="https://logseq.com/">Logseq</a>、<a href="https://heptabase.com/">Heptabase</a> 等筆記軟體，<strong>覺得這些東西實在太複雜</strong>的人——它們確實都很複雜😷</li><li>不想用 Apple Notes 的人。</li></ol><hr><h2 id="不用-Apple-Notes-的理由"><a href="#不用-Apple-Notes-的理由" class="headerlink" title="不用 Apple Notes 的理由"></a>不用 Apple Notes 的理由</h2><p>可能有讀者好奇，既然前面都說 Apple Notes「不止免費，也符合訴求」，那為什麼我不用 Apple Notes 呢？</p><p>我可以想到<strong>兩個理由</strong>，而且它們<strong>對我已經足夠充分</strong>。</p><h3 id="一、Apple-Notes-對-Markdown-的支援不足"><a href="#一、Apple-Notes-對-Markdown-的支援不足" class="headerlink" title="一、Apple Notes 對 Markdown 的支援不足"></a>一、Apple Notes 對 Markdown 的支援不足</h3><p>不足？恩…其實就是沒什麼支援啦！</p><p>別誤會，我個人並不愛寫「<strong>純 Markdown</strong>」，否則我應該會是 <a href="https://hackmd.io/">HackMD</a> 或 <a href="https://ulysses.app/">Ulysses</a> 的支持者——顯然我不是。</p><p>且我在〈<a href="https://blog.kyomind.tw/my-markdown-writing-flow/#%E4%B8%8D%E6%84%9B-Markdown%EF%BC%8C%E5%8F%AA%E6%84%9B%E7%B7%A8%E8%BC%AF%E5%99%A8%E7%9A%84%E6%88%91">Notion + VS Code：我的 Markdown 寫作工作流</a>〉中已表明：我還是更偏好編輯器一些。</p><p>但是！<strong>文件本身最好還是要支援 Markdown</strong>，因為這樣才能<strong>輕鬆跨平台</strong>。</p><p>這也是為什麼我可以在 Notion 上寫文章草稿，然後直接<strong>複製貼上</strong>，就能在 VS Code 中繼續編輯，然後發表。</p><h3 id="二、文字排版的選項太少"><a href="#二、文字排版的選項太少" class="headerlink" title="二、文字排版的選項太少"></a>二、文字排版的選項太少</h3><p>對我而言，這是 Apple Notes <strong>最大的缺點</strong>，也是我不用它的<strong>根本理由</strong>。</p><p>事實上，很多筆記軟體都有這個問題。而我「<strong>只會選擇</strong>」允許我控制<strong>字體大小、字型、行高</strong>（三者缺一不可）的筆記工具。</p><ul><li><strong>Notion</strong>：字體只能選「大或小」，而且字型是固定的，十分陽春。<ul><li>但因為有<strong>網頁版</strong>，我能透過 <a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">stylus</a> 等瀏覽器外掛，直接重設 CSS 樣式，進而改變字體、字型、行高。</li><li>所以我在電腦上只使用 Notion 的網頁版，不考慮 macOS 版本。</li><li>而手機版，偶爾會用來查看筆記，但不會用來寫筆記，所以影響不大。</li></ul></li><li><strong>Logseq</strong>：沒有網頁版，但因為有<code>custom.css</code>設定檔，<strong>排版可以完全自訂</strong>。</li><li><strong>Bear</strong>：沒有網頁版，也沒有設定檔。但它的字型、字體大小、行高，<strong>全部都可以調整！</strong>🎉</li></ul><p><strong>中文排版</strong>是個大議題，會相當程度影響使用者體驗——<strong>至少很影響我的體驗</strong>。</p><p>有興趣可參考這篇〈<a href="https://medium.com/deerlight/medium-6a42f494254">留在 Medium 及暫不自架站</a>〉對「中英文排版差異」的討論：</p><blockquote><p>中文字體的結構統一卻容易缺少節奏感，它需要更多的考量，在編排文字時需要對文字的結構適當的調整，增加文字的節奏，感營造舒適的編排。</p></blockquote><blockquote><p>若需要同時兼顧中英文字體的呈現，不僅是在介面上下手，而是對不同語系的字體樣式都必須要設定得很詳細。</p></blockquote><p>我完全認同。</p><hr><h2 id="為什麼說-Bear-是-Evernote-最佳替代？"><a href="#為什麼說-Bear-是-Evernote-最佳替代？" class="headerlink" title="為什麼說 Bear 是 Evernote 最佳替代？"></a>為什麼說 Bear 是 Evernote 最佳替代？</h2><p>當然是因為它們的「<strong>頁面格局</strong>」和使用方式都相對類似，如圖：</p><p><img src="https://i.imgur.com/5vlTatc.png" alt="Bear 2 使用者介面"><span class="cap">Bear 2 使用者介面</span></p><p>兩者從左至右都是：分類選單、分類文章摘要、本文——只是 Bear 美得多☺️</p><p>不得不承認，這種排版無疑是<strong>最簡潔有力的排版</strong>，使用上非常直觀，對任何人都能輕鬆上手。難怪 Apple Notes 也採用了這個呈現方式。</p><h3 id="標籤-VS-記事本"><a href="#標籤-VS-記事本" class="headerlink" title="標籤 VS 記事本"></a>標籤 VS 記事本</h3><p>真要說不同的話，早期的 Evernote 採用的是很傳統的分類資料夾，稱為「<strong>記事本</strong>」，而且只限一層。加上堆疊，也不過兩層。</p><p>就像我在〈<a href="https://medium.com/code-and-me/why-evernote-7cd2abbfbafd">心得 |《曼無止盡》第40期：Evernote 的重生之路</a>〉一文說的：</p><blockquote><ul><li>只允許「記事本堆疊&gt;記事本&gt;記事」最多共 3 個層級的目錄結構，不像 Notion 或 WorkFlowy 可以無限層級</li><li>承上，層級很少，所以你無法進行太複雜的「專案架構」規劃，只能以簡單分類的方式來歸納記事而已，這顯然不太符合時代潮流</li></ul></blockquote><p>相對的，Bear 則是用「標籤」來形成分類，彈性更大，而且支援無限層級。</p><p>但老實說，<strong>現在的我已不覺得「層級少」是個問題</strong>，我目前的 Notion 或 Logseq 中，往往也<strong>只用兩個層級</strong>而已。</p><blockquote><p>為什麼？</p></blockquote><h3 id="過度分類-x3D-自找麻煩"><a href="#過度分類-x3D-自找麻煩" class="headerlink" title="過度分類 &#x3D; 自找麻煩"></a>過度分類 &#x3D; 自找麻煩</h3><p>因為「多層級」是一種<strong>由上而下</strong>，有著強烈「<strong>中心化精神</strong>」的筆記方式，就像<a href="https://online.visual-paradigm.com/tw/diagrams/templates/organization-chart/organizing-big-pile-of-projects/">傳統的大型組識</a>一樣。它的優點是層次井然、有條理，缺點則是笨重、缺乏彈性。</p><p>「<strong>笨重、缺乏彈性</strong>」在這裡的意思是：你常常得對任意一則筆記<strong>進行詳細的分類</strong>，才能確定它們所在的知識體系——我認為這是在<strong>自找麻煩</strong>。</p><p>而我也自找麻煩了好多年😅，所以才不禁在「<a href="https://blog.kyomind.tw/logseq/#%E4%BA%8C%E3%80%81%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%AD%86%E8%A8%98">二、去中心化筆記</a>」中感嘆道：</p><blockquote><p>分類是一件<strong>令人頭痛的事</strong>，尤其在你還無法摸清楚當前事物該如何分類之際，感覺自己正事（筆記本身）都還沒做，就已深陷在「<strong>架構上的束縛</strong>」。</p></blockquote><p>尤其一個概念往往是<strong>多維的</strong>，複雜的分類容易帶來<strong>管理上的混亂</strong>，而且還會讓你<strong>分心</strong>，因為你得時常思考「<strong>這個筆記應該放在哪裡？</strong>」</p><p>太累了。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a></p></blockquote><p>後來 Evernote 也加入了<a href="https://www.playpcesor.com/2016/03/evernote-3-1.html">層級標籤功能</a>，兩者的區別就更小了。真要說的話，主要差異還是產品給人的感覺，尤其是<strong>整體感</strong>與<strong>美感</strong>。</p><p>Evernote 畢竟是 2008 年的產物，受限於時空與古老的軟體架構，而且還要跨平台。它落後於時代，我覺得情有可原。</p><p>但就讓它安息吧。</p><hr><p>好，簡單的比較結束，我們來看看這次 Bear 2 更新對我來說有哪些亮點。所有的更新項目請參考<a href="https://blog.bear.app/2023/07/bear-2-is-here/">網頁</a>，這裡只提其中一部分。</p><h2 id="一、隱藏-Markdown-符號"><a href="#一、隱藏-Markdown-符號" class="headerlink" title="一、隱藏 Markdown 符號"></a>一、隱藏 Markdown 符號</h2><p><img src="https://i.imgur.com/sjJb6cX.png"></p><p>這是一段沒有隱藏 Markdown 符號的 Bear 文本，說真的看起來就是有點煩。而且以前沒有開關，它一定會顯示。</p><p>我相信不是每個人都討厭這樣的設計，因為它的好處是<strong>文本的長度會完全固定</strong>，不會因為 Markdown 符號的顯示、隱藏而有區別。</p><p>但缺點當然就是——略嫌妨礙閱讀。</p><p>現在總算有開關了，讓使用者可以自由選擇。</p><h2 id="二、可調整圖片大小"><a href="#二、可調整圖片大小" class="headerlink" title="二、可調整圖片大小"></a>二、可調整圖片大小</h2><p><img src="https://i.imgur.com/TNj2LeB.png"></p><p>這個真的很重要！</p><p>雖然這功能 Notion、Logseq 都有，但呈現上各有優劣。</p><p>Logseq 的最爛，調整鈕一樣是在右下角，但沒那麼好操作。而且調完後，前後的文本不會跟著移動，需要重新讀取區塊才行。差評！</p><p>Notion 就好多了，使用圖片左右兩側的判定區來調整大小。</p><p>Bear 也很不錯！調整鈕做得很美，拉起來也很順。和 Logseq 相同，圖片都會靠左，而 Notion 則是置中。我個人偏好靠左，與文字一致。</p><h2 id="三、超連結編輯器"><a href="#三、超連結編輯器" class="headerlink" title="三、超連結編輯器"></a>三、超連結編輯器</h2><p><img src="https://i.imgur.com/8yPlckm.png"></p><p>在 Markdown 文件中要編輯超連結，真的不太方便，所以很多支援 Markdown 的軟體會有類似上圖的超連結編輯器，比如 Notion 就有。</p><p>我覺得 Bear 貼心之處在於，每個超連結的末端都加了「<strong>鉛筆</strong>」圖示，按下去即可直接編輯，確實方便。</p><p>相較之下，Notion 則需要游標在連結上<strong>短暫停留</strong>，我感覺稍為麻煩一點。</p><p>但 Bear 的不足則是無法直接取消超連結，只能透過清空下面的連結內容來達成，這就太不直觀了。</p><h2 id="四、還不錯的摺疊功能"><a href="#四、還不錯的摺疊功能" class="headerlink" title="四、還不錯的摺疊功能"></a>四、還不錯的摺疊功能</h2><p><img src="https://i.imgur.com/SFdsEJJ.png"></p><p>相當於 Notion 中的 Toggle，<del>但要透過呼叫選單才能操作，有點不便</del>。</p><p>效果是把整個標題的內容都收納起來，收納後會呈現上面那個 H3 標題樣式。摺疊功能在「<a href="https://blog.kyomind.tw/silver-bullets/#%E4%BA%8C%E3%80%81%E6%94%B6%E5%90%88">清單式筆記</a>」幾乎是必備元素，已經相當成熟。</p><p>經<a href="https://github.com/kyomind/blog-reply/issues/17#issuecomment-1642026218">網友補充</a>，摺疊功能可以透過快捷鍵「<code>⌘ + &#39;</code>」操作，那就很方便了！</p><p>如此一來，這個摺疊功能將<strong>明顯超越 Notion 的 Toggle</strong>，因為 Notion 的 Toggle 是<strong>獨立元素</strong>，不可以和一般版本的標題、清單混用。</p><p>而 Bear 的摺疊功能，則是<strong>直接融入</strong>標題、清單中，使用上更為簡潔、自然。</p><h2 id="五、其它更新項目簡評"><a href="#五、其它更新項目簡評" class="headerlink" title="五、其它更新項目簡評"></a>五、其它更新項目簡評</h2><p>其餘比較值得一提的更新：</p><ul><li><strong>Table of Contents</strong>：不是在文本中，是在<strong>資訊欄的第二分頁</strong>，可以快速跳轉同頁內容，對長文本比較有用。</li><li><strong>表格</strong>：偶爾需要，而且用起來比 Notion 的順手。</li><li><strong>自訂字型</strong>：雖然我覺得這是現代筆記工具的<strong>基本</strong>，但很多軟體都沒有！</li><li><strong>反向連結</strong>：類似 Notion 會把<strong>連結到這個筆記</strong>的相關筆記清單列在頁面開頭，而 Bear 則是放在<strong>資訊欄的第三分頁</strong>。查看起來不方便，我覺得不實用。</li></ul><p>附帶一提，在 Bear 筆記頁中輸入<code>[[</code>然後空一格，會出現頁面搜尋清單，可以讓你輕鬆建立<strong>正向連結</strong>。（也就是把其餘筆記連結到當前頁面）</p><hr><h2 id="結語：對需求保持清醒"><a href="#結語：對需求保持清醒" class="headerlink" title="結語：對需求保持清醒"></a>結語：對需求保持清醒</h2><p>Bear 2 力求在維持簡潔的基礎上，盡可能加入一些常用的便捷功能。</p><p>在這個筆記軟體的戰國時代，「功能的<strong>多樣化</strong>與<strong>複雜化</strong>」幾乎是現代筆記軟體都會遇到的<strong>兩難困境</strong>，猶如一場軍備競賽：</p><ul><li>別人有的功能你沒有，難免會<strong>流失一些客群</strong>。</li><li>但如果你有樣學樣，不斷增加新功能，又可能<strong>讓使用者感到負擔</strong>。</li></ul><p>這種情況下還要繼續貫徹簡潔精神，我認為很不容易。所以我依舊欣賞 Bear，因為它有一定的——被嫌棄的勇氣。</p><p>當然，某些功能的更新也讓我覺得，它感受到一定的壓力，不得不加入。</p><p><strong>如何保持清醒，對目標用戶需求有一定清晰認知</strong>，是開發方需要不斷思考的問題。</p><p>而對身為使用者的我們而言，恐怕也是如此。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CkddA67.png&quot; alt=&quot;bear.app&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉一文中，我曾提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你正在尋找一款和 Evernote 界面相似、使用邏輯相仿，且&lt;strong&gt;符合現代潮流&lt;/strong&gt;的 app，那麼我誠摯推薦自己也有在用的 &lt;a href=&quot;https://bear.app/&quot;&gt;Bear&lt;/a&gt;。（可惜它只限 macOS 與 iOS 平台）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bear（中文名稱：&lt;strong&gt;熊掌記&lt;/strong&gt;）、Notion、Logseq 這三者，都是我目前&lt;strong&gt;持續使用中&lt;/strong&gt;的筆記軟體，雖然在使用量上，它們呈現一個&lt;strong&gt;非常不均勻&lt;/strong&gt;的分布：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logseq：80%&lt;/li&gt;
&lt;li&gt;Notion：15%&lt;/li&gt;
&lt;li&gt;Bear：5%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對，你沒看錯，Bear 的使用量只佔我全部筆記的 5% 而已。&lt;/p&gt;
&lt;p&gt;儘管如此，我依舊是一個忠實的 Bear 付費用戶。原因無他，因為無論是 Notion 還是 Logseq，它們都太「&lt;strong&gt;重&lt;/strong&gt;」了！&lt;/p&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Bear" scheme="https://blog.kyomind.tw/tags/Bear/"/>
    
    <category term="Evernote" scheme="https://blog.kyomind.tw/tags/Evernote/"/>
    
  </entry>
  
  <entry>
    <title>淺談我對蘋果 M 系列晶片的看法——超新星爆發</title>
    <link href="https://blog.kyomind.tw/apple-silicon/"/>
    <id>https://blog.kyomind.tw/apple-silicon/</id>
    <published>2023-07-02T09:23:58.000Z</published>
    <updated>2023-08-10T08:47:09.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/fGGona2.jpg" alt="apple.com"><span class="cap">apple.com</span></p><p>昨天寫了這篇〈<a href="https://blog.kyomind.tw/mac-mini/">M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南</a>〉後，我發現，我對蘋果 M 系列晶片的讚揚，還遠遠沒有寫夠！</p><p>因此，我續寫了這篇，補充我對 M 系列晶片的看法——解釋為什麼我對它的評價如此之高，甚至接近「信仰」的程度。</p><p>這不僅僅因為它的高效能、低功耗，更重要的是，它讓我深刻理解到：原來（處理器）<strong>世界真的能夠被顛覆</strong>！</p><p>而要充分表達其中的「感動」，還得從採用 Intel 處理器時代的 Mac 說起。</p><span id="more"></span><hr><h2 id="從-Core-系列開始擠牙膏的-Intel"><a href="#從-Core-系列開始擠牙膏的-Intel" class="headerlink" title="從 Core 系列開始擠牙膏的 Intel"></a>從 Core 系列開始擠牙膏的 Intel</h2><p>Apple Mac 早期用的是 IBM <a href="https://zh.wikipedia.org/zh-tw/PowerPC">PowerPC</a> 架構的處理器，但因為效能不足，於 2005 年宣布轉向使用 Intel 處理器。</p><p>Intel 從 2006 的 <a href="https://zh.wikipedia.org/zh-tw/%E9%85%B7%E7%9D%BF#Core%E5%BE%AE%E6%9E%B6%E6%A7%8B%EF%BC%8864%E4%BD%8D%E5%85%83%EF%BC%89">Core</a> 架構開始，與競爭對手 AMD 漸漸拉開了技術差距，造就了其長達 10 年的獨大地位。</p><p>同時也開啟了 Intel 長達 10 年的「<a href="https://youtu.be/4bhHPeCZu0w">擠牙膏之旅</a>」——fuxk。</p><p>直到 2017 年，AMD 推出了全新的 <a href="https://zh.wikipedia.org/zh-tw/AMD_Ryzen">Ryzen</a> 處理器，重新點燃戰火，才正式打破了 Intel 的絕對優勢地位。</p><h2 id="處理器發展的黑暗時代"><a href="#處理器發展的黑暗時代" class="headerlink" title="處理器發展的黑暗時代"></a>處理器發展的黑暗時代</h2><p>維基百科是這麼描述中古黑暗時期：</p><blockquote><p><strong>歐洲黑暗時代</strong>（<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E8%AF%AD">英語</a>：<strong>Dark Ages</strong> 或 <strong>Dark Age</strong>）在編史工作上是指在<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E6%AC%A7">西歐</a>歷史上，從<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD">西羅馬帝國</a>的滅亡到<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E8%89%BA%E5%A4%8D%E5%85%B4">文藝復興</a>開始，一段文化層次下降或者社會崩潰的時期。 在 19 世紀，隨著對<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%B8%96%E7%BA%AA">中世紀</a>更多的了解，整個時代都被描述成「黑暗」的說法受到了挑戰。</p></blockquote><p>如文中所言，中世紀這段時期，是否真的該稱為「黑暗」時代，容有不同看法。</p><p>然而，Intel 獨大的這 10 年，它的壟斷地位對個人電腦發展的影響，就是一片黑暗！</p><p>從 Core 1 代到 7 代，每次更新的效能提升幅度，從前期的 10-15%，到後期甚至降到了 10% 以下，真是充分利用了自身的優勢，令人火大。</p><hr><h2 id="終於有「誠意」的-8-代"><a href="#終於有「誠意」的-8-代" class="headerlink" title="終於有「誠意」的 8 代"></a>終於有「誠意」的 8 代</h2><p>再看維基百科對第 8 代 Core——<a href="https://zh.wikipedia.org/zh-tw/Coffee_Lake">Coffee Lake</a>——的評價：</p><blockquote><p>Coffee Lake 標誌著個人電腦中處理器核心數的一次大升級，<strong>而上一次這樣的升級還是十年前的 Core 2 Duo</strong>。這次的升級主要是因為 AMD 的 Ryzen 系列處理器。</p></blockquote><p>平心而論，8 代 Core 的效能提升絕對是有目共睹的——早該如此了好嗎？</p><p>和前代 Kaby Lake 相比，效能幾乎翻倍！因為筆電處理器的核心數量，從雙核升級到了 4 核，所以確實很有感。</p><p>導致我曾一度以為，擁有 4 核心處理器的 Macbook，應該接近「完全體」了。因此，在 2020 年，我換了<a href="https://blog.kyomind.tw/weekly-review-09/#%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%8F%B0-Macbook%EF%BC%9AMacbook-Air-2020-Intel-%E7%89%88">新的 Macbook Air</a>。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-09/">09，我的 Macbook 之旅 + 新的野心</a></p></blockquote><p>雖然這台 Mac 配備了 Intel 更新的<a href="https://www.intel.com.tw/content/www/tw/zh/products/sku/196589/intel-core-i51030ng7-processor-6m-cache-up-to-3-50-ghz/specifications.html">第 10 代 CPU</a>，但因為屬於<strong>超低功耗系列</strong>，整體效能尚不及採用第 8 代 CPU——<a href="https://www.intel.com.tw/content/www/tw/zh/products/sku/135935/intel-core-i58259u-processor-6m-cache-up-to-3-80-ghz/specifications.html">i5-8259U</a>——的 13 吋 Macbook Pro。</p><p>但考慮它 <a href="https://browser.geekbench.com/processors/intel-core-i5-1030ng7">Geekbench 多核跑分</a>也有 [i5-8259U 跑分</p><p>然而事實是：這台 Mac 的效能<strong>明顯達不到我的要求——它離「完全體」還很遠！</strong></p><hr><h2 id="超新星爆發：Apple-Silicon-M1-降臨"><a href="#超新星爆發：Apple-Silicon-M1-降臨" class="headerlink" title="超新星爆發：Apple Silicon M1 降臨"></a>超新星爆發：Apple Silicon M1 降臨</h2><p>所謂<a href="https://zh.wikipedia.org/zh-tw/%E8%B6%85%E6%96%B0%E6%98%9F">超新星爆發</a>，實際上是大質量恆星生命週期的<strong>終點</strong>，而不是開始或誕生的象徵。</p><p>但因為爆發產生的亮度極高，能量巨大，當我們談論新事物或新概念時，有時我們會用「超新星爆發」來形容它們帶來的顯著變革和影響。</p><p>這種比喻意味著該新事物的出現，伴隨極大的能量和劇烈的變動，<strong>且很可能改變現有的狀態和平衡。</strong></p><p>2020 年底，專為 Mac 設計的 Apple Silicon 晶片正式發表，它的名字叫 <a href="https://zh.wikipedia.org/zh-tw/Apple_M1">M1</a>。</p><p>和我原有的 Macbook Air 相比，它的效能是誇張的 3 倍，而續航力竟然也是 3 倍——<strong>不可思議</strong>。這顯然超越了我們對「進化」的理解——這是「<strong>超新星爆發</strong>」。</p><hr><h2 id="小結：Way-to-Go"><a href="#小結：Way-to-Go" class="headerlink" title="小結：Way to Go"></a>小結：Way to Go</h2><p>革命不可能常常發生，在 M1 帶給我們如此深刻的印象之後，後續的 M2 自然很難複製同樣的衝擊。</p><p>但對我來說，配備 M 系列晶片的 Mac，已經可以稱為「<strong>完全體</strong>」。</p><p>意即，這台機器要用上十年、八年，我相信完全不是問題。這是舊 Intel 時代處理器，所無法帶給我的想望。</p><p>這也是為什麼我願意為 M2 Pro Mac mini 加購那麼多「不一定必要」的升級——因為我對它的<strong>長期價值</strong>，有著相當的信心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fGGona2.jpg&quot; alt=&quot;apple.com&quot;&gt;&lt;/p&gt;
&lt;p&gt;昨天寫了這篇〈&lt;a href=&quot;https://blog.kyomind.tw/mac-mini/&quot;&gt;M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南&lt;/a&gt;〉後，我發現，我對蘋果 M 系列晶片的讚揚，還遠遠沒有寫夠！&lt;/p&gt;
&lt;p&gt;因此，我續寫了這篇，補充我對 M 系列晶片的看法——解釋為什麼我對它的評價如此之高，甚至接近「信仰」的程度。&lt;/p&gt;
&lt;p&gt;這不僅僅因為它的高效能、低功耗，更重要的是，它讓我深刻理解到：原來（處理器）&lt;strong&gt;世界真的能夠被顛覆&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;而要充分表達其中的「感動」，還得從採用 Intel 處理器時代的 Mac 說起。&lt;/p&gt;</summary>
    
    
    
    <category term="隨筆雜談" scheme="https://blog.kyomind.tw/categories/%E9%9A%A8%E7%AD%86%E9%9B%9C%E8%AB%87/"/>
    
    
    <category term="Apple Silicon" scheme="https://blog.kyomind.tw/tags/Apple-Silicon/"/>
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南</title>
    <link href="https://blog.kyomind.tw/mac-mini/"/>
    <id>https://blog.kyomind.tw/mac-mini/</id>
    <published>2023-07-01T13:12:39.000Z</published>
    <updated>2023-08-22T16:08:30.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/h8Mebn5.jpg" alt="Cassiopeia A 超新星殘骸，直徑約 10 光年"><span class="cap">Cassiopeia A 超新星殘骸，直徑約 10 光年</span></p><p>今年 4 月，我入手了 M2 Pro 版的 <a href="https://www.apple.com/tw/mac-mini/">Mac mini</a>，至今已使用了快 3 個月。隨著配備 M2 Max 的 <a href="https://www.apple.com/tw/mac-studio/">Mac Studio</a> 發表，我認為是時候分享一下我的心得和選購指南——雖然這只是一個粗略的指南。</p><blockquote><p>相關文章：<a href="/apple-studio-display/">Apple Studio Display 適合你嗎？——我的心得與選購指南</a></p></blockquote><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文主要寫給那些<strong>「想買 Mac mini 但還有所遲疑的人」</strong>作為參考，我不會特別鼓吹要買哪一款，這是一篇「平靜」的心得。</p><p>此外，這篇文章是以<strong>我的核心需求</strong>——<a href="/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/">軟體開發</a>——為出發點，對同為軟體工程師的讀者而言，可能更具參考價值。</p><span id="more"></span><h2 id="我的-Mac-mini-規格"><a href="#我的-Mac-mini-規格" class="headerlink" title="我的 Mac mini 規格"></a>我的 Mac mini 規格</h2><p>先講規格，如開頭所言，這是一台 M2 Pro 版的 Mac mini，並做了一些升級：</p><ul><li>升級 CPU 晶片：10C&#x2F;16C（CPU 和 GPU 核心數）升級為 12C&#x2F;19C。</li><li>升級 32 GB RAM。</li><li>升級 1 TB SSD。</li><li>升級 10 Gigabit 乙太網卡。</li></ul><p>總計 69900 元，但我<strong>並不推薦</strong>這樣的配置，文末會推薦我認為 <strong>CP 值較高</strong>的選項。</p><h2 id="為什麼-Mac-mini-才是我寫程式最佳選擇？"><a href="#為什麼-Mac-mini-才是我寫程式最佳選擇？" class="headerlink" title="為什麼 Mac mini 才是我寫程式最佳選擇？"></a>為什麼 Mac mini 才是我寫程式最佳選擇？</h2><p>對於大部分工程師來說，14 或 16 吋的 Macbook Pro 應該是首選。即使在家中使用，也可以透過外接大螢幕來提供更好的工作體驗。</p><p>確實如此，我以前也是這樣想的。</p><p>直到〈<a href="https://blog.kyomind.tw/weekly-review-09/">09，我的 Macbook 之旅 + 新的野心</a>〉，重新思考了自己的需求後，<strong>我發現我真正需要的，是 Mac mini——也許你也是。</strong></p><p>我主要的考慮有三：</p><ol><li>我很少把筆電帶出門使用，雖然是遠端工作但我從不去咖啡廳，所以機動性需求非常小。</li><li>即使真的要帶筆電出門，我也不想帶 14 吋甚至 16 吋的 Macbook Pro——它們都太重也太厚了。</li><li>家中使用，外接<a href="https://blog.kyomind.tw/weekly-review-13/">大螢幕</a>後，筆電<strong>只剩下主機功能</strong>，繼續放在桌上<strong>顯得很佔空間</strong>，不符合我的簡潔美學。很多人會把它立起來或當小螢幕使用，但我不喜歡。</li></ol><p>由此可知，在絕大部分時候，Mac mini 才是我的首選。</p><hr><h2 id="新-Mac-都有的-SSD-降速問題"><a href="#新-Mac-都有的-SSD-降速問題" class="headerlink" title="新 Mac 都有的 SSD 降速問題"></a>新 Mac 都有的 SSD 降速問題</h2><p>現在要買 M2 晶片的 Mac，無論桌機還是筆電，我們都不得不接受一個現實：只要是該系列的「<strong>最低規格</strong>」，那 SSD 就一定是<strong>單晶片</strong>——這意味著<strong>速度較慢</strong>，而且還<strong>慢上不少</strong>。</p><p>哪怕是 M2 Pro 入門起跳的 512 GB SSD，一樣有這個問題，著實令人不快。因為通常最低階的規格，對多數人而言，就是 CP 值最高的選擇。</p><p>而蘋果想必也深知這一點，讓你陷入兩難，真的很討厭！</p><blockquote><p>蘋果你贏了。</p></blockquote><h2 id="為什麼我選擇-M2-Pro？"><a href="#為什麼我選擇-M2-Pro？" class="headerlink" title="為什麼我選擇 M2 Pro？"></a>為什麼我選擇 M2 Pro？</h2><p>作為一個靠電腦吃飯的軟體工程師，我買電腦比較沒那麼重視 CP 值。所以原本一直都把目光放向 Max 而非 Pro。</p><p>原因也非常直接簡單：「因為它叫 Max，作為一個工程師，我應該要 Max！」，即使我明白 Max 和 Pro 在 CPU 效能上是相同的。</p><p>不過在做了更多功課後，我還是得承認，如果用不到 Max 多出來的 GPU 核心，那買 Max 的機型就完完全全是一種浪費。</p><p>而現實中的我，連 Pro 版 GPU 核心都用不太到🐸</p><hr><h2 id="Mac-mini-的選購考量"><a href="#Mac-mini-的選購考量" class="headerlink" title="Mac mini 的選購考量"></a>Mac mini 的選購考量</h2><p>好，捨棄 Max！這是好事，因為 Mac mini 也沒有 Max 版本。如果我堅持要 Max，就只能購買 Mac Studio。</p><p>但我才不想買「體積龐大（相對於 mini😷）」的 Studio！我想這也是促成我堅定選擇 M2 Pro 的<strong>另一大考量</strong>——mini 最多只有 Pro，而我要 mini。</p><p>但問題又來了，如果要買 mini，是要買 M2 版還是 M2 Pro 版呢？</p><blockquote><p>平心而論，我覺得都可以。</p></blockquote><p>這不是開玩笑，因為 M2（或說 M1 及以後）的 Mac，相較於以前的 Intel CPU，效能實在強太多了，而且功耗也低得多。</p><p>以至於我不禁感到，選購 M2 或 M2 Pro，也許只是一個「心情」議題——我真心這麼認為。意即，好一點的規格，很多時候只是為了心安而已。</p><h2 id="M2-和-M2-Pro-差異"><a href="#M2-和-M2-Pro-差異" class="headerlink" title="M2 和 M2 Pro 差異"></a>M2 和 M2 Pro 差異</h2><p>不過話又說回來，哪怕只是為了心安，我們也得先知道 M2 和 M2 Pro 有什麼差異。</p><p>兩者的差異可參考這個影片〈<a href="https://www.youtube.com/watch?v=szBpbSMhe_s">The TRUTH about New Mac Mini after 1 Month - M2 vs M2 Pro!</a>〉，有著相當完整的比較。</p><p>對我而言，大概有這幾個主要差別：</p><ol><li>相較於 M2，Pro 是更強的 CPU 與 GPU。提升幅度依不同場景，約落在 40-80% 之間。</li><li>M2 Pro 的記憶體上限是 32 GB，而 M2 則是 24 GB。對於需要大量記憶體的人，這是一個重要考量。</li><li>M2 Pro 的記憶體頻寬從 100 GB 提升至 200 GB。這個好評！</li><li>SSD 的速度也有差別（而且差滿多的XD），可參考下圖：</li></ol><p><img src="https://i.imgur.com/bSiCE1t.png" alt="來源：Max Tech"><span class="cap">來源：Max Tech</span></p><p>雖然 SSD 速度上差很多，但實際感受上，可能沒有多大差異。</p><p>我的看法是，除非你能「榨乾」GPU，比如全職影像工作者，否則 M2 或 M2 Pro 的「<strong>體感差異</strong>」終究是有限的。</p><p>而且退萬步言，哪怕是 M2，要剪輯多軌 4K 影片，也是沒問題的。</p><p><strong>真正需要嚴肅考慮的，或許是 RAM 的大小！</strong>因為在某些單次就要載入大檔案的情境（比如載入機器學習資料集），RAM 的不足真的會讓效率大幅下降。</p><p>除了上述兩種情況，其它時候，兩者大同小異。所以我才說，這是一個心情議題。</p><hr><h2 id="Mac-mini-與-Mac-Studio-的選購考量"><a href="#Mac-mini-與-Mac-Studio-的選購考量" class="headerlink" title="Mac mini 與 Mac Studio 的選購考量"></a>Mac mini 與 Mac Studio 的選購考量</h2><p>最近 M2 Max 版的 <a href="https://www.apple.com/tw/shop/buy-mac/mac-studio">Mac Studio</a> 發表了，這會一定程度影響「<strong>高階 Mac mini</strong>」的<strong>選購合理性</strong>，值得一提。</p><p>怎麼說？講白了就是，如果你選了 M2 Pro 版的 Mac mini，而且像我一樣，對它進行了若干升級，那它的 CP 值很可能就會<strong>明顯不如</strong> M2 Max 的 Mac Studio。</p><p>以我的 Mac mini 為例，足足升級了 4 個項目，而 Mac Studio 只要升級 SSD，規格上就幾乎就完勝。差別如下：</p><ol><li>升級後，Mac Studio 僅貴了 1000 左右（69900 VS 70999）。</li><li>Mac Studio 的 GPU 從 mini 的 19 核變成 30 核！</li><li>Mac Studio 機體正面多了兩個 USB-C 埠和讀卡機——對某些人可謂愛不釋手。</li><li>Mac Studio 的記憶體頻寬從每秒 200 GB 提升到 400 GB。</li></ol><p>其它暫且不論，光多花 1000 元就足足多了 11 核心的 GPU，這道計算題……似乎不是太困難😎——想想 M2 Macbook Air 僅從 8 核 GPU 升到 10 核，就要 3000 元。</p><p>總之，如果你想買「<strong>升級版</strong>」M2 Pro Mac mini，不妨先看一下 Mac Studio <strong>是否更符合自己的需求</strong>，再決定也不遲。</p><h2 id="我依舊選擇-Mac-mini"><a href="#我依舊選擇-Mac-mini" class="headerlink" title="我依舊選擇 Mac mini"></a>我依舊選擇 Mac mini</h2><p>說了這麼多，主要是為讀者——也就是螢幕前的你——考慮。若此時此刻，讓我再重新選擇，我還是會選 Mac mini，而且一樣會升級。</p><p>現在我們已經知道，這樣的升級，相較於直接購買 Mac Studio，多少是不太划算的，那我<strong>鍾情於 Mac mini 的理由</strong>又是如何呢？主要有三：</p><ol><li>Mac Studio 的體積太大了！足足有 3 台 Mac mini 這麼大，我不能接受XD。</li><li>Mac Studio 多出來的 GPU 效能，我用不太到，畢竟連 M2 Pro 的 GPU 對我都屬效能過剩。<ol><li>附帶一提，我升級 M2 Pro 的 CPU 晶片，主要是為了 <strong>CPU 部分的提升</strong>——大概 20%，對一些<strong>計算密集</strong>的任務仍有大用。</li><li>比如我很常用 <a href="https://goodsnooze.gumroad.com/l/macwhisper">MacWhisper</a> 將聲音轉成文字，<a href="https://github.com/openai/whisper/pull/382">受限於模型</a>，目前在 macOS 上只能靠 CPU 運算，快個 20% 總是好的。</li></ol></li><li>值得欣慰的是，根據<a href="https://youtu.be/fkhkm1wQS18">這則影片</a>的測試，Mac Studio 採用的新一批 SSD，在跑分上甚至還略遜於 mini，如圖（僅供參考）：</li></ol><p><img src="https://i.imgur.com/745De6H.png" alt="來源：Max Tech"><span class="cap">來源：Max Tech</span></p><p>Mac Studio 是一台強大的性能怪獸，只是我目前還用不上。有朝一日，會再考慮。</p><hr><h2 id="選購建議"><a href="#選購建議" class="headerlink" title="選購建議"></a>選購建議</h2><p>身為一個軟體工程師，在選購「吃飯工具」時，我不會太在乎 CP 值，所以加了一些讓自己「<strong>心情更好</strong>」的升級，儘管我知道這些升級<strong>對於實際體驗的影響有限</strong>。</p><p>這樣的心態很像散文〈<a href="https://medium.com/code-and-me/%E7%AC%AC%E4%B9%9D%E5%91%B3-453d14626ed7">第九味</a>〉中的那句話：「喫是為己，穿是為人。」</p><blockquote><p><strong>但我並不推薦你這麼做。</strong></p></blockquote><h3 id="Mac-選購建議"><a href="#Mac-選購建議" class="headerlink" title="Mac 選購建議"></a>Mac 選購建議</h3><p>如前所述，在蘋果的精心設計下，<strong>通常系列的入門款，就是 CP 值最高的選擇</strong>。因此，如果你是 Mac 新手且只有文書需求，我推薦入門款的 M2 Mac mini。</p><p>如果你也是軟體工程師，則 M2 Pro 無疑是<strong>更加均衡的選擇</strong>。而入門款的 M2 Pro Mac mini，恰恰是<strong>效能與價格競爭力兼具</strong>的不敗選項。</p><p>如果你影像工作者，且需要<strong>非常強大的 GPU 運算力</strong>，那麼從 Mac Studio 開始考慮，或許會比較快。</p><h3 id="Macbook-選購建議"><a href="#Macbook-選購建議" class="headerlink" title="Macbook 選購建議"></a>Macbook 選購建議</h3><p>2020 舊款、2022 新款的 Macbook Air 我都有，M1 Pro 的 Macbook Pro 也曾短暫入手過，說說我對它們的看法。</p><p>如果<strong>只能擁有一台 Macbook</strong>，我會毫不猶豫地選擇 <strong>M2 Macbook Air</strong>。因為它的外觀設計幾乎完美符合我對於輕薄筆電的想像——圓潤的邊角及線條，太美了。</p><p>但如果是推薦身邊的人買，我八成還是會選舊款 M1 Macbook Air，因為它的價格更加親民、性能足夠好。不到 3 萬就能擁有這樣一台機器，<strong>這是以前所無法想像的。</strong></p><p>至於 Macbook Pro，顯然更適合<strong>對效能有要求</strong>，並希望透過一台 Macbook，一次滿足在家與外出使用的人。</p><p>附帶一提，<strong>盡量避免在 14 吋的 Macbook Pro 上選用 Max 版的 CPU</strong>，因為它的<strong>散熱能力相對有限</strong>。在持續高負載下，CPU 容易因過熱而降頻，造成<strong>性能瓶頸</strong>。</p><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>整體而言，我對於手上這台 Mac mini 可謂<strong>相當滿意</strong>。它以極低功耗提供了十分優秀的效能和穩定性，充分滿足了我在工作、學習上的需求。</p><p>我不得不佩服蘋果 M 系列晶片之強大，猶如<strong>超新星爆發</strong>。而你，也值得擁有。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/apple-silicon/">淺談我對蘋果 M 系列晶片的看法——超新星爆發</a></p></blockquote><p>在我看來，要說 Mac 有什麼<strong>致命缺點</strong>，大概就是<strong>升級真的好貴！</strong>而且<strong>無法自行升級</strong>。但這也是蘋果一貫的作風，我只能眼睜睜看著自己的錢包被掏空🥹</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/h8Mebn5.jpg&quot; alt=&quot;Cassiopeia A 超新星殘骸，直徑約 10 光年&quot;&gt;&lt;/p&gt;
&lt;p&gt;今年 4 月，我入手了 M2 Pro 版的 &lt;a href=&quot;https://www.apple.com/tw/mac-mini/&quot;&gt;Mac mini&lt;/a&gt;，至今已使用了快 3 個月。隨著配備 M2 Max 的 &lt;a href=&quot;https://www.apple.com/tw/mac-studio/&quot;&gt;Mac Studio&lt;/a&gt; 發表，我認為是時候分享一下我的心得和選購指南——雖然這只是一個粗略的指南。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;/apple-studio-display/&quot;&gt;Apple Studio Display 適合你嗎？——我的心得與選購指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;本文主要寫給那些&lt;strong&gt;「想買 Mac mini 但還有所遲疑的人」&lt;/strong&gt;作為參考，我不會特別鼓吹要買哪一款，這是一篇「平靜」的心得。&lt;/p&gt;
&lt;p&gt;此外，這篇文章是以&lt;strong&gt;我的核心需求&lt;/strong&gt;——&lt;a href=&quot;/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/&quot;&gt;軟體開發&lt;/a&gt;——為出發點，對同為軟體工程師的讀者而言，可能更具參考價值。&lt;/p&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="開箱評論" scheme="https://blog.kyomind.tw/tags/%E9%96%8B%E7%AE%B1%E8%A9%95%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</title>
    <link href="https://blog.kyomind.tw/django-models/"/>
    <id>https://blog.kyomind.tw/django-models/</id>
    <published>2023-06-24T17:31:49.000Z</published>
    <updated>2023-08-31T18:09:36.984Z</updated>
    
    <content type="html"><![CDATA[<!-- ![by Léo Alexandre](https://i.imgur.com/yK0Us6a.jpg) --><!-- ![](https://i.imgur.com/TBQKYrC.png) --><p><img src="https://i.imgur.com/lyxUZv1.png" alt="github.com/kyomind/kyo-django-tutorial"><span class="cap">github.com/kyomind/kyo-django-tutorial</span></p><p>工作上使用 Django 近 2 年，卻很少發表關於 Django 主題的文章，是時候該來補一補了。</p><p>那就從 Django ORM 開始吧！因為 ORM（<a href="https://docs.djangoproject.com/en/4.2/topics/db/models/">Django Models</a>）可以說是無論你怎麼使用 Django（全端或前後端分離），都不得不學的核心部分。</p><p>怎麼說？我們先來看看，在「<strong>前後端分離</strong>」的開發趨勢下，Django 的三大核心——MTV——的重要性有哪些變動。</p><span id="more"></span><h2 id="前後端分離下的-Django-MTV"><a href="#前後端分離下的-Django-MTV" class="headerlink" title="前後端分離下的 Django MTV"></a>前後端分離下的 Django MTV</h2><p>在 Django 中，MTV 指的是「<strong>Model-Template-View</strong>」架構模式。類似於 <a href="https://zh.wikipedia.org/zh-tw/MVC">MVC</a>，這是 Django 框架的核心設計模式，用於組織和分離應用程式的不同部分。</p><ul><li><strong>Model（模型）：</strong> 模型負責處理與資料庫相關的操作，它是定義數據結構、資料表和資料庫查詢的地方。</li><li><strong>Template（模板）：</strong> 模板用於前端。它是一個包含 HTML、CSS 和一些額外標記語言（例如 Django 的模板語言）的文件，用於定義網頁的外觀和內容。</li><li><strong>View（視圖）：</strong> 視圖是應用程式處理邏輯的地方。它接收來自前端的 HTTP 請求，並根據需要調用相應的模型和模板來生成回應。</li></ul><h3 id="前後端分離對三大元件的重要性影響"><a href="#前後端分離對三大元件的重要性影響" class="headerlink" title="前後端分離對三大元件的重要性影響"></a>前後端分離對三大元件的重要性影響</h3><p>假設你是一個前後端分離下的 Django 工程師，那通常是負責<strong>後端的 API 開發</strong>。</p><p>首先，顯然 Template 不需要了，因為這是前端的範疇，而 View 呢？相當程度會被 <a href="https://www.django-rest-framework.org/">Django REST framework</a>（以下皆簡稱為 DRF）所取代。說「取代」不太正確，應該說「升級」。</p><p>帶來的影響是 View 中相當部分操作細節與學習重點會遷移到 DRF 本身，而非 Django 提供的原生功能。</p><p>比如<code>request.data</code>，重新封裝了 Django 中的<code>request.POST</code>和<code>request.FILES</code>兩個屬性，類似的情況還有<code>APIView</code>或<code>@api_view</code>等等。</p><p>既然 Template 被前端取代，而 View 的功能則被 DRF 重新封裝。可想而知，三大元件中重要性<strong>唯一不變</strong>的，就是 Model——Django ORM。</p><p>可見，作為一個 Django 開發者，學好 ORM 是絕對不虧的！</p><h2 id="有助於學習-FastAPI"><a href="#有助於學習-FastAPI" class="headerlink" title="有助於學習 FastAPI"></a>有助於學習 FastAPI</h2><p>如果這樣還不夠，我再給你一個學好 Django ORM 的理由。（加分項）</p><p>現在火紅的 <a href="https://github.com/tiangolo/fastapi">FastAPI</a>，本身並沒有包括 ORM 功能，所以需要你另外選擇 ORM 套件。常見的選項有 <a href="https://github.com/sqlalchemy/sqlalchemy">SQLAlchemy</a>、<a href="https://github.com/tortoise/tortoise-orm">Tortoise ORM</a>。</p><p><strong>而 Tortoise ORM 正是</strong><a href="https://github.com/tortoise/tortoise-orm#introduction">受到 Django ORM 的啟發</a>，所以學好 Django ORM 之後，學習 Tortoise ORM 會更容易上手：</p><blockquote><p>Tortoise ORM is an easy-to-use asyncio ORM (Object Relational Mapper) <strong>inspired by Django</strong>.</p></blockquote><blockquote><p><strong>Tortoise ORM was built with relations in mind and admiration for the excellent and popular Django ORM.</strong> It’s engraved in its design that you are working not with just tables, you work with relational data.</p></blockquote><p>附帶一提，我個人不太喜歡 SQLAlchemy，因為它的語法相對複雜，還有那過時的官方文件網站排版（這點和 DRF 很像XD）。所以推薦 Tortoise ORM。</p><hr><h2 id="範例程式碼專案介紹"><a href="#範例程式碼專案介紹" class="headerlink" title="範例程式碼專案介紹"></a>範例程式碼專案介紹</h2><p>如前所述，我打算寫一系列的 Django 教學文章，有範例程式碼，會更方便讀者學習、參考。於是我建了一個 GitHub Repo 名為「<a href="https://github.com/kyomind/kyo-django-tutorial">kyo-django-tutorial</a>」，把文章中使用的程式碼同步更新於此。</p><p>這是一個典型的 Django 專案，而且有著完整的 Python 環境設定，各種細節都和我個人開發一致，有 Poetry、pre-commit 與基本的 linter、formatter 設定等，方便你重現環境並跟著操作。</p><p>以下是簡單的介紹。</p><h3 id="專案環境介紹"><a href="#專案環境介紹" class="headerlink" title="專案環境介紹"></a>專案環境介紹</h3><p>支援 Poetry，方便重建專案所需的 Python 虛擬環境。但你也可以不使用它，我有另外準備<code>requirements.txt</code>供<code>pip</code>安裝。</p><p>pre-commit 完全可選，基本上用不到，除非你有打算變更程式碼的內容。只要不使用指令<code>pre-commit install</code>，它相當於不存在。但如果你想用的話，整個<code>.pre-commit-config.yaml</code>設定檔都寫好了。</p><p>隨著文章更新，未來還會支援 Docker，敬請期待。</p><h3 id="工具版本說明"><a href="#工具版本說明" class="headerlink" title="工具版本說明"></a>工具版本說明</h3><p>Django 版本為 4.2 LTS，對 Python 的版本有一定要求，不能太舊，要 3.8 以上。</p><p>Python 版本使用 3.10.11，建議至少使用 3.8.1，雖然剛剛說 Django 只要求 3.8，但因為 Flake8 版本是 6.0.0，要求 Python 至少要 3.8.1 XD。建議直接還是安裝 3.10 或更新的版本。</p><hr><p>基本的介紹就到這裡，我們趕緊進入本篇的重點。</p><h2 id="本文重點：Django-ORM-外鍵關聯設定"><a href="#本文重點：Django-ORM-外鍵關聯設定" class="headerlink" title="本文重點：Django ORM 外鍵關聯設定"></a>本文重點：Django ORM 外鍵關聯設定</h2><p><a href="https://docs.djangoproject.com/en/4.2/topics/db/models/">Django Models</a>，也就是 database table 的 <a href="https://zh.wikipedia.org/zh-tw/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84">OOP</a> 型態，透過 ORM 來實現兩者的對應關係——從 table 到 Python class。</p><p>如果說 ORM 是 Django 的核心之一，而 ORM 的核心會是什麼呢？我相信其中一個答案，就是「<strong>外鍵關聯</strong>」（<strong>relationships</strong>）。若是少了關聯，資料表就像孤立的島嶼，根本無法真實模擬世界。</p><p>剛開始寫 Django ORM 時，疑問最多的就是外鍵關聯了！因為它不止重要，而且十分常用。外鍵關聯又分一對一、一對多（多對一）與多對多，我們會先著重在前兩者的介紹——因為它們最常遇到，方便你快速上手。</p><p><strong>本文為上篇，主要是系列前言與外鍵設定教學，查詢部分則留到下篇。</strong></p><h2 id="專案模型介紹"><a href="#專案模型介紹" class="headerlink" title="專案模型介紹"></a>專案模型介紹</h2><p>學習 Django 模型和外鍵關係的最佳方法，是透過具體的例子。在上述專案中，我準備了一個最常見的範例：<a href="https://github.com/kyomind/kyo-django-tutorial/blob/01-django-models/post/models.py">文章模型</a>。</p><p>選這個例子主要出於兩個原因：</p><ol><li>它很容易想像。</li><li>它同時包括了一對一、一對多、多對多等不同情境。</li></ol><p>模型對應的情境大致是這樣：你有一個個人的部落格網站，只有你可以發表文章，而讀者可以留言。</p><p>因為只有一個作者，也就是你，所以模型省略了作者的部分。這些設計都是為了方便介紹而已，不必對它們的真實性太過認真。</p><p>以下我們一一介紹這 3 個模型。</p><h3 id="Title：文章標題"><a href="#Title：文章標題" class="headerlink" title="Title：文章標題"></a>Title：文章標題</h3><p>通常標題只會是文章模型的一個欄位，很少獨立出來。我這樣設計是為了呈現一對一關係，而且這裡有分主、副標題，多少為獨立出來增加了一些合理性。</p><h3 id="Post：文章"><a href="#Post：文章" class="headerlink" title="Post：文章"></a>Post：文章</h3><p>最主要的模型，其餘兩個模型都和它有關。</p><p>與標題是一對一關係，直接有一個<code>title</code>外鍵欄位關聯到 Title 模型，另一個欄位則是<code>content</code>。</p><h3 id="Comment：留言"><a href="#Comment：留言" class="headerlink" title="Comment：留言"></a>Comment：留言</h3><p>用來說明對一多關係的模型，有一個外鍵欄位<code>post</code>關聯到 Post。對 Post 來說，則會產生一個「<strong>反向關聯</strong>（<a href="https://allwin-raju-12.medium.com/reverse-relationship-in-django-f016d34e2c68">reverse relationship</a>）」屬性，下面會詳細介紹。</p><p>三者的關係可以畫成簡單的<strong>實體關聯圖</strong>（Entity Relationship Diagram，簡稱 <strong>ERD</strong>），如下：</p><p><img src="https://i.imgur.com/5qO8q8E.png"></p><p>Django 會自動幫你在外鍵屬性名稱加上<code>_id</code>，轉換成 db 中 table 欄位的名稱，所以上面圖中的欄位名稱是<code>title_id</code>與<code>post_id</code>。</p><hr><h2 id="在-Model-中建立外鍵欄位"><a href="#在-Model-中建立外鍵欄位" class="headerlink" title="在 Model 中建立外鍵欄位"></a>在 Model 中建立外鍵欄位</h2><p>我們知道，ORM 所對應的 table 欄位，都是用 Python 類別中的類別屬性來定義與規範的。而 db 欄位的 schema 則對應 model 屬性的「參數」。</p><p>尤其是外鍵屬性，因為要建立關聯，使用的參數通常比較多，格式上也和一般欄位屬性有所差別。</p><p>無論如何，了解外鍵欄位常用的參數與其代表的意義，相當必要，這也是本篇的重心。</p><p>以下介紹一對一和一對多的外鍵關聯設定，讀者可適時參考深獲開發者好評的 <a href="https://docs.djangoproject.com/en/4.2/">Django 文件</a>，我們只就重點進行說明。</p><h2 id="一對一關係"><a href="#一對一關係" class="headerlink" title="一對一關係"></a>一對一關係</h2><p>參考<code>OneToOneField</code>的<a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#onetoonefield">文件</a>，有兩個必填的<strong>位置參數</strong>，即<code>to</code>和<code>on_delete</code>。</p><p>先看一下專案中存在一對一關係的兩個 model（為了網頁呈現，我縮減了單行字元上限與空行數、省略了無關部分，所以和原始碼有所不同）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Title</span>(models.Model):</span><br><span class="line">    main = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    subtitle = models.CharField(max_length=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><code>OneToOneField</code>即外鍵中的一對一關係欄位，第一個參數是<code>to</code>，為目標關聯的 model，有兩種格式：</p><ol><li>model class 本身。</li><li>字串。用於無法直接引用的情境，比如本例中的 title 欄位，Title 類別定義在 Post 之後。</li></ol><p>第二個參數是<code>on_delete</code>，用來定義「關聯物件被刪除時」當前物件該如何處理的行為。有多揰模式，最常用的不外乎<code>CASCADE</code>、<code>PROTECT</code>、<code>SET_NULL</code>這 3 種，其餘所有選項與行為定義，可以參考<a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.CASCADE">文件</a>。</p><p>除了<code>to</code>和<code>on_delete</code>兩個必要參數，剩下的都是 optional，不過還有一個參數也非常重要，那就是<code>related_name</code>。</p><h2 id="related-name-與反向關聯"><a href="#related-name-與反向關聯" class="headerlink" title="related_name 與反向關聯"></a>related_name 與反向關聯</h2><p><code>related_name</code>用於指定關聯<strong>目標 model</strong>（本例為 Title）的「反向關聯」<strong>屬性名稱</strong>。這個屬性對查詢很實用，所以<code>related_name</code>也是外鍵屬性中重要的參數之一。</p><p>我們從 model 角度來看外鍵建立後的效果，以及<code>related_name</code>所扮演的角色。</p><h3 id="Post-角度"><a href="#Post-角度" class="headerlink" title="Post 角度"></a>Post 角度</h3><p>Post 有一個屬性為<code>title</code>，也就是我們所建立的外鍵，這個屬性在 model 中是明示的，意味著它在 db table 中也會有對應的欄位——<code>title_id</code>。其中<code>_id</code>是 Django 幫你加的，你可以透過<code>class Meta</code>自行定義這個欄位的名稱。</p><p>事實上，建立關聯不一定只能指向目標 model 的「主鍵」，只要是 model 中的  unique 欄位都可以，可參考 <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey.to_field">to_field 文件</a>。</p><h3 id="Title-角度"><a href="#Title-角度" class="headerlink" title="Title 角度"></a>Title 角度</h3><p>一對一關係建立後，對 Title model 或它的實例而言，它得到了什麼？——反向關聯屬性。</p><p>這個屬性在 model 中沒有明示，你從 model 中看不出 Title 有什麼屬性可以指向 Post。但實際上 Title 確實有一個反向關聯屬性指向 Post。</p><p>這就是反向關聯的特性，它是「<strong>隱式</strong>」的，這個屬性確實存在。而<strong>反向關聯屬性的名稱就是前述</strong><code>related_name</code><strong>所定義的名稱</strong>，即<code>post</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> title = models.OneToOneField(</span><br><span class="line">     <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure><p>所以，Title 的所有實例，比如有一個實例叫<code>title_1</code>，一定會有一個<strong>反向關聯屬性</strong><code>post</code>，而它的返回值依不同情況有兩種可能：</p><ol><li><code>title_1</code>已經被關聯到某個 Post 實例比如<code>post_1</code>，那<code>title_1.post</code>的值就是該<code>post_1</code>實例。</li><li><code>RelatedObjectDoesNotExist</code>物件。當<strong>實例之間的關聯還不存在</strong>，試圖取得關聯實例將會出現這樣的錯誤。</li></ol><p>附帶一提，<code>RelatedObjectDoesNotExist</code>其實就是<code>ObjectDoesNotExist</code>的子類別。所以如果你想要捕捉它，直接使用常見的<code>ObjectDoesNotExist</code>即可。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    title_1.post</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><h3 id="反向關聯屬性"><a href="#反向關聯屬性" class="headerlink" title="反向關聯屬性"></a>反向關聯屬性</h3><p>上述<code>post</code>屬性並未在 model class 中明示（但物件有此屬性），資料表中也<strong>不存在相對應的欄位</strong>。它本質上只是一個「<strong>ORM 查詢捷徑</strong>」——但非常實用。</p><p>這種隱式的設計讓我們<strong>更容易識別</strong>在外鍵關係中，哪些屬性是<strong>正向關聯</strong>，哪些則是<strong>反向關聯</strong>。</p><p>反向關聯允許我們透過簡單的<strong>屬性呼叫</strong>，就能夠輕鬆地獲取相關資料，而不需要額外的操作和查詢語句。</p><hr><h2 id="一對多關係"><a href="#一對多關係" class="headerlink" title="一對多關係"></a>一對多關係</h2><blockquote><p>class <code>ForeignKey</code>(to, on_delete, **<strong>options</strong>) <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey">¶</a></p></blockquote><blockquote><p>A <strong>many-to-one</strong> relationship. <strong>Requires two positional arguments</strong>: the class to which the model is related and the <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey.on_delete"><code>on_delete</code></a> option.</p></blockquote><p>我們在前述一對一關係費了很大的功夫將關聯的細節詳加說明，有了上述基礎，理解一對多關係也會容易得多。</p><p>Django 稱<code>ForeignKey</code>為「<strong>many-to-one</strong>」，即多對一關係，從 model 角度看，確實更合理。因為建立這個<code>ForeignKey</code>屬性的 model，必然屬於關係中的「<strong>多方</strong>」。所以是「多對一」。</p><p>不過無論一對多或多對一，主要區別是視角不同，都是同一種關係。下面我還是用「一對多」這個詞進行說明。</p><p>我選擇先講一對一是因為它相對單純，不需要一次理解太多事情。而一對多（或多對一），即 Django 中的 ForeignKey，則有更多參數和變化，但我們依舊只關注其中最重要的部分。</p><h3 id="專案程式碼說明"><a href="#專案程式碼說明" class="headerlink" title="專案程式碼說明"></a>專案程式碼說明</h3><p>毫無疑問，文章和它的留言是一對多關係，一篇文章可以有「0 到多個」留言，注意這個 0 還滿重要的！這也是它和一對一關係很不同的地方。</p><p>回到程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 留言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br></pre></td></tr></table></figure><p>我們可以看到，Comment 有一個欄位叫<code>post</code>，是一個<code>ForeignKey</code>。這個<code>ForeignKey</code>欄位，最常用的參數還是那 3 個，前 2 個前面已經有介紹，在此不贅。</p><p>第 3 個參數仍是<code>related_name</code>，但它的引數值<code>&#39;comments&#39;</code>看起來，和一對一的<code>related_name</code>在命名上有所不同——它是複數！</p><h2 id="related-name-在一對多關係中的重點"><a href="#related-name-在一對多關係中的重點" class="headerlink" title="related_name 在一對多關係中的重點"></a>related_name 在一對多關係中的重點</h2><p>前提已經提過，<code>related_name</code>實際上是為「反向關聯屬性」進行命名。</p><p><code>post</code>屬性的<code>related_name=&#39;comments&#39;</code>意味著，Post model 將得到一個名為「comments」反向關聯屬性。</p><p>一個 Post 實例，假設為<code>post_1</code>，可以透過<code>post_1.comments</code>取得所有和它關聯的 Comment 實例。可能有 1 個、多個，甚至沒有。</p><blockquote><p>這裡有一個細節是，<code>post_1.comments</code>只會先取得「<a href="https://docs.djangoproject.com/en/4.2/ref/models/relations/#django.db.models.fields.related.RelatedManager">關係管理器</a>」物件，再透過該物件取得「由 Comment 關聯實例組成的<code>QuerySet</code>」，比如：<code>post_1.comments.all()</code>。</p></blockquote><p>這和一對一關係中，你呼叫反向關聯屬性時，可能得到一個<strong>關聯實例</strong>或拋出<code>RelatedObjectDoesNotExist</code>有明顯不同。</p><h3 id="related-name-的預設名稱"><a href="#related-name-的預設名稱" class="headerlink" title="related_name 的預設名稱"></a>related_name 的預設名稱</h3><p>如果你在建立欄位時沒有給定<code>related_name</code>引數，那 Django 會自動給你預設名稱。</p><p>在一對一中，預設名稱為外鍵欄位所屬 Model 名稱的小寫。</p><p>參考 Post 的一對一外鍵程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>related_name</code>的預設值就是 Post 的小寫——<code>post</code>。顯然我定義的其實就是預設值而已。一對一時，是否定義<code>related_name</code>影響不大，<strong>因為它的預設值往往就已足夠</strong>。</p><p>在一對多，預設名稱為外鍵欄位所屬 Model 名稱的小寫再加上<code>_set</code>後綴。你可能就未必喜歡這樣的命名了。</p><p>一樣看一下相關程式片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果沒有定義<code>related_name</code>，則被關聯的 Post 將獲得 Django 預設的反向關聯屬性名稱「<code>comment_set</code>」。</p><p>無論是自定義的<code>comments</code>或預設的<code>comment_set</code>，都表達它的內涵是一個「複數」，這是一對多的特色（多對多也是如此）。</p><h2 id="良好的-related-name-命名"><a href="#良好的-related-name-命名" class="headerlink" title="良好的 related_name 命名"></a>良好的 related_name 命名</h2><p>實務中，把這個<code>related_name</code>命名好還是很重要的，雖然大部分時候用單純的複數就可以搞定，就像上面的<code>comments</code>，但為了<strong>增進程式的可讀性</strong>，也有需要你花費巧思的時候。</p><p>比如，任何專案都需要有憑證才能被存取，而一個憑證可以讓多個專案共用，此時我們可能會這樣設計：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Project</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    certificate = models.ForeignKey(<span class="string">&#x27;Certificate&#x27;</span>,</span><br><span class="line">                                    on_delete=models.PROTECT,</span><br><span class="line">                                    related_name=<span class="string">&#x27;used_by_projects&#x27;</span>)</span><br></pre></td></tr></table></figure><p>這裡的 related_name 不再用死板板的<code>projects</code>來命名，因為當你透過<code>Certificate</code>物件要訪問「<strong>所有使用該憑證的專案</strong>」時，<code>certificate.used_by_projects</code>顯然會比<code>certificate.projects</code><strong>更具描述性</strong>——尤其在<code>Certificate</code>還有<strong>更多其它關聯</strong>的時候，太多<code>certificate.XXXs</code>容易讓人混淆。</p><p>簡言之，<code>used_by_projects</code>命名<strong>讓程式更可讀</strong>，讓你一看就知道這個<code>related_name</code>的意義與用途。</p><hr><h2 id="小結：關聯是-model-核心"><a href="#小結：關聯是-model-核心" class="headerlink" title="小結：關聯是 model 核心"></a>小結：關聯是 model 核心</h2><p>耗費了如此多的幅篇，詳細講述關聯設定，都是為了強調一個重點：關聯是 Django ORM 的核心之一。</p><p>通過關聯，我們能夠模擬真實世界中的關係，使資料表之間建立起有意義的連結。</p><p>了解一對一和一對多的關聯設定，以及反向關聯屬性的使用，我們能夠更好地應用 Django ORM，建構出高效且具有關聯性的資料模型。</p><p>而辛苦建立這些模型與關聯，就是為了能夠充分利用它們！</p><p>下篇文章將探討，如何有效對這些關聯模型進行查詢，輕鬆地從模型中檢索和篩選所需的資料。</p><p>請敬期待。</p>]]></content>
    
    
    <summary type="html">&lt;!-- ![by Léo Alexandre](https://i.imgur.com/yK0Us6a.jpg) --&gt;
&lt;!-- ![](https://i.imgur.com/TBQKYrC.png) --&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;github.com/kyomind/kyo-django-tutorial&quot;&gt;&lt;/p&gt;
&lt;p&gt;工作上使用 Django 近 2 年，卻很少發表關於 Django 主題的文章，是時候該來補一補了。&lt;/p&gt;
&lt;p&gt;那就從 Django ORM 開始吧！因為 ORM（&lt;a href=&quot;https://docs.djangoproject.com/en/4.2/topics/db/models/&quot;&gt;Django Models&lt;/a&gt;）可以說是無論你怎麼使用 Django（全端或前後端分離），都不得不學的核心部分。&lt;/p&gt;
&lt;p&gt;怎麼說？我們先來看看，在「&lt;strong&gt;前後端分離&lt;/strong&gt;」的開發趨勢下，Django 的三大核心——MTV——的重要性有哪些變動。&lt;/p&gt;</summary>
    
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="ORM" scheme="https://blog.kyomind.tw/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>19，AI 時代的生存指南（二）數位斷捨離</title>
    <link href="https://blog.kyomind.tw/weekly-review-19/"/>
    <id>https://blog.kyomind.tw/weekly-review-19/</id>
    <published>2023-06-10T11:27:31.000Z</published>
    <updated>2023-08-31T06:59:32.099Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/mmEzb21.png"></p><p>上一篇〈<a href="https://blog.kyomind.tw/weekly-review-17/">17，AI 時代的生存指南（一）我對 AI 工具的投入與觀望</a>〉並沒有真正進入「生存指南」這個核心主題，只能算是整個系列的前言。</p><p>為避免你忘記，我們再來回顧一下，前一篇所提出的，本系列的宗旨：</p><blockquote><p>我期望這系列和一般談論 AI 文章的一個核心差別是：<strong>它們主要用來「降低」AI 資訊焦慮，而非增加。</strong></p></blockquote><blockquote><p>更具體地說，這個系列是「<strong>我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄</strong>」，這樣才有趣。</p></blockquote><p>而本篇要探討的，就是這系列最核心的「生存手段」：數位斷捨離。</p><p>數位斷捨離（Digital Declutter）作家卡爾．紐波特（Cal Newport）在其著作《<a href="https://www.books.com.tw/products/0010843512">深度數位大掃除</a>》一書中所提出。</p><p>數位斷捨離是一種整理和簡化數位世界的方法，旨在<strong>減少干擾並提升專注力</strong>。通過過濾數位訊息和限制使用數位工具（尤其是社交平台），我們可以節省時間和精力，更好地專注於重要的事情。</p><p>這種方法有助於建立一個更有意義和平衡的數位生活。所以它不止是方法，也是一種「<strong>價值觀與實踐</strong>」。</p><p>概念理解上沒什麼困難，但實踐起來可遠遠不是如此。</p><span id="more"></span><h2 id="本文重點"><a href="#本文重點" class="headerlink" title="本文重點"></a>本文重點</h2><p>這篇文章不會有太多關於「數位斷捨離」的做法與細節討論。而是<strong>試圖推論與強調，它在 AI 時代的重要性，以及在現實世界中所面臨的困難。</strong></p><p>此外，我並非「<a href="https://zh.wikipedia.org/zh-tw/%E6%A5%B5%E7%B0%A1%E4%B8%BB%E7%BE%A9">極簡主義</a>」愛好者，而是屬於「<a href="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/">簡潔主義</a>」的信徒。雖然它們都有一個「簡」字，但後者更強調「<strong>過猶不及、適可而止</strong>」的精神——更重視「<strong>均衡</strong>」。</p><p>理解了上述前提後，讓我們進入正文。</p><hr><h2 id="我的兩篇《深度數位大掃除》心得"><a href="#我的兩篇《深度數位大掃除》心得" class="headerlink" title="我的兩篇《深度數位大掃除》心得"></a>我的兩篇《深度數位大掃除》心得</h2><p>早在 3 年前，還在 <a href="https://medium.com/">Medium</a> 平台創作時期，我就寫過關於《深度數位大掃除》一書的「實踐心得」，即<strong>個人版的數位斷捨離</strong>，前後總共 2 篇：</p><ol><li><a href="https://medium.com/code-and-me/my-digital-declutter-216d472f8251">每天都是一種練習：我的數位斷捨離</a></li><li><a href="https://medium.com/code-and-me/31%E5%A4%A9-%E6%88%91%E7%9A%84%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2%E5%BF%83%E5%BE%97-51289e99ff96">31天：我的數位斷捨離心得</a></li></ol><p>這是個有趣的嘗試，尤其讓我印象深刻的，是第二篇中的這段與這個規則：</p><ul><li><strong>在捷運或公車的「刷卡範圍」內，不得使用手機通話以外的功能</strong></li></ul><blockquote><p>簡單講就是不能滑手機，而且也不能聽音樂。</p></blockquote><blockquote><p>這是一條我無法明確告訴你為什麼值得這麼做，但實踐後仍然建議你嘗試看看的規則。</p></blockquote><blockquote><p>如果真的需要一個理由，或許可以說，在這個我們都自願或被迫保持「連線狀態」的智慧手機時代。在一個人坐捷運無聊難耐，讓你有充分的動機與理由拿出手機消磨（或善加利用）的時候，你卻沒有這麼做，這是沉默而自覺的戰鬥。</p></blockquote><blockquote><p>你靜靜地坐著或站著，看著周圍的人，沉浸在網路的世界裡。而至少在此刻，你選擇不要這麼做。</p></blockquote><p>真的，那幾個月，我上下班坐捷運時，就是這樣傻傻地看著別人滑手機，心癢難耐，甚至不禁想問：「為什麼要制定這種規則來為難自己？我得到了什麼？」</p><p>「我得到了什麼？」不是一個容易回答的問題——因為它的好處並非立竿見影。這也是為何「數位斷捨離」通常很難持續。</p><p>網路上你可以找到不少實踐心得，遵從書中的建議，貫徹為期 1 個月的數位斷捨離。但你很難找到持續超過 3 個月甚至半年的實踐心得，連我自己，最後也大概只堅持了 3 個月，就差不多「<strong>打回原形</strong>」了。</p><h2 id="數位斷捨離常常只是一場短暫的狂歡"><a href="#數位斷捨離常常只是一場短暫的狂歡" class="headerlink" title="數位斷捨離常常只是一場短暫的狂歡"></a>數位斷捨離常常只是一場短暫的狂歡</h2><p>用「<strong>狂歡</strong>」來形容<strong>充滿限制且帶有自律意味</strong>的數位斷捨離，可能有點詭異，卻也不失真實，為什麼？</p><p>因為它富含一種「我將擺脫數位工具成癮並重獲新生」的<strong>期待</strong>。和一般狂歡通常以大鳴大放的形式不同，這種期待蘊含了一股內持、蓄勢待發的力量。它暗潮湧動，使人從情感上，<strong>將其視為達成目標和恢復精神自由的萬靈藥</strong>。</p><p>因此，在實踐數位斷捨離的初期，雖然辛苦，但我們會暫時感到一陣<strong>自由和解脫</strong>。儘管這種過程伴隨著一定的自我限制，但也對於能夠重新獲得對自己時間和注意力的<strong>掌控感</strong>到興奮甚至滿足。</p><p>這類「狂歡」形式雖然不常見，但它真實地反映了我們對於解放自己的數位束縛的期待與渴望。</p><p>我承認這種感覺確實「很好」，但這樣的動機是<strong>不健康</strong>的，因為它和所有的狂歡一樣，都有一個<strong>「致命問題」——很難持續。</strong></p><h2 id="為什麼數位斷捨離很難超過-3-個月？"><a href="#為什麼數位斷捨離很難超過-3-個月？" class="headerlink" title="為什麼數位斷捨離很難超過 3 個月？"></a>為什麼數位斷捨離很難超過 3 個月？</h2><p>把數位斷捨離當成是一場狂歡、救贖，或所謂的「數位排毒」，往往註定要失敗。</p><p>試想，數位斷捨離所要對抗的，都是什麼樣的洪水猛獸？</p><p>沒錯，就是那些精心設計，讓你容易非常數位成癮的社交平台與內容平台，比如臉書、Instagram、YouTube、TikTok……等等。</p><p>最關鍵的是，獲取它們的門檻可謂低之又低，近在眼前，唾手可得。因此，社交平台和內容平台所提供的即時滿足感和快樂，往往讓人很難抗拒。</p><h3 id="長路漫漫的數位斷捨離"><a href="#長路漫漫的數位斷捨離" class="headerlink" title="長路漫漫的數位斷捨離"></a>長路漫漫的數位斷捨離</h3><p>相較之下，數位斷捨離就不那麼討喜。它要你自制、找尋替代活動（書中稱之為「<strong>優質的休閒活動</strong>」），還要反思數位工具你對的意義。</p><p>要求還真多。</p><p>前期，你確實可以藉由上述的「<strong>期待</strong>」來支持，但這樣的期待也是種<strong>有限資源</strong>。把數位斷捨離當作是一種「<strong>自我救贖</strong>」，確實可以成為堅持的動力——最多持續 1 個月。</p><p>1 個月以後，期待帶來的初始動力散去，我們就很容易陷入「<strong>我得到了什麼？</strong>」茫然。</p><h3 id="數位斷捨離的意義與價值"><a href="#數位斷捨離的意義與價值" class="headerlink" title="數位斷捨離的意義與價值"></a>數位斷捨離的意義與價值</h3><p>如果「我得到了什麼？」的答案，對你來說<strong>還不夠清晰</strong>，那麼<strong>放棄</strong>恐怕是<strong>遲早的事情</strong>，因為回到原點比茫然堅持，可要容易得太多。</p><p>然而，我更想<strong>強調</strong>：這個問題的答案，<strong>幾乎不可能一開始就很清晰</strong>。因為，數位斷捨離的意義，往往是需要你<strong>透過實踐</strong>才能<strong>慢慢體會</strong>的。</p><p>不止實踐，你還需要<strong>時間</strong>與<strong>自我理解</strong>。</p><p>所以我們可以看到，網路確實上有不少篇心得，講述自己如何實踐了為期 30 天的數位斷捨離，那感覺，是多麼地讓人神清氣爽、重獲新生。</p><p><strong>然後，就沒有然後了。</strong></p><hr><h2 id="我為何重拾數位斷捨離？"><a href="#我為何重拾數位斷捨離？" class="headerlink" title="我為何重拾數位斷捨離？"></a>我為何重拾數位斷捨離？</h2><p>說了那麼多，都是在唱衰數位斷捨離，難道真的沒救了嗎？</p><p>我想其中的奇妙之處正在於，本來我也覺得「算了，就這樣吧！要持續貫徹，需要長期的嘗試與不斷改善規則」。</p><p>對我來說這也不是不可能，作為曾經全職準備國考與軟體工程師轉職的人（就是待業時間很長的意思），有很多「建立個人長期制度」的經驗（包括很多失敗經驗），我知道怎麼做能更接近「<strong>可持續性</strong>」。</p><p>換言之，我對一件事情「能否持續」的<strong>敏感度</strong>，還是比較高的。</p><p>所以我才會猶豫不前，因為我知道這件事的難度。</p><h3 id="值得嗎？"><a href="#值得嗎？" class="headerlink" title="值得嗎？"></a>值得嗎？</h3><p>還是那個問題「值得嗎？」——這是個大哉問。</p><p>對我而言，以往是的答案是「<strong>我不確定</strong>」。而現在或許值得了，因為 AI 時代到來。</p><p>AI 帶給我的「<strong>資訊煩躁感（資訊焦慮）</strong>」，讓我感到「<strong>必須要做些什麼</strong>」應對。</p><p>這不是因為資訊量隨 AI 的爆發而再度遽增（我覺得這反而是相對無關緊要的部分），而是「<strong>做事的方法</strong>」因為 AI 而改變了。</p><p>所以，作為渺小的人類，對抗資訊焦慮的「<strong>防禦手段</strong>」也得跟著升級才行。那麼，什麼才是真正有效的手段？</p><p>思來想去，我最終的答案<strong>還是——數位斷捨離</strong>。</p><h2 id="內心的平靜"><a href="#內心的平靜" class="headerlink" title="內心的平靜"></a>內心的平靜</h2><p>說了那麼多，其實我們所求的，不過就是「<strong>內心的平靜</strong>」而已。</p><p>然而內心的平靜卻也是世上最易失又難得的珍貴體驗，我們只能一步一步靠近。</p><h3 id="目前的具體做法"><a href="#目前的具體做法" class="headerlink" title="目前的具體做法"></a>目前的具體做法</h3><p>一開始說不會講太多做法，但還是要提一下，才好想像我的數位斷捨離的具體內容。</p><p>目前我實踐中的數位斷捨離規則大致如下：</p><ol><li>每天早上 9 點到下午 6 點，不登入 Line 桌面版。</li><li>身體接觸床面時，存取手機不得超過一分鐘！（防止睡前滑手機行為）</li><li>半夜 1 點到早上 6 點，不聽任何多媒體的聲音。</li><li>河濱散步時，不存取、使用手機。（培養發散思維模式）</li><li>少用臉書。</li></ol><p>咦？怎麼沒有搭公車、捷運不能用手機那條？本來有的，但太難了，只好暫時捨棄🫡</p><p>規則的組成與細節，會一直變動，達到「有效且可持續」的部分，才會漸漸確定下來。</p><p>毫無疑問，這會是一個<strong>不算短的過程</strong>，1 個月是絕對不夠的。因為能堅持 1 個月的事，未必能堅持 3 個月。</p><hr><h2 id="結語：3-個月只是開端"><a href="#結語：3-個月只是開端" class="headerlink" title="結語：3 個月只是開端"></a>結語：3 個月只是開端</h2><p>1 個月也好，3 個月也罷，它們都只是漫長人生中的一小部分。僅僅在這麼短的時間內達成數位斷捨離，很難帶來本質上的改變。</p><p>數位斷捨離的目的不僅僅是在短期內達成某個特定的目標，而是<strong>要在局部，永久地建立有別於以往的生活方式。</strong></p><p>在開始之前，我們要先嚴肅地認知到：<strong>這真的很難</strong>——凡是改變都很難。</p><p>數位斷捨離是<strong>習慣的養成</strong>，從更高的角度看，更是一種「<strong>價值取捨</strong>」。</p><p>有些東西——哪怕是好東西——你必須<strong>捨棄</strong>，才能換得幾分<strong>心靈上的平靜</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mmEzb21.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-17/&quot;&gt;17，AI 時代的生存指南（一）我對 AI 工具的投入與觀望&lt;/a&gt;〉並沒有真正進入「生存指南」這個核心主題，只能算是整個系列的前言。&lt;/p&gt;
&lt;p&gt;為避免你忘記，我們再來回顧一下，前一篇所提出的，本系列的宗旨：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我期望這系列和一般談論 AI 文章的一個核心差別是：&lt;strong&gt;它們主要用來「降低」AI 資訊焦慮，而非增加。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;更具體地說，這個系列是「&lt;strong&gt;我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄&lt;/strong&gt;」，這樣才有趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而本篇要探討的，就是這系列最核心的「生存手段」：數位斷捨離。&lt;/p&gt;
&lt;p&gt;數位斷捨離（Digital Declutter）作家卡爾．紐波特（Cal Newport）在其著作《&lt;a href=&quot;https://www.books.com.tw/products/0010843512&quot;&gt;深度數位大掃除&lt;/a&gt;》一書中所提出。&lt;/p&gt;
&lt;p&gt;數位斷捨離是一種整理和簡化數位世界的方法，旨在&lt;strong&gt;減少干擾並提升專注力&lt;/strong&gt;。通過過濾數位訊息和限制使用數位工具（尤其是社交平台），我們可以節省時間和精力，更好地專注於重要的事情。&lt;/p&gt;
&lt;p&gt;這種方法有助於建立一個更有意義和平衡的數位生活。所以它不止是方法，也是一種「&lt;strong&gt;價值觀與實踐&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;概念理解上沒什麼困難，但實踐起來可遠遠不是如此。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="簡潔主義" scheme="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/"/>
    
    <category term="資訊焦慮" scheme="https://blog.kyomind.tw/tags/%E8%B3%87%E8%A8%8A%E7%84%A6%E6%85%AE/"/>
    
    <category term="數位斷捨離" scheme="https://blog.kyomind.tw/tags/%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
  </entry>
  
</feed>
