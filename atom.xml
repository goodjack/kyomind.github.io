<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-04-20T04:41:54.048Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python API 開發：善用 Enum 的三大關鍵特性</title>
    <link href="https://blog.kyomind.tw/python-enum/"/>
    <id>https://blog.kyomind.tw/python-enum/</id>
    <published>2024-04-19T09:11:47.000Z</published>
    <updated>2024-04-20T04:41:54.048Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5lvKO0a.jpeg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>想必你知道 Python 中有一個內建的特殊類別叫 <a href="https://docs.python.org/zh-tw/3.12/library/enum.html#enum.Enum">Enum</a>（來自 <a href="https://docs.python.org/zh-tw/3.12/library/enum.html">enum</a> 模組），專門用來處理「列舉」態型的資料集合。</p><p>如同 <a href="https://docs.python.org/zh-tw/3/library/collections.html">collection</a> 模組中的各種容器（比如：<a href="https://docs.python.org/zh-tw/3/library/collections.html#collections.deque"><code>deque</code></a>、<a href="https://docs.python.org/zh-tw/3/library/collections.html#collections.Counter"><code>Counter</code></a>），Enum 已經定義好很多「<strong>內建特性（屬性、方法、行為）</strong>」供你使用。這些特性會讓你在<strong>處理特定情境</strong>時非常順手。</p><p>但是，這些特性也使得 Enum 類別與一般類別<strong>有著很大的差異，增加了學習門檻</strong>。</p><p>如你所見，Enum 的特性頗多，這讓人在學習、使用之前，難免有點<strong>望之卻步</strong>——至少我是這樣！</p><h2 id="本文主旨與架構"><a href="#本文主旨與架構" class="headerlink" title="本文主旨與架構"></a>本文主旨與架構</h2><p>本文分享我最近才開始把 Enum 應用在 API 開發中的經驗——從它的三大特性入手，並輔以一個實際問題情境。</p><p>Enum 的特性不少，但只要知曉這三件事，就可以在遇到「列舉」欄位時，善用 Enum 來提升開發效率，同時增進程式碼的簡潔與穩健。</p><p>不過話說回來，即使不是開發 API，也不影響你對本文的理解。只是我的經驗是從後端開發而來。</p><h3 id="本文架構"><a href="#本文架構" class="headerlink" title="本文架構"></a>本文架構</h3><p>為了讓你感受 Enum 的強大與美妙，<strong>本文的架構經過精心設計。</strong></p><p>我會先提出一個<strong>問題情境</strong>，然後再介紹 Enum 的<strong>三大特性</strong>，最後看看 Enum 的特性在問題情境中<strong>如何有效發揮</strong>，讓程式碼變得更加優雅。</p><p>也就是它<strong>解決了什麼痛點！</strong></p><p>藉由這個流程，相信你對 Enum 會有更進一步的理解。</p><span id="more"></span><hr><p>我們先從的問題情境開始。</p><h2 id="問題情境"><a href="#問題情境" class="headerlink" title="問題情境"></a>問題情境</h2><p>為了有效講解，舉個<strong>實例</strong>是必要的，但我會<strong>盡可能簡化</strong>，著眼於能夠彰顯 Enum 價值的部分。</p><p>作為一個 Django API 開發者，不管是什麼專案，幾乎都會出現「列舉型」資料。此時 Django ORM 中對應的就是「<a href="https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.Field.choices">choices</a>」欄位。</p><p>假設我們現在要開發一個 Docker 相關的服務（這是我實際遇到的情境），其中一個 API 是「新增容器」。而容器有一個需要使用者輸入的設定是：restart policy。</p><p>從官方文件可知，Docker 容器的 restart policy <a href="https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy">總共就只有 4 種而已</a>——沒錯，它屬於<strong>列舉型資料</strong>！</p><h3 id="Django-Model-欄位設計"><a href="#Django-Model-欄位設計" class="headerlink" title="Django Model 欄位設計"></a>Django Model 欄位設計</h3><p>此時，我們的 Django model 欄位會長這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    RESTART_POLICIES = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&#x27;always&#x27;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&#x27;unless-stopped&#x27;</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="string">&#x27;on-failure&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    restart_policy = models.PositiveSmallIntegerField(</span><br><span class="line">        choices=RESTART_POLICIES, default=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>為了方便講解與避免混淆，這裡我採用了「數字（0-3）」作為列舉成員。但實際工作中，我使用的是「字串」，也就是<code>&#39;no&#39;</code>、<code>&#39;always&#39;</code>等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    RESTART_POLICIES = (</span><br><span class="line">        (<span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;no&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;always&#x27;</span>, <span class="string">&#x27;always&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;unless-stopped&#x27;</span>, <span class="string">&#x27;unless-stopped&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;on-failure&#x27;</span>, <span class="string">&#x27;on-failure&#x27;</span>),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>這是一個<strong>重要的細節</strong>，以後會另篇討論：什麼時候列舉成員應該用數字，而什麼時候用字串更好。</p><p>為了專注於對 Enum 的學習，這裡採最常見的「數字」版本。</p><hr><h2 id="以往的做法"><a href="#以往的做法" class="headerlink" title="以往的做法"></a>以往的做法</h2><p>以前用 DRF（<a href="https://www.django-rest-framework.org/">Django REST framework</a>）開發 API 列舉資料時，除了在 model 增加了上述的 choices 限制，我並沒有使用 Enum。</p><p>這裡有一個問題：那前端人員怎麼知道列舉的「成員」<strong>有幾個、有哪些？</strong>當然只能靠 API 文件！</p><p>以往我們都是用 <a href="https://apiblueprint.org/">API Blueprint</a> 寫 API 文件。說真的，我不喜歡，太多手刻細節了——難怪它的普及率也不高🙂‍↔️</p><p>雖然你在 codebase 中看不到 Enum 的身影，但是，為了增加<strong>程式碼可讀性</strong>，我們還會額外設計這樣的類別（這是為了後端開發者們在維護上的考慮）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如何使用這個類別？</p><p>一個典型的情境是，在 view 函式中<strong>將變數值與列舉成員進行比較</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> restart_policy == RestartPolicy.UNLESS_STOPPED</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>有了<code>RestartPolicy</code>，程式碼變得更加<strong>直觀</strong>，<strong>易讀</strong>。</p><p>換句話說，我們<strong>不會</strong>直接這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> restart_policy == <span class="number">2</span>  <span class="comment"># 咦，2 是什麼東西？</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><hr><h2 id="驗證列舉成員"><a href="#驗證列舉成員" class="headerlink" title="驗證列舉成員"></a>驗證列舉成員</h2><p>如果列舉資料只限於後端自行使用，那上述的寫法其實就足夠了。</p><p>但是，很多時候列舉資料是從<strong>前端（使用者輸入）</strong>來的。</p><p>此時你<strong>首先</strong>要驗證前端給的資料，<strong>是不是屬於這個列舉集合的成員</strong>！套用上面的寫法就會顯得囉嗦：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    RestartPolicy.NO,</span><br><span class="line">    RestartPolicy.ALWAYS,</span><br><span class="line">    RestartPolicy.UNLESS_STOPPED,</span><br><span class="line">    RestartPolicy.ON_FAILURE):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>為了不要讓程式這麼冗長，我們通常會幫這個類別加上一個簡單的<code>ALL</code>屬性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br><span class="line">    ALL = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>於是程式碼變成這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">not</span> <span class="keyword">in</span> RestartPolicy.ALL:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>好像還可以，不是嗎？——但這顯然<strong>不是最佳實踐</strong>。</p><p>雖然在這個例子中，restart policy 主要就這 4 種，而且也不太會變動。</p><p>但如果在別的列舉場合，偶爾甚至不時會增加成員時，我們的 ALL 屬性的值也要跟著修正，這會產生潛在的「同步」問題——<strong>忘記</strong>一併更新 ALL 屬性。</p><h3 id="使用序列化器驗證"><a href="#使用序列化器驗證" class="headerlink" title="使用序列化器驗證"></a>使用序列化器驗證</h3><p>話說回來，DRF 有<a href="https://www.django-rest-framework.org/api-guide/serializers/">序列化器模組</a>，作為驗證輸入資料正確性的手段。</p><p>只要你有寫序列化器，通常也不需要像上述程式碼一般手工驗證。</p><p>但畢竟寫序列化器需要一定的成本與維護，一些相對簡單的 POST API，你可能未必有相關的序列化器。</p><p>退萬步言，你就是要在某些自定義的邏輯進行手動驗證，上面的程式碼還是會出現。</p><h2 id="目前寫法的問題"><a href="#目前寫法的問題" class="headerlink" title="目前寫法的問題"></a>目前寫法的問題</h2><p>假設沒有序列化器輔助，要在程式碼中進行手工驗證，上述寫法有兩個不妥之處：</p><ol><li>要驗證 input 資料是否為合法列舉成員，太囉嗦、冗長了。</li><li>如果加上<code>ALL</code>這類自定義屬性，雖然可以減緩程式碼冗長問題，又產生了潛在的同步問題。</li></ol><p>事實上，即使沒有<code>ALL</code>屬性，<strong>第一種寫法一樣存在同步問題</strong>。因為你要<strong>手動</strong>維護這個驗證條件。</p><p><code>ALL</code>屬性只是把這個「<strong>新增、刪除列舉成員</strong>」的<strong>同步議題</strong>從 view 函式中（或任何其它用到的地方）抽離出來，統一移到類別中控管。</p><p>這或許可以算是一個<strong>改進</strong>：當情況變動時，需要跟著修改的地方<strong>只剩下一個</strong>——<code>ALL</code>本身。<strong>但依舊不是最佳解法。</strong></p><hr><h2 id="Python-Enum-三大特性"><a href="#Python-Enum-三大特性" class="headerlink" title="Python Enum 三大特性"></a>Python Enum 三大特性</h2><p>自從寫 <a href="https://django-ninja.dev/">Django Ninja</a> 後，為了渲染出嚴謹的 API 文件，我不得不用 Enum 了（可參考文章最後的<a href="/python-enum/#%E8%A3%9C%E5%85%85%EF%BC%9AEnum-%E9%A1%9E%E5%88%A5%E5%9C%A8-Django-Ninja-%E4%B8%AD%E7%9A%84%E6%87%89%E7%94%A8">補充</a>部分），同時也感受到了它的強大！</p><p>我們來看看，採用 Enum 之後會有什麼改變。</p><p>在此之前，我們要先介紹 Enum 中，<strong>我認為最重要的三大特性</strong>。至少在我的例子中，知道這三個特性會非常有用。</p><p>我們看一下加入了 Enum 後的類別模樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>我把<code>ALL</code>屬性移除了，因為它不再需要。</p><p>我們就以這個新類別為例，來看看 Enum 的三大特性。</p><hr><h2 id="一、Enum-類別可以用-for-迴圈迭代"><a href="#一、Enum-類別可以用-for-迴圈迭代" class="headerlink" title="一、Enum 類別可以用 for 迴圈迭代"></a>一、Enum 類別可以用 for 迴圈迭代</h2><p>一般的類別並不能以 for 迴圈迭代，因為沒有實作<code>__iter__</code>方法，但 Enum 有！</p><p>對於「列舉」這種有限成員的情況，能迭代它非常重要。</p><p>還記得原來的<code>ALL</code>屬性嗎？ <code>ALL = [0, 1, 2, 3]</code></p><p>這個<code>ALL</code>屬性的值，其實就是<strong>為了取得類別中的每一個屬性值</strong>。但有了 Enum，我們不用這麼麻煩了！</p><p>那我要怎麼取得 Enum 類別中的所有屬性值？這就要看下面第二個特性。</p><h2 id="二、了解-Enum-實例"><a href="#二、了解-Enum-實例" class="headerlink" title="二、了解 Enum 實例"></a>二、了解 Enum 實例</h2><p>這段特別長，因為它包含了<strong>三個子命題</strong>，都和 Enum 實例有關。</p><p>這裡要先問：<strong>如何取得 Enum 實例？</strong></p><h3 id="Enum-實例的建構與條件"><a href="#Enum-實例的建構與條件" class="headerlink" title="Enum 實例的建構與條件"></a>Enum 實例的建構與條件</h3><p>沒錯，和一般的類別相同，都是從建構與初始化開始，依舊使用上面的例子，我們可以像這樣獲得 Enum 實例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = RestartPolicy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>和一般類別不同的是，這裡的建構引數，<strong>只能是「Enum 任一成員的屬性值」。</strong></p><p>換句話說，<strong>所有 Enum 實例都是由 Enum 成員值（比如上述的 2）建構而來的</strong>。</p><p>此外，<strong>沒有引數也不行！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沒有引數會報錯</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy()</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">TypeError: EnumMeta.__call__() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure><p>而建構出的實例，就是<strong>「代表該成員」的 Enum 實例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>)</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Enum-類別屬性「就是」Enum-實例"><a href="#Enum-類別屬性「就是」Enum-實例" class="headerlink" title="Enum 類別屬性「就是」Enum 實例"></a>Enum 類別屬性「就是」Enum 實例</h2><blockquote><p><strong>這是 Enum 最重要的特性之一，也是最容易讓人困惑的地方。</strong></p></blockquote><p>除了透過建構，其實<strong>直接呼叫類別屬性</strong>，也能夠得到<strong>同一個</strong> Enum 成員實例！</p><p>這是一般類別所<strong>難以想像</strong>的，因為一般類別呼叫類別屬性後，只會得到單純的<strong>值</strong>，比如本文一開始的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這裡是非 Enum 版的 RestartPolicy</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>回到 Enum。換言之，下面兩種寫法，獲得的結果<strong>完全相同</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>)</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>不了解這個特性，會讓你對 Enum 的使用產生很大困惑。</strong></p><h3 id="單例模式"><a href="#單例模式" class="headerlink" title="單例模式"></a>單例模式</h3><p>更進一步說，Enum 類別的每一個成員實例，實際上都是<strong>單例</strong>。</p><p>這意味著對於每個成員，無論你在程式碼中呼叫多少次，<strong>都是指向「同一個」物件。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = RestartPolicy(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>p2 = RestartPolicy(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>p1 <span class="keyword">is</span> p2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) <span class="keyword">is</span> RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>了解這一點，就能夠更好地利用 Enum 來處理列舉資料。</p><hr><h2 id="Enum-實例的兩個屬性"><a href="#Enum-實例的兩個屬性" class="headerlink" title="Enum 實例的兩個屬性"></a>Enum 實例的兩個屬性</h2><p>所有 Enum 成員實例都有兩個內建的屬性：<code>name</code>與<code>value</code>。</p><p><code>name</code>是<strong>成員的名稱</strong>，也就是<strong>類別屬性名稱</strong>；<code>value</code>則是<strong>成員的值</strong>。</p><p>我們分別使用<strong>兩種不同的實例取得方式</strong>來呼叫這兩個屬性！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>).name</span><br><span class="line"><span class="string">&#x27;UNLESS_STOPPED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同於</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED.name</span><br><span class="line"><span class="string">&#x27;UNLESS_STOPPED&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED.value</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同於</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>).value</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>綜上所述，如果用 for 迴圈迭代<code>RestartPolicy</code>，你將得到（這裡使用<code>repr</code>突顯）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> RestartPolicy:</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="built_in">repr</span>(i))</span><br><span class="line"></span><br><span class="line">&lt;RestartPolicy.NO: <span class="number">0</span>&gt;</span><br><span class="line">&lt;RestartPolicy.ALWAYS: <span class="number">1</span>&gt;</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br><span class="line">&lt;RestartPolicy.ON_FAILURE: <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>得到<code>RestartPolicy</code>每一個成員實例。</strong></p><hr><h2 id="三、Enum-實例之間可以進行比較"><a href="#三、Enum-實例之間可以進行比較" class="headerlink" title="三、Enum 實例之間可以進行比較"></a>三、Enum 實例之間可以進行比較</h2><p>Enum 成員之間，支援身分比較（<code>is</code>）和等值（<code>==</code>）比較。</p><p>只不過，如前所述，每一個 Enum 成員都是「<strong>單例</strong>」。所以身分比較和等值比較對於 Enum 成員是<strong>等價</strong>的，因為每個成員都是<strong>唯一</strong>的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) == RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) <span class="keyword">is</span> RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>大部分時候，使用等值比較就已經足夠。</p><hr><h2 id="使用-Enum-改進！"><a href="#使用-Enum-改進！" class="headerlink" title="使用 Enum 改進！"></a>使用 Enum 改進！</h2><p>現在你對 Enum 的特性已經有了相當的了解。我們來看看原來的程式碼在使用 Enum 版本後，會發生什麼樣的變化。</p><p>回顧一下之前的問題：</p><ol><li>要驗證 input 資料是否為合法列舉成員，太囉嗦、冗長了。</li><li>如果加上<code>ALL</code>這類自定義屬性，雖然可以減緩程式碼冗長問題，又產生了潛在的同步問題。</li></ol><h3 id="對問題一的改善"><a href="#對問題一的改善" class="headerlink" title="對問題一的改善"></a>對問題一的改善</h3><p>現在，你想要驗證 input 值是否屬於列舉成員，可以這樣寫（我們假設 input 值為 2，代表<code>&#39;unless-stopped&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">in</span> [p.value <span class="keyword">for</span> p <span class="keyword">in</span> RestartPolicy]:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>因為 <code>RestartPolicy</code> 類別現在是可以用 <code>for</code> 迭代了！而每一個元素則是成員實例，需要透過<code>value</code>屬性取值，所以可以像上面那樣寫。</p><p>乍看之下，好像也沒有方便到哪去？確實如此😅，沒關係，我們還有<a href="#%E9%80%8F%E9%81%8E%E3%80%8C%E5%BB%BA%E7%AB%8B-Enum-%E5%AF%A6%E4%BE%8B%E3%80%8D%E9%80%B2%E8%A1%8C%E9%A9%97%E8%AD%89">後手</a>。</p><h3 id="Pydantic-預處理"><a href="#Pydantic-預處理" class="headerlink" title="Pydantic 預處理"></a>Pydantic 預處理</h3><p>如果你有用 Pydantic 對資料預處理（FastAPI、Django Ninja 等後端框架會自動做這件事），通常<code>payload.restart_policy</code>的值，就已經是一個 Enum 實例了。</p><blockquote><p>當然，如果有用 Pydantic 預處理，這個驗證根本不需要XD，這裡只是為了舉例。</p></blockquote><p>如此一來，驗證成員身分的寫法將<strong>異常簡單</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">in</span> RestartPolicy:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>對，就這麼簡單！</p><p>因為<code>in</code>運算子的內部，本來就會迭代後面接的物件了——所以<code>in</code>後面必須緊接一個 iterable，<strong>而 Enum 類別正是一個 iterable。</strong></p><hr><h2 id="透過「建立-Enum-實例」進行驗證"><a href="#透過「建立-Enum-實例」進行驗證" class="headerlink" title="透過「建立 Enum 實例」進行驗證"></a>透過「建立 Enum 實例」進行驗證</h2><p>但如果你的<code>payload.restart_policy</code>，就<strong>只是一般的值</strong>，而不是 Enum 成員。那該怎麼辦？難道真的要像上面那樣，寫落落長的<code>[p.value in p in RestartPolicy]</code>嗎？</p><p>當然不！其實做法一樣非常簡單，那就是「<strong>直接用這個值來建立實例</strong>」。</p><p><a href="#Enum-%E5%AF%A6%E4%BE%8B%E7%9A%84%E5%BB%BA%E6%A7%8B%E8%88%87%E6%A2%9D%E4%BB%B6">前面</a>說過，Enum 實例<strong>只能由 Enum 成員值建構而來</strong>。所以，如果你輸入的值不是<strong>合法</strong>的 Enum 成員，建構實例時就會拋出<code>ValueError</code>。</p><p>換句話說，<strong>只要能成功建立實例，就是合法的成員</strong>！所以你可以這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    RestartPolicy(payload.restart_policy)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果是不合法的，比如 4，則會拋出<code>ValueError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ValueError: <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid RestartPolicy</span><br></pre></td></tr></table></figure><p>總之，<strong>記得處理這個例外。</strong></p><h3 id="對問題二的改善"><a href="#對問題二的改善" class="headerlink" title="對問題二的改善"></a>對問題二的改善</h3><p>既然 Enum 類別本身就可以用 for 迭代以取得所有成員（甚至直接使用<code>in</code>運算子），那就<strong>完全沒必要</strong>再寫前面像<code>ALL</code>一樣的屬性，然後還要維護它。</p><p>由此可見，Enum 真的棒！</p><hr><h2 id="補充：Enum-類別在-Django-Ninja-中的應用"><a href="#補充：Enum-類別在-Django-Ninja-中的應用" class="headerlink" title="補充：Enum 類別在 Django Ninja 中的應用"></a>補充：Enum 類別在 Django Ninja 中的應用</h2><p>前面說到我會開始用 Enum，正是因為 Django Ninja。</p><p>Django Ninja 的 <a href="https://django-ninja.dev/guides/response/">Schema</a> 實際上就是 Pydantic 的 <a href="https://docs.pydantic.dev/latest/concepts/models/#validation">BaseModel</a>。</p><p>Schema 用來描述 API 輸入與輸出的資料結構。主要的功能有二：</p><ol><li><strong>驗證</strong>輸入資料是否符合規範。</li><li><strong>自動產生</strong> API 文件。</li></ol><p>我們看一下使用了 Enum 型別後的 Schema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateContainerRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    restart_policy: RestartPolicy</span><br></pre></td></tr></table></figure><p>直接將<code>restart_policy</code>欄位型別標記為<code>RestartPolicy</code>，如此渲染出的 API 文件，不止能限定輸入資料的型別，連「<strong>值域</strong>」也會有<strong>明確標示</strong>：</p><p><img src="https://i.imgur.com/A8RgBlS.png" alt="型別：integer；值域：僅限 0、1、2、3"><span class="cap">型別：integer；值域：僅限 0、1、2、3</span></p><p>甚至還能把<code>RestartPolicy</code>類別中的<code>docstring</code><strong>直接渲染成欄位說明</strong>，太貼心了吧！偉哉 Pydantic！</p><p>好處不止如此，一旦你<strong>變更</strong>了<code>RestartPolicy</code>的內容（比如<strong>增加了成員選項</strong>），API 文件也會<strong>自動更新</strong>。</p><p>不必再手動修改 API 文件，也不必修改 Schema 的 type hints，完全省去了「同步」的煩惱。</p><hr><p>除了上述的「<strong>數字列舉</strong>」版，我同時再附上「<strong>字串列舉</strong>」版本，看圖你應該就能理解，為何我一開始說，有時候列舉資料用字串會更好。</p><p><img src="https://i.imgur.com/9eCQcFB.png"></p><p>直接採用字串選項，對前端人員更加友善——<strong>更容易了解每個選項代表的意義。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5lvKO0a.jpeg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;想必你知道 Python 中有一個內建的特殊類別叫 &lt;a href=&quot;https://docs.python.org/zh-tw/3.12/library/enum.html#enum.Enum&quot;&gt;Enum&lt;/a&gt;（來自 &lt;a href=&quot;https://docs.python.org/zh-tw/3.12/library/enum.html&quot;&gt;enum&lt;/a&gt; 模組），專門用來處理「列舉」態型的資料集合。&lt;/p&gt;
&lt;p&gt;如同 &lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html&quot;&gt;collection&lt;/a&gt; 模組中的各種容器（比如：&lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html#collections.deque&quot;&gt;&lt;code&gt;deque&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt;），Enum 已經定義好很多「&lt;strong&gt;內建特性（屬性、方法、行為）&lt;/strong&gt;」供你使用。這些特性會讓你在&lt;strong&gt;處理特定情境&lt;/strong&gt;時非常順手。&lt;/p&gt;
&lt;p&gt;但是，這些特性也使得 Enum 類別與一般類別&lt;strong&gt;有著很大的差異，增加了學習門檻&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如你所見，Enum 的特性頗多，這讓人在學習、使用之前，難免有點&lt;strong&gt;望之卻步&lt;/strong&gt;——至少我是這樣！&lt;/p&gt;
&lt;h2 id=&quot;本文主旨與架構&quot;&gt;&lt;a href=&quot;#本文主旨與架構&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與架構&quot;&gt;&lt;/a&gt;本文主旨與架構&lt;/h2&gt;&lt;p&gt;本文分享我最近才開始把 Enum 應用在 API 開發中的經驗——從它的三大特性入手，並輔以一個實際問題情境。&lt;/p&gt;
&lt;p&gt;Enum 的特性不少，但只要知曉這三件事，就可以在遇到「列舉」欄位時，善用 Enum 來提升開發效率，同時增進程式碼的簡潔與穩健。&lt;/p&gt;
&lt;p&gt;不過話說回來，即使不是開發 API，也不影響你對本文的理解。只是我的經驗是從後端開發而來。&lt;/p&gt;
&lt;h3 id=&quot;本文架構&quot;&gt;&lt;a href=&quot;#本文架構&quot; class=&quot;headerlink&quot; title=&quot;本文架構&quot;&gt;&lt;/a&gt;本文架構&lt;/h3&gt;&lt;p&gt;為了讓你感受 Enum 的強大與美妙，&lt;strong&gt;本文的架構經過精心設計。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我會先提出一個&lt;strong&gt;問題情境&lt;/strong&gt;，然後再介紹 Enum 的&lt;strong&gt;三大特性&lt;/strong&gt;，最後看看 Enum 的特性在問題情境中&lt;strong&gt;如何有效發揮&lt;/strong&gt;，讓程式碼變得更加優雅。&lt;/p&gt;
&lt;p&gt;也就是它&lt;strong&gt;解決了什麼痛點！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;藉由這個流程，相信你對 Enum 會有更進一步的理解。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5lvKO0a.jpeg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Enum" scheme="https://blog.kyomind.tw/tags/Enum/"/>
    
    <category term="Pydantic" scheme="https://blog.kyomind.tw/tags/Pydantic/"/>
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>27，正式入手《流暢的 Python》第二版</title>
    <link href="https://blog.kyomind.tw/weekly-review-27/"/>
    <id>https://blog.kyomind.tw/weekly-review-27/</id>
    <published>2024-04-14T15:17:50.000Z</published>
    <updated>2024-04-15T01:20:54.993Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>Weekly Review 原則上著眼於「<strong>非程式類</strong>」內容，而這是一本程式相關的書，所以這期不會討論書中的技術細節，只聊聊<strong>我的主觀感受</strong>。</p><p>講它，是因為我對這本書的<strong>期待很高</strong>，它絕對有這個地位與份量，更別說它真的很厚！（量了一下有 5 公分厚，打算這星期拿去影印店<strong>拆成 3 本</strong>）</p><p>趁著清明連假的天瓏日（滿千折百活動），我總算入手了 Python 進階書籍中的口碑之作——《<a href="https://www.tenlong.com.tw/products/9786263246331">流暢的 Python</a>》，第二版。</p><p>還沒有開始讀，但先簡單分享一下<strong>我的看法與期待。</strong></p><span id="more"></span><h2 id="作為第一版讀者"><a href="#作為第一版讀者" class="headerlink" title="作為第一版讀者"></a>作為第一版讀者</h2><p>早在我開始 Python 軟體工程師職涯之前，即 2019 上半年準備轉職的期間，就讀過了《流暢的 Python》第一版——的一部分。</p><p>所以在面試 StreetVoice 寫程式測驗試題的時候（其中一題就是「以 mutable 資料作為函式參數預設值」的經典題目），立刻就想到了書中「幽靈公車」的例子。</p><p>不過，那時只讀了一部分，就早早束之高閣了。因為剩下部分對當時的我來說，還太過進階。</p><h2 id="2021-年，第二版消息與精讀計畫"><a href="#2021-年，第二版消息與精讀計畫" class="headerlink" title="2021 年，第二版消息與精讀計畫"></a>2021 年，第二版消息與精讀計畫</h2><p>2021，已經當了 2 年的 Python 工程師，這一年我總算把《流暢的 Python》讀完了。</p><p>但說真的，讀完也沒用。如果工作中用不到，這些東西，對我來說依舊是「書上的知識」，而不是我真實能力的一部分。</p><p>所以有點失落，不知該如何是好，想說是不是再認真細讀一次、兩次……結果下半年就得知了第二版正在撰寫中的消息。</p><p>喜新厭舊如我，自然不想再看舊書（以前對法律的參考書也是如此），想等中文版出了再說。於是這個「精讀」計畫就被無限期延後了。</p><h2 id="繁體中文版，正式出爐"><a href="#繁體中文版，正式出爐" class="headerlink" title="繁體中文版，正式出爐"></a>繁體中文版，正式出爐</h2><p>台灣中文版在英文出版後的一年內，遲遲沒有消息（我的判斷方式是繁中的第一版是否絕版不賣了），讓我不禁擔心：該不會不引進繁中版了吧？</p><p>還好，我想多了，應該只是第二版書更厚，翻譯花了更多時間而已。去年 10 月，本書的繁體中文版正式在台灣上市。</p><p><strong>但我並沒有在第一時間入手。</strong></p><h2 id="眾裡尋他千百度"><a href="#眾裡尋他千百度" class="headerlink" title="眾裡尋他千百度"></a>眾裡尋他千百度</h2><p>因為我不禁在想，是不是有「<strong>更好、更簡單</strong>」的選擇。</p><p>說來矛盾，明明是學 Python 的進階特性（也就是<strong>比較難</strong>的部分），我卻希望能「更簡單」。</p><p>但也不奇怪，這裡的更簡單，指的是「<strong>更容易上手、入門</strong>」——也就是<strong>更少痛苦</strong>。對於這些<strong>相對棘手</strong>的主題，我總是想找到一個「<strong>比較好啃</strong>」的方式。</p><p>所以我開始把期望寄託在其它書上，這些書本來就買了好多本，一直只是都沒讀！</p><p>所幸，過去一個多月的「<a href="https://www.facebook.com/kyomind/posts/pfbid02eQaYDFtE13cfsDofWPXZuiHjBuSqjr1nhBGiYpysGDktveGRiEVB9SxaKnJjy2zpl">圖書館時間</a>」，我基本把它們都翻完了。</p><p>並初步確認了每一本書對我的價值，以及後續還要投入多少時間。</p><h2 id="燈火闌珊處"><a href="#燈火闌珊處" class="headerlink" title="燈火闌珊處"></a>燈火闌珊處</h2><p>翻完這些書，我明白了一件事——《流暢的 Python》確實是最好的！</p><p>當然，無論《Python 精粹》或是《Python 神乎其技》，都有其可看之處。但《流暢的 Python》終歸還是 Python 進階書籍中的佼佼者。</p><p>正因為看過了其它書，所以我才更明白本書的精彩與不可取代。</p><p>前兩本書，我不會想從頭到尾精讀，但《流暢的 Python》有這個價值。</p><p>一言以蔽之，如果只打算好好讀一本 Python 進階書籍，就這本吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Weekly Review 原則上著眼於「&lt;strong&gt;非程式類&lt;/strong&gt;」內容，而這是一本程式相關的書，所以這期不會討論書中的技術細節，只聊聊&lt;strong&gt;我的主觀感受&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;講它，是因為我對這本書的&lt;strong&gt;期待很高&lt;/strong&gt;，它絕對有這個地位與份量，更別說它真的很厚！（量了一下有 5 公分厚，打算這星期拿去影印店&lt;strong&gt;拆成 3 本&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;趁著清明連假的天瓏日（滿千折百活動），我總算入手了 Python 進階書籍中的口碑之作——《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263246331&quot;&gt;流暢的 Python&lt;/a&gt;》，第二版。&lt;/p&gt;
&lt;p&gt;還沒有開始讀，但先簡單分享一下&lt;strong&gt;我的看法與期待。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>26，改用 Buttondown 作為文章訂閱服務</title>
    <link href="https://blog.kyomind.tw/weekly-review-26/"/>
    <id>https://blog.kyomind.tw/weekly-review-26/</id>
    <published>2024-04-10T14:22:04.000Z</published>
    <updated>2024-04-11T13:15:51.972Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>去年 2 月，部落格新增了「email 文章訂閱」功能，採用的方案是免費的 <a href="http://follow.it/">follow.it</a>。</p><p>它會把我的 RSS 新文章轉成 email，然後寄送給訂閱的讀者。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-12/">12，blog 新增文章訂閱功能——使用 follow.it</a></p></blockquote><p>如該篇中所言，「<strong>文章訂閱功能</strong>」確實是現代部落格的一大需求。</p><p>網路上的資訊眾多，我自己作為讀者，也常常感覺<strong>被淹沒</strong>。遇到一個喜歡的作者，想要追蹤，此時<strong>作者是否提供了訂閱功能，就至關重要。</strong></p><p>文章訂閱功能，可以由寫作平台提供，比如 Medium、Substack。不然就得自己來，因此我一開始就為 blog 提供了 RSS 訂閱。</p><p>但 RSS 畢竟不是一般人常用的資訊接收方式（<strong>我自己也不用</strong>），它只能滿足小眾人口的需求。所以最終我還是選擇了像 follow.it 這樣的「RSS to email」服務。</p><span id="more"></span><h2 id="為何選擇-follow-it"><a href="#為何選擇-follow-it" class="headerlink" title="為何選擇 follow.it"></a>為何選擇 follow.it</h2><p>用過電子報服務的都知道，這些服務<strong>真的不便宜！</strong></p><p>比如其中相對「高貴」的 ConvertKit，從它的 <a href="https://convertkit.com/pricing">pricing</a> 頁面可以看到，它的付費版僅僅 300 個訂戶，每月就要 9 美元！（而且這還是基於<strong>年繳</strong>的「優惠價」）</p><p>這也是為何很多人選擇在 Substack 上寫作，它對於需要發送「大量」電子報給讀者的創作者非常友好——<strong>不用錢。</strong></p><p>但我既已從 Medium 獨立，有了自己的 blog，自然不會再跑去 Substack 上寫作。選擇免費的 follow.it，也是情理之中。</p><blockquote><p>相關文章：</p><ul><li><a href="https://blog.kyomind.tw/my-own-blog-part-one/">我自架部落格的理由與選擇（上）理由篇</a></li><li><a href="https://blog.kyomind.tw/my-own-blog-part-two/">我自架部落格的理由與選擇（下）選擇篇</a></li></ul></blockquote><h2 id="改用-Buttondown"><a href="#改用-Buttondown" class="headerlink" title="改用 Buttondown"></a>改用 Buttondown</h2><p>一年過去，在佛系經營下（畢竟我的「電子報」就只是純粹的新文章通知，也不好意思鼓吹訂閱），訂戶也超過了 100 人，讓我不禁尋思更好的文章訂閱方案。</p><p>畢竟免費有一定<strong>代價</strong>，follow.it 的電子報會在你文章的開頭、結尾夾帶大量廣告。而且廣告的<strong>格調不高</strong>，讓人看了不禁有點<strong>傷眼</strong>🤡</p><p>那為何不一開始就採用電子報供應商的方案？主要有兩個原因：</p><ol><li>不是每家都有「RSS to email」功能，有提供這個功能的，都要花錢！</li><li>那時覺得 follow.it 就完全滿足我了。</li></ol><p>不過，此一時，彼一時。</p><p>就在今年 3 月上旬，我決定正式付費改用 <a href="https://buttondown.email/pricing">Buttondown</a>。</p><blockquote><p>如果你有興趣，可以考慮使用我的<a href="https://buttondown.email/refer/kyo">推薦連結</a>註冊。</p></blockquote><h2 id="為何選擇-Buttondown"><a href="#為何選擇-Buttondown" class="headerlink" title="為何選擇 Buttondown"></a>為何選擇 Buttondown</h2><p>知道它，以及決定選擇它，主要有兩個原因。</p><p>一方面，它是我有在 follow 的兩位作者都推薦過的電子報服務，可參考這兩篇文章：</p><ul><li><a href="https://vocus.cc/article/61a48a31fd89780001ed3b87">我念念不忘的電子報平台 Buttondown</a></li><li><a href="https://pinchlime.com/blog/first-impression-of-buttondown/">令人忍不住想掏錢支持的 Buttondown</a></li></ul><p>另一方面，以我預想的長期訂戶數量（5 年內不超過 1000 人）——也就是 1000 人以內，Buttondown 的價格<strong>還算是可接受的</strong>。</p><p>一年要價 90 美元（月付則是每個月 9 美元），雖然稱不上便宜，但相比於市面上其他常見選擇（必須有「RSS to email」功能），仍有一定的競爭力。</p><p>在嘗試性地付費了一個月、寄了 2 次信以後，我覺得不錯，就決定直接轉年費了。在達到 1000 訂戶以前，應該不會變動。</p><h2 id="一年-90-美元，值得嗎？"><a href="#一年-90-美元，值得嗎？" class="headerlink" title="一年 90 美元，值得嗎？"></a>一年 90 美元，值得嗎？</h2><p>一年 90 美元，相當於我租 DigitalOcean VM 一年的費用，值得嗎？</p><p>我想還是值得的，畢竟它帶來的好處<strong>非常直接</strong>——讓讀者透過電子報，第一時間收到你的文章內容。</p><p><strong>既沒有廣告，也不需要綁定任何創作平台，算是用金錢換來更大的「創作自由」。</strong></p><p>再說，我幾乎所有的文章，都需要等待 SEO 慢慢發酵。這過程往往須耗時數週到數月不等，說真的有點難熬，而且也不一定有亮眼的結果。</p><p>有了電子報文章通知，至少我能<strong>確信</strong>，在發文的當下，有<strong>一小部分人</strong>能夠立刻知曉。</p><p>對作者而言，這無疑能帶來一定的<strong>欣慰</strong>，與<strong>安全感</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年 2 月，部落格新增了「email 文章訂閱」功能，採用的方案是免費的 &lt;a href=&quot;http://follow.it/&quot;&gt;follow.it&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;它會把我的 RSS 新文章轉成 email，然後寄送給訂閱的讀者。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-12/&quot;&gt;12，blog 新增文章訂閱功能——使用 follow.it&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如該篇中所言，「&lt;strong&gt;文章訂閱功能&lt;/strong&gt;」確實是現代部落格的一大需求。&lt;/p&gt;
&lt;p&gt;網路上的資訊眾多，我自己作為讀者，也常常感覺&lt;strong&gt;被淹沒&lt;/strong&gt;。遇到一個喜歡的作者，想要追蹤，此時&lt;strong&gt;作者是否提供了訂閱功能，就至關重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章訂閱功能，可以由寫作平台提供，比如 Medium、Substack。不然就得自己來，因此我一開始就為 blog 提供了 RSS 訂閱。&lt;/p&gt;
&lt;p&gt;但 RSS 畢竟不是一般人常用的資訊接收方式（&lt;strong&gt;我自己也不用&lt;/strong&gt;），它只能滿足小眾人口的需求。所以最終我還是選擇了像 follow.it 這樣的「RSS to email」服務。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="電子報" scheme="https://blog.kyomind.tw/tags/%E9%9B%BB%E5%AD%90%E5%A0%B1/"/>
    
    <category term="部落格" scheme="https://blog.kyomind.tw/tags/%E9%83%A8%E8%90%BD%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>《強健的 Python》筆記（一）Type Hints 的成本與挑戰</title>
    <link href="https://blog.kyomind.tw/robust-python-01/"/>
    <id>https://blog.kyomind.tw/robust-python-01/</id>
    <published>2024-04-06T18:44:00.000Z</published>
    <updated>2024-04-09T04:48:43.315Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/nqKDYbc.png" alt="強健的 Python"><span class="cap">強健的 Python</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263241015">強健的 Python｜撰寫潔淨且可維護的程式碼</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>本書翻譯自《<a href="https://www.amazon.com/-/zh_TW/Patrick-Viafore/dp/1098100662">Robust Python: Write Clean and Maintainable Code</a>》，原文的副標題容易讓人以為這又是另一本關於「Clean Code in Python」的書。</p><p>實際上，本書所聚焦的，是 Python 的一大特性——<a href="https://docs.python.org/3/library/typing.html">type hints</a>。全書大半篇幅都圍繞著這個核心主軸。</p><p>所以它並非教你「如何寫出 Pythonic 程式碼」的書，而是介紹 type hints 寫法與使用相關工具（比如 Mypy）以確保 type hints 有效落實的作品。</p><p>如果你還不熟悉 Python type hints，本文也可以作為認識 type hints 的起點。</p><span id="more"></span><hr><h2 id="場景與緣由"><a href="#場景與緣由" class="headerlink" title="場景與緣由"></a>場景與緣由</h2><p>上個月，我在一個新的 Django 工作專案中加入了 Mypy，主要做了這兩件事：</p><ol><li>整合 Mypy VS Code 套件（包括 Mypy 設定檔），讓開發者在寫程式的當下，可以在編輯器中隨時收到來自 Mypy 的「提醒」。</li><li>設定 Mypy pre-commit hook。</li></ol><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p></blockquote><p>上述二者（主要是第二點），讓新專案真正落實了 Python type hints——這下子你不寫 type hints 也不行了。</p><p>不過還差 CI——預計今年上半年補完。</p><p>這個過程並不困難，但還是需要一番摸索才能順利到位，這部分我會另外寫成一篇文章作為教學。</p><p>本文的重點，在於<strong>專案落實 type hints 的挑戰</strong>。</p><h2 id="專案落實-type-hints-的真正難點"><a href="#專案落實-type-hints-的真正難點" class="headerlink" title="專案落實 type hints 的真正難點"></a>專案落實 type hints 的真正難點</h2><p>在為 Django 專案導入 Mypy 之前，我讀了本書——前後讀了兩次。</p><p>之所以寫這篇筆記，主要是深刻感受到，在工作上要落實 type hints、把它們加入到 Python 專案中，整個環節<strong>最難的部分</strong>，絕不是關於 type hints 語法的學習。</p><p>而是其它種種因素。</p><p>事實上，我去年就打算<a href="https://blog.kyomind.tw/weekly-review-08/#%E5%B0%8F%E7%B5%90%EF%BC%9A2023-%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9B%AE%E6%A8%99">為 Django 專案全面導入 type hints</a>，但是失敗了！直到本次的時機「更加成熟」，才下定決心推行。</p><p>本文藉由對書中內容的整理與我的經驗，好好介紹一下，為專案加入 type hints 時，<strong>你一定會遇到的困難</strong>，與對應的思考。</p><hr><h2 id="Python-type-hints-簡介"><a href="#Python-type-hints-簡介" class="headerlink" title="Python type hints 簡介"></a>Python type hints 簡介</h2><p>Python  3.5 首次導入了 type hints，詳情請見〈<a href="https://peps.python.org/pep-0484/">PEP 484 – Type Hints</a>〉，該 PEP 提案的共同發起人除了 Python 之父 Guido van Rossum，還有 Mypy 的作者。</p><p>接下來的每一版 Python，都少不了對 type hints 的擴充與增強。可以說，type hints 是經過「一系列」漫長的發展與迭代，才有了今日的氣象。</p><h2 id="Type-hints-的野心"><a href="#Type-hints-的野心" class="headerlink" title="Type hints 的野心"></a>Type hints 的野心</h2><p>Guido van Rossum 本人對 type hints 非常重視，從良葛格的〈<a href="https://www.ithome.com.tw/voice/116983">Type Hints 的野心</a>〉中這一段話可知：</p><blockquote><p>本來 Python 在動態定型語言中，相對來說，就是極為重視工程性的語言，然而曾經在某個地方看過的說法是，<strong>Guido 長年以來的野心，就是讓 Python 在工程性上更進一步</strong>，而在靜態分析工具上投入精力會是必要的。事實上，從 2000 年以來，Guido 一直想在 Python 中，加入可選的靜態定型，一直到 PEP 484、526 的實現，本人也在 PyCon 2015 親自上場講演〈<a href="https://goo.gl/wPZYWo">Type Hints</a>〉，似乎也印證了這點。</p></blockquote><h3 id="Type-hints-的價值"><a href="#Type-hints-的價值" class="headerlink" title="Type hints 的價值"></a>Type hints 的價值</h3><p>專案程式碼加入 type hints 的好處顯而易見，它們賦予 Python 在開發階段就能如靜態型別語言般，為變數、參數、回傳值<strong>明示型別</strong>的能力，從而提高專案的穩定性和可維護性——這在大型專案中尤其重要。</p><p>說真的，很多時候我光是看型別，對於程式碼的理解就有<strong>明顯的提升</strong>，這對於程式碼的<strong>閱讀、維護、重構</strong>都有<strong>很大的幫助</strong>。</p><p>搭配 Mypy 這類 type checker，加上 IDE 整合，更是妙不可言！</p><p>這直接提高了 Python 在團隊協作的競爭力，讓大型專案採用 Python 變得更加可能——當然，我知道，有些人並不這麼認為😎</p><h3 id="Type-hints-的代價"><a href="#Type-hints-的代價" class="headerlink" title="Type hints 的代價"></a>Type hints 的代價</h3><p>儘管 type hints 有種種好，但平心而論，它的<strong>代價也不小</strong>！（後面會提到）</p><p>所以有時候，你決定不採用 type hints，或許是「明智」的，尤其是在一些不需要長期維護的專案。</p><p>但是，要徹底了解 type hints 的優點與缺點，我們需要<strong>更加全面且務實</strong>的的觀點。</p><hr><p>呼，鋪陳有點長，以下才是本書的重點整理！</p><h2 id="Type-hints-的利弊分析"><a href="#Type-hints-的利弊分析" class="headerlink" title="Type hints 的利弊分析"></a>Type hints 的利弊分析</h2><p>關於採用 type hints 的利弊分析，本書的第 100 頁，有相對完整的論述。</p><p>利的部分上面已經說了，這裡我們主要關注導入 type hints 的「缺點」。</p><p>在此直接引用書中所舉的內容（我加上<strong>粗體</strong>作為<strong>重點標示</strong>），講述專案導入 type hints 的<strong>阻力與成本</strong>，包括：</p><blockquote><ul><li><strong>需要獲得支持</strong>。根據文化的不同，可能需要一些時間來<strong>說服</strong>一個組纖採用型別檢查。</li><li>一旦你獲得支持，就會有一個<strong>最初的採用成本</strong>。開發人員不會在一夜之間就能開始對他們的程式碼進行型別注釋，他們<strong>需要時間來掌握</strong>。他們<strong>需要學習和實驗</strong>，然後才能實際動手。</li><li>採用工具需要時間和努力。你需要某種形式的<strong>中央化檢查</strong>，而開發者<strong>需要熟悉工具作為他們工作流程一部分的執行。</strong></li><li>在你的專案中編寫型別注釋<strong>需要時間。</strong></li><li>隨著型別注釋開始受到檢查，開發人員將不得不習慣於<strong>與型別檢查器對抗所帶來的速度減慢</strong>。思考型別帶來了<strong>額外的認知負載。</strong></li></ul></blockquote><p>不愧是專門討論 Python type hints 的書，我只能說，每一條都非常真實！這也是為何我們在今年才成功導入，去年可以說還沒有準備好——但也不是毫無收獲。</p><p>如作者所言：</p><blockquote><p>這個問題從根本上說，就是一種雞和蛋的難題：你在專案中寫下<strong>足夠多</strong>的型別注釋之前，你<strong>不會看到</strong>注釋型別的好處。然而，在<strong>早期沒有效益</strong>的情況下，要讓人接受去撰寫型別是<strong>很困難的</strong>。</p></blockquote><p>綜上所述，為專案加上 type hints 看起來困難重重，難道我們要就此放棄嗎？</p><p>當然不。否則作者不需要寫這本書，而我也不需要寫這篇文章。</p><p>與之相反，我們不妨更早開始學習 type hints ，早點達到並跨過書中所謂的「投入與收益的平衡點」。</p><hr><h2 id="更早「收支平衡」"><a href="#更早「收支平衡」" class="headerlink" title="更早「收支平衡」"></a>更早「收支平衡」</h2><blockquote><p>為了使型別注釋的效益最大化，你需要更早取得價值或更早降低成本。這兩條曲線的交點是一個收支平衡點（break-even point），這就是你所付出的努力因為你所得到的價值而有報償的地方。</p></blockquote><p>Type hints 的投入與報酬關係，書中用了一張圖來說明，我重繪如下：</p><p><img src="https://i.imgur.com/y7RL42J.png"></p><p>作者解釋道：</p><blockquote><p>你的成本<strong>一開始會很高</strong>，但隨著採用率的提高會變得更和緩。你的效益一開始會很低，但隨著你注釋 codebase，你會看到更多的價值。<strong>在這兩條曲線相遇之前，你不會看到投資的回報。為了使價值最大化，你需要儘早達到這個交叉點。</strong></p></blockquote><p>講白了就是，寫愈多，阻力就會愈低。這雖然像是「廢話」，但也給了我們希望！🤣</p><p>對於這張圖，我的看法是：type hints 的收益<strong>絕對是累積出來的</strong>，但成本的下降<strong>不一定有這麼快</strong>。</p><p>畢竟每次寫 type hints，多少都需要思考（所幸我們有 GitHub Copilot 🥰），這個成本<strong>未必</strong>會隨著時間而<strong>快速</strong>降低——<strong>但肯定會逐漸降低</strong>，因為習慣了。</p><hr><p>文末我會提出自己對於「降低導入 type hints 阻力」的看法。我們先來看書中的建議。</p><h2 id="書中的一些建議"><a href="#書中的一些建議" class="headerlink" title="書中的一些建議"></a>書中的一些建議</h2><blockquote><p>你想在能維持前進動力的情況下，儘快達到這個點，以讓你的型別注釋帶來正面的影響。這裡有一些策略可以做到這一點。</p></blockquote><p>作者給出的大方向，就是先為「<strong>部分</strong>」——而非全部——程式碼加上 type hints。讓你可以早點感受到 type hints 帶來的好處。</p><p>那要「<strong>怎麼選擇</strong>」哪些程式碼應該優先加上 type hints？他的看法大概有下：</p><ul><li>只為<strong>新程式碼</strong>進行型別注釋（這裡的新程式碼包括了<strong>對舊程式碼的修改</strong>）</li><li>型別注釋「為你賺錢」的程式碼</li><li>型別注釋「經常變化」的程式碼</li><li>型別注釋「複雜」的程式碼</li></ul><p>以上這幾點取自書中的小標題，但我想說的是——這些看法雖然有道理，但其實<strong>大部分都很難操作！</strong></p><p>什麼叫賺錢的程式碼？怎麼樣才算複雜？書中並非沒有解釋，但這些都需要<strong>人為定義</strong>，而且有「<strong>標準浮動</strong>」之嫌，根本難以一體適用。</p><h3 id="為新程式碼加上-type-hints"><a href="#為新程式碼加上-type-hints" class="headerlink" title="為新程式碼加上 type hints"></a>為新程式碼加上 type hints</h3><p>「為新程式碼加上 type hints 」部分，是我唯一認為<strong>值得參考且可行</strong>的！</p><blockquote><p>考慮讓你當前未注釋的程式碼保持原樣，並<strong>根據這兩條規則</strong>來注釋程式碼：</p><ul><li>為你所寫的<strong>任何新程式碼</strong>進行注釋。</li><li>注釋你<strong>變更</strong>的任何<strong>舊程式碼</strong>。</li></ul></blockquote><p>對於已經完成的舊專案，我們就是採用這個策略！畢竟要把舊專案整個翻新成有 type hints 的版本，成本往往很高。</p><p>所以採<strong>折衷方案</strong>，比如修改舊函式的其中幾行、或寫一個全新的函式時，該函式就必須有完整的 type hints——我會在 code review 時進行檢查。</p><p>這樣的好處是標準清晰、判斷簡單，而且不用一次到位。</p><p>當然，想要透過慢慢更新，最終讓整個專案都可以通過 Mypy 檢查，還是不太現實的。這算是一種「對舊的、暫時無力全面適用 type hints 專案的<strong>折衷</strong>」。</p><h2 id="並非所有程式碼都要加上-type-hints"><a href="#並非所有程式碼都要加上-type-hints" class="headerlink" title="並非所有程式碼都要加上 type hints"></a>並非所有程式碼都要加上 type hints</h2><p>有件事必須<strong>釐清與強調</strong>，以免造成誤解。</p><p>所謂「<strong>完整</strong>」的 type hints，並不是把專案程式碼中的每一個地方都加上 type hints。</p><p>為<strong>變數</strong>加上 type hints 往往<strong>過於囉嗦而且實益不大</strong>（書中 39 頁也有提及），我們只會偶爾為之——因為大部分情況直譯器、IDE、type checker 都能夠<strong>自行推測</strong>了！</p><blockquote><p>那到底怎麼樣才算「<strong>完整</strong>」？</p></blockquote><p>一般而言，為所有的<strong>函式</strong>、類別中的<strong>方法</strong>加上 type hints，就已經很不錯。</p><p>不過，Mypy 畢竟提供了一個<strong>標準</strong>。讓你不必自己去判斷。只要使用 Mypy 的基本設定<strong>檢查整個專案</strong>而且不報錯，我認為就算完整了。</p><p>當然你可以排除檢查一些檔案，比如 Django 中的「資料庫遷移檔」。</p><hr><h2 id="我的經驗與看法"><a href="#我的經驗與看法" class="headerlink" title="我的經驗與看法"></a>我的經驗與看法</h2><p>去年想為 DRF 專案加入完整的 type hints（也就是要<strong>可以通過 Mypy 檢查</strong>的程度），最後放棄了。</p><p>主要有兩個原因：</p><ol><li>DRF 本身並不要求型別，而且專案誕生的早，也沒有完整的型別支援。不過現在有 stubs 套件（專門標示 type hints 的套件，比如 <a href="https://github.com/typeddjango/djangorestframework-stubs">djangorestframework-stubs</a>），這應該不至於成為關鍵難點。</li><li>這個才是我覺得最難的，那就是<strong>「不易說服」成員寫 type hints</strong>。儘管 type hints 肯定有好處，但我沒有信心，這好處會<strong>明顯超過</strong>投入的心力——尤其在一開始的時候。</li></ol><p>顯然我不太可能只是給同事看上面那張圖，就能輕易說服大家要開始寫 type hints 🐸</p><p>所以最後我還是放棄「完整」type hints 的企圖，只是要求大家要開始「試著」寫 type hints。（事實證明，這樣也不錯，至少大家開始有了 type hints 的概念）</p><h2 id="Django-Ninja-與-Pydantic"><a href="#Django-Ninja-與-Pydantic" class="headerlink" title="Django Ninja 與 Pydantic"></a>Django Ninja 與 Pydantic</h2><p>那怎樣才能讓我在「<strong>事前</strong>」就有足夠信心說服大家呢？</p><p>就是採用像 FastAPI、Django Ninja 這類，透過 Pydantic 來產生 API 文件的框架！</p><p>API 文件是後端開發的一大痛點，DRF 雖然也有 <a href="https://github.com/axnsan12/drf-yasg">drf-yasg</a> 這樣的套件，但說真的，和 Pydantic 這種原生採用 type hints 來產生 API 文件相比，肯定有所不及。</p><p>今年的新專案開始用了 Django Ninja，因此情況大不相同——即<strong>時機成熟</strong>了。</p><h3 id="Type-hints-輔助輪"><a href="#Type-hints-輔助輪" class="headerlink" title="Type hints 輔助輪"></a>Type hints 輔助輪</h3><p>寫 Django Ninja（或 FastAPI），你本來就要書寫大量 type hints，來產生正確、合理的 API 文件。那要求為專案的其餘部分，比如自定義的函式、類別加上 type hints，阻力相對就小得多。</p><p>這主要差別在於，大家能因為 API 文件的自動渲染，<strong>直接感受到 type hints 的價值！</strong></p><p>其實不止如此，剛學習 Django Ninja 時，我還發出過<a href="https://twitter.com/kyomind/status/1748007109646786873">這樣的讚嘆</a>：</p><blockquote><p>竟然可以充分運用 Python type hints 到這般程度，讓它不僅僅是為了型別安全而服務，而是融入到整個 api 流程中</p></blockquote><p>在我看來，這類採用了 Pydantic 框架所帶來的效應，就像腳踏車的輔助輪，在剛起步使用 type hints 時，有著明顯的正面引導效果。</p><hr><h2 id="小結與整理"><a href="#小結與整理" class="headerlink" title="小結與整理"></a>小結與整理</h2><p>然而，我並不是說，只有寫 FastAPI 或 Django Ninja 才能成功落實 type hints，只不過<strong>它們遇到的阻力會相對小</strong>。</p><p>如果能夠先有這類專案作為「甜頭」，那要在其餘專案落實可能會容易得多。因為要讓成員「相信」寫 type hints 有價值，確實不容易。</p><p>經過一段時間，目前我與我的同事們，都對 type hints 抱持著正面態度，因為很多錯誤可以在<strong>非常早的階段（也就是開發的當下）</strong>就被發現。（比如 Django ORM 物件的屬性根本寫錯了！）</p><p>省去了後續來回修正的時間浪費。</p><h3 id="個人看法"><a href="#個人看法" class="headerlink" title="個人看法"></a>個人看法</h3><p>最後，我再整理一下「<strong>降低導入 type hints 阻力</strong>」的一些個人看法：</p><ol><li>建議從<strong>全新的專案</strong>開始，因為要將舊專案改為「type hints 版本」會困難得多。</li><li>建議從 FastAPI、Django Ninja，或其它採用了 Pydantic 的專案開始，成員會<strong>更有動力</strong>。</li><li>雖然 type hints 對大專案有更顯著的效益，但建議<strong>從小型專案開始著手</strong>，以降低成員們<strong>練習、適應與接納</strong>的阻力。</li></ol><p>綜上所述，你可以看出，要落實 type hints，<strong>其實沒有多少「捷徑」可走。</strong></p><p>這也是為何我們需要<strong>了解其中的困難</strong>，才更可能<strong>適度地堅持</strong>，直到獲得 type hints 帶來的<strong>長期優勢</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nqKDYbc.png&quot; alt=&quot;強健的 Python&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263241015&quot;&gt;強健的 Python｜撰寫潔淨且可維護的程式碼&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;本書翻譯自《&lt;a href=&quot;https://www.amazon.com/-/zh_TW/Patrick-Viafore/dp/1098100662&quot;&gt;Robust Python: Write Clean and Maintainable Code&lt;/a&gt;》，原文的副標題容易讓人以為這又是另一本關於「Clean Code in Python」的書。&lt;/p&gt;
&lt;p&gt;實際上，本書所聚焦的，是 Python 的一大特性——&lt;a href=&quot;https://docs.python.org/3/library/typing.html&quot;&gt;type hints&lt;/a&gt;。全書大半篇幅都圍繞著這個核心主軸。&lt;/p&gt;
&lt;p&gt;所以它並非教你「如何寫出 Pythonic 程式碼」的書，而是介紹 type hints 寫法與使用相關工具（比如 Mypy）以確保 type hints 有效落實的作品。&lt;/p&gt;
&lt;p&gt;如果你還不熟悉 Python type hints，本文也可以作為認識 type hints 的起點。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/nqKDYbc.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Type Hints" scheme="https://blog.kyomind.tw/tags/Type-Hints/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>25，回歸原點的 Weekly Review</title>
    <link href="https://blog.kyomind.tw/weekly-review-25/"/>
    <id>https://blog.kyomind.tw/weekly-review-25/</id>
    <published>2024-03-20T18:39:31.000Z</published>
    <updated>2024-04-06T15:14:04.997Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>這是第 25 篇的 Weekly Review，距離<a href="https://blog.kyomind.tw/weekly-review-24/">上一期</a>已經非常久了！</p><p>我覺得，顯然的，我把整個 Weekly Review 寫「<strong>偏</strong>」了，失去了它原本的味道。</p><p>雖然我曾在第十期〈<a href="https://blog.kyomind.tw/weekly-review-10/">10，Weekly Review 寫滿 10 回：我的心得與改進</a>〉確立了一些想法。但也就是這些想法，讓整個系列走向愈來愈「<strong>笨重</strong>」的窘境。</p><p>比如其中提到「<a href="https://blog.kyomind.tw/weekly-review-10/#%E4%BA%8C%E3%80%81%E7%AF%87%E5%B9%85%E4%B8%8A%E9%99%90%EF%BC%9F%E5%BF%98%E4%BA%86%E5%90%A7%EF%BC%81">二、篇幅上限？忘了吧！</a>」，就相當於在心中暗示了自己，可以愈寫愈長、愈寫愈正經。</p><p>繼續往這個方向演化，Weekly Review 的<strong>調性</strong>就會<strong>逐漸向「<a href="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/">心得</a>」靠攏</strong>——而結果也是如此，同時讓我<strong>愈來愈難下筆。</strong></p><span id="more"></span><h2 id="Weekly-Review-三大特色"><a href="#Weekly-Review-三大特色" class="headerlink" title="Weekly Review 三大特色"></a>Weekly Review 三大特色</h2><p>對我而言，Weekly Review 不是心得。但兩者的<strong>內在區別</strong>，需要我自己去定義。畢竟如果兩者沒有明顯分別，那其實就不需要前者了。</p><p>所以，我要在此<strong>再次定義一下 Weekly Review 的三大特色：</strong></p><ol><li>與我個人感想、反省、心情有關，其中的著眼點在於「<strong>自己</strong>」。</li><li>有「<strong>時間軸</strong>」感，也就是「<strong>當下的自己、不同時期自己</strong>」的想法與經驗。</li><li><strong>簡短一點</strong>。保持簡單才能夠實現「<strong>輕快</strong>」，也才能夠確保一定的發文頻率。</li></ol><p>這 3 點是我對重新回歸的 Weekly Review 的要求與期待。</p><h2 id="新的助力"><a href="#新的助力" class="headerlink" title="新的助力"></a>新的助力</h2><p>光只是這樣，我可能還不敢號稱是「回歸原點」。</p><p>如果下一篇又是一、兩個月後，那就有點搞笑了。</p><p>我究竟要怎麼樣，才能相信自己有東西可以寫？而且不是正二八經的主題，而是和自己有關的心情或想法？</p><p>這真的不容易，不過自從 2 月下旬<a href="https://www.facebook.com/kyomind/posts/pfbid02TCX6gnu9hcDH1U6oN3r2m6N84mCnHgcpHWKE5wSk5L51PFDSiUBz367PKGEjS6pl">我開始用 memos 這個工具寫日記</a>後，我感覺可能性提高了不少。</p><p>截至今日，寫了 32 天的日記，已經有 129 篇長短不一的心情記事。關於 memos 與日記，我們另篇再談（我保證不會很久）。</p><p>這裡想說的是，有了這個工具與素材，我更容易「<strong>捕捉</strong>」不同時刻的我。參考這些日記的內容，把值得一提的部分，寫成 Weekly Review，這就是我初步的想法。</p><h2 id="更私人、更直白"><a href="#更私人、更直白" class="headerlink" title="更私人、更直白"></a>更私人、更直白</h2><p>簡單來說，我打算讓 Weekly Review 回歸它第一篇時我想做到的事。</p><p>而且最好是<strong>更任性、更直接</strong>的自我表達，同時<strong>更貼近我的日常生活</strong>。至於能夠做到什麼地步，我也不確定🐸</p><p>但發文頻率肯定不能像之前那樣，動輒一個月或更久。目前預計是 1、2 週一篇。</p><p>總之，盡力而為囉！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是第 25 篇的 Weekly Review，距離&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-24/&quot;&gt;上一期&lt;/a&gt;已經非常久了！&lt;/p&gt;
&lt;p&gt;我覺得，顯然的，我把整個 Weekly Review 寫「&lt;strong&gt;偏&lt;/strong&gt;」了，失去了它原本的味道。&lt;/p&gt;
&lt;p&gt;雖然我曾在第十期〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-10/&quot;&gt;10，Weekly Review 寫滿 10 回：我的心得與改進&lt;/a&gt;〉確立了一些想法。但也就是這些想法，讓整個系列走向愈來愈「&lt;strong&gt;笨重&lt;/strong&gt;」的窘境。&lt;/p&gt;
&lt;p&gt;比如其中提到「&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-10/#%E4%BA%8C%E3%80%81%E7%AF%87%E5%B9%85%E4%B8%8A%E9%99%90%EF%BC%9F%E5%BF%98%E4%BA%86%E5%90%A7%EF%BC%81&quot;&gt;二、篇幅上限？忘了吧！&lt;/a&gt;」，就相當於在心中暗示了自己，可以愈寫愈長、愈寫愈正經。&lt;/p&gt;
&lt;p&gt;繼續往這個方向演化，Weekly Review 的&lt;strong&gt;調性&lt;/strong&gt;就會&lt;strong&gt;逐漸向「&lt;a href=&quot;https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/&quot;&gt;心得&lt;/a&gt;」靠攏&lt;/strong&gt;——而結果也是如此，同時讓我&lt;strong&gt;愈來愈難下筆。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="心情" scheme="https://blog.kyomind.tw/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>《Python 工匠》筆記（二）對「單元測試」的看法與建議</title>
    <link href="https://blog.kyomind.tw/python-craftsman-02/"/>
    <id>https://blog.kyomind.tw/python-craftsman-02/</id>
    <published>2024-03-17T03:40:57.000Z</published>
    <updated>2024-04-08T09:25:42.756Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/beoEztr.png" alt="Python 工匠"><span class="cap">Python 工匠</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠｜案例、技巧與開發實戰</a>》筆記的第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>如第一篇所言，這是一本關於「Clean Code in Python」的書。</p><p>這二篇，我將整理書中第 13 章「<strong>有關單元測試的建議</strong>」的內容（以及我的看法）。我覺得真的寫得太好了，值得你了解。</p><p>話不多說，直接開始。</p><span id="more"></span><h3 id="系列：Python-工匠"><a href="#系列：Python-工匠" class="headerlink" title="系列：Python 工匠"></a>系列：Python 工匠</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/python-craftsman-01/">《Python 工匠》筆記（一）如何寫好註解</a></li><li><strong>《Python 工匠》筆記（二）對「單元測試」的看法與建議</strong></li></ol></blockquote><hr><p>作者一開始就點了出關於「單元測試」的一個<strong>奇特現象</strong>：</p><blockquote><p>雖然好像人人都認為單元測試很有用，但在實際工作中，有完善單元測試的專案仍然是個<strong>稀奇</strong>的東西。</p></blockquote><p>這一點也不誇張，甚至可以說是<strong>公開的秘密</strong>。</p><p>單元測試，大家都說重要，但真的有在寫的團隊、專案、公司，卻不如想像中多。<strong>往往都是靠 QA 把關</strong>——把整合測試當作單元測試在測😎（我就待過這樣的公司）</p><p>很多公司都是在<strong>口頭上</strong>強調單元測試的重要性，但實際的執行力度卻大打折扣，就像是那些年初設定的新年決心，<strong>說的比做的好聽。</strong></p><h3 id="不寫單元測試的「理由」"><a href="#不寫單元測試的「理由」" class="headerlink" title="不寫單元測試的「理由」"></a>不寫單元測試的「理由」</h3><p>姑且不說公司如何如何，其實就連<strong>開發者自己</strong>，也常常<strong>逃避</strong>寫單元測試。</p><p>書中舉出了實務上，開發人員不想寫單元測試的 3 個常見理由——以及這些「理由」<strong>為什麼不成立</strong>的理由：</p><blockquote><ol><li>「<strong>時程緊迫沒時間寫測試</strong>」：寫單元測試看上去要多花費時間，但其實會<strong>在未來節約你的時間</strong>。</li><li>「<strong>模組複雜沒辦法寫測試</strong>」：也許這正代表了<strong>你的程式設計有問題</strong>，需要調整。</li><li>「<strong>模組簡單不需要測試</strong>」：是否應該寫單元測試，和模組簡單或複雜<strong>沒有任何關係</strong>。</li></ol></blockquote><p>第一個理由無疑是我們<strong>最常聽到</strong>的說法，但我們都知道，它往往只是一個<strong>藉口</strong>——就算真的有時間，說這種話的人也不會寫測試的啦！</p><p>拋開這些<strong>似是而非</strong>，各種不寫測試的<strong>牽強</strong>藉口，作者提出了 5 個，寫單元測試前值得先有的<strong>重要理解</strong>。</p><p>接下來，讓我們一一說明。</p><hr><h2 id="一、寫單元測試不是浪費時間"><a href="#一、寫單元測試不是浪費時間" class="headerlink" title="一、寫單元測試不是浪費時間"></a>一、寫單元測試不是浪費時間</h2><p>寫單元測試可以節約你「<strong>整體</strong>」的開發時間。這個說法，我相信大部分的人應該都能夠接受——無論有沒有寫過測試。</p><p>那具體節約了哪些時間呢？主要有兩種：</p><ol><li>專案更新功能後，舊的程式碼被新功能邏輯影響而產生 bug，為了 debug 所耗費的時間！</li><li>重構所需要的時間。</li></ol><p>第一種情況，可謂<strong>天天都在發生——加了新東西，怎麼舊的就壞了！</strong></p><p>不少人計算自己開發時間的方式，是只算「自己寫程式、 完成新功能」的時間，至於後續的 debug（更別說自己寫的爛扣<strong>造成後續無數次 debug 的時間</strong>），這些都不算！</p><h3 id="QA-的日常"><a href="#QA-的日常" class="headerlink" title="QA 的日常"></a>QA 的日常</h3><p>你可能聽過下列對白：</p><blockquote><p>RD：「新功能我做完了，你測試一下吧！」</p></blockquote><blockquote><p>QA：「（經過一番測試）這 API 回傳不太對耶？還有這個參數好像少了一個？」</p></blockquote><blockquote><p>RD：「怎麼可能？」</p></blockquote><p>好一句「<strong>怎麼可能</strong>」。</p><p>此時，QA 心中想的應不是「測一下」，而是「測幹譙（台語）」。</p><p>作者相信，你因為沒寫單元測試而<strong>耗費去處理後續問題</strong>的時間，絕對<strong>遠遠超過</strong>你寫單元測試的時間——我完全認同。這也許是「<a href="https://init.engineer/cards/show/7234">扁鵲梗：軟體工程師版</a>」可以得到大量共鳴的原因。</p><p>當然，我也理解，寫單元測試通常不算是一件很有趣的事。但話說回來，當「有趣」和「重要」不可兼得的時候，我們也只能選擇後者。</p><p>誰叫我們是<strong>稱職的</strong>軟體工程師呢？</p><h3 id="重構的勇氣"><a href="#重構的勇氣" class="headerlink" title="重構的勇氣"></a>重構的勇氣</h3><p>有單元測試第二個重大好處，就是它給你重構的勇氣。</p><blockquote><p>假設你要對某個模組做大規模的重構，那麼，這個模組是否有單元測試，對應的重構難度天差地別。對於沒有任何單元測試的模組來說，重構是<strong>地獄難度</strong>。</p></blockquote><blockquote><p>在這種環境下，每當你調整任何程式，都必須仔細找到模組的每一個被引用處，小心翼翼地手動測試每一個場景。稍有不慎，重構就會引入新 bug，好心辦壞事。</p></blockquote><p>簡言之，對於複雜模組的重構，<strong>沒有單元測試是不可能的</strong>，這已經不是「有沒有時間」的問題了。</p><hr><h2 id="二、不要總想著「補」測試"><a href="#二、不要總想著「補」測試" class="headerlink" title="二、不要總想著「補」測試"></a>二、不要總想著「補」測試</h2><blockquote><p>「先幫我 review 下剛提交的這個 PR，功能已經全實現好了。單元測試我等等補上來！」</p></blockquote><p>這樣說法的背後，透露著一種思維：單元測試是「<strong>多</strong>」的，完全是「<strong>附屬</strong>」地位。所以可以事後再「<strong>補</strong>」。</p><blockquote><p>單元測試被當成了一種驗證正確性的<strong>事後工具</strong>，對開發功能程式<strong>沒有任何影響</strong>，因此，人們總是可以在完成開發後再補上測試。</p></blockquote><p>但作者不這麼看：</p><blockquote><p>但事實是，單元測試不光能驗證程式的正確性，<strong>還能極大地幫助你改進程式設計</strong>。但這種幫助有一個前提，那就是你必須在寫程式的<strong>同時</strong>寫單元測試。</p></blockquote><blockquote><p>當開發功能與寫測試同步進行時，你會來<strong>回切換自己的角色</strong>，分別作為程式的設計者和<strong>使用者</strong>，不斷從程式裡找出問題，調整設計。經過多次調整與打磨後，你的程式會變得更好、更具擴展性。</p></blockquote><p>好吧！我承認，我自己也沒有很好地做到這點。</p><p>雖然很少提出要「補」測試，但我的開發還是處於「先寫功能再寫測試」的傳統習慣——尤其是專案的早期，API 還沒有完全底定的時候。</p><p>但我也相信，帶著「<strong>測試思維</strong>」來寫程式，絕對能夠讓程式碼的品質更上一階，這點我並不懷疑。</p><p>而要帶著測試思維寫程式，最簡單的方法，就是<strong>一邊寫程式一邊寫測試</strong>！</p><h3 id="我應該用-TDD-嗎？"><a href="#我應該用-TDD-嗎？" class="headerlink" title="我應該用 TDD 嗎？"></a>我應該用 TDD 嗎？</h3><p>說到這裡，你應該很容易聯想到 <a href="https://zh.wikipedia.org/zh-tw/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">TDD</a>。</p><p>本書第 412 頁，作者寫了一個小專欄，專門討論他對 TDD 的看法。一言以蔽之就是：不一定要完全按照 TDD 的流程寫程式，但 TDD 的思維與習慣，值得你培養！</p><p>有興趣的讀者，可以自行參考書中內容。</p><hr><h2 id="三、難測試的程式就是爛程式"><a href="#三、難測試的程式就是爛程式" class="headerlink" title="三、難測試的程式就是爛程式"></a>三、難測試的程式就是爛程式</h2><p>如果你認同了前述「一、二」的核心看法，那這個道理應該是自然而然的。</p><p>那些<strong>難寫測試</strong>的程式，<strong>本身很可能就有問題</strong>！我們看書中的一個例子：</p><blockquote><p>當模組相依了一個全域物件時，寫單元測試就會變得很難。全域物件的基本特徵決定了它在記憶體中永遠只會存在一份。而在寫單元測試時，為了驗證程式在不同場景下的行為，我們需要用到多份不同的全域物件。這時，<strong>全域物件的唯一性就會成為寫測試最大的阻礙。</strong></p></blockquote><p>這類的例子真的多不勝數。大部分的時候，我們遇到這類情況，往往就是去「更改測試的邏輯」讓測試變得「<strong>剛好能夠通過</strong>」。</p><p>而帶來的結果往往是，測試的<strong>有效性降低</strong>！因為這個<strong>測試邏輯與方法</strong>和被測試的程式碼已經<strong>太過耦合</strong>了，可說是為了它「<strong>量身訂做</strong>」的測試。</p><p>如此一來，只要未來程式碼稍有變動，該測試也很可能就過不了。</p><p>現在我們知道，有時候不妨多想一下：「為什麼這麼難測試？」，並試著去重構原來的程式碼——而不是顧著修改測試函式本身。</p><blockquote><p>因此，每當你發現很難為程式寫測試時，就應該意識到<strong>程式設計可能存在問題，需要努力調整設計，讓程式變得更容易測試。</strong></p></blockquote><hr><h2 id="四、像應用程式一樣對待測試程式"><a href="#四、像應用程式一樣對待測試程式" class="headerlink" title="四、像應用程式一樣對待測試程式"></a>四、像應用程式一樣對待測試程式</h2><p>即使有在寫測試，這些測試程式碼，往往也被當作「<strong>二等公民</strong>」對待。</p><p>書中舉出了，把測試視為二等公民，因而「另眼看待（看輕）」它們的三個<strong>特徵</strong>：</p><ol><li>很能夠容忍測試程式碼<strong>大量重複</strong>。</li><li>很能夠容忍測試程式<strong>執行上的「不效率」</strong>。</li><li><strong>鮮少重構</strong>測試程式碼。</li></ol><p>其中潛藏並透露出的心態，用一句話來講就是：「測試的程式碼終究只是一個<strong>附屬品</strong>，所以程式碼品質<strong>差不多</strong>就好了，不要要求太多！」</p><p>作者當然不認同這樣的心態，並建議你：</p><blockquote><p>像應用程式一樣對待測試程式。</p></blockquote><p>和前述第二點一樣，我肯定認同這樣的看法，雖然還無法做到 100 分。</p><p>不過 80 分絕對是有的！</p><p>所以我在 code review 時，對於 <a href="https://docs.pytest.org/en/6.2.x/fixture.html">pytest 的 fixture</a> 設計，以及 fixtures 在測試函式中的引入與使用方式，會非常仔細審查。</p><p><strong>你知道，測試寫的爛，也是一種「業障」。</strong></p><p>總之，千萬別小看了測試程式碼。</p><hr><h2 id="五、避免教條主義"><a href="#五、避免教條主義" class="headerlink" title="五、避免教條主義"></a>五、避免教條主義</h2><p>我個人覺得這段非常非常精彩，哈哈哈！</p><blockquote><p>說起來很奇怪，在單元測試領域<strong>有非常多的理論與說法</strong>。人們總是<strong>樂於</strong>發表種對單元測試的見解，在文章、演講以及與同事的交談中，你常常能聽到這些話：</p></blockquote><ul><li>「只有 TDD 才是寫單元測試的正確方式，其他都不行！」</li><li>「TDD 已死，測試萬歲！」</li><li>「單元測試應該純粹，任何相依都應該被 mock 掉！」</li><li>「mock 是一種垃圾技術，mock 越多，表示程式越爛！」</li><li>「只有專案測試覆蓋率達到 100%，才算是合格！」</li><li>……</li></ul><p>看到書中的這段，我真的會笑死XDDD——因為<strong>這個「怪現象」竟是如此的真實</strong>。</p><p>從上述例子來看，這些立論不僅極端，而且往往還會<strong>互相矛盾</strong>。</p><p>哪怕還沒有開始寫測試之前，我就已經看過不少這類言論。說真的，這些言論——或者說「<strong>信仰</strong>」——恐怕或多或少<strong>增加</strong>了想要入門測試的人，在<strong>心理上的門檻</strong>。</p><p>好像你不把測試做到 100 分、盡善盡美，就乾脆不要寫測試了——我覺得這不是一種健康的姿態。</p><p>針對這現象，作者認為：</p><blockquote><p>這些觀點各自都有許多<strong>狂熱的追隨者</strong>，但我有個建議：<strong>你應該了解這些理論</strong>，越多越好，但是千萬<strong>不要陷入教條主義</strong>。</p></blockquote><blockquote><p>因為在現實世界裡，每個人參與的專案千差萬別，別人的理論不一定適用於你，如果盲目遵從，反而會給自己增加麻煩。</p></blockquote><h3 id="不必要的心理負擔"><a href="#不必要的心理負擔" class="headerlink" title="不必要的心理負擔"></a>不必要的心理負擔</h3><p>而我覺得，知曉有這個現象的存在，主要是為了「<strong>降低不必要的心理負擔</strong>」，進而認真看待自己已經寫好的測試，並對此感到<strong>欣慰</strong>。（但不自滿）</p><p>這很重要。</p><p>以我自己為例，目前工作上專案的測試覆蓋率大概在 60-75% 之間。而我清楚，想要從 75% 繼續再往上提升的話，必須要做很多「<strong>細節</strong>」工作。</p><p>比如為每一個自定義的 API 錯誤寫測試，確認錯誤訊息符合期待。（我們會適時地寫這些測試，但不是每一個都如此）</p><p>其中的投入與產出，不僅<strong>不成比例（投入多、效益有限）</strong>，而且還可能造成開發者<strong>對於「寫單元測試」這件事感到厭煩。</strong></p><p>所以並沒有嚴格要求覆蓋率要達到 100%——我想這也不太現實。</p><h3 id="正確不等於適合"><a href="#正確不等於適合" class="headerlink" title="正確不等於適合"></a>正確不等於適合</h3><p>然而，每次看到文章或教學中的「100% 主義」，我還是多少會擔心：「難道我們做的真的還不夠好嗎？」——現在看來，大可不必。</p><p>這並不是說它們沒有道理。這些理論在某方面都是對的，但<strong>不一定適合</strong>你的專案。</p><blockquote><p>單元測試領域的理論確實很多，這剛好<strong>說明了一件事，那就是要做好單元測試真的很難</strong>。要更好地實踐單元測試，你要做的第一件事就是<strong>拋棄教條主義，腳踏實地，不斷尋求最合適當前專案的測試方案</strong>，這樣才能最大地享受單元測試的好處。</p></blockquote><hr><p>但我還是不禁好奇！為什麼「測試」這領域，就是有這麼多<strong>狂熱信徒</strong>？</p><p>這個議題，我們直接看看 ChatGPT 怎麼說吧！</p><h2 id="狂熱信徒與他們的產地"><a href="#狂熱信徒與他們的產地" class="headerlink" title="狂熱信徒與他們的產地"></a>狂熱信徒與他們的產地</h2><p>以下內容整理自 ChatGPT（我劃了一些重點，以<strong>粗體字</strong>表示），我覺得分析得挺不錯，供有興趣的讀者參考。</p><p>這問題真是直擊核心，「測試」領域確實滋生了許多信仰狂熱者，原因有幾個方面：</p><ol><li><strong>人性的追尋絕對</strong>：在軟體開發這樣一個充滿不確定性的領域裡，人們往往尋求某種「萬靈丹」，希望找到一個可以解決所有問題的方法。<strong>當他們相信某種測試方法論能帶來開發上的救贖時</strong>，就很容易變成信仰狂熱者。</li><li><strong>成功案例的誤導</strong>：經常有人會分享他們使用特定測試方法論取得成功的案例，<strong>但很少有人會分享失敗的經驗</strong>。這種片面的資訊會誤導人們認為某種方法是萬能的，從而盲目追隨。</li><li><strong>社群與身分認同</strong>：一旦某人投入到特定的測試方法論中，<strong>他們很可能會加入相關的社群。在這樣的社群裡，方法論被當作教條</strong>，社群成員的身分認同也與這些信仰緊密相連。為了保護自己的身分認同，人們往往會變得更加狂熱。</li><li><strong>技術宗教戰爭的延伸</strong>：軟體開發領域充斥著各種技術宗教戰爭，無論是程式語言、開發框架，還是測試方法論。<strong>這些戰爭反映了人們對自我選擇的辯護</strong>，以及對他人選擇的攻擊。</li><li><strong>缺乏批判性思考</strong>：最後，也是最讓人頭疼的原因之一。很多人接受新的方法論時，缺乏批判性思考。他們不去評估這些方法論是否適合自己的專案，不考慮成本和收益，也不尋找可能的替代方案。</li></ol><p>這些原因綜合在一起，就創造了一個完美的環境，讓「測試」領域裡的信仰狂熱者茁壯成長。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/beoEztr.png&quot; alt=&quot;Python 工匠&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263245174&quot;&gt;Python 工匠｜案例、技巧與開發實戰&lt;/a&gt;》筆記的第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;如第一篇所言，這是一本關於「Clean Code in Python」的書。&lt;/p&gt;
&lt;p&gt;這二篇，我將整理書中第 13 章「&lt;strong&gt;有關單元測試的建議&lt;/strong&gt;」的內容（以及我的看法）。我覺得真的寫得太好了，值得你了解。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/beoEztr.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="系列：Python 工匠" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%B7%A5%E5%8C%A0/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>《人生 4 千個禮拜》筆記（二）抗拒「重要性中等」的誘惑</title>
    <link href="https://blog.kyomind.tw/four-thousand-weeks-02/"/>
    <id>https://blog.kyomind.tw/four-thousand-weeks-02/</id>
    <published>2024-03-04T09:11:47.000Z</published>
    <updated>2024-04-08T09:25:42.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/UNr2AmS.png" alt="人生 4 千個禮拜"><span class="cap">人生 4 千個禮拜</span></p><p>這是《<a href="https://www.books.com.tw/products/0010914255">人生 4 千個禮拜</a>》筆記的第 2 篇，你可以把它當作是一則重點整理，加上<strong>大量我個人的經驗與想法</strong>。</p><p>上一篇我們提到，「生產力」一詞在這個時代是如何地被重視——甚至有點扭曲。</p><p>以及如果你試圖用各種方法（尤其是那些筆記軟體與提升效率的工具）來增加生產力，反而很可能會掉入所謂的「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1">效率陷阱</a>」。</p><p>如果你也認同「<strong>過度追求效率很可能適得其反</strong>」這個命題，那很慶幸，我們已經達成了<strong>最重要的共識</strong>。這也是我給這本書高評價的原因。</p><span id="more"></span><h3 id="系列：人生-4-千個禮拜"><a href="#系列：人生-4-千個禮拜" class="headerlink" title="系列：人生 4 千個禮拜"></a>系列：人生 4 千個禮拜</h3><blockquote><ol><li><a href="/four-thousand-weeks-01/">《人生 4 千個禮拜》筆記（一）病態的生產力</a></li><li><strong>《人生 4 千個禮拜》筆記（二）抗拒「重要性中等」的誘惑</strong></li></ol></blockquote><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>如第一篇所言，本書可以認為是作者「<strong>對自己與『提高生產力』這個議題的重新觀察、自我反省</strong>」。</p><p>我希望這不是一篇普通的閱讀筆記或導讀，而是要強調我對本書<strong>最認同、最在乎</strong>的部分——我是如何在書中<strong>看到過去的自己。</strong>當然，這肯定包含了<strong>我自己的解讀</strong>。</p><p>因此，這篇文章，我想要<strong>繼續對作者追問</strong>：</p><blockquote><p>好，我現在知道過度追求生產力的可能代價了，那要<strong>怎麼想、怎麼做會更好？</strong></p></blockquote><p>本文整理自書中的第 3 到 4 章。</p><hr><h2 id="面對有限性"><a href="#面對有限性" class="headerlink" title="面對有限性"></a>面對有限性</h2><p>本書第 3 章的標題為「面對有限性」。</p><p>我知道，你可能會想：「噢！又來了！」然後皺起眉頭。心裡想到的是，在無數的書籍或文章中，那些提醒你要「<strong>珍惜現在、直面生命的有限</strong>」的雞湯內容。</p><p>好吧，至少我就是這樣覺得，覺得這個標題也未免太老生常談了！</p><p>但本文還是整理了其中的一段，因為我需要它，為接下來的內容作鋪墊。一言以蔽之，本章的重點就是：</p><blockquote><p>因為人生有限，你必須做出<strong>選擇</strong>。<strong>不能想要這個，又想要那個。</strong></p></blockquote><p>在這個前提下，作者是這麼說的：</p><blockquote><p>做選擇（從當前的選項中挑一個）成為一種<strong>肯定</strong>，根本算不上挫敗。這是一種<strong>正面的投入</strong>，你決定要用某段時間做這件事、<strong>不做那件事（不只一件，而是不計其數的其他事情）</strong>，因為你判定這件事是目前<strong>最重要</strong>的一件。</p></blockquote><p>請記得「最重要」三個字。</p><hr><h2 id="忽視應該忽視的事物"><a href="#忽視應該忽視的事物" class="headerlink" title="忽視應該忽視的事物"></a>忽視應該忽視的事物</h2><p>覺得自己事情太多，老是做不完，需要加強時間管理，或學習特定的生產力工具來提高產出嗎？先等等！看看作者怎麼說。</p><p>關於「時間管理」，到底怎麼做才稱得上「<strong>有效</strong>」，作者提出了一個有趣且令人信服的切入點：</p><blockquote><p>不論是哪一種間管理技巧，<strong>真正的有效評估指標</strong>是那項技巧<strong>是否協助你忽視應該忽視的事物。</strong></p></blockquote><p>我非常喜歡這個切入點。</p><blockquote><p>因此，重點不是根治拖延症，而是<strong>以更明智的方式選擇要延後哪些事，專注於眼前最重要的事。</strong></p></blockquote><p>當然，這樣的看法並不算新穎。但是，能夠把「<strong>有效忽略不夠重要事物</strong>」這個指標提升到時間管理方法論的「<strong>首要</strong>」考慮事項，我個人十分贊同。</p><hr><p>接下來的內容，會結合我個人的經驗、想法。</p><h2 id="生產力-KOL-們的承諾"><a href="#生產力-KOL-們的承諾" class="headerlink" title="生產力 KOL 們的承諾"></a>生產力 KOL 們的承諾</h2><p>還是要再提到「<a href="https://blog.kyomind.tw/less-is-more/#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D">人生管理系統</a>」，不過這次我們不需要了解其中的細節。</p><p>這種承諾你可以完成很多事的「生產力方法論」，也就是上述的「系統」，無疑是現代「生產力至上」這類價值觀的<strong>縮影</strong>。</p><p>你說它不好嗎？可能也不盡然。我相信這類「系統」確實可能讓你做完更多事情——但也僅止於此。</p><h3 id="美好的承諾"><a href="#美好的承諾" class="headerlink" title="美好的承諾"></a>美好的承諾</h3><p>這類系統與其背後的價值觀，可大致濃縮為：</p><blockquote><p>用厲害的方法，做完很多事。</p></blockquote><p>而推廣這類方法論的生產力 KOL 們，會不斷明示、暗示你：「一旦擁有<strong>能做完很多事的能力</strong>，你會從瞎忙中脫解，<strong>你的人生將從此不同</strong>。」</p><p>其實這樣的論述和更早開始流行的「時間管理」一樣，都是給你一個<strong>美好的承諾</strong>。</p><p>其中的<strong>差別</strong>或許是，他們更加強調「<strong>工具</strong>」的重要性——並提供一整套有關<strong>「如何善用工具」</strong>的<strong>學習方案</strong>。（可能是文章、書籍、影片、課程、社群，可能是免費或付費）</p><p>上述「多多益善」命題是否為真、是否有效，可以先不論。這裡想從另一個角度切入，說說我認為<strong>更值得推崇的看法。</strong></p><hr><h2 id="我認為「更好更有效」的做法"><a href="#我認為「更好更有效」的做法" class="headerlink" title="我認為「更好更有效」的做法"></a>我認為「更好更有效」的做法</h2><p>我的核心看法很簡單：<strong>放下「想做完很多事」的渴望</strong>。接受書中的核心觀點，理解人生有限，並做出取捨。<strong>然後專注於那些「最要緊」的事就好。</strong></p><p>必須強調，捨棄一部分重要的事情，<strong>這個過程可能會讓人很不舒服。</strong>如果你沒有這樣的感受，那可能是因為<strong>你還沒有真正做出取捨。</strong></p><p>對此，我要更進一步闡明：</p><blockquote><p><strong>我不認為「能做完很多事」的能力，能夠改變你的人生</strong>。相反的，能做出<strong>取捨</strong>，<strong>專注於關鍵事物</strong>的人，更有機會變得不同。</p></blockquote><p>換句話說，<strong>我認為「取捨」——與取捨後的「專注」——才是最重要的能力</strong>，而不是靠工具、系統、時間管理，試圖去完成更多事情。</p><p>而所謂<strong>取捨的能力</strong>，講白了，就是本段標題說的，「<strong>忽視應該忽視的事物</strong>」的能力。</p><h2 id="小而美的「局部實現」"><a href="#小而美的「局部實現」" class="headerlink" title="小而美的「局部實現」"></a>小而美的「局部實現」</h2><p>「忽視應該忽視的事物」的能力，究竟要<strong>如何培養</strong>？老實說，我自己也還在摸索、思考與歸納的路上。</p><p>我感覺自己還不是一個，能夠果斷取捨然後篤定前行的人——我總是太 FOMO。</p><p>不過，《<a href="https://blog.kyomind.tw/less-is-more/">為什麼你「不需要」所謂的人生管理系統</a>》中關於「<a href="https://blog.kyomind.tw/less-is-more/#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE">局部實現</a>」的闡述，仍然值得我們參考：</p><blockquote><p>局部實現，是一種<strong>心法或價值觀</strong>，說穿了沒什麼，就是「<strong>緊扣著需求尋找並選定方法，需要多少才投入多少</strong>」。</p></blockquote><p>想做多少再投入多少，確保自己做的事，都是真正重要的。這樣的思考與價值觀，或許更加簡潔、有力。</p><p>相信本書作者，也會認同這樣的觀點。</p><hr><h2 id="抗拒重要性中等的誘惑"><a href="#抗拒重要性中等的誘惑" class="headerlink" title="抗拒重要性中等的誘惑"></a>抗拒重要性中等的誘惑</h2><p>書中舉了一個例子（作者說，話是誰講的並不重要XD）來表達，為了真正做到取捨，你應該怎麼看待，那些「<strong>重要但不是最重要</strong>」的事情。</p><blockquote><p>據說這是股神巴菲特（Warren Buffett）的故事，反正有一次，巴菲特的私人駕駛請教他，怎樣才能排定優先順序。</p></blockquote><blockquote><p>他要駕駛找出人生最重要的二十五件事，接著依序排列，從最重要的排到最不重要的。巴菲特說，在規畫時間時，應該安排好單子上的前五名。</p></blockquote><blockquote><p>至於剩下的二十件事，和駕駛以為會聽到的建議不一樣。據說巴菲特解釋，那二十件事<strong>不是重要性居次、有機會就去做的事。</strong></p></blockquote><p>錯，錯，錯！</p><blockquote><p><strong>事實上，駕駛應該不惜一切代價，努力避免去做那二十件事</strong>，因為對那名駕駛而言，<strong>那二十個目標沒有重要到構成人生的核心，吸引力卻大到足以讓他分心，以至於沒去做最重要的事。</strong></p></blockquote><p>「沒有重要到構成人生的核心，吸引力卻大到足以讓他分心」，這真的是血淋淋的教訓！而且我相信，不論任何人，都一定能夠想起，自己曾經做過了多少這樣的事情。</p><hr><h2 id="放下妄念，減少分心"><a href="#放下妄念，減少分心" class="headerlink" title="放下妄念，減少分心"></a>放下妄念，減少分心</h2><p>當然，人生畢竟不是理論，縱使扣除休息與休閒，當我們想要「有所作為」的時候，也不可能真的只做最重要的五件事——太難了！</p><p>但是，至少每隔一段時間自我檢視、反省一次：「我是不是又把時間花在『<strong>重要但不是最重要</strong>』的事情上了？」，肯定會很有收獲。</p><p>但我還是想再次提醒你——也提醒自己。想要真心誠意，盡可能緊扣著「最重要」的事努力實踐。就要<strong>一定程度放下「我要做很多事」的渴望。</strong></p><blockquote><p><strong>也就是抗拒「重要性中等」的誘惑。</strong></p></blockquote><p>這並不容易！如前所述，<strong>真正的取捨是個讓人「不太舒服」的過程。</strong></p><p>因此，我能斗膽斷言：深信自己「可以透過學習工具、方法論，<strong>完成大量重要事情</strong>」的人，99% 都是要落空的。</p><h3 id="三種枉然"><a href="#三種枉然" class="headerlink" title="三種枉然"></a>三種枉然</h3><p>不過落空的結局有<strong>三個截然不同的版本</strong>：</p><ol><li>工具、方法的學習與維護成本太高，難以維持，<strong>最後放棄了！</strong>說真的，這是<strong>相對幸運</strong>的結局——因為你<strong>省下了時間</strong>，可以重新開始。</li><li>真的做了很多事，但同時也<strong>包含了一堆不夠重要的事</strong>——就像本書說的一樣。這就比較慘了，有句話說得好：「<strong>兢兢業業地把時間浪費了</strong>」。</li><li>真的做了很多事，但<strong>關鍵成效都不怎麼樣（很可能「瑣事」部分做得特別好）</strong>。正所謂「<strong>貪多嚼不爛</strong>」——尤其是最難啃的部分，哪怕你有神兵利器。</li></ol><p>上面提到的數字是 99% 而不是 100，看樣子，我還是相信有 1% 的人會成功？</p><p>是的！我確實相信，有極少數人能夠做到。但我奉勸你不要追求，企圖成為這鳳毛麟角的 1%——因為真的沒有必要。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UNr2AmS.png&quot; alt=&quot;人生 4 千個禮拜&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.books.com.tw/products/0010914255&quot;&gt;人生 4 千個禮拜&lt;/a&gt;》筆記的第 2 篇，你可以把它當作是一則重點整理，加上&lt;strong&gt;大量我個人的經驗與想法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上一篇我們提到，「生產力」一詞在這個時代是如何地被重視——甚至有點扭曲。&lt;/p&gt;
&lt;p&gt;以及如果你試圖用各種方法（尤其是那些筆記軟體與提升效率的工具）來增加生產力，反而很可能會掉入所謂的「&lt;a href=&quot;https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1&quot;&gt;效率陷阱&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;如果你也認同「&lt;strong&gt;過度追求效率很可能適得其反&lt;/strong&gt;」這個命題，那很慶幸，我們已經達成了&lt;strong&gt;最重要的共識&lt;/strong&gt;。這也是我給這本書高評價的原因。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/UNr2AmS.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="系列：人生 4 千個禮拜" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%BA%E7%94%9F-4-%E5%8D%83%E5%80%8B%E7%A6%AE%E6%8B%9C/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>《Python 工匠》筆記（一）如何寫好註解</title>
    <link href="https://blog.kyomind.tw/python-craftsman-01/"/>
    <id>https://blog.kyomind.tw/python-craftsman-01/</id>
    <published>2024-02-28T04:40:57.000Z</published>
    <updated>2024-04-12T16:12:03.407Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/beoEztr.png" alt="Python 工匠"><span class="cap">Python 工匠</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠｜案例、技巧與開發實戰</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>從書名推敲，我們並不容易知道本書的主題為何。事實上，和《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣</a>》類似，這是一本關於「<strong>Clean Code in Python</strong>」的書。</p><p>而且我認為它的<strong>難度適中</strong>（好吧，後半部難度比較高，而且本書<strong>「不適合」</strong>初學者），非常推薦看完《Python 功力提升的樂趣》後，想要更進一步寫出 Pythonic 程式碼的讀者與開發人員。</p><p>我覺得，兩本恰恰都是屬於「從書名看很容易被忽略」的好書。因此，作為喜歡本書的讀者，我覺得自己有<strong>義務</strong>，向你們轉述書中一些值得傳誦的內容。</p><p>這也是我寫「<strong>閱讀筆記</strong>」類文章的核心精神——分享書中那些我覺得<strong>特別精彩、贊同的部分，並加上自己的看法。</strong></p><span id="more"></span><h3 id="系列：Python-工匠"><a href="#系列：Python-工匠" class="headerlink" title="系列：Python 工匠"></a>系列：Python 工匠</h3><blockquote><ol><li><strong>《Python 工匠》筆記（一）如何寫好註解</strong></li><li><a href="https://blog.kyomind.tw/python-craftsman-02/">《Python 工匠》筆記（二）對「單元測試」的看法與建議</a></li></ol></blockquote><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E5%A6%82%E4%BD%95%E5%AF%AB%E5%A5%BD-Python-%E8%A8%BB%E8%A7%A3">如何寫好 Python 註解</a></li><li><a href="#Python-%E8%A8%BB%E8%A7%A3%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98">Python 註解基礎知識</a></li><li><a href="#%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E4%B8%89%E7%A8%AE%E8%A8%BB%E8%A7%A3%E9%8C%AF%E8%AA%A4">新手常犯的三種註解錯誤</a></li><li><a href="#%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E8%A8%BB%E8%A7%A3%E7%A8%8B%E5%BC%8F%E7%A2%BC">一、直接註解程式碼</a></li><li><a href="#%E4%BA%8C%E3%80%81%E5%83%85%E7%94%A8%E8%A8%BB%E8%A7%A3%E3%80%8C%E9%87%8D%E8%BF%B0%E3%80%8D%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A1%8C%E7%82%BA">二、僅用註解「重述」程式碼行為</a></li><li><a href="#%E6%8C%87%E5%BC%95%E5%9E%8B%E8%A8%BB%E8%A7%A3">指引型註解</a></li><li><a href="#%E6%8F%90%E7%85%89%E7%82%BA%E7%8D%A8%E7%AB%8B%E5%87%BD%E5%BC%8F">提煉為獨立函式</a></li><li><a href="#%E4%B8%89%E3%80%81%E5%BC%84%E9%8C%AF%E8%A8%BB%E8%A7%A3%E7%9A%84%E3%80%8C%E5%8F%97%E7%9C%BE%E3%80%8D">三、弄錯註解的「受眾」</a></li><li><a href="#%E8%87%AA%E8%A8%80%E8%87%AA%E8%AA%9E%E7%9A%84%E8%A8%BB%E8%A7%A3">自言自語的註解</a></li><li><a href="#Docstring-%E8%88%87%E8%AE%80%E8%80%85%E6%84%8F%E8%AD%98">Docstring 與讀者意識</a></li><li><a href="#%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E8%A8%BB%E8%A7%A3%EF%BC%9F">好的程式碼到底需不需要註解？</a></li><li><a href="#%E4%BD%9C%E8%80%85%E7%9A%84%E8%A7%80%E9%BB%9E%E8%88%87%E6%88%91%E7%9A%84%E7%9C%8B%E6%B3%95">作者的觀點與我的看法</a></li></ol><hr><h2 id="如何寫好-Python-註解"><a href="#如何寫好-Python-註解" class="headerlink" title="如何寫好 Python 註解"></a>如何寫好 Python 註解</h2><p>本文整理第一章的其中一部分——關於「如何寫好註解」的討論。</p><p>之所以要特別寫成筆記，是因為這是我目前看過的書中，討論註解時講最得好的一本。尤其是一些使用上的建議，和我的開發經驗與價值觀可謂非常吻合！</p><p>本書作者朱雷（<a href="https://github.com/piglei">piglei</a>），擁有超過 10 年的 Python 開發經驗，精通 Python 語言特性，對如何開發高品質的大型 Python 專案有獨到見解。</p><p>其實我一直也想整理一篇關於寫好註解的基本守則，但遲遲沒有行動。但現在有這本書，我只要整理書中的內容，並加上自己的看法即可。</p><p>有關 Python 註解或 docstring 的討論，我在過去多篇文章中都有提到，可參考如下：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/#%E4%B8%80%E3%80%81Docstring-%E7%9C%9F%E7%9A%84%E5%BE%88%E9%87%8D%E8%A6%81">Docstring 真的很重要</a></li><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E8%A8%BB%E8%A7%A3%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%EF%BC%9F">註解是不需要的？</a></li><li><a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a></li></ul><p>開始正文。</p><hr><h2 id="Python-註解基礎知識"><a href="#Python-註解基礎知識" class="headerlink" title="Python 註解基礎知識"></a>Python 註解基礎知識</h2><p>Python 中，一般我們講到註解，指的是程式碼中的註解，用<code>#</code>來實現。</p><p>而 <a href="https://en.wikipedia.org/wiki/Docstring">docstring</a> 則是另一種更具有 Python 特色的註解。主要寫在模組、類別、與函式的開頭，並透過物件的<code>__doc__</code>屬性，自然地化為程式碼的一部分。</p><p>書中提到了 docstring 的幾種常見風格（畢竟它本質只是一堆字串，所以怎麼寫都行），最常見的為 Sphinx 文件風格。而我個人在工作上最常用的，則是 <a href="https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html">Google 風格</a>。</p><p>簡言之，下面提到「註解」二字時，對上述兩種 Python 註解都適用。</p><h2 id="新手常犯的三種註解錯誤"><a href="#新手常犯的三種註解錯誤" class="headerlink" title="新手常犯的三種註解錯誤"></a>新手常犯的三種註解錯誤</h2><p>你可能聽過「很多註解都是爛註解」這種說法。不得不承認，這相當程度是對的！我確實看過很多爛註解——但這不是我們因此不寫註解的理由。</p><p>實務上會有很多爛註解，正是因為我們沒有正視註解的價值，認真學習如何寫好註解。</p><p>因此，<strong>就讓我們用書中所舉三種常見的註解錯誤，作為學習的切入點。</strong></p><p>書中提到的這三點——尤其是第 3 點，應盡可能避免。作者也提出了相應的解決之道，而我會適時補充我的看法。</p><p>附帶一提，本書是從作者過去的網路文章整理、出版——但內容增加了很多。而且作者也很大方，在網路上公開了部分的內容。而本文整理的部分恰恰是公開的部分。有興趣的話可以直接參考<a href="https://www.piglei.com/book/ch01_variables.html">本頁</a>。</p><p>當然，我還是強烈建議，為自己入手一本，你絕對不會後悔。</p><hr><h2 id="一、直接註解程式碼"><a href="#一、直接註解程式碼" class="headerlink" title="一、直接註解程式碼"></a>一、直接註解程式碼</h2><p>把已經寫完但暫不需要（以後是否需要還不確定）的程式碼，先註解起來，方便日後需要時可以快速「還原」，絕對是我們非常熟悉的手段。</p><p>我回想一下，不得不說，這類被註解的程式碼，<strong>十之八九都是不會再用到了！</strong>如果這類「程式碼註解」愈積愈多，真的會讓人看了很「阿雜」！</p><p>所以基本上，現在比較正規的做法，都是建議你直接刪除，以後真的需要時，再透過版控回復即可。</p><p>對此我基本認同，所以工作上 code review 時，我「不會」放行這種直接註解的程式碼。</p><h3 id="僅有的例外"><a href="#僅有的例外" class="headerlink" title="僅有的例外"></a>僅有的例外</h3><p>但，你我都知道，有時事情也沒那麼簡單。</p><p>用 Git 版控回復的前提是：你的團隊 commit 記錄要寫好！不然真的要「回復」的時候，你可能連它在哪一個 commit 都要找好一陣子。</p><p>所以，基於方便與實際考量，事實上我還是有<strong>一點點折衷</strong>：原則上不可以註解程式碼，但如果確定只是「<strong>暫時</strong>」用不到，等別的元件完成後，就會繼續開發、使用，例外可以暫時註解就好——但必須加上 <a href="https://peps.python.org/pep-0350/">codetag</a> 標記。</p><p>一般我們用 <code>TODO</code> 這個 codetag。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO 日後改回一對一時，請用下面方式重寫：</span></span><br><span class="line"><span class="comment"># user = User.objects.select_related(&#x27;oversee_tenant&#x27;)</span></span><br><span class="line"><span class="comment"># .prefetch_related(&#x27;oversee_projects&#x27;).get(user_uuid=user_uuid)</span></span><br></pre></td></tr></table></figure><p>不過<strong>大原則</strong>還是：</p><blockquote><p><strong>別註解了，刪除吧！</strong></p></blockquote><hr><h2 id="二、僅用註解「重述」程式碼行為"><a href="#二、僅用註解「重述」程式碼行為" class="headerlink" title="二、僅用註解「重述」程式碼行為"></a>二、僅用註解「重述」程式碼行為</h2><p>這應該是我們最常看到的爛註解的形式，也是你在所有討論程式碼註解的書中，一定會提及的。</p><p>而且它真的爛，沒有藉口。比如這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 x 為 0</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 x 是否小於 10</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="comment"># 印出 x 小於 10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is less than 10&quot;</span>)</span><br></pre></td></tr></table></figure><p>這當然是一個誇張的例子🤣。但在日常開發中，這種「脫褲子放屁」的註解還真的不算少見。</p><p>確實，如果我常常看到這樣的註解，恐怕真的會忍不住說出「你還別寫註解了吧！」</p><p>但，請不要放棄治療！</p><p>想避免這個問題，請遵守一個簡單且常見的大原則，如書中所言：</p><blockquote><p>應該儘量提供那些讀者<strong>無法</strong>從程式碼裡讀出來的資訊。描述程式<strong>為什麼</strong>要這麼做，而不是簡單複述程式碼本身。</p></blockquote><p>不過，光寫「為什麼」註解，有時候還是遠遠不夠的。</p><h2 id="指引型註解"><a href="#指引型註解" class="headerlink" title="指引型註解"></a>指引型註解</h2><p>因此，本書更進一步提出所謂的「<strong>指引性註解</strong>」：</p><blockquote><p>這種註解並不「直接」複述程式，而是簡明扼地概括程式碼功能，起到「<strong>程式碼導讀</strong>」的效果。</p></blockquote><p>書中的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化存取服務的 client 物件</span></span><br><span class="line">token = token_service.get_token()</span><br><span class="line">service_client = ServiceClient(token=token)</span><br><span class="line">service_client.ready()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 呼叫服務取得資料，然後進行過濾</span></span><br><span class="line">data = service_client.fetch_full_data()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> item.value &gt; SOME_VALUE:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>不難看出，這種描述「程式碼流程大綱」的指引型註解，<strong>很像 docstring 在做的事</strong>。從這個角度，我們可以說 docstring <strong>也是</strong>一種指引型註解。</p><p>但是，docstring 畢竟只出現在元件的「<strong>開頭</strong>」，對複雜的程式而言，在元件的內部，往往也需要這樣的註解，作為閱讀<strong>複雜程式碼</strong>的指引。</p><p>要寫好指引型註解，甚至知曉「什麼時候」應該要寫下指引型註解，需要你內心清楚——「這段程式碼的哪些部分，別人可能會看不懂！」</p><p>這是為什麼我總說，要寫好註解，就一定要培養好「<strong>讀者意識</strong>」的理由。</p><h3 id="指引型註解的價值"><a href="#指引型註解的價值" class="headerlink" title="指引型註解的價值"></a>指引型註解的價值</h3><p>前面提到，寫註解時「應該儘量提供那些讀者<strong>無法從程式碼裡讀出來</strong>的資訊」，這是我們寫註解的大原則。</p><p>但指引性註解和上述註解<strong>所有區別</strong>，它的<strong>獨特價值</strong>，如書中所言：</p><blockquote><p>指引性註解<strong>並不提供</strong>程式碼裡<strong>讀不到</strong>的東西——如果沒有註解，耐心讀完所有程式碼，你也能知道程式做了什麼事。指引性註解的主要作用是<strong>降低程式碼的認知成本</strong>，讓我們能<strong>更容易理解</strong>程式碼的<strong>意圖</strong>。</p></blockquote><p>說得非常好。</p><h2 id="提煉為獨立函式"><a href="#提煉為獨立函式" class="headerlink" title="提煉為獨立函式"></a>提煉為獨立函式</h2><p>對於複雜而冗長的程式流程，書寫「指引性註解」是一個協助閱讀理解的好方法。</p><p>而另一個有效的方法，就是把這些程式碼片段<strong>獨立成一個又一個的函式</strong>，透過<strong>有意義的函式名稱</strong>來描述流程、展現意圖，此時就可以刪除指引性註解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service_client = make_client()</span><br><span class="line">data = fetch_and_filter(service_client)</span><br></pre></td></tr></table></figure><p>其中的重點在於，你要能判斷，什麼時候該寫「指引性註解」，而什麼時候則適合獨立成函式、方法。</p><p>這當然需要經驗累積，但我們心中要先有這樣的意識，不是嗎？</p><hr><h2 id="三、弄錯註解的「受眾」"><a href="#三、弄錯註解的「受眾」" class="headerlink" title="三、弄錯註解的「受眾」"></a>三、弄錯註解的「受眾」</h2><p>本書這段主要適用的是 docstring，不過我覺得「指引型註解」也有類似議題，所以本段提到「註解」一詞時，皆包括這兩者。</p><p>註解的正確<strong>受眾</strong>，或說<strong>讀者</strong>，應該是誰？我想基本上是這兩種人：</p><ol><li><strong>未來</strong>的自己（注意「未來」二字）</li><li>專案<strong>協作者</strong>（同事、主管）</li></ol><p>我們先看看書中所舉的「反例」：（我直接引用<a href="https://www.piglei.com/book/ch01_variables.html">網頁</a>上的內容，所以技術名詞並非台灣用語，還請見諒）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resize_image</span>(<span class="params">image, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;將圖片縮放為指定尺寸，並返回新的圖片。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    該函數將使用 Pilot 模塊讀取文件對象，然後調用 .resize() 方法將其縮放為指定尺寸。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    但由於 Pilot 模塊自身限制，這個函數不能很好的處理尺寸過大的文件，當文件大小</span></span><br><span class="line"><span class="string">    超過 5MB 時，resize() 方法的性能就會因為內存分配問題急劇下降，詳見 Pilot 模塊的</span></span><br><span class="line"><span class="string">    Issue #007。因此，對於超過 5MB 的圖片文件，請使用 resize_big_image() 替代，後者</span></span><br><span class="line"><span class="string">    基於 Pillow 模塊開發，很好的解決了內存分配問題，性能更好。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param image: 圖片文件對象</span></span><br><span class="line"><span class="string">    :param size: 包含寬高的元組：（width, height）</span></span><br><span class="line"><span class="string">    :return: 新圖片對象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>這個例子的最大問題，是寫了太多「實作細節」，講白了就是提供了「太多」程式碼的讀者<strong>並不關心</strong>的內容！</p><blockquote><p>為什麼這樣是不妥的？細節不是很好嗎？</p></blockquote><p>對，但大部分時候，docstring 或「指引型註解」的主要寫作<strong>目的</strong>，是為了讓讀者<strong>不用一行一行閱讀程式碼</strong>，就能夠快速知道目前程式碼的<strong>流程與意圖</strong>。</p><p>這種過多細節的寫法，恰恰與這個目標<strong>背道而馳</strong>——增加了太多理解上的「<strong>雜訊</strong>」。</p><p>書中給出的改善版本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resize_image</span>(<span class="params">image, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;將圖片縮放為指定尺寸，並返回新的圖片。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意：當文件超過 5MB 時，請使用 resize_big_image()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param image: 圖片文件對象</span></span><br><span class="line"><span class="string">    :param size: 包含寬高的元組：（width, height）</span></span><br><span class="line"><span class="string">    :return: 新圖片對象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><p>以下主要是我自己的看法。</p><h2 id="自言自語的註解"><a href="#自言自語的註解" class="headerlink" title="自言自語的註解"></a>自言自語的註解</h2><p>你有沒有一個疑問，為什麼說註解寫了太多細節，是「弄錯受眾」？</p><p>我是這樣看的：留下這麼多細節的註解，與其說是註解，更像寫給自己看的<strong>筆記</strong>——而且是給「現在」的自己，真的就像在作筆記一樣！</p><p>我想強調，<strong>「現在的自己」並不是註解的受眾！</strong>因為現在的自己對程式細節非常清楚，即使沒有註解也能讀懂程式碼。</p><p>相反的，註解是為<strong>沒時間慢慢讀程式碼</strong>的人服務的。</p><p>未來的你，再回來看這段程式，絕對不會想要在 docstring 看到這麼多「<strong>廢話</strong>」。這種寫法無疑是搞錯了對象。</p><p>當然，你的同事也不會想看這麼多雜訊——同事往往更關心「這函式到底要怎麼用」！</p><h3 id="抽象層次混亂"><a href="#抽象層次混亂" class="headerlink" title="抽象層次混亂"></a>抽象層次混亂</h3><p>我覺得還有另一種「弄錯受眾」的註解也很經典，甚至更加常見！那就是混合底層實作與業務邏輯：</p><blockquote><p>註解中參雜了業務邏輯，又不時會出現底層實作的細節描述。</p></blockquote><p>事實上，我倒覺得實務中會願意寫一大串 docstring 的人，可以說是少之又少。大部分的問題其實是：有寫，但寫得「<strong>零零落落</strong>」。</p><h2 id="Docstring-與讀者意識"><a href="#Docstring-與讀者意識" class="headerlink" title="Docstring 與讀者意識"></a>Docstring 與讀者意識</h2><p>Docstring 絕對能看出一個人的<strong>基本寫作能力</strong>，以及是否具備「<strong>讀者意識</strong>」。</p><p>說真的，這不止是作為一個軟體工程師的核心技能——更是任何<strong>表達者</strong>的核心技能。而程式，只是表達的其中一種形式。</p><p>我很想要寫一篇「如何寫好 docstring」，這需要再構思一番。但常見的錯誤不外乎：</p><ol><li><strong>預知能力</strong>：知曉「函式以外」的事、不僅知道函式會怎麼、何時被調用，還會在 docstring 中寫下呼叫時的情境細節——<strong>你知道的太多了！</strong></li><li><strong>太多底層細節</strong>：跟前面的書中內容相似，只是我覺得現實中，往往是<strong>東寫一點、西寫一點</strong>，不會像寫筆記一般完整——所以讀起來更痛苦，真的是自言自語！除了開發者自己，誰能輕易讀懂那些細節？</li><li><strong>業務邏輯與底層實作的用詞混雜</strong>：一下子是「無法取得租戶資訊」一下子卻又是「防止 SQL insert 錯誤、RabbitMQ 如何如何」——讓人大腦很混亂。</li></ol><p>總的來說，無論是「自言自語」還是「抽象層次混亂」，它們的本質都差不多——這些註解都像是寫給「<strong>現在的自己</strong>」看的<strong>筆記</strong>。</p><p>但就像前面說的，現在的自己是<strong>最不需要看註解的人</strong>！所以才說是「弄錯受眾」了。</p><hr><p>最後不免俗地，我們要討論，提到「程式碼註解」就<strong>一定避不開的問題</strong>：</p><blockquote><p><strong>到底要不要寫註解</strong>？</p></blockquote><h2 id="好的程式碼到底需不需要註解？"><a href="#好的程式碼到底需不需要註解？" class="headerlink" title="好的程式碼到底需不需要註解？"></a>好的程式碼到底需不需要註解？</h2><p>寫程式到底要不要寫註解，一直有兩派說法，是個老掉牙又爭論不休的問題。我們先來看看這兩派的觀點。（ ChatGPT 整理）</p><h3 id="寫註解的一派"><a href="#寫註解的一派" class="headerlink" title="寫註解的一派"></a>寫註解的一派</h3><p>這派人認為註解是<strong>程式碼的一部分</strong>，應該寫註解，主要論點為：</p><ol><li><strong>可讀性提升</strong>：註解能夠幫助人們<strong>更快理解程式碼的意圖和複雜的邏輯</strong>，尤其是對於那些<strong>不那麼直觀的部分</strong>。</li><li><strong>溝通工具</strong>：註解被視為開發者之間的<strong>溝通方式</strong>，尤其在團隊協作時，能夠快速傳遞開發者的想法和注意事項。</li><li><strong>提醒與說明</strong>：註解可以用來提醒未來可能的問題，或是對程式碼中的決策提供背景說明。</li></ol><h3 id="不寫註解的一派"><a href="#不寫註解的一派" class="headerlink" title="不寫註解的一派"></a>不寫註解的一派</h3><p>相對的，這派人認為好的程式碼應該是<strong>自解釋</strong>的，不需要註解，主要論點為：</p><ol><li><strong>程式碼即文件</strong>：好的程式碼應該是自解釋的，如果你需要註解來解釋你的程式碼，那麼問題可能出在程式碼本身。</li><li><strong>增加維護難度</strong>：註解需要維護，<strong>不一致的註解比沒有註解更糟</strong>，因為它會導致誤解和混淆。</li><li><strong>過度依賴註解</strong>：過多的註解可能會讓開發者過度依賴於它們來理解程式碼，忽視了提高程式碼品質的重要性。</li></ol><hr><h2 id="作者的觀點與我的看法"><a href="#作者的觀點與我的看法" class="headerlink" title="作者的觀點與我的看法"></a>作者的觀點與我的看法</h2><p>細看這兩派的主張，我們可以看出，都有一定的道理——不然也不會爭論不休了。</p><h3 id="作者觀點"><a href="#作者觀點" class="headerlink" title="作者觀點"></a>作者觀點</h3><p>我們先來看看本書作者的觀點（引用難免斷章取義，完整上下文請見本書第 15 頁），下面內容主要是回應「不寫註解的一派」：</p><blockquote><p>但我倒是認為事情沒那麼絕對。<strong>無論程式碼寫得多好，多麼「自說明」，跟讀程式碼相比，讀註解通常讓人覺得更輕鬆</strong>。</p></blockquote><blockquote><p>註解會讓人們<strong>覺得親切</strong>（尤其當註解是中文時），<strong>高品質的指引性註解確實會讓程式碼更易讀</strong>。有時抽象一個新函式，不見得就一定比一行註解加上幾行程式碼更好。</p></blockquote><p>第一段引用，其實就跟我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a>」中的主張一致：</p><blockquote><p>在我看來，無論程式寫得如何簡潔易讀，對一些比較複雜的函式或類別而言，docstring 終究是不可少的。<strong>因為文字的詮釋能力和程式碼相比，絕不在同一個層次</strong>，相信這也是為何 docstring 會有屬於自己的獨立 PEP 加以規範的理由。</p></blockquote><h3 id="我的看法與結論"><a href="#我的看法與結論" class="headerlink" title="我的看法與結論"></a>我的看法與結論</h3><p>既然都寫了這篇文章，想當然爾我是「<strong>支持</strong>」寫註解的一派。</p><p>不過，反對派說註解會<strong>增加維護難度</strong>，以及可能讓人<strong>更加依賴註解</strong>而忽略了提升程式碼品質，我覺得這些擔憂也<strong>非常真實</strong>。</p><p>所以，對我來說，問題不在於「要不要寫註解？」，而是<strong>「怎麼樣才能寫好註解？」</strong>。這也是本文想回答的問題。</p><p>我的結論是：寫註解，<strong>但也要適度</strong>。並保持對「<strong>讀者意識</strong>」的敏感：<strong>不寫多餘的註解，也不寫自言自語的註解。</strong></p><h3 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h3><ul><li><a href="https://www.explainthis.io/zh-hant/swe/a-philosophy-of-software-design/part3">《A Philosophy of Software Design》心得 3 — 寫程式時該寫註解 (comments) 嗎？如果要的話該怎麼寫？</a></li><li><a href="https://www.facebook.com/darkthread.net/photos/a.345323768929153/1185728258222029/">【程序員的日常】程式註解該寫多細？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/beoEztr.png&quot; alt=&quot;Python 工匠&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263245174&quot;&gt;Python 工匠｜案例、技巧與開發實戰&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;從書名推敲，我們並不容易知道本書的主題為何。事實上，和《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣&lt;/a&gt;》類似，這是一本關於「&lt;strong&gt;Clean Code in Python&lt;/strong&gt;」的書。&lt;/p&gt;
&lt;p&gt;而且我認為它的&lt;strong&gt;難度適中&lt;/strong&gt;（好吧，後半部難度比較高，而且本書&lt;strong&gt;「不適合」&lt;/strong&gt;初學者），非常推薦看完《Python 功力提升的樂趣》後，想要更進一步寫出 Pythonic 程式碼的讀者與開發人員。&lt;/p&gt;
&lt;p&gt;我覺得，兩本恰恰都是屬於「從書名看很容易被忽略」的好書。因此，作為喜歡本書的讀者，我覺得自己有&lt;strong&gt;義務&lt;/strong&gt;，向你們轉述書中一些值得傳誦的內容。&lt;/p&gt;
&lt;p&gt;這也是我寫「&lt;strong&gt;閱讀筆記&lt;/strong&gt;」類文章的核心精神——分享書中那些我覺得&lt;strong&gt;特別精彩、贊同的部分，並加上自己的看法。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/beoEztr.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="系列：Python 工匠" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%B7%A5%E5%8C%A0/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>為什麼你「不需要」所謂的人生管理系統</title>
    <link href="https://blog.kyomind.tw/less-is-more/"/>
    <id>https://blog.kyomind.tw/less-is-more/</id>
    <published>2024-01-21T20:33:14.000Z</published>
    <updated>2024-03-21T21:34:27.821Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/PwPTWYK.jpg" alt="by Myriam Wares"><span class="cap">by Myriam Wares</span></p><p>在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉一文與其所屬的「<a href="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion/">Simple Notion 系列</a>」中，我已用不少幅篇，明確表達我對這類「<strong>大而全</strong>」生產力系統的<strong>隱憂</strong>與<strong>質疑</strong>。</p><p>在其它文章中，也有過類似討論：</p><ul><li><a href="https://blog.kyomind.tw/four-thousand-weeks-01/">《人生 4 千個禮拜》筆記（一）病態的生產力</a></li><li><a href="https://blog.kyomind.tw/weekly-review-11/">11，我絕不當資訊的聚合者</a></li></ul><p>本文將進行一次「<strong>總結式</strong>」的整理，重新闡述<strong>不用這類系統的三大理由</strong>。並提出我認為相對可行的<strong>替代方案：局部實現</strong>。</p><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85">本文主旨與目標讀者</a></li><li><a href="#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D">所謂的「人生管理系統」</a></li><li><a href="#%E5%A4%A7%E7%B3%BB%E7%B5%B1%E7%9A%84%E5%85%A9%E5%80%8B%E7%89%B9%E5%BE%B5">大系統的兩個特徵</a></li><li><a href="#%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E8%A6%81%E9%80%99%E9%BA%BC%E7%94%A8">為什麼不要這麼用</a></li><li><a href="#3-%E5%80%8B%E3%80%8C%E4%B8%8D%E3%80%8D%E7%9A%84%E7%90%86%E7%94%B1">3 個「不」的理由</a></li><li><a href="#%E4%B8%80%E3%80%81%E6%88%90%E6%9C%AC%E9%81%8E%E9%AB%98%EF%BC%9A%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8%E7%9A%84%E4%BB%A3%E5%83%B9">一、成本過高：神兵利器的代價</a></li><li><a href="#%E4%BA%8C%E3%80%81%E9%81%A9%E5%BE%97%E5%85%B6%E5%8F%8D%EF%BC%9A%E5%81%9A%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%91%A3%E4%BA%8B">二、適得其反：做了更多瑣事</a></li><li><a href="#%E4%B8%89%E3%80%81%E7%B3%BB%E7%B5%B1%E6%9C%83%E8%A7%B8%E7%99%BC%E4%BD%A0%E3%80%8C%E8%BF%BD%E6%B1%82%E5%AE%8C%E6%95%B4%E3%80%8D%E7%9A%84%E6%9C%AC%E8%83%BD">三、系統會觸發你「追求完整」的本能</a></li><li><a href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%82%96%E8%AB%96">完整的悖論</a></li><li><a href="#%E8%88%89%E4%BE%8B%EF%BC%9ANotion-%E9%96%B1%E8%AE%80%E7%AE%A1%E7%90%86">舉例：Notion 閱讀管理</a></li><li><a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D">不必要的欄位</a></li><li><a href="#%E5%86%8D%E8%AB%96%E7%94%9F%E7%94%A2%E5%8A%9B%E9%81%94%E4%BA%BA">再論生產力達人</a></li><li><a href="#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE">更適合一般人的做法：局部實現</a></li><li><a href="#%E7%94%A8%E3%80%8C%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE%E3%80%8D%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1">用「局部實現」取代人生管理系統</a></li><li><a href="#%E7%B5%90%E8%AA%9E%EF%BC%9A%E6%8E%A5%E5%8F%97%E6%AE%98%E7%BC%BA%E8%88%87%E9%81%BA%E6%86%BE">結語：接受殘缺與遺憾</a></li></ol><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文想表達一個<strong>核心看法</strong>：</p><blockquote><p>打造大而全的「<strong>人生管理系統</strong>」，期望它全面提升你的生產力，<strong>可能不是一個好主意。</strong></p></blockquote><p>我知道，在這個資訊爆炸、快速變遷的時代，<strong>追求生產力</strong>幾乎可說是一種「<strong>顯學</strong>」。</p><p>這類系統也許為「<strong>少部分人</strong>」帶來了可觀的成就、自我掌控感，甚至是<strong>安全感</strong>。</p><p>因此他們能夠<strong>信誓旦旦</strong>地告訴你：「相信我！這是一個超棒的方法，而且你也能夠！」</p><p>老實說，連我自己都很難完全抗拒「高效、生產力」這類的主題，我想這是所有懷抱著自我期許之人的本能吧！</p><p>所以我並不打算阻止你去追求、建立屬於自己的<strong>生產力方法論</strong>。本文想要<strong>提醒</strong>的是——這些方法<strong>最好不要</strong>是「大而全」的那種，而是要能夠做到「<strong>取捨</strong>」。</p><p>不過，人生之難，就難在取捨。</p><span id="more"></span><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文目標讀者有二：</p><ol><li>像我一樣，已經一定程度地追逐過所謂「生產力工作流」的人，卻因此<a href="https://blog.kyomind.tw/simple-notion/#%E3%80%8C%E8%B3%A6%E8%83%BD%E5%BC%8F%E6%8C%AB%E6%95%97%E3%80%8D">感到失望或懷疑</a>，覺得<strong>並沒有從中獲得真正的提升</strong>。</li><li><strong>想提高生產力，還在這條路上摸索，尋找自己適合工具、方法的人。</strong></li></ol><p>對於這兩類讀者，我希望通過<strong>我的經驗和觀察</strong>，提供一個<strong>不同於「<a href="https://www.google.com/search?q=%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1">主流</a>」的視角</strong>。</p><p>一言以蔽之，我相信對大部分人而言，真正有效的提升並不在於建立一個龐大而複雜的系統。<strong>反而一些簡單的做法，往往更有效。</strong></p><hr><h2 id="所謂的「人生管理系統」"><a href="#所謂的「人生管理系統」" class="headerlink" title="所謂的「人生管理系統」"></a>所謂的「人生管理系統」</h2><p>文章一開始，我們需要對本文中提到的這類「<strong>系統</strong>」——或者應該稱為「<strong>提高生產力的方法論</strong>」，做出基本的定義。</p><p>從上古時期的 <a href="https://en.wikipedia.org/wiki/Getting_Things_Done">GTD</a>、到現在的 <a href="https://fortelabs.com/blog/para/">PARA</a>，以至於你在網路上、YouTube 影片中，所看到任何關於建立一套「<strong>流程</strong>」來<strong>組織與管理</strong>你的<strong>生產力活動</strong>（比如工作、學習、寫作），都算。</p><p>這些系統、方法論，往往都不打算只解決你一、兩個小問題，而是雄心壯志地宣稱<strong>可以改變你的人生</strong>。</p><p>藉由<strong>全方位自我管理</strong>，帶給你不同於以往的<strong>全新做事思維</strong>，讓你從<strong>混亂、瞎忙、事情做不完</strong>的焦頭爛額中<strong>解脫</strong>出來。</p><p>從此過上「<strong>高效、優雅、有目標</strong>」的充實生活。</p><p>聽起來對我們的人生真的很有幫助呢！☺️</p><p>所以我們姑且稱它為「人生管理系統」。</p><p>在這個強調終身學習的時代，這類系統也很常以「<strong>個人知識管理系統</strong>」的形式活躍，從 GTD（把事情做完）到 PARA（整理知識、有效學習），能看出時代的變遷。</p><hr><h2 id="大系統的兩個特徵"><a href="#大系統的兩個特徵" class="headerlink" title="大系統的兩個特徵"></a>大系統的兩個特徵</h2><p>這些方法論，往往具備<strong>兩個特徵</strong>，這也是它們可以自稱為「系統」的主要原因。</p><h3 id="一、複雜"><a href="#一、複雜" class="headerlink" title="一、複雜"></a>一、複雜</h3><p>所謂的複雜，指的是<strong>你幾乎很難一看就學會</strong>。往往還需要<strong>看書、上課，或者看一堆教學影片</strong>，才能慢慢領略其中具體的做法與精神。</p><p>總之，<strong>這個「系統」本身就是一套需要學習的方法。</strong></p><p>毫無疑問，在這個自媒體時代，這類系統的「<strong>最佳代言人</strong>」，就是眾多<strong>生產力 KOL</strong>。可能是一個 YouTuber，或生產力部落客。</p><p>他們會在 YouTube 或自己的部落格上，分享關於「<strong>如何建立與使用</strong>」這類系統的文章影片。再多一點，則是會有自己的<strong>課程</strong>或<strong>書籍</strong>。</p><h3 id="二、流程化"><a href="#二、流程化" class="headerlink" title="二、流程化"></a>二、流程化</h3><p>除了複雜，這類系統的另一個明顯的特徵——「<strong>流程化</strong>」。</p><p>遵循一定的<strong>規則、順序、條件</strong>，就像<strong>生產線</strong>一樣，把知識——或任何其它你需要處理、學習的事物——當作原料，透過<strong>一套完整的工具使用流程</strong>，讓它們變成「你的東西」，或產出相對應的成果。</p><p>想當然爾，<strong>這不會是簡單的幾個步驟</strong>，而是一整套宏大理論（甚至說是「<strong>信仰</strong>」可能也不為過），加上<strong>各式各樣實踐上的細節、建議</strong>所組成。</p><p>什麼！GTD、PARA 你都沒聽過？沒關係，因為本文要討論的，不是任何具體的生產力方法，也不是它們究竟有沒有效，而是<strong>更高層次的價值觀議題</strong>。</p><hr><h2 id="為什麼不要這麼用"><a href="#為什麼不要這麼用" class="headerlink" title="為什麼不要這麼用"></a>為什麼不要這麼用</h2><p>如「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E7%94%9F%E7%94%A2%E5%8A%9B%E8%BB%9F%E9%AB%94%E7%9A%84%E6%88%B0%E5%9C%8B%E6%99%82%E4%BB%A3">生產力軟體的戰國時代</a>」中所說，上述的系統或方法論，無一例外都是透過某一款<strong>筆記軟體</strong>（有時甚至是一整套工具）來實現，無論是 Notion 或 Evernote。</p><p>這可以理解，畢竟理論終歸是理論，還是需要工具來落實。以前可能是紙筆，但在這個時代，軟體、app 才是我們最常用的工具。</p><p>而本文要強調的則是「為什麼<strong>不要這麼用</strong>」這些軟體——<strong>不要</strong>在這些軟體之上，或好些軟體之間，建立一個<strong>複雜的工作流程</strong>。</p><blockquote><p><strong>不要在這些軟體之上，或好些軟體之間，建立一個複雜的工作流程。</strong></p></blockquote><hr><h2 id="3-個「不」的理由"><a href="#3-個「不」的理由" class="headerlink" title="3 個「不」的理由"></a>3 個「不」的理由</h2><p><strong>為什麼不？</strong></p><p>開頭的 3 篇文章中，都有提到不這麼做的理由，讓我搭配引述，重新為你疏理一番。</p><p>歸納起來，主要有下列 3 個理由。</p><p>特別提醒：用來落實本文中「系統」的工具，<strong>並不限於 Notion</strong>，只不過 Notion 可能是最常被使用、提及的工具而已。</p><h2 id="一、成本過高：神兵利器的代價"><a href="#一、成本過高：神兵利器的代價" class="headerlink" title="一、成本過高：神兵利器的代價"></a>一、成本過高：神兵利器的代價</h2><p>在「<a href="https://blog.kyomind.tw/simple-notion/#%E7%B6%AD%E6%8C%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8C%81%E7%BA%8C%E9%81%8B%E8%BD%89%EF%BC%8C%E6%98%AF%E5%80%8B%E3%80%8C%E9%AB%94%E5%8A%9B%E6%B4%BB%E3%80%8D">維持工作流持續運轉，是個『體力活』</a>」中，我是這麼說的：</p><blockquote><p>很遺憾，<strong>對這套「系統」每一天的落實、記錄，大多仍須由你「手動」執行</strong>。<br>　<br>哪怕 Notion 有 <strong>API 整合</strong>，可以省下一些時間。網路上也有眾多<strong>模板</strong>，供你直接套用。但是，你設計出來的工作流，<strong>其中最核心的部分，往往只能由你自己——手動維護。</strong></p></blockquote><p>而這些手動的功夫，勢必將帶來大量的時間、精力的消耗。<strong>系統愈大、愈是精巧，成本就愈高。</strong></p><p>我認為對大部分人而言，如此巨大的投入，<strong>幾乎很難獲得「相應」的回報。</strong></p><blockquote><p><strong>為什麼？</strong></p></blockquote><p>因為你其實<strong>不需要</strong>這麼多回報。</p><p>大部分時候，產出價值的關鍵在於「<strong>把事情做好</strong>」，而不是「做<strong>好多</strong>事情」。</p><p><strong>而就我所知，要把一些事情做好，並不需要太複雜的工具或管理技巧。</strong></p><p>不過話說回來，如果你的野心更大，想要「<strong>把好多事情都做好</strong>」，那可能確實需要這類系統。</p><p>然而，這樣的想法，也有其背後的<strong>隱憂</strong>——讓我們看第二個理由。</p><hr><h2 id="二、適得其反：做了更多瑣事"><a href="#二、適得其反：做了更多瑣事" class="headerlink" title="二、適得其反：做了更多瑣事"></a>二、適得其反：做了更多瑣事</h2><p><strong>時間成本</strong>，是採用「人生管理系統」的<strong>一大門檻</strong>，而且光是需要投入的時間成本，<strong>其實就足以勸退一半以上的嘗試者。</strong></p><p>其中的理由可想而知：<strong>因為太累了嘛！</strong>🤣</p><p>但是！如果你動力過人、積極實踐，並沒有因為成本而卻步。那第二個理由則是我們<strong>更需要關心的。</strong></p><p>我在「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1">效率陷阱</a>」中提到：</p><blockquote><p>有時候，這些<strong>額外增加的效率</strong>（生產力）就像是超商的「<strong>第二件 6 折</strong>」零食。平時你知道零食不健康，所以不會多買。<br>　<br>但有了這個折扣，我們往往忍不住，買更多——內心還覺得很划算。<br>　<br>正如前述，這些事如果不是「必須的」，那「提高對此事的生產力」，往往只是讓你花費更多時間，做那些<strong>本來就不需要做的事</strong>！——就像<strong>多吃了一堆零食</strong>。</p></blockquote><p>換句話說，如果你真的能「把好多事情都做好」，那你<strong>也</strong>很可能——<strong>且幾乎不可避免地</strong>——會增加做「<strong>不重要瑣事</strong>」的<strong>數量與比例</strong>。</p><p>而這些瑣事對<strong>整體產出的價值，當然是「有害」的！</strong></p><hr><p>你乍聽可能覺得：「會嗎？事情是否重要，我一直都是<strong>了然於心</strong>的啊！」</p><p>但我想說，現實恐怕沒有這般美好。</p><p>接下來的第三個理由，將會一定程度論證這一點：<strong>我們對事物重要性的判斷，並不總是那麼敏感。</strong></p><h2 id="三、系統會觸發你「追求完整」的本能"><a href="#三、系統會觸發你「追求完整」的本能" class="headerlink" title="三、系統會觸發你「追求完整」的本能"></a>三、系統會觸發你「追求完整」的本能</h2><p>還記得十多年前，超商非常流行的「<a href="https://www.foodnext.net/column/columnist/paper/5357454895">集點公仔收集</a>」活動嗎？</p><p>年輕的讀者可能沒什麼印象，這個熱潮當時真的流行了好幾年才慢慢消退。</p><p>仔細想想，為什麼會這麼流行？是因為這些公仔、飾品真的很吸引人嗎？這只是一部分原因。當然，也不乏對特定主題本來就有興趣的愛好者。</p><p>但其中一個<strong>不容忽視的要素</strong>是——<strong>我們對於「事物完整性」的本能追求</strong>：</p><blockquote><p>而純喫茶則是運用包裝上的瓢蟲元素，推出了一系列不同品種花紋的公仔，<strong>不少人也是特別去購買產品來完成收集的目標</strong>。</p></blockquote><p>「完成收集目標」意謂著，<strong>為什麼收集</strong>並不那麼重要，重要的是它<strong>必須被完成</strong>。</p><p>可想而知，對<strong>完整性</strong>的本能偏好，很可能會讓我們<strong>忽略</strong>，追求完整<strong>究竟是為了什麼？</strong></p><h3 id="系統讓人想要「更完整」"><a href="#系統讓人想要「更完整」" class="headerlink" title="系統讓人想要「更完整」"></a>系統讓人想要「更完整」</h3><p>那這個本能和「系統」有什麼關係？</p><p>系統，<strong>特別是那些複雜的「人生管理系統」</strong>，它的設計往往<strong>很容易激發</strong>我們追求完整的本能。</p><p>回顧一下我在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉提過的，那些鼓吹你入坑「人生管理系統」的<strong>迷人標語</strong>：</p><ul><li>我用 Notion <strong>高效管理工作與生活</strong>，告別瞎忙，重新找回人生主導權。</li><li>透過 Notion「<strong>打造○○系統、輕鬆整合✕✕</strong>」，讓我可以<strong>一站式管理一切</strong>。</li><li>Notion 幫助我<strong>實現夢想，完成目標</strong>，創造屬於我的美好人生。</li></ul><p>就算沒有真的實踐過，我們光看這些宣傳詞，<strong>想必也能合理推測：</strong></p><blockquote><p>這樣的系統，勢必要追求<strong>一定的完整性，才能有效應對不同面向上的各種需求</strong>——畢竟它可是要<strong>改變你的人生</strong>！</p></blockquote><p>結合不同功能模組（在 Notion 中就是許多 database），形成一套<strong>完整的「工作流」、「系統」</strong>，正是它們主要的<strong>設計思路</strong>。</p><hr><h2 id="完整的悖論"><a href="#完整的悖論" class="headerlink" title="完整的悖論"></a>完整的悖論</h2><p>這種大而全的設計思路，讓我們不自覺地想要<strong>填滿每一個環節上的空白、講究每一個角落的細節——即使這些細節對我們的整體目標並不重要。</strong></p><p>就像那些公仔收集活動一樣，系統<strong>觸發</strong>了我們對「完整性」的<strong>渴望</strong>，讓我們陷入了一種<strong>錯誤的追求方向</strong>——「我要把它們都收集完！」</p><p>在大系統中，我們可能花很多時間思考<strong>系統本身的設計、優化管理方法</strong>，而忽略了<strong>真正對我們重要的事情</strong>，也就是<strong>系統「本來」想達到的目的。</strong></p><p>追求完整的本能，再結合複雜的系統設計，<strong>最終可能導致我們的生產力「下降」，而非提升。</strong></p><p>到頭來，我們花費了太多時間在維護、優化系統，而非利用它來提升我們的生活品質或工作效率。</p><blockquote><p>這是<strong>我曾有過的經驗</strong>，不知你是否也熟悉？</p></blockquote><p>因此，與其說是<strong>完整的悖論</strong>，或許更適合稱之為——完整的「<strong>詛咒</strong>」。</p><hr><h2 id="舉例：Notion-閱讀管理"><a href="#舉例：Notion-閱讀管理" class="headerlink" title="舉例：Notion 閱讀管理"></a>舉例：Notion 閱讀管理</h2><p>我們舉一個<strong>典型且普遍</strong>的例子來感受一下，「追求完整」導致你花時間在鎖事上，真的<strong>比想像中的更容易發生。</strong></p><p>「<strong>用 Notion 做閱讀書籍的管理</strong>」這個需求場景，絕對是一搜尋就一大堆。在 YouTube 上搜尋「Notion 閱讀筆記」之類的關鍵字，能找到的相關影片更是多不勝數。</p><p>甚至不用搜尋，Notion 官方已經幫你收集了大量用戶提供的模板，供你直接套用：</p><ul><li><a href="https://www.notion.so/templates/category/books">Books templates</a></li></ul><p>並不是說，用 Notion 整理自己的閱讀清單、筆記有什麼問題。<strong>這絕對是好事。</strong></p><p>但如果你也有過類似的嘗試——用 Notion database 管理自己的閱讀清單。應該很容易發現，這個過程一不小心就可能會「<strong>走火入魔</strong>」。</p><p>一開始是書名、作者這類基本欄位，但隨著這個「系統」愈來感完整，<strong>你會很想要為它加入更多「點綴式」的資訊欄位</strong>，包括一些與排版設計有關的元素，比如封面、icon、顏色等等。</p><h2 id="不必要的欄位"><a href="#不必要的欄位" class="headerlink" title="不必要的欄位"></a>不必要的欄位</h2><p>簡言之，基於一種「完整記錄」的偏好，你可能會增加一些<strong>實際上沒多少用處</strong>，但會「<strong>讓人感覺很好、很完整</strong>」的欄位。</p><p>這些欄位在 Notion 閱讀管理資料庫中<strong>經常出現</strong>，但它們更多是<strong>為了追求「完整性」</strong>，而非<strong>實際的閱讀效益</strong>而設計，比如：</p><ol><li><strong>書籍封面圖片</strong>：封面圖片可以讓整個資料庫看起來<strong>更生動</strong>，但對於實際的閱讀和理解並沒有太大幫助。</li><li><strong>購買、借閱、開始、完成日期</strong>：記錄對這本書相關行動的時間點。</li><li><strong>出版資訊</strong>：包括出版社、出版年份等。</li><li><strong>多重標籤系統</strong>：例如創建多個標籤來分類書籍的主題、風格、情緒等，這增加了管理的複雜性，實際上的用處有限——<strong>不過確實讓人感覺很好XD</strong></li><li><strong>閱讀狀態</strong>：例如「想讀」、「正在讀」、「已讀」等狀態，這一定程度上有助於組織，但太複雜則會變成負擔，比如狀態有 5、6 種之多。</li><li><strong>引用和摘錄</strong>：對書中的特定段落或引言進行詳細記錄。我知道很多人喜歡！我也喜歡。對於學術工作或深入研究比較有用，但對於一般閱讀者而言，很可能只是增加了不必要的工作量。</li></ol><p>這些欄位雖然可以讓你的閱讀資料庫<strong>看起來很全面</strong>，但實際上，對<strong>提升閱讀體驗</strong>或<strong>增進理解</strong>往往<strong>沒有太大幫助</strong>（甚至可以說<strong>毫無關係</strong>）。反而讓你<strong>花費更多時間在製作、管理這些數據，而非真正的閱讀思考。</strong></p><p>讀書本來沒那麼複雜，不外乎<strong>明白一些事，然後有所行動</strong>。但工具可能讓它<strong>變得複雜</strong>，而「<strong>系統</strong>」更是如此。</p><p><img src="https://i.imgur.com/drRrybF.png" alt="工具可能讓閱讀變得複雜，而系統更是如此"><span class="cap">工具可能讓閱讀變得複雜，而系統更是如此</span></p><p><strong>最壞</strong>的情況是，我們被這些強大系統所<strong>吞噬</strong>，淪為「<strong>為系統工作</strong>」的人，而非利用系統的人。</p><hr><p>當然，上述只是最壞情況，而且情況總是在變動，不能一概而論。</p><p>但話說回來，那些知名的生產力達人，他們好像並沒有這樣的困擾？</p><p>確實，因為這些人是「凌駕於系統之上」的人。</p><p>下一段我們要討論，這類人和一般人，<strong>究竟有什麼不同。</strong></p><h2 id="再論生產力達人"><a href="#再論生產力達人" class="headerlink" title="再論生產力達人"></a>再論生產力達人</h2><p>下面舉例的瓦基和電腦玩物，都是我認為「<a href="https://blog.kyomind.tw/simple-notion/#%E5%81%A5%E5%BA%B7%E8%88%87%E7%97%85%E6%85%8B%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B">健康</a>」的生產力達人。以他們為例，有助於我們理解「生產力達人」的<strong>特質</strong>，以及<strong>為什麼——你可能無法成為他們。</strong></p><p>在「<a href="https://blog.kyomind.tw/simple-notion/#%E4%BD%A0%E6%98%AF%E5%93%AA%E4%B8%80%E7%A8%AE%E4%BA%BA%EF%BC%9F">你是哪一種人？</a>」中，我使用了「生產力狂魔」一詞來形容那些擁有強大生產力且<strong>能持續貫徹</strong>的人：</p><blockquote><p>你得承認，有些人就是<strong>紀律良好且生產力過人</strong>，一樣時間他們能產出數倍成果，且品質有保證。比如<a href="https://readingoutpost.com/">閱讀前哨站</a>站長「<a href="https://readingoutpost.com/about/">瓦基</a>」，在台積電當工程師時，他能利用下班時間完成大量書籍閱讀與心得輸出，週而復始，筆耕不綴，進而<a href="https://crossing.cw.com.tw/article/15467">實踐了自己的志業</a>。</p></blockquote><p>這裡改用「生產力達人」這個詞彙，更加中性。</p><p>上述的瓦基，或我們熟悉的<a href="https://www.playpcesor.com/">電腦玩物</a>站長，他們都擁有驚人的生產力，更可貴的是——<strong>持續產出</strong>的能力。</p><p>我相信，他們不太會受困於系統，因為：</p><blockquote><p>這樣的人有著<strong>很強的自我調節能力，能持續地調整自己的行為，讓自己不斷進步</strong>——近乎<strong>本能</strong>。</p></blockquote><p>相比於一般人，他們擁有「<strong>更遠大的目標</strong>」，他們是「<strong>利用系統</strong>」的人。</p><blockquote><p>不過，我同時也相信，<strong>這樣的人，只是少數</strong>。</p></blockquote><p>沒錯，我真心認為，這樣的人只是少數，而且<strong>只會是少數。</strong></p><h3 id="生產力達人終究只是少數"><a href="#生產力達人終究只是少數" class="headerlink" title="生產力達人終究只是少數"></a>生產力達人終究只是少數</h3><p>生產力達人<strong>當然不是天生的</strong>，但必定是經過<strong>不斷自我追求、精進而煉成。</strong>（不然這世界也太不公平😂）</p><p>而我認為，這種<strong>不斷追求</strong>生產力的<strong>動力與本能——很大程度是天生的。</strong></p><p><strong>這是一種非常強烈的價值觀偏好。</strong></p><p>對我們這些普通人來說，要達到生產力達人的輸出量，肯定相當困難，<strong>但並非不可能。</strong>然而，如果要「<strong>持續</strong>」為之，沒有一定的動力與本能，恐怕還是不行的。</p><blockquote><p><strong>大部分人對生產力的渴求，並沒有那麼強烈。</strong></p></blockquote><p>這就是為什麼我們需要<strong>更實用、更適合自己</strong>的管理方法，而非盲目追求那些<strong>「強大」</strong>的系統。</p><p>畢竟，最有效的生產力提升方法，應該是能幫助我們<strong>專注於真正重要的事情</strong>，而不是讓我們陷入<strong>無止境的系統維護、資訊收集和管理壓力</strong>中。</p><hr><h2 id="更適合一般人的做法：局部實現"><a href="#更適合一般人的做法：局部實現" class="headerlink" title="更適合一般人的做法：局部實現"></a>更適合一般人的做法：局部實現</h2><p><strong>絕對有人需要大系統，而且能利用它們做的很好。</strong>只不過，大部分人如果也想按照相同的方式來提升生產力，基於上述三大理由，恐怕將<strong>適得其反</strong>。</p><p>因此，我相信，對大多數人來說，一個<strong>更現實且可行</strong>的方法是「<strong>局部實現</strong>」。</p><h3 id="局部實現：不完整，但更有效"><a href="#局部實現：不完整，但更有效" class="headerlink" title="局部實現：不完整，但更有效"></a>局部實現：不完整，但更有效</h3><p>局部實現，是一種<strong>心法或價值觀</strong>，說穿了沒什麼，就是「<strong>緊扣著需求尋找並選定方法，需要多少才投入多少</strong>」。</p><p>更具體地說，它有兩大核心內涵。</p><h3 id="一、方法改進宜適可而止"><a href="#一、方法改進宜適可而止" class="headerlink" title="一、方法改進宜適可而止"></a>一、方法改進宜適可而止</h3><p>如果當前方法<strong>已能做出 80 分成果，一定程度滿足需求了</strong>，就<strong>不要</strong>再繼續追尋「更有效方法」——宜適可而止。</p><p>必須強調，這裡不是指結果一律只追求 80 分就好。</p><p>而是，如果結果已經有 80 分，但你想要進一步提升，<strong>建議不要試圖從「手段、方法」上去改進。更不需要去建立一個複雜的系統。</strong></p><p>無論什麼系統，對於已有 80 分的產出結果，<strong>很可能已不構成影響</strong>。再從方法上改進，企圖更進一步提升產出品質，往往只是緣木求魚。</p><h3 id="二、分別而非整體：謹慎關聯"><a href="#二、分別而非整體：謹慎關聯" class="headerlink" title="二、分別而非整體：謹慎關聯"></a>二、分別而非整體：謹慎關聯</h3><p>「系統」二字最讓我<strong>害怕</strong>的，就是它隱約<strong>暗示</strong>著系統的各個元件之間，存在著<strong>巧妙的「關聯」</strong>，所以它們能共同組合成一個「工作流」。</p><p>我的建議是：<strong>謹慎關聯</strong>。</p><p>可以的話，<strong>不要關聯，因為所有關聯都是有「代價」的。</strong></p><p>我還是要用 Notion 舉例，因為我比較熟。Notion 的資料庫關聯，無疑是強大的功能，但真的不宜濫用。</p><p>何謂濫用？那就是本來一個 db 就能完成的需求，因為可以「關聯」，所以你決定把它拆成兩個甚至更多 db 來做，因為這樣<strong>更條理分明</strong>，也更有「<strong>組合後的整體美感</strong>」——我就幹過這種事！而且還不止一次。</p><p>最後我往往還是把 db 砍到剩 1 個。因為<strong>實在太煩了</strong>。</p><blockquote><p>相關內容：</p><ul><li><a href="https://blog.kyomind.tw/stumbling-on-notion/#%E9%81%8E%E5%BA%A6%E8%A8%AD%E8%A8%88%EF%BC%9A%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E7%AD%86%E8%A8%98%E6%9E%B6%E6%A7%8B%E5%B8%AB">過度設計：人人都是筆記架構師</a></li><li><a href="https://blog.kyomind.tw/notion-database/#%E8%B3%87%E6%96%99%E5%BA%AB%E5%A4%AA%E5%A4%9A%E4%BA%86%EF%BC%81">資料庫太多了！</a></li></ul></blockquote><h3 id="對關聯的渴望"><a href="#對關聯的渴望" class="headerlink" title="對關聯的渴望"></a>對關聯的渴望</h3><p>為什麼總是<strong>忍不住</strong>想要關聯呢？</p><p>我想你也看出來了，對「關聯」的渴望，正是「追求完整」的本能所致——我們<strong>很喜歡</strong>事物「<strong>看起來像是一個整體</strong>」，更甚於它們只是一堆<strong>零散的部分</strong>。</p><blockquote><p><strong>所以必須把它們關聯起來。</strong></p></blockquote><p>追求完整往往帶來不必要的複雜，<strong>而「關聯」正是複雜小惡魔們誕生的溫床😈</strong></p><p>在我看來，對付複雜的最佳思維就是：<strong>各個擊破就好</strong>——不關聯，不整體。方法簡單、有效，<strong>能「恰如其分」解決問題</strong>，就是足夠好的方法。</p><p>當然，這會破壞一個大系統的「<strong>美感與整體感</strong>」，使之<strong>不再完整。</strong></p><p>對，我<strong>就是要</strong>破懷這樣的美感。</p><p>因為這種美感，正是讓我們「<strong>感覺良好</strong>」的來源，卻也是<strong>陷入困境</strong>的開端。</p><hr><h2 id="用「局部實現」取代人生管理系統"><a href="#用「局部實現」取代人生管理系統" class="headerlink" title="用「局部實現」取代人生管理系統"></a>用「局部實現」取代人生管理系統</h2><p>接下來<strong>以我自己為例</strong>，再聊聊更多「局部實現」的<strong>具體實作</strong>。</p><p><a href="https://blog.kyomind.tw/bear/#%E6%88%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E6%AC%BE%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94">我目前的主力筆記軟體</a>包括了 Notion 與 Logseq。說真的，這兩款軟體，都能創造出非常複雜的系統——它們在功能上皆強大而靈活。</p><p>但無論 Notion 還是 Logseq，「局部實現」策略都是可行的。</p><p>這意味著你可以在這些平台上建立<strong>特定的、專注於某一個或幾個目標的小流程</strong>，而不是一個涵蓋所有事情的龐大系統。</p><h3 id="我在-Notion-的局部實現"><a href="#我在-Notion-的局部實現" class="headerlink" title="我在 Notion 的局部實現"></a>我在 Notion 的局部實現</h3><p>Notion 中，我目前有在用的，<strong>只有一個</strong> database。用來管理我的寫作（主要）與個人 side project。</p><p><img src="https://i.imgur.com/BjE4elR.png" alt="Notion 寫作管理看板"><span class="cap">Notion 寫作管理看板</span></p><p>Notion 的簡易看板對我來說完全夠用，我不需要 Trello 這類更專業的專案管理軟體。</p><p>附帶一提，如果你有<strong>更加專業</strong>的「看板」需求，尤其是<strong>工作上的專案管理</strong>，千萬不要用 Notion，<strong>會很痛苦</strong>。</p><blockquote><p>我怎麼知道？望向工作上的 Notion 看板……🥲</p></blockquote><p>關於這個看板與 Notion 寫作，可參考：</p><ul><li><a href="https://www.facebook.com/kyomind/posts/pfbid03Zbm1vC5QGPVVeoH9YmhUBdmL88CW5whKtcwj2QssHHUyBT8oReRdSoytL3H2p1Gl">靠「看板」吧！</a>（臉書貼文，講述該看板誕生緣由）</li><li><a href="https://blog.kyomind.tw/my-markdown-writing-flow/">Notion + VS Code：我的 Markdown 寫作工作流</a>（講述我用 Notion 寫作部分，而且已經融入上述看板了）</li></ul><p>沒了，我主要就用 Notion 管理與進行「<strong>寫作</strong>」這一件事而已。</p><p>我以前也把很多事塞進 Notion，但我發現<strong>它能勝任的部分不多</strong>。很多事它都能做，但<strong>做的不是特別好</strong>——尤其是學習。</p><p>現在這樣的 Notion 用法，讓我非常喜歡且滿意。而設計上述看板需花多久的時間呢？<strong>應該不到半小時。</strong></p><p>使用看板的過程中，我嘗試過上述的「<strong>把一個資料庫拆成兩個，再互相關聯</strong>」，但始終<strong>沒有成功</strong>。（前後還試了兩次！😱）</p><p>用了一個月左右，我發現這樣簡單的看板，<strong>效果竟超乎想像的好——我的「發文紀律」明顯提升了！</strong></p><p>既然如此，這方法已經足夠，依「<strong>局部實現</strong>」思維，<strong>我也該適可而止了。</strong></p><h3 id="我在-Logseq-的局部實現"><a href="#我在-Logseq-的局部實現" class="headerlink" title="我在 Logseq 的局部實現"></a>我在 Logseq 的局部實現</h3><p>前面提到，Notion 對我的學習效果不是很好。</p><p>但我做筆記，最大的訴求就是學習，尤其是學習程式。所以我後來改用了 Logseq。</p><p>把<strong>學習用筆記軟體</strong>從 Notion 換成 Logseq 的具體緣由，我會再另篇討論。</p><p>而我現在用 Logseq 的學習方式，也很簡單：</p><ol><li>用 Logseq 寫學習筆記。大部分是<strong>程式相關</strong>，記錄實作時的<strong>踩坑經驗、重要知識、歸納與心得</strong>。認真寫筆記，對我<strong>幫助很大</strong>，可參考<a href="https://www.facebook.com/kyomind/posts/pfbid0sotiMpKkNWAR9w6kTyLeZj3LAF29qEhbiAfBWfHWyGU46EzAiozc3475ixYU47Azl">這篇臉書貼文</a>。</li><li>把上述筆記做成<strong>閃卡</strong>，按時複習。卡片的<strong>具體模樣</strong>，可參考<a href="https://www.facebook.com/fomo.kyo/posts/pfbid0KMyv8WAyMJSQBz8kvVQsmhXmHRspVknx3wwCcdjwvNJrH22bpZKZPMxcEZHECVJVl">這篇臉書貼文</a>。</li></ol><p>容我引用第二篇中的一段：</p><blockquote><p>程式開發時勤做筆記，把筆記切成一張張閃卡（flashcard），每天複習一些卡片。不用多，10-20 張就夠了<br>　<br>對我而言，是不錯的學習方式（我以前還很不以為然呢 XD）<br>　<br>經實測，它有助於我於更靈活運用這些開發知識。簡言之，我比以前「更容易想起」實作上要注意的細節，與其中的原理——因為我踩過這些坑、做了筆記，然後用閃卡複習</p></blockquote><p>Logseq 對我當然還有別的重要使用方式，比如記錄我的晚餐與當次用餐心得！但主要的大目標，就只有<strong>學習</strong>。</p><p>我從來不覺得自己正在使用什麼「系統」。</p><p>我覺得，<strong>筆記就只是筆記而已。</strong></p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a></p></blockquote><hr><h3 id="局部實現更可能讓工具為你所用，而不是被系統束縛"><a href="#局部實現更可能讓工具為你所用，而不是被系統束縛" class="headerlink" title="局部實現更可能讓工具為你所用，而不是被系統束縛"></a>局部實現更可能讓工具為你所用，而不是被系統束縛</h3><p>上述這些方法，說真的，都滿「<strong>平淡</strong>」的。我也不知道怎麼樣才能把它們寫得更 fancy 一點——可能是因為<strong>我沒有「系統」可言。</strong></p><p>採用「局部實現」思維，意味著你可以選擇最適合當前需求的工具和方法，從而使工具真正為你所用。<strong>因為這些方法都比較「小」，要用不用，皆操之在己。</strong></p><p>雖然系統提倡者們都不約而同地宣稱：精緻而完善的系統，能使人找回生活的主導權！（此時文案旁通常還要搭配一則<strong>漂亮的圖表</strong>，讓你感受「<strong>系統的整體之美</strong>」）</p><p><strong>但我不這麼看。</strong></p><p>我認為，相比於大系統，使用小方法的局部實現，更容易讓我專注於<strong>事物的本質</strong>，而非被系統所束縛。</p><p>回想一下，學習所謂「人生管理系統」的過程中，你是否曾有過這樣的<strong>自我懷疑</strong>：</p><blockquote><p><strong>我覺得這東西真的很棒！但是我不夠認真，所以還用不好。</strong></p></blockquote><p><strong>相信我——</strong></p><blockquote><p><strong>那很可能不是你的問題。</strong></p></blockquote><p>我誠摯認為，<strong>不值得</strong>再花費時間精力去<strong>折騰</strong>那些「<strong>看起來很棒</strong>，但<strong>實際效果極其有限</strong>」的系統、功能、模組。比如上述「<a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D">不必要的欄位</a>」。</p><p><strong>人生苦短</strong>，你完全可以把精力集中在<strong>真正重要的事情</strong>上，<strong>直接提高</strong>結果的品質。</p><hr><h2 id="結語：接受殘缺與遺憾"><a href="#結語：接受殘缺與遺憾" class="headerlink" title="結語：接受殘缺與遺憾"></a>結語：接受殘缺與遺憾</h2><p>我本來想要使用「<strong>擁抱</strong>」這個詞，但這詞常常被濫用在一些心靈雞湯中，情感上也不是非常協調。</p><p>因為殘缺或遺憾，<strong>都不是我們喜歡的東西（我們喜歡完整）</strong>，要「擁抱」它們，本身就已<strong>違反人性</strong>——太虛假。</p><p>而「<strong>接受</strong>」一詞則更貼切些，<strong>帶有幾分不捨，與幾分坦然</strong>，很適合。</p><p>我相信，我們面對「大系統」的心態，也是如此。</p><h3 id="「完整性」的誘惑"><a href="#「完整性」的誘惑" class="headerlink" title="「完整性」的誘惑"></a>「完整性」的誘惑</h3><p>前面講的我自己的局部實現案例，可以說，沒什麼特別之處，任何人都能做到。</p><p>不過連我自己在這個過程中，<strong>都還是很容易受到「完整性」的誘惑。</strong></p><p>我可是寫了這篇七千字長文，不斷提醒你要小心「完整性誘惑」的作者，但我自己還是會受到誘惑。只能說，<strong>本能的力量，真的很強大。</strong></p><p>當然我並非「系統愛好者」，所以不太可能被誘惑到去建立一個完整的系統。<strong>但不得不承認，我也常常很想要去「優化方法」。</strong></p><p>在此，我想要再次告訴你，<strong>也提醒我自己：方法真的沒那麼重要。</strong></p><p>大系統、工作流，<strong>真正讓人著迷的</strong>，往往是這些系統「<strong>本身</strong>」，而非其產出的結果。</p><p>人生管理系統就像一座<strong>壯麗的城堡，它的外觀、內部設計、各個房間的佈置，無不讓人陶醉其中。</strong>但這座城堡的<strong>主人</strong>——也就是你——<strong>卻未必快樂。</strong></p><h3 id="畫框與畫作"><a href="#畫框與畫作" class="headerlink" title="畫框與畫作"></a>畫框與畫作</h3><p>就像畫框與畫的關係，我們被<strong>精緻的畫框</strong>所吸引，甚至忘記了畫框的存在目的，是為了<strong>襯托畫作</strong>。</p><p>當然，話說回來，<strong>沒有方法確實不妥</strong>，但方法的改進，應適可而止。</p><p>上述看板就是很好的例子，它實在很簡單，簡單到不值一提，但對我寫作紀律的提升，大概從 0 分提高到了 60 分。</p><p>我還要<strong>繼續改進</strong>這個看板嗎？或許可以，或許不必。</p><p>寫文章並不是我的工作，如果能擁有 60 分的寫作紀律，且能夠持續保持，那我已<strong>相當自豪。</strong>這意味著我的「<strong>寫作畫框</strong>」已經<strong>足夠好了。</strong></p><h3 id="殘缺與遺憾"><a href="#殘缺與遺憾" class="headerlink" title="殘缺與遺憾"></a>殘缺與遺憾</h3><p>我認為，保持方法的殘缺與遺憾，是一種「<strong>高明的妥協</strong>」。</p><p>小方法比大系統更容易掌握，更可能讓我們<strong>專注於「畫作」本身</strong>。</p><p>接受殘缺並不意味著放棄進步，而是在進步的過程中，<strong>試著學會區分：哪些只是手段，而哪些才是本質。</strong></p><blockquote><p><strong>手段可以殘缺。唯有本質的完整，才值得我們一心追求——至死方休。</strong></p></blockquote><p>擺脫對系統的「<strong>依賴</strong>」後，甚至會發現，我們的生產力<strong>其實已經有了顯著的提升</strong>。這樣的提升，<strong>來自於我們對「自身局限」的理解和接受。</strong></p><p>這種心態的轉變，不僅提高了生產力，更重要的是：<strong>減少了不必要的壓力和焦慮。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/PwPTWYK.jpg&quot; alt=&quot;by Myriam Wares&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉一文與其所屬的「&lt;a href=&quot;https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion/&quot;&gt;Simple Notion 系列&lt;/a&gt;」中，我已用不少幅篇，明確表達我對這類「&lt;strong&gt;大而全&lt;/strong&gt;」生產力系統的&lt;strong&gt;隱憂&lt;/strong&gt;與&lt;strong&gt;質疑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在其它文章中，也有過類似討論：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/four-thousand-weeks-01/&quot;&gt;《人生 4 千個禮拜》筆記（一）病態的生產力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-11/&quot;&gt;11，我絕不當資訊的聚合者&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文將進行一次「&lt;strong&gt;總結式&lt;/strong&gt;」的整理，重新闡述&lt;strong&gt;不用這類系統的三大理由&lt;/strong&gt;。並提出我認為相對可行的&lt;strong&gt;替代方案：局部實現&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;本文目錄&quot;&gt;&lt;a href=&quot;#本文目錄&quot; class=&quot;headerlink&quot; title=&quot;本文目錄&quot;&gt;&lt;/a&gt;本文目錄&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85&quot;&gt;本文主旨與目標讀者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D&quot;&gt;所謂的「人生管理系統」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%A7%E7%B3%BB%E7%B5%B1%E7%9A%84%E5%85%A9%E5%80%8B%E7%89%B9%E5%BE%B5&quot;&gt;大系統的兩個特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E8%A6%81%E9%80%99%E9%BA%BC%E7%94%A8&quot;&gt;為什麼不要這麼用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-%E5%80%8B%E3%80%8C%E4%B8%8D%E3%80%8D%E7%9A%84%E7%90%86%E7%94%B1&quot;&gt;3 個「不」的理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E3%80%81%E6%88%90%E6%9C%AC%E9%81%8E%E9%AB%98%EF%BC%9A%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8%E7%9A%84%E4%BB%A3%E5%83%B9&quot;&gt;一、成本過高：神兵利器的代價&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E3%80%81%E9%81%A9%E5%BE%97%E5%85%B6%E5%8F%8D%EF%BC%9A%E5%81%9A%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%91%A3%E4%BA%8B&quot;&gt;二、適得其反：做了更多瑣事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89%E3%80%81%E7%B3%BB%E7%B5%B1%E6%9C%83%E8%A7%B8%E7%99%BC%E4%BD%A0%E3%80%8C%E8%BF%BD%E6%B1%82%E5%AE%8C%E6%95%B4%E3%80%8D%E7%9A%84%E6%9C%AC%E8%83%BD&quot;&gt;三、系統會觸發你「追求完整」的本能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%82%96%E8%AB%96&quot;&gt;完整的悖論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%88%89%E4%BE%8B%EF%BC%9ANotion-%E9%96%B1%E8%AE%80%E7%AE%A1%E7%90%86&quot;&gt;舉例：Notion 閱讀管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D&quot;&gt;不必要的欄位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%8D%E8%AB%96%E7%94%9F%E7%94%A2%E5%8A%9B%E9%81%94%E4%BA%BA&quot;&gt;再論生產力達人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE&quot;&gt;更適合一般人的做法：局部實現&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%94%A8%E3%80%8C%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE%E3%80%8D%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1&quot;&gt;用「局部實現」取代人生管理系統&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B5%90%E8%AA%9E%EF%BC%9A%E6%8E%A5%E5%8F%97%E6%AE%98%E7%BC%BA%E8%88%87%E9%81%BA%E6%86%BE&quot;&gt;結語：接受殘缺與遺憾&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;本文想表達一個&lt;strong&gt;核心看法&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;打造大而全的「&lt;strong&gt;人生管理系統&lt;/strong&gt;」，期望它全面提升你的生產力，&lt;strong&gt;可能不是一個好主意。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我知道，在這個資訊爆炸、快速變遷的時代，&lt;strong&gt;追求生產力&lt;/strong&gt;幾乎可說是一種「&lt;strong&gt;顯學&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;這類系統也許為「&lt;strong&gt;少部分人&lt;/strong&gt;」帶來了可觀的成就、自我掌控感，甚至是&lt;strong&gt;安全感&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此他們能夠&lt;strong&gt;信誓旦旦&lt;/strong&gt;地告訴你：「相信我！這是一個超棒的方法，而且你也能夠！」&lt;/p&gt;
&lt;p&gt;老實說，連我自己都很難完全抗拒「高效、生產力」這類的主題，我想這是所有懷抱著自我期許之人的本能吧！&lt;/p&gt;
&lt;p&gt;所以我並不打算阻止你去追求、建立屬於自己的&lt;strong&gt;生產力方法論&lt;/strong&gt;。本文想要&lt;strong&gt;提醒&lt;/strong&gt;的是——這些方法&lt;strong&gt;最好不要&lt;/strong&gt;是「大而全」的那種，而是要能夠做到「&lt;strong&gt;取捨&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;不過，人生之難，就難在取捨。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/PwPTWYK.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>為文章標註 Not By AI？ 我覺得大可不必</title>
    <link href="https://blog.kyomind.tw/not-by-ai/"/>
    <id>https://blog.kyomind.tw/not-by-ai/</id>
    <published>2024-01-14T16:37:05.000Z</published>
    <updated>2024-01-30T14:56:38.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/917fAxf.png" alt="notbyai.fyi"><span class="cap">notbyai.fyi</span></p><p>前陣子，我得知了「<a href="https://notbyai.fyi/">Not By AI</a>」這個徽章的存在。</p><p>它提倡為你的創作（以下都指文章）加上這個標籤，<strong>聲明是由人類所寫</strong>。</p><p>我們先看一下這個徽章的<a href="https://notbyai.fyi/#not-by-ai-mission">創立使命</a>（中文為 Google 翻譯）：</p><blockquote><p><strong>使命</strong><br>「Not By AI」徽章的創建是為了鼓勵更多的人製作原創內容並幫助用戶識別人類生成的內容。最終目標是確保人類繼續進步。<br>　<br>專家估計，到 2025 年，90% 的線上內容將由人工智慧產生。隨著人工智慧產生內容的激增，值得注意的是人工智慧是根據人類生成的內容進行訓練的。如果人類僅僅依靠人工智慧來產生前進的內容，那麼人工智慧產生的任何新內容都可能只是過去的內容的回收。這可能對人類進步構成重大障礙。只有限制對人工智慧的依賴並繼續創造原創內容才能推動我們作為一個物種向前發展。</p></blockquote><p>我乍一看覺得<strong>有點心動</strong>，而且作為一個長期創作的部落格作者，像「Not By AI」這種「自我主張型」的標籤，僅是在本能情感上，就有股莫名的吸引力。</p><p>但同時又覺得，好像哪裡<strong>怪怪的</strong>。</p><span id="more"></span><hr><h2 id="寫在前頭"><a href="#寫在前頭" class="headerlink" title="寫在前頭"></a>寫在前頭</h2><p>這篇文章與其說是討論「Not By AI」徽章的必要性，不如說是討論背後透露出的更大議題：「<strong>在人工智慧時代，我們該如何看待自己與 AI 的關係？</strong>」。</p><p>而「Not By AI」則是一個<strong>支點</strong>，讓我們可以從中展開討論。</p><p>換言之，它提供了一個<strong>具體的情境與切入視角</strong>，讓我們可以挖掘並獲得自己的思考、喜好、想法，進而發現自己在這個議題上的相關立場。</p><p>而本文表述<strong>我的立場。</strong></p><hr><h2 id="和-AI-討論「Not-By-AI」"><a href="#和-AI-討論「Not-By-AI」" class="headerlink" title="和 AI 討論「Not By AI」"></a>和 AI 討論「Not By AI」</h2><p>雖然我在情感上很想要直接使用這個徽章，但我的理性與直覺卻告訴我：<strong>先等等</strong>。</p><p>這個時候該怎麼辦？以前，你可以慢慢獨立思考，把一些可能的思考素材與蛛絲馬跡寫下來。但現在你有更好的夥伴了！——ChatGPT。</p><p>這個議題，我們直接問問 AI 吧！看看「它」怎麼說（這是我自己訂製的 GPT，回答的口吻比較機車一點，請多多擔待🙏）：</p><blockquote><p>這個「Not By AI」徽章，看起來像是一種懷舊情懷和對 AI 的不信任感結合的產物。實話實說，這種做法有點自欺欺人。當然，表明你的內容是純手工、未經 AI 處理的，<strong>對某些讀者來說可能有點吸引力</strong>，就像有機食品對某些消費者來說更有吸引力一樣。但別自欺了，這不過是一種行銷手段，<strong>實際上對內容的品質沒有任何保證。</strong><br>　<br>使命中提到限制對 AI 的依賴並繼續創造原創內容是推動人類進步的關鍵。<strong>這種觀點忽略了技術與人類創意的互補性</strong>。僅僅通過拒絕或限制 AI 的使用，無法推動人類在藝術、科學或任何其他領域的真正進步。相反，我們應該學會如何更好地利用 AI 來擴展我們的創作能力和視野。<br>　<br>我的建議？專注於創作高品質、有價值的內容。如果你的內容夠好，無論是不是 AI 生成的，讀者都會欣賞。別太在意這些浮華的徽章。真正的價值在於你的內容和你作為開發者的專業知識，而不是某個標籤。<strong>讓你的創作自己說話吧！</strong></p></blockquote><p>我覺得它講得很好，讓我豁然開朗。</p><p>這也是為什麼，在面對那些我認為重要的課題時，我一定會先跟 AI 討論一番——它帶給我的啟發，往往超乎想像。</p><hr><h2 id="我的兩個看法"><a href="#我的兩個看法" class="headerlink" title="我的兩個看法"></a>我的兩個看法</h2><p>參考上述 AI 的回答，我大致得出了自己的結論。</p><p>同時也明白，為什麼一開始，我雖然受到「Not By AI」徽章在情感上的吸引，但心裡卻始終覺得不自然、不自在。</p><p>我的看法如下。</p><h2 id="讀者或許沒那麼在意，文章是人還是-AI-寫的"><a href="#讀者或許沒那麼在意，文章是人還是-AI-寫的" class="headerlink" title="讀者或許沒那麼在意，文章是人還是 AI 寫的"></a>讀者或許沒那麼在意，文章是人還是 AI 寫的</h2><p>為了闡述好這個命題，我得從文章<strong>「作者」與「讀者」兩個角度</strong>分別討論。讀者角度，再依照不同的「<strong>閱讀目的</strong>」，說明為何大部分時候，讀者並不那麼在乎，文章是人還是 AI 寫的。</p><h3 id="作者角度"><a href="#作者角度" class="headerlink" title="作者角度"></a>作者角度</h3><p>身為作者，我非常希望自己的文章能夠做到邏輯清晰、文筆生動、內容對讀者有價值，最好還很有<strong>個人特色</strong>！</p><p>這是為什麼我看到「Not By AI」的號召時，會覺得心動：「作為茫茫人海中的一員，<strong>我想要被看見、被記得！</strong>」</p><p>但，這也只是我從作者角度的<strong>個人期望</strong>而已。</p><h3 id="讀者角度"><a href="#讀者角度" class="headerlink" title="讀者角度"></a>讀者角度</h3><p><strong>更多時候，我是一個讀者。</strong></p><p>當我是讀者，對於眼前這篇文章是人還是 AI 寫的，依<strong>不同的閱讀目的</strong>，我會有不同的在意程度。</p><h4 id="一、具有個人特色、經驗、感受的文章"><a href="#一、具有個人特色、經驗、感受的文章" class="headerlink" title="一、具有個人特色、經驗、感受的文章"></a>一、具有個人特色、經驗、感受的文章</h4><p>看這類文章，我通常是因為「<strong>喜歡或認同該作者</strong>」，比如《<a href="https://zebraletter.substack.com/">斑馬通信</a>》。此時我的確會在意，文章是出自人類之手。</p><p>這或許是「Not By AI」徽章對身為讀者的我而言，少數的價值。</p><p>但若再深挖一尺，會進一步發現：與其說我在意「<strong>文章是人類寫的</strong>」這件事，還不如說我<strong>真正在意</strong>的是「<strong>文章是『這個人』寫的</strong>」。</p><p>換句話說，如果文章是別人代筆，即使代筆的是人類，那也是不行的！</p><h4 id="二、實用性文章"><a href="#二、實用性文章" class="headerlink" title="二、實用性文章"></a>二、實用性文章</h4><p>前述文章只佔一小部分，我看的文章有 9 成以上，都屬於「實用性」文章。</p><p>這類文章，我更在乎寫得好不好、對我是否有幫助。作者是誰，則相對次要。</p><p>當然，能寫出好文章的作者，<strong>絕對值得被記住</strong>、讚賞、追蹤。我也希望能夠看到更多好文章。</p><p>好的作者，我會記得，慢慢的，他們的文章就變成了第一類文章。</p><p>但，這個作者，就非得是個「人」嗎？就算是 AI 寫的，只要寫得好，那為什麼我不追蹤、不多看呢？<strong>只因為文章不是出自人類之手？</strong></p><blockquote><p>這個理由，略嫌薄弱。</p></blockquote><p>綜上所述，作為一個讀者，我會記得那些，帶給我心情與智識上滿足感的作者們——但不是只有人類才能辦到。</p><p><strong>AI 也常常帶給我智識上的滿足感、讓我感到欣慰。</strong></p><hr><h2 id="標註「Not-By-AI」解決不了任何問題"><a href="#標註「Not-By-AI」解決不了任何問題" class="headerlink" title="標註「Not By AI」解決不了任何問題"></a>標註「Not By AI」解決不了任何問題</h2><p>如果「解決」二字太沉重，我們可以解讀成「改善」。</p><p>老實說，我覺得「Not By AI」徽章能夠改善的，大概只有「<strong>身為作者的焦慮感</strong>」——我們真的很怕被 AI 取代！</p><p>然而，為文章加上「Not By AI」標籤，對讀者而言，究竟可以改善什麼問題呢？</p><h3 id="文章的真實性？"><a href="#文章的真實性？" class="headerlink" title="文章的真實性？"></a>文章的真實性？</h3><p>顯然「Not By AI」徽章對改善文章「真實性」部分，幫不上忙。</p><p>因為不管是 AI 還是人類創造的內容，都有錯誤或造假的可能。現有的內容農場，不就是源自人類的惡意與對內容的不尊重？</p><p>甚至，這種標籤還可能會給讀者一種<strong>虛假的安全感</strong>，使我們降低身為一個讀者，對內容品質、真實的<strong>思考敏感度</strong>——人類寫的應該更可靠的，對吧？</p><h3 id="內容的品質與創新？"><a href="#內容的品質與創新？" class="headerlink" title="內容的品質與創新？"></a>內容的品質與創新？</h3><p>想當然爾，「Not By AI」不能保證內容的品質或創新，畢竟這個徽章本來就不是拿來聲明與內容品質相關的事項。</p><p>但是，如前所述，身為讀者，我更在乎的是內容本身。好的文章應該是具有深度、引人思考，或者提供新的視角，而這些特性與其是否由 AI 創作<strong>無關</strong>。</p><p>看完一篇文章，我看到了作者放的「Not By AI」徽章，我依舊不禁會想：「所以呢？這個『Not By AI』聲明，對我有實質幫助嗎？」</p><h3 id="「Not-By-AI」的重點就是它本身？"><a href="#「Not-By-AI」的重點就是它本身？" class="headerlink" title="「Not By AI」的重點就是它本身？"></a>「Not By AI」的重點就是它本身？</h3><p>我們當然可以說，上述這些問題，本來就不是「Not By AI」徽章的重點。畢竟它只是一個「<strong>聲明</strong>」，而非「解決方案」。</p><p>這個徽章的重點，就是它本身——強調由「人類」所創作。</p><p>我可以理解，但仍不禁好奇，這種強調，對讀者而言，真的有那麼重要嗎？讀者真的會因為看到「Not By AI」徽章，而<strong>更願意閱讀</strong>這篇文章嗎？</p><p>退萬步言，假設讀者<strong>真的更在乎</strong>「人類」創作的內容。<strong>可是，讀者要如何驗證，這個徽章「說的是真的」呢？</strong></p><p>比如，我可以為文章標示「Not By AI」，卻透過 AI 幫我產生大部分內容，只要修改到<strong>讓讀者看不出來</strong>就好。</p><hr><p>總的來說，我覺得「Not By AI」<strong>唯一的價值</strong>就是……<strong>讓作者感受到一絲心安與自豪。</strong></p><p>寫出一篇文章，絕對值得自豪。但我認為這種<strong>自豪感</strong>，應該來自於<strong>對內容本身的投入</strong>，而非只因為「<strong>這是我親手寫的喔！</strong>」。</p><p>所以，儘管本站的任一篇文章，都能夠符合「<a href="https://notbyai.fyi/#who-can-use-not-by-ai-badge">The Not By AI 90% Rule</a>」（9 成以上的內容由人類創作），我依舊不會放上「Not By AI」徽章。</p><p>我認為一個作者在創作與呈現作品時，強調「人類 vs AI」的二分法，對讀者而言，並沒有太大價值。</p><p>在我看來，文章內容真正的二分法，只有「好看 vs 不好看」而已。</p><p>如果真的想為自己的文章<strong>宣誓點什麼</strong>，除了「Not By AI」，我覺得也不妨考慮「<strong>本文寫了 4 小時</strong>」、「<strong>用生命創作</strong>」等徽章——我一定對你刮目相看👀</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我倒是不反對作者為自己的文章加上「Not By AI」標籤，甚至還會因此而<strong>多看兩眼</strong>。只是我知道，那就<strong>只是一個標籤</strong>而已。</p><p>作為一個讀者，我真正在乎的，只有<strong>作品本身帶給我的連結與共鳴</strong>，無論是人類創作，還是 AI 生成。</p><p>當然，有些事物是<strong>人類專屬</strong>的，比如某篇食記與對某道料理的感受。如果你告訴我這是「AI 親自去試吃的心得」，那我會感到<strong>十分無言</strong>🐸</p><p>但問題的關鍵始終不在於<strong>「誰寫的」</strong>，而在於<strong>「寫得怎麼樣」</strong>。</p><p>一篇文章能否觸動人心、提供有價值的見解，或帶來新的洞察，永遠是最重要的。</p><p>而一個簡單的「Not By AI」標籤，永遠無法帶給你這些答案或線索。</p><hr><h2 id="後記：為何我仍相信-AI"><a href="#後記：為何我仍相信-AI" class="headerlink" title="後記：為何我仍相信 AI"></a>後記：為何我仍相信 AI</h2><p>我並非一個 AI 樂觀主義者。</p><p>真要說的話，我應該屬於悲觀的那一方，身為一個軟體工程師，我時常擔憂，未來可能被 AI 取代。</p><p>但是，就像我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#AI-%E8%BC%94%E5%8A%A9%E5%AF%AB-Code">AI 輔助寫 Code</a>」中說的：</p><blockquote><p>不同的時代有不同的努力方式，作為一個 AI 時代的開發者，我們要學習<strong>與 AI 共舞。</strong></p></blockquote><p>活在這個時代，我所能選擇<strong>最好的努力方式</strong>，就是<strong>用心和 AI 協作</strong>。</p><p>事實上，本文的創作過程，就是我和 ChatGPT 不斷對話的過程。</p><p>我花費了大量時間與它交談、討論，甚至讓它挑戰我的觀點。如果沒有 AI，這篇文章會比你現在看到的更平庸且無聊得多——連我自己都不想看。</p><p>所以，我無法發自內心認為，為自己的文章加上「Not By AI」標籤，是一件值得自豪的事。（但我覺得這是一件「<strong>可愛</strong>」的事，所以我不反對你這麼做）</p><p>畢竟，一篇文章的好壞，最終還是要由讀者來評價。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/917fAxf.png&quot; alt=&quot;notbyai.fyi&quot;&gt;&lt;/p&gt;
&lt;p&gt;前陣子，我得知了「&lt;a href=&quot;https://notbyai.fyi/&quot;&gt;Not By AI&lt;/a&gt;」這個徽章的存在。&lt;/p&gt;
&lt;p&gt;它提倡為你的創作（以下都指文章）加上這個標籤，&lt;strong&gt;聲明是由人類所寫&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們先看一下這個徽章的&lt;a href=&quot;https://notbyai.fyi/#not-by-ai-mission&quot;&gt;創立使命&lt;/a&gt;（中文為 Google 翻譯）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使命&lt;/strong&gt;&lt;br&gt;「Not By AI」徽章的創建是為了鼓勵更多的人製作原創內容並幫助用戶識別人類生成的內容。最終目標是確保人類繼續進步。&lt;br&gt;　&lt;br&gt;專家估計，到 2025 年，90% 的線上內容將由人工智慧產生。隨著人工智慧產生內容的激增，值得注意的是人工智慧是根據人類生成的內容進行訓練的。如果人類僅僅依靠人工智慧來產生前進的內容，那麼人工智慧產生的任何新內容都可能只是過去的內容的回收。這可能對人類進步構成重大障礙。只有限制對人工智慧的依賴並繼續創造原創內容才能推動我們作為一個物種向前發展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我乍一看覺得&lt;strong&gt;有點心動&lt;/strong&gt;，而且作為一個長期創作的部落格作者，像「Not By AI」這種「自我主張型」的標籤，僅是在本能情感上，就有股莫名的吸引力。&lt;/p&gt;
&lt;p&gt;但同時又覺得，好像哪裡&lt;strong&gt;怪怪的&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/917fAxf.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
