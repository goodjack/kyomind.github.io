<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-01-14T19:32:42.402Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>為文章加上「Not By AI」標籤？ 我覺得大可不必</title>
    <link href="https://blog.kyomind.tw/not-by-ai/"/>
    <id>https://blog.kyomind.tw/not-by-ai/</id>
    <published>2024-01-14T16:37:05.000Z</published>
    <updated>2024-01-14T19:32:42.402Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/917fAxf.png" alt="notbyai.fyi"><span class="cap">notbyai.fyi</span></p><p>前陣子，我得知了「<a href="https://notbyai.fyi/">Not By AI</a>」這個徽章的存在。</p><p>簡單講就是為你的創作（以下都指文章）加上這個標籤，聲明是由人類所寫。</p><p>我們先看一下這個徽章的<a href="https://notbyai.fyi/#not-by-ai-mission">創立使命</a>（中文為 Google 翻譯）：</p><blockquote><p><strong>使命</strong><br>「Not By AI」徽章的創建是為了鼓勵更多的人製作原創內容並幫助用戶識別人類生成的內容。最終目標是確保人類繼續進步。<br>　<br>專家估計，到 2025 年，90% 的線上內容將由人工智慧產生。隨著人工智慧產生內容的激增，值得注意的是人工智慧是根據人類生成的內容進行訓練的。如果人類僅僅依靠人工智慧來產生前進的內容，那麼人工智慧產生的任何新內容都可能只是過去的內容的回收。這可能對人類進步構成重大障礙。只有限制對人工智慧的依賴並繼續創造原創內容才能推動我們作為一個物種向前發展。</p></blockquote><p>我乍看就覺得<strong>有點心動</strong>，而且作為一個長期創作的部落格作者，像「Not By AI」這種「自我主張型」的標籤，僅是在本能情感上，就有一股莫名的吸引力。</p><p>但同時又覺得，好像哪裡<strong>「怪怪的」</strong>。</p><span id="more"></span><hr><h2 id="和-AI-討論「Not-By-AI」"><a href="#和-AI-討論「Not-By-AI」" class="headerlink" title="和 AI 討論「Not By AI」"></a>和 AI 討論「Not By AI」</h2><p>雖然我在情感上很想要直接使用這個徽章，但我的理性與直覺卻告訴我：<strong>先等等</strong>。</p><p>這個時候該怎麼辦？以前，你可以慢慢獨立思考，把一些可能的思考素材與蛛絲馬跡寫下來。但現在你有更好的夥伴了！——ChatGPT。</p><p>沒錯，我們已經不需要像以前一樣，從頭開始思考——因為這很累、很辛苦，所以大多時候，我們會選擇「<strong>乾脆不思考</strong>」。</p><p>這個議題，直接問問 AI 吧！看看「它」怎麼說（這是我自己訂製的 GPT，回答的口吻比較機車一點，請多多擔待）：</p><blockquote><p>這個「Not By AI」徽章，看起來像是一種懷舊情懷和對 AI 的不信任感結合的產物。實話實說，這種做法有點自欺欺人。當然，表明你的內容是純手工、未經 AI 處理的，<strong>對某些讀者來說可能有點吸引力</strong>，就像有機食品對某些消費者來說更有吸引力一樣。但別自欺了，這不過是一種行銷手段，<strong>實際上對內容的品質沒有任何保證。</strong><br>　<br>使命中提到限制對 AI 的依賴並繼續創造原創內容是推動人類進步的關鍵。<strong>這種觀點忽略了技術與人類創意的互補性</strong>。僅僅通過拒絕或限制 AI 的使用，無法推動人類在藝術、科學或任何其他領域的真正進步。相反，我們應該學會如何更好地利用 AI 來擴展我們的創作能力和視野。<br>　<br>我的建議？專注於創作高品質、有價值的內容。如果你的內容夠好，無論是不是 AI 生成的，讀者都會欣賞。別太在意這些浮華的徽章。真正的價值在於你的內容和你作為開發者的專業知識，而不是某個標籤。<strong>讓你的創作自己說話吧！</strong></p></blockquote><p>我覺得它講得很好，讓我豁然開朗。</p><p>這也是為什麼，在面對那些我認為重要的課題時，我一定會先跟 AI 討論一番——它帶給我的啟發，往往超乎想像。</p><hr><h2 id="我的兩個看法"><a href="#我的兩個看法" class="headerlink" title="我的兩個看法"></a>我的兩個看法</h2><p>參考上述 AI 的回答，我已經大致得出自己的結論了。</p><p>同時也明白，為什麼一開始，我雖然受到「Not By AI」徽章在情感上的吸引，但心裡卻始終覺得不自然、不自在。</p><p>我的兩個看法如下。</p><h2 id="讀者或許沒那麼在意，文章是人還是-AI-寫的"><a href="#讀者或許沒那麼在意，文章是人還是-AI-寫的" class="headerlink" title="讀者或許沒那麼在意，文章是人還是 AI 寫的"></a>讀者或許沒那麼在意，文章是人還是 AI 寫的</h2><p>為了闡述好這個命題，我得從文章「作者」與「讀者」兩個角度分別討論。讀者角度，再依照不同的「<strong>閱讀目的</strong>」，說明為何大部分時候，讀者並不那麼在乎，文章是人還是 AI 寫的。</p><h3 id="作者角度"><a href="#作者角度" class="headerlink" title="作者角度"></a>作者角度</h3><p>身為作者，我非常希望自己的文章能夠做到邏輯清晰、文筆生動、內容對讀者有價值，最好還很有<strong>個人特色</strong>！</p><p>這是為什麼我看到「Not By AI」的號召時，會覺得心動：「作為茫茫人海中的一員，<strong>我想要被看見、被記得！</strong>」</p><p>但，這也只是從作者角度的<strong>個人期望</strong>而已。</p><h3 id="讀者角度"><a href="#讀者角度" class="headerlink" title="讀者角度"></a>讀者角度</h3><p><strong>更多時候，我是一個讀者。</strong></p><p>當我是讀者，對於眼前這篇文章是人還是 AI 寫的，依照<strong>不同的閱讀目的</strong>，我會有不同的在意程度。</p><h4 id="一、具有個人特色、經驗、感受的文章"><a href="#一、具有個人特色、經驗、感受的文章" class="headerlink" title="一、具有個人特色、經驗、感受的文章"></a>一、具有個人特色、經驗、感受的文章</h4><p>這類文章，我通常是因為「<strong>喜歡或認同該作者</strong>」所以才決定要看，比如《<a href="https://zebraletter.substack.com/">斑馬通信</a>》。此時我的確會在意，文章是出自人類之手。</p><p>這或許是「Not By AI」徽章對身為讀者的我而言，少數的價值。</p><p>但若再深挖一尺，我會進一步發現：與其說我在意「<strong>文章是人類寫的</strong>」這件事，還不如說我<strong>真正在意</strong>的是「<strong>文章是『這個人』寫的</strong>」。</p><p>換句話說，如果文章是別人代筆，即使代筆的是人類，那也是不行的！</p><h4 id="二、實用性文章"><a href="#二、實用性文章" class="headerlink" title="二、實用性文章"></a>二、實用性文章</h4><p>前述文章只佔一小部分，我看的文章有 9 成以上，都屬於「實用性」文章。</p><p>這類文章，我更在乎寫得好不好、是否對我有幫助。作者是誰，相對次要。</p><p>當然，能寫出好文章的作者，<strong>絕對值得被記住</strong>、讚賞、追蹤。我也希望能夠看到更多好文章。</p><p>但，這個作者，就非得是個「人」嗎？就算是 AI 寫的，只要寫得好，那為什麼我不追蹤呢？<strong>只因為文章不是出自人類之手？</strong></p><blockquote><p>我覺得這個理由略嫌薄弱。</p></blockquote><hr><p>綜上所述，作為一個讀者，我會記得那些，帶給我心情與智識上滿足感的作者們——但這並不是只有人類才能辦到。</p><p><strong>AI 也常常帶給我智識上的滿足感，而我因此感到欣慰。</strong></p><h2 id="標註「Not-By-AI」解決不了任何問題"><a href="#標註「Not-By-AI」解決不了任何問題" class="headerlink" title="標註「Not By AI」解決不了任何問題"></a>標註「Not By AI」解決不了任何問題</h2><p>如果「解決」二字太沉重，我們可以解讀成「改善」。</p><p>老實說，我覺得「Not By AI」徽章能夠改善的，大概只有「<strong>身為作者的焦慮感</strong>」——我們真的很怕被 AI 取代！</p><p>然而，為文章加上「Not By AI」標籤，究竟可以解決（改善）什麼問題呢？</p><h3 id="文章的真實性？"><a href="#文章的真實性？" class="headerlink" title="文章的真實性？"></a>文章的真實性？</h3><p>顯然「Not By AI」徽章對改善「真實性」部分，肯定幫不上忙。</p><p>因為不管是 AI 還是人類創造的內容，都有弄錯或造假的可能。現有的內容農場，不就是源自人類的惡意與對內容的不尊重？</p><p>甚至，這種標籤還可能會給讀者一種<strong>錯誤的安全感</strong>，使我們降低身為一個讀者，對內容品質、真實的<strong>思考敏感度</strong>——人類應該更可靠的，對吧？</p><h3 id="內容的品質與創新？"><a href="#內容的品質與創新？" class="headerlink" title="內容的品質與創新？"></a>內容的品質與創新？</h3><p>想當然爾，「Not By AI」不能保證內容的品質或創新，畢竟這個徽章本來就不是拿來聲明與內容品質相關的事項。</p><p>但是，如前所述，身為讀者，我更在乎的是內容本身。好的文章應該是具有深度、引人思考，或者提供新的視角，而這些特性與其是否由 AI 創作<strong>無關</strong>。</p><p>看完一篇文章，我看到了作者放的「Not By AI」徽章，我依舊會不禁想：「所以呢？這個『Not By AI』聲明，對我有實質幫助嗎？」</p><h3 id="「Not-By-AI」的重點就是它本身？"><a href="#「Not-By-AI」的重點就是它本身？" class="headerlink" title="「Not By AI」的重點就是它本身？"></a>「Not By AI」的重點就是它本身？</h3><p>我們當然可以說，上述這些問題，本來就不是「Not By AI」徽章的重點。它只是一個「<strong>聲明</strong>」，而非「解決方案」。</p><p>這個徽章的重點，就是它本身——強調「人類」的創作，以及「AI」的威脅。</p><p>我可以理解，但我仍不禁好奇，這種強調，對讀者而言，真的有那麼重要嗎？讀者真的會因為看到「Not By AI」徽章，而更願意閱讀這篇文章嗎？</p><p>退萬步言，假設讀者真的更在乎「人類」創作的內容。<strong>可是，讀者又怎麼知道這個徽章是真的呢？</strong></p><p>我可以為文章標示「Not By AI」，再讓 AI 幫我產生大部分內容，最後再修改到讓讀者<strong>看不出來</strong>就好。</p><hr><p>總的來說，我覺得「Not By AI」<strong>唯一的價值</strong>就是……<strong>讓作者感受到一絲心安與自豪。</strong></p><p>寫出一篇文章，絕對值得自豪。但我認為這種<strong>自豪感</strong>，應該來自於<strong>對內容本身的投入</strong>，而非只因為「<strong>這是我親手寫的喔！</strong>」。</p><p>所以，儘管本站的任一篇文章，都能夠符合「<a href="https://notbyai.fyi/#who-can-use-not-by-ai-badge">The Not By AI 90% Rule</a>」（9 成以上的內容由人類創作），我依舊不會放上「Not By AI」徽章。</p><p>我認為一個作者在創作與呈現作品時，強調「人類 vs AI」的二分法，對讀者而言，並沒有太大價值。</p><p>在我看來，文章內容真正的二分法，只有「好看 vs 不好看」而已。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>話說回來，我倒是不反對作者為自己的文章加上「Not By AI」標籤，甚至還會因此而<strong>多看兩眼</strong>。只是我知道，那就<strong>只是一個標籤</strong>而已。</p><p>作為一個讀者，我真正在乎的，只有<strong>作品本身帶給我的連結與共鳴</strong>，無論是人類創作，還是 AI 生成。</p><p>當然，有些事物是<strong>人類專屬</strong>的，比如某篇食記與對某道料理的感受。如果你告訴我這是「AI 親自去試吃的心得」，那我會感到<strong>十分無言</strong>🐸</p><p>但問題的關鍵始終不在於<strong>「誰寫的」</strong>，而在於<strong>「寫得怎麼樣」</strong>。</p><p>一篇文章能否觸動人心、提供有價值的見解，或帶來新的洞察，永遠是最重要的。</p><p>而一個簡單的「Not By AI」標籤，永遠無法帶給你這些答案或線索。</p><hr><h2 id="後記：為何我仍相信-AI"><a href="#後記：為何我仍相信-AI" class="headerlink" title="後記：為何我仍相信 AI"></a>後記：為何我仍相信 AI</h2><p>我並非一個 AI 樂觀主義者。</p><p>真要說的話，我應該屬於悲觀的那一方，身為一個軟體工程師，我時常擔憂，未來可能被 AI 取代。</p><p>但是，就像我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#AI-%E8%BC%94%E5%8A%A9%E5%AF%AB-Code">AI 輔助寫 Code</a>」中說的：</p><blockquote><p>不同的時代有不同的努力方式，作為一個 AI 時代的開發者，我們要學習<strong>與 AI 共舞。</strong></p></blockquote><p>活在這個時代，我所能選擇<strong>最好的努力方式</strong>，就是<strong>用心和 AI 協作</strong>。</p><p>事實上，本文的創作過程，就是我和 ChatGPT 不斷對話的過程。</p><p>我花費了大量時間與它交談、討論，甚至讓它挑戰我的觀點。如果沒有 AI，這篇文章會比你現在看到的更平庸且無聊得多——連我自己都不想看。</p><p>所以，我無法發自內心認為，為自己的文章加上「Not By AI」標籤，是一件值得自豪的事。（但我覺得這是一件「<strong>可愛</strong>」的事，所以我不反對你這麼做）</p><p>畢竟，一篇文章的好壞，最終還是要由讀者來評價。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/917fAxf.png&quot; alt=&quot;notbyai.fyi&quot;&gt;&lt;/p&gt;
&lt;p&gt;前陣子，我得知了「&lt;a href=&quot;https://notbyai.fyi/&quot;&gt;Not By AI&lt;/a&gt;」這個徽章的存在。&lt;/p&gt;
&lt;p&gt;簡單講就是為你的創作（以下都指文章）加上這個標籤，聲明是由人類所寫。&lt;/p&gt;
&lt;p&gt;我們先看一下這個徽章的&lt;a href=&quot;https://notbyai.fyi/#not-by-ai-mission&quot;&gt;創立使命&lt;/a&gt;（中文為 Google 翻譯）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使命&lt;/strong&gt;&lt;br&gt;「Not By AI」徽章的創建是為了鼓勵更多的人製作原創內容並幫助用戶識別人類生成的內容。最終目標是確保人類繼續進步。&lt;br&gt;　&lt;br&gt;專家估計，到 2025 年，90% 的線上內容將由人工智慧產生。隨著人工智慧產生內容的激增，值得注意的是人工智慧是根據人類生成的內容進行訓練的。如果人類僅僅依靠人工智慧來產生前進的內容，那麼人工智慧產生的任何新內容都可能只是過去的內容的回收。這可能對人類進步構成重大障礙。只有限制對人工智慧的依賴並繼續創造原創內容才能推動我們作為一個物種向前發展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我乍看就覺得&lt;strong&gt;有點心動&lt;/strong&gt;，而且作為一個長期創作的部落格作者，像「Not By AI」這種「自我主張型」的標籤，僅是在本能情感上，就有一股莫名的吸引力。&lt;/p&gt;
&lt;p&gt;但同時又覺得，好像哪裡&lt;strong&gt;「怪怪的」&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/917fAxf.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Django ORM：一對一、一對多外鍵教學（中）反向關聯</title>
    <link href="https://blog.kyomind.tw/reverse-relationships/"/>
    <id>https://blog.kyomind.tw/reverse-relationships/</id>
    <published>2024-01-06T17:07:40.000Z</published>
    <updated>2024-01-10T08:08:20.210Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a> 系列連載的第 2 篇。</p><p>搭配學習的範例程式碼，可參考 GitHub 專案：<a href="https://github.com/kyomind/Django-Tutorial">Django-Tutorial</a>。更多 Django 教學，請見「<a href="https://blog.kyomind.tw/django/">Django 文章總覽</a>」。</p><h3 id="系列：Django-ORM-外鍵入門"><a href="#系列：Django-ORM-外鍵入門" class="headerlink" title="系列：Django ORM 外鍵入門"></a>系列：Django ORM 外鍵入門</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/django-models/">Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</a></li><li><strong>Django ORM：一對一、一對多外鍵教學（中）反向關聯</strong></li></ol></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我們介紹完 Django ORM 的關聯設定，接下來本應該要進入查詢部分。不過，由於「反向關聯」在 ORM 查詢中扮演著十分重要的角色。</p><p>所以我決定專門寫這個（中）篇，好好介紹 Django ORM 中的「<strong>反向關聯</strong>」。</p><span id="more"></span><p>本文可以視為是第一篇的「<strong>補充</strong>」——對「反向關聯屬性」多加著墨。</p><p>不用說，這篇文章需要你先充分理解<a href="https://blog.kyomind.tw/django-models/">第一篇</a>的內容，再行閱讀。尤其是該文中的這三個部分：</p><ul><li><a href="https://blog.kyomind.tw/django-models/#related-name-%E8%88%87%E5%8F%8D%E5%90%91%E9%97%9C%E8%81%AF">related_name 與反向關聯</a></li><li><a href="https://blog.kyomind.tw/django-models/#related-name-%E5%9C%A8%E4%B8%80%E5%B0%8D%E5%A4%9A%E9%97%9C%E4%BF%82%E4%B8%AD%E7%9A%84%E9%87%8D%E9%BB%9E">related_name 在一對多關係中的重點</a></li><li><a href="http://localhost:4000/django-models/#related-name-%E7%9A%84%E9%A0%90%E8%A8%AD%E5%90%8D%E7%A8%B1">related_name 的預設名稱</a></li></ul><p>請務必熟悉。</p><hr><h2 id="理解反向關聯"><a href="#理解反向關聯" class="headerlink" title="理解反向關聯"></a>理解反向關聯</h2><p>我們可以從「正向關聯」來比較反向關聯，會更好理解。</p><p>在 Django ORM 中，正向關聯意指那些<strong>由我們明示定義的欄位</strong>，比如<code>ForeignKey</code>、<code>OneToOneField</code>等欄位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    <span class="comment"># 這是一個正向關聯欄位</span></span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><p>正向關聯屬性的<strong>最大特色</strong>是，它對應著資料庫 table 中的<strong>特定外鍵欄位</strong>。換句話說，它和 model 中的其它欄位一樣，都是「<strong>實體</strong>」的。</p><h3 id="反向關聯是「虛擬」的"><a href="#反向關聯是「虛擬」的" class="headerlink" title="反向關聯是「虛擬」的"></a><strong>反向關聯是「虛擬」的</strong></h3><p>而反向關聯是「<strong>虛擬</strong>」的。</p><p>所謂的「虛擬」，是指反向關聯<strong>並不直接對應於資料庫中的一個實際欄位</strong>。它只存在於 Django ORM 層面上，作為模型關係的一部分。</p><p>這種設計使得我們可以在不增加額外資料庫欄位的情況下，輕鬆地管理和查詢模型間的關係與對應的實例。</p><p>換言之，即使沒有反向關聯，我們<strong>還是可以</strong>透過標準 ORM 語法，查詢想要的資料——<strong>只是比較麻煩！</strong></p><p>反向關聯在「快速獲得關聯實例」這個需求場景，<strong>大大突顯</strong>了 ORM 查詢相對於原生 SQL 查詢的便利性。也讓你多增加了一個使用 ORM 的理由。</p><h3 id="反向關聯屬性的返回值"><a href="#反向關聯屬性的返回值" class="headerlink" title="反向關聯屬性的返回值"></a><strong>反向關聯屬性的返回值</strong></h3><p>根據關聯的類型，反向關聯的「屬性值」會有所不同。</p><p>在一對一關係中，反向關聯屬性返回的是一個的<strong>關聯模型實例</strong>。在一對多關係中，返回的是一個<code>QuerySet</code>（嚴格來說其實是<strong>關係管理器</strong>——<code>RelatedManager</code>），代表所有相關聯的模型實例集合。</p><p>這種彈性使得反向關聯成為 Django ORM 中一個極其強大且靈活的存在。</p><hr><p>好，講完了定義，我們趕緊來看，反向關聯屬性在實務上究竟是如何被使用。以及使用上的注意事項。</p><p>不過在此之前，我必須對原來範例程式碼中的 model 結構，做出一些<strong>調整</strong>。</p><h2 id="範例程式碼模型調整"><a href="#範例程式碼模型調整" class="headerlink" title="範例程式碼模型調整"></a>範例程式碼模型調整</h2><p>我要變更其中的「一對一」model 關係，因為原來的設計<strong>有兩個比較大的缺陷</strong>。我們先看看舊的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(<span class="string">&#x27;Title&#x27;</span>,</span><br><span class="line">                                 on_delete=models.PROTECT,</span><br><span class="line">                                 related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.title.main&#125;</span> - <span class="subst">&#123;self.title.subtitle&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Title</span>(models.Model):</span><br><span class="line">    main = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    subtitle = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.main&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure><p>第一個缺陷，是 Post 和 Title 的一對一關係，<strong>有違現實</strong>。</p><p>把 Title 變成一個關聯物件，是非常少見的。這不僅會讓讀者「難以想像」，無法感同身受。後續使用這模型來實作 API 時，這個設計不良問題會更加突顯。</p><p>所以，還是改成比較符合現實的版本——但又不能脫離「部落格文章關係模型」這個大框架，如何再想一個更「有感」的一對一關係，不禁又讓我苦思了一段時間。</p><p>和 ChatGPT 討論很多可能，始終找不到非常適合的例子。最後我決定這樣：把 Title 改為 Post 的一個欄位，這是比較尋常且合理的做法。</p><p>一對一部分，改用「Subtitle」模型替代。這樣一來，Post 就有了一個「可選」的副標題。</p><p>沒錯，為了突顯「<strong>反向關聯不存在</strong>」這個議題，Subtitle 必須是「可選」的。也就是<strong>不一定每篇文章都要有關聯的 Subtitle。</strong></p><p>原來的「Post - Title」關聯，就不是「可選」的——即<strong>兩者都一定要有</strong>。不能呈現一對一關係不存在時的情境，這是舊程式碼第二個缺陷。</p><h3 id="Subtitle-模型介紹"><a href="#Subtitle-模型介紹" class="headerlink" title="Subtitle 模型介紹"></a>Subtitle 模型介紹</h3><p>我們來到更新後的業務邏輯中。想像每一篇部落格文章，都一定會有標題，所以標題現在只是 Post 模型的一個欄位而已。</p><p>但是，如果你願意，你可以為這篇文章加上「<strong>副標題</strong>」，也就是關聯 Subtitle。這完全是「可選」的，加不加隨你。</p><p>如果你用過寫作平台 <a href="https://medium.com/">Medium</a>，就知道它的文章正是「副標題可選」的設定。</p><p>雖然新設計還是不盡理想，因為它和 Title 一樣，其實也可以只是 Post 的一個欄位就好。但無論如何，Subtitle 主要是為了讓本文可以舉例，它的存在價值與合理性，我們暫不深究。</p><p>這裡我們只需知曉一件事：Post 可能有關聯的 Subtitle，也可能沒有。且兩者是一對一關係。</p><h3 id="新模型關聯"><a href="#新模型關聯" class="headerlink" title="新模型關聯"></a>新模型關聯</h3><p>如上述修正後，新的<code>models.py</code>內容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.title&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可選的副標題</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtitle</span>(models.Model):</span><br><span class="line">    content = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    post = models.OneToOneField(Post,</span><br><span class="line">                                on_delete=models.CASCADE,</span><br><span class="line">                                related_name=<span class="string">&#x27;subtitle&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.content&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 留言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    post = models.ForeignKey(Post,</span><br><span class="line">                             on_delete=models.CASCADE,</span><br><span class="line">                             related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.content&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure><p>不知道你覺得如何？我感覺更加井然有序了！很適合用來作為教學文章解說的範例。</p><hr><p>接下來，我們就用上述的程式碼實例，來一一解說反向關聯。</p><h2 id="一對一反向關聯"><a href="#一對一反向關聯" class="headerlink" title="一對一反向關聯"></a>一對一反向關聯</h2><p>請看 Post 與 Subtitle 這兩個模型，它們是典型的一對一關係。</p><p>Subtitle 實例有著「正向關聯」屬性（欄位）——<code>post</code>，可以關聯 Post 模型的<strong>一個</strong>特定實例。</p><p>反之，Post 有著「反向關聯」屬性，即<code>related_name=&#39;subtitle&#39;</code>中的<code>subtitle</code>。不過，即使你沒有特別定義<code>related_name</code>，這裡的「預設」反向關聯屬性名稱，也是<code>subtitle</code>（即關聯模型名稱的「小寫」型態）。</p><p>圖形說明如下：</p><p><img src="https://i.imgur.com/zbZqGeh.png" alt="正向關聯與反向關聯"><span class="cap">正向關聯與反向關聯</span></p><h3 id="一對一反向關聯查詢重點"><a href="#一對一反向關聯查詢重點" class="headerlink" title="一對一反向關聯查詢重點"></a>一對一反向關聯查詢重點</h3><p>我們假設上述兩個模型的實例分別為<code>post_1</code>、<code>subtitle_1</code>。</p><p>想要查詢<code>post_1</code>所關聯的 Subtile 實例，有兩種方法，分別是<strong>一般查詢</strong>，與<strong>反向關聯查詢</strong>。</p><p>一般查詢方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtitle = Subtitle.objects.<span class="built_in">filter</span>(post=post_1)</span><br></pre></td></tr></table></figure><p>如前所述，即使沒有反向關聯，我們一樣可以得到我們想查詢的資料。</p><p>但透過反向關聯屬性，則會更加方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtitle = post_1.subtitle</span><br></pre></td></tr></table></figure><h3 id="一對一反向關聯不存在與錯誤錯理"><a href="#一對一反向關聯不存在與錯誤錯理" class="headerlink" title="一對一反向關聯不存在與錯誤錯理"></a>一對一反向關聯不存在與錯誤錯理</h3><p>一對一反向關聯有一個重點，那就是「關聯物件不存在時的錯誤處理」。</p><p>兩個「可以」建立關聯的模型物件，並非「一定要」建立關聯。因此，<code>post_1</code>的反向關聯屬性，不一定總是對應著一個 Subtitle 實例——有可能<strong>關聯不存在</strong>。</p><p>當關聯不存在時，訪問<code>post_1.subtitle</code>會引發<code>RelatedObjectDoesNotExist</code>例外。</p><p>考慮到「關聯不存在」的可能，我們的程式常常會這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    subtitle = post_1.subtitle</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中<code>ObjectDoesNotExist</code>是<code>RelatedObjectDoesNotExist</code>的父類別，因為你無法直接引用<code>RelatedObjectDoesNotExist</code>。</p><p>這種寫法雖然不算優雅，但它<strong>明確地表達了你的意圖</strong>。</p><hr><h2 id="一對多反向關聯"><a href="#一對多反向關聯" class="headerlink" title="一對多反向關聯"></a>一對多反向關聯</h2><p>一對多關係，我們要把目光放到 Post 與 Comment 這兩個模型。</p><p>其中 Post 是「一方」，而 Comment 則是「多方」。</p><p>一對多關係中，<code>ForeignKey</code>欄位<strong>肯定是實作在「多方」</strong>，所以上述程式碼，定義這個欄位的模型是 Comment：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    post = models.ForeignKey(Post,</span><br><span class="line">                             on_delete=models.CASCADE,</span><br><span class="line">                             related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="一對多反向關聯查詢重點"><a href="#一對多反向關聯查詢重點" class="headerlink" title="一對多反向關聯查詢重點"></a>一對多反向關聯查詢重點</h3><p>一樣，我們假設上述模型實例分別為<code>post_1</code>、<code>comment_1</code>。</p><p>其中<code>comment_1</code>有正向關聯屬性<code>post</code>（即 ForeignKey）。而<code>post_1</code>有「一對多」反向關聯屬性<code>comments</code>（從<code>related_name=&#39;comments&#39;</code>獲得）——注意這個複數。</p><p>同理，想獲得<code>post_1</code>所有關聯 Comment 實例，有一般查詢和透過反向關聯查詢。</p><p>一般查詢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments = Comment.objects.<span class="built_in">filter</span>(post=post_1)</span><br></pre></td></tr></table></figure><p>反向關聯查詢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure><h3 id="與一對一關係的區別"><a href="#與一對一關係的區別" class="headerlink" title="與一對一關係的區別"></a>與一對一關係的區別</h3><p>訪問一對一反向關聯屬性，會得到兩種可能：</p><ol><li>關聯物件。</li><li><code>RelatedObjectDoesNotExist</code>例外。</li></ol><p>而一對多的反向關聯，則<strong>只有一種可能：關係管理器物件</strong>（<code>RelatedManager</code>）。</p><p><code>RelatedManager</code>和<code>Manager</code>（即<code>.objects</code>的屬性值）類似，都是獲取 QuerySet 的「入口」。所以上述的<code>post_1.comments.all()</code>需要最後的<code>all()</code>方法，透過「關係管理器」再獲取「由關聯實例組成的 QuerySet」。</p><p>換句話說，光是呼叫<code>post_1.comments</code>本身，<strong>你只會得到「關係管理器」物件</strong>。記住這點，這將影響你對於「關聯不存在」時的處理。</p><h3 id="一對多反向關聯不存在"><a href="#一對多反向關聯不存在" class="headerlink" title="一對多反向關聯不存在"></a>一對多反向關聯不存在</h3><p>如果<code>post_1</code>有可能還沒有任何 Comment 關聯實例。那我們應該怎麼樣在程式中考慮進去呢？</p><p>我們第一個想到的可能是這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">if</span> comments:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上面這樣寫確實是可以的，當 QuerySet 為空，會被視為 falsy。不過更好、更 Django 的寫法則是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> post_1.comments.exists():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>然後千萬不要寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments</span><br><span class="line"><span class="keyword">if</span> comments:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>因為此時的<code>comments</code>變數內容是一個<strong>關係管理器物件</strong>，它一定會被視為 <a href="https://www.freecodecamp.org/news/truthy-and-falsy-values-in-python/">truthy</a>。意即這個判斷條件<strong>永遠會成立</strong>。</p><hr><h2 id="以「反向關聯是否存在」為查詢條件"><a href="#以「反向關聯是否存在」為查詢條件" class="headerlink" title="以「反向關聯是否存在」為查詢條件"></a>以「反向關聯是否存在」為查詢條件</h2><p>如果你想以「反向關聯是否存在」作為<strong>查詢的條件</strong>，比如我想查詢「<strong>沒有留言的文章</strong>」有哪些，要怎麼做呢？答案是——<code>isnull</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts_without_comments = Post.<span class="built_in">object</span>.<span class="built_in">filter</span>(comments__isnull=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>注意其中的<strong>雙底線</strong>，這是典型的 ORM 查詢條件使用方式。</p><p>同理，我想要查詢「<strong>有副標題（subtitle）的文章</strong>」則是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts_with_subtitle = Post.<span class="built_in">object</span>.<span class="built_in">filter</span>(subtitle__isnull=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>可以看到，上面兩個例子，都用透過 Post 的「反向關聯屬性」來進行過濾查詢——就像是一個普通的欄位一樣。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Django ORM 中的反向關聯，是 ORM 皇冠上的一顆明珠。</p><p>為什麼說 ORM 相對於原生 SQL 查詢更加優雅？從上述程式碼範例中，反向關聯無疑是最好的答案——像<code>post_1.subtitle</code>和<code>post_1.comments.exists()</code>這樣的語句，不僅簡潔，且非常可讀。</p><p>善用反向關聯，你將成為更加道地、成熟的 Django 開發者。</p><hr><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>我很少為自己的文章寫「後記」，不過仔細想想，為這篇好不容易才產出的文章寫點後記，也是值得的。</p><p>平常開發使用 Django ORM，其實也沒有想太多，只要「熟悉、習慣」就好。有時候用久了，對於常見的元素，甚至就不怎麼思考了。</p><p>但是！寫文章就不同了。為了向讀者解釋其中的細節，思考上不能草草帶過，至少要了解文中提到的部分，大概是怎麼一回事。</p><h3 id="創作流程與心得"><a href="#創作流程與心得" class="headerlink" title="創作流程與心得"></a>創作流程與心得</h3><p>為了完成這篇文章，我實際上做了這些事：</p><ol><li>先和 ChatGPT 討論文章架構、內容的取捨。同時我意識到了第一篇文章所提出的模型，在「一對一」部分有一開始提到的兩個設計缺陷。怎麼補救，也經過了一番取捨：<ol><li>第一種做法是另外提出不同的模型作為舉例，只適用於本篇，這個解法比較簡單。</li><li>第二種做法則是重新設計模型中的「一對一」部分。雖然比較辛苦，但對強化範例程例程式碼的整體感、完成度，更有助益。顯然，我選擇了後者。</li></ol></li><li>重新把塵封在 Notion 的 Django 筆記（Django ORM 部分）拿出來讀，大概有 2 萬字。雖然花時間，但我覺得很有幫助，難怪人家說寫文章一定會進步。<ol><li>以前做這些筆記，也複習過幾次，但最後還是不了了之。</li><li>趁這次機會，我把它們「移植」到 Logseq 上，以「閃卡」形式重見天日。我還發現，需要做成的卡片張數，原來並沒有我想像中的多。</li></ol></li><li>完成前兩步，最後才是把本文的內容生出來。但正因為有前兩步的鋪墊，這一步也走得相對踏實（雖然過程依舊不輕鬆）。</li></ol><p>總之，寫一篇文章真是不容易呀！希望它對你有所幫助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;https://blog.kyomind.tw/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 系列連載的第 2 篇。&lt;/p&gt;
&lt;p&gt;搭配學習的範例程式碼，可參考 GitHub 專案：&lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;Django-Tutorial&lt;/a&gt;。更多 Django 教學，請見「&lt;a href=&quot;https://blog.kyomind.tw/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;h3 id=&quot;系列：Django-ORM-外鍵入門&quot;&gt;&lt;a href=&quot;#系列：Django-ORM-外鍵入門&quot; class=&quot;headerlink&quot; title=&quot;系列：Django ORM 外鍵入門&quot;&gt;&lt;/a&gt;系列：Django ORM 外鍵入門&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/django-models/&quot;&gt;Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Django ORM：一對一、一對多外鍵教學（中）反向關聯&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇我們介紹完 Django ORM 的關聯設定，接下來本應該要進入查詢部分。不過，由於「反向關聯」在 ORM 查詢中扮演著十分重要的角色。&lt;/p&gt;
&lt;p&gt;所以我決定專門寫這個（中）篇，好好介紹 Django ORM 中的「&lt;strong&gt;反向關聯&lt;/strong&gt;」。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="ORM" scheme="https://blog.kyomind.tw/tags/ORM/"/>
    
    <category term="Django ORM" scheme="https://blog.kyomind.tw/tags/Django-ORM/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="系列：Django ORM 外鍵入門" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ADjango-ORM-%E5%A4%96%E9%8D%B5%E5%85%A5%E9%96%80/"/>
    
  </entry>
  
  <entry>
    <title>《人生 4 千個禮拜》筆記（一）病態的生產力</title>
    <link href="https://blog.kyomind.tw/four-thousand-weeks-01/"/>
    <id>https://blog.kyomind.tw/four-thousand-weeks-01/</id>
    <published>2023-12-23T18:05:48.000Z</published>
    <updated>2024-01-11T13:32:31.052Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/UNr2AmS.png"></p><p>這是《<a href="https://www.books.com.tw/products/0010914255">人生 4 千個禮拜</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上<strong>大量我個人的經驗與想法</strong>。</p><p>我認為，如果你不是書中描寫的這類人——<strong>在某些方面、某種程度上對追求生產力有過一定追求的人</strong>。那看本書很可能只覺得它像是<strong>一連串的高級雞湯文</strong>。</p><p>比如「接受人生有限」這樣的話，你可能早就聽過無數次，甚至已經麻木了。</p><p>然而，作者在書中把這類人在「生產力追求路上」所伴隨的種種「<strong>荒謬</strong>」與「<strong>弔詭</strong>」之處，精準地勾勒出來，令人拍案叫絕。</p><p>或許你不是這樣的人，沒關係，因為我（某種程度）是。</p><p>所以我會試著把這樣的努力與隨之而來的困境，盡可能展現出來，好比是種自嘲。就像〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉中的我。</p><span id="more"></span><h3 id="系列：人生-4-千個禮拜"><a href="#系列：人生-4-千個禮拜" class="headerlink" title="系列：人生 4 千個禮拜"></a>系列：人生 4 千個禮拜</h3><blockquote><ul><li>《人生 4 千個禮拜》筆記（一）病態的生產力</li></ul></blockquote><p>和「<a href="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%8A%9F%E5%8A%9B%E6%8F%90%E5%8D%87%E7%9A%84%E6%A8%82%E8%B6%A3/">系列：Python 功力提升的樂趣</a>」一樣，我們<a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E5%8F%AA%E8%AC%9B%E9%87%8D%E9%BB%9E">只講重點</a>。</p><p>再次提醒，本文中有相當部分屬於我自己的看法，而非單純書中觀點的整理。我會適度明示地區分這兩者，還請讀者留意。</p><p>本文整理書中的前言到第 2 章。</p><hr><h2 id="從成功學到生產力"><a href="#從成功學到生產力" class="headerlink" title="從成功學到生產力"></a>從成功學到生產力</h2><blockquote><p>本書的確又是一本談善用時間的書，但宗旨是我們所知的時間管理大慘敗，<strong>我們需要停止假裝那些方法有用。</strong></p></blockquote><p>作者 Oliver Burkeman 是《<a href="https://zh.wikipedia.org/zh-tw/%E8%A1%9B%E5%A0%B1">衛報</a>》的專欄作家，寫的正是有關「如何提高生產力」、「時間管理」等主題。</p><p>只不過他後來發現：這些所謂的「提高」，並不像想像中的那般美好。因此才有了本書的誕生。換言之，本書可說是他對自己與「提高生產力」這個議題的重新觀察、自我反省。</p><p>當然，也不是每一個人張口閉口都是生產力。但不可諱言地，現代人對生產力的重視與追求，確實與日俱增。</p><h3 id="從抽象到具體"><a href="#從抽象到具體" class="headerlink" title="從抽象到具體"></a>從抽象到具體</h3><p>以往書店的書架上，總有一櫃是滿滿的「自我提升」、「成功學」。現在當然還是有，但就我的觀察，它們更多被一大票「<strong>工具方法論</strong>」的書所取代了。比如電腦玩物站長的《<a href="https://www.books.com.tw/products/0010929730">防彈筆記法</a>》。</p><p>這是一個<strong>從抽象到具體</strong>的演化過程，也不難理解其中的緣由。</p><p>畢竟，無論是成功學還是自我提升，都是高度的抽象概念，很難有具體的方法可以直接照著做，而結果又很難驗證，它們都太空泛了！</p><p>這些內容已經無法滿足現代人，我們想要更加「<strong>看得到、摸得著</strong>」的東西，最好能立刻看到這些方法、工具的效果——於是我們有了「生產力」。</p><p>從抽象的「成功、自我提升」到具體的「<strong>提高生產力、時間管理</strong>」。</p><hr><h2 id="生產力至上"><a href="#生產力至上" class="headerlink" title="生產力至上"></a>生產力至上</h2><blockquote><p>最近幾年，我們被活出百分之百全效生活的建議給淹沒，市面上的書籍鼓勵我們做到《極度生產力》，《一週工作 4 小時》，還要《更聰明、更快、更好》。</p></blockquote><p>這些書暗示著：我們應該不斷地改進自己，讓自己變得更有效率，更有生產力。</p><blockquote><p>五花八門的網站要我們化身為「生活駭客」，好讓完成日常事務的時間能少個幾秒鐘（「生活駭客」一詞本身就是<strong>古怪的建議</strong>，彷彿你的人生頂多稱得上某種老是出錯的裝置，需要加以調整，不再處於未達最佳運轉的狀態）。</p></blockquote><p>你對上述現象可能不陌生，又或許你並不是這樣的人，甚至感到嗤之以鼻。</p><p>但這個世界上，確實有這麼一部分人（包括我），時常在乎「怎麼做會比較快？還能再快嗎？」等議題。</p><p>雖然我自認為不是一個追求極致生產力的人——遠遠不是。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-11/">11，我絕不當資訊的聚合者</a></p></blockquote><p>然而，我發現，追求生產力並不是只有「實踐」這個面向而已。有時候光是「空想」，就是一種<strong>貪婪</strong>。</p><p>而這樣的貪婪會帶來所謂的「<a href="https://zh.wikipedia.org/zh-tw/%E9%94%99%E5%A4%B1%E6%81%90%E6%83%A7%E7%97%87">FOMO</a>」（這裡指對資訊的錯失恐懼）與<strong>明顯的焦慮感</strong>。從這個角度看，我依舊深陷其中。所以我需要這本書。</p><hr><h2 id="現代生產力離不開工具"><a href="#現代生產力離不開工具" class="headerlink" title="現代生產力離不開工具"></a>現代生產力離不開工具</h2><p>這部分不是書中內容，而是我的看法。</p><p>生產力其實也不是什麼新概念，就算是幾千年前的人，也會追求怎麼「怎麼做事更快、更好」——只不過他們可能不是用「生產力」這個詞而已。</p><p>那為何現在「生產力」一詞已經成為顯學？</p><p>仔細想想，「生產力」一詞大概是這近 10 年才比較頻繁被使用、強調。這其中的差別究竟是什麼？</p><p>我認為關鍵的差別是「工具」——工具進化了。</p><h2 id="軟體即生產力"><a href="#軟體即生產力" class="headerlink" title="軟體即生產力"></a>軟體即生產力</h2><p>工具，尤其是電腦、網路時代的核心工具——<strong>軟體</strong>，和以往相比，已經大大地進化了。我們使用各式各樣軟體，來完成工作上的簡報、提案、包括我的程式碼。</p><p>這些軟體讓我們更有效率地完成任務，並且增加了我們的工作能力。當然，這也意味著我們需要學習和掌握更多的軟體技能。</p><p><strong>說穿了，我們其實就是把「使用這些軟體的產出成果」視為生產力。</strong></p><p><strong>而所謂「提高生產力」，某種程度就是指：提高我們對這些軟體的使用技巧、方法。</strong></p><p>這些軟體對現代人而言太過尋常，以致「生產力」一詞也變得如此普及、朗朗上口。</p><p>這樣的論述可能不夠全面，但我覺得在大方向上確實如此，你說呢？</p><h2 id="生產力軟體的戰國時代"><a href="#生產力軟體的戰國時代" class="headerlink" title="生產力軟體的戰國時代"></a>生產力軟體的戰國時代</h2><p>而在各式工具軟體中，哪一種更能成為生產力的代名詞？</p><p>如果是 2000 到 2010 年，所謂的生產力軟體，大概是指微軟 Office 系列——忘掉那個美好的上古時代吧！</p><p>2010 年代至今，毫無疑問，生產力軟體的代名詞，就是「<strong>筆記軟體</strong>」。</p><p>當然還有各式各樣讓你工作、生活更加「方便」的軟體，如：</p><ul><li>專案管理軟體：Trello、Asana。</li><li>個人時間管理軟體：Todoist、TickTick。</li><li>工作流程自動化軟體：Zapier、IFTTT。</li></ul><p>但筆記軟體絕對是其中的<strong>主角</strong>。</p><h2 id="筆記軟體為王"><a href="#筆記軟體為王" class="headerlink" title="筆記軟體為王"></a>筆記軟體為王</h2><p>筆記軟體是現代生產力舞台的主角，這點你可能很難否認。</p><p>比如時間管理，你聽過 GTD。目標管理，你聽過 OKR。甚至還有關於個人知識管理的 <a href="https://fortelabs.com/blog/para/">PARA Method</a>、卡片盒筆記法。太多太多了。</p><p>凡此種種，當你決定要<strong>實踐</strong>的時候，你幾乎都必須選擇一套筆記軟體來使用。（當然也是可以用紙本啦！不過，呃…你懂的）</p><p>難怪現代生產力 KOL 們，多離不開教你怎麼「高效使用」某某筆記軟體。彷彿不好好學習、善用這些工具，就要被時代拋棄。</p><hr><p>說得有點遠了，讓我們回到本書。</p><p>作者並沒有提及筆記軟體，但他也認為，善用各種技巧、產品，能讓你做事更快、更有效率，當下能帶給你強烈的掌控感——這種感覺真的很好！</p><blockquote><p>問題不在於這些技巧與產品沒用。它們確實有用。你可以完成更多事，趕去開更多會，送孩子去更多課後活動，替你的雇主賺更多錢。</p></blockquote><p>但接下來的故事可能就沒那麼迷人了。</p><blockquote><p>然而矛盾的是，成功後，我們得到的只有感到更忙碌、更焦慮，某方面來講還更空虛。</p></blockquote><h2 id="生產力的弔詭"><a href="#生產力的弔詭" class="headerlink" title="生產力的弔詭"></a>生產力的弔詭</h2><p>生產力最大的弔詭在於，當你學習了新技巧，新工具，把以往要花上 2 小時的事，在半小時內俐落地完成之後——你發現新任務以更快的速度進來了！</p><p>這描述有點誇張，但也有真實之處。</p><p>誇張的部分在於，不是每件都能夠藉由工具、技巧，大幅縮短所需要的時間。有些事——<strong>尤其是那些困難的事</strong>——就是需要佔用你大量的心力與精神。</p><p>能夠大幅縮短的，往往是一些瑣事。當然，我認為，能夠減少做瑣事的時間，絕對是好的、有益的。只要你確保你做的是「<strong>必要</strong>」的瑣事。</p><h3 id="工作是做的不完的"><a href="#工作是做的不完的" class="headerlink" title="工作是做的不完的"></a>工作是做的不完的</h3><p>而真實之處在於，我們都知道，工作——長期而言——是做不完的。你能夠做得更快，往往就會做得更多。</p><blockquote><p>美國人類學家愛德華．霍爾（Edward T. Hall）談到現代世界的時間，感覺就像是永遠不會停下的輸送帶，我們一送出完成的工作，就會冒出新工作。</p></blockquote><p>所謂變得「更有生產力」，似乎只是<strong>加快輸送帶的運轉速度</strong>，而不是讓我們變得比以前更加從容、有餘裕。</p><p>這裡的關鍵命題應該是：這些多出來的時間、多完成的工作，對你而言是否有足夠的價值？如果有，那生產力仍是值得追求的。</p><p>所以，我倒不認為作者說的「感到更忙碌、更焦慮，某方面來講還更空虛」現象一定會發生——這個描述有點太片面、太戲劇化了。</p><p>不過接下來的「效率陷阱」，則是本書的一大亮點。</p><hr><h2 id="效率陷阱"><a href="#效率陷阱" class="headerlink" title="效率陷阱"></a>效率陷阱</h2><blockquote><p>效率陷阱最糟糕的地方，在於「質」也會受到影響，你愈是努力塞進每一件事，<strong>你用在最沒意義的事情上的時間，反而會增多。</strong></p></blockquote><p>換言之，一旦你做某些事情的速度變快、變容易，你很可能會傾向<strong>做更多</strong>。</p><p>這真是一個巨大的諷刺，卻又如此的真實。</p><h3 id="第二件-6-折"><a href="#第二件-6-折" class="headerlink" title="第二件 6 折"></a>第二件 6 折</h3><p>有時候，這些<strong>額外增加的效率</strong>（生產力）就像是超商的「<strong>第二件 6 折</strong>」零食。平時你知道零食不健康，所以不會多買。</p><p>但有了這個折扣，我們往往忍不住，買更多——內心還覺得很划算。</p><p>正如前述，這些事如果不是「必須的」，那「提高對此事的生產力」，可能往往只是讓你花費更多時間，做那些<strong>本來就不需要做的事</strong>！——就像<strong>多吃了一堆零食</strong>。</p><p>我在〈<a href="https://blog.kyomind.tw/stumbling-on-notion/">少則得，多則惑：使用 Notion 時的兩個常見陷阱</a>〉提到的兩種典型情況，就屬於不必要的瑣事——卻能夠消耗你大量心力☺️</p><p>難怪文中不禁感嘆：</p><blockquote><p>但如果你讓我選，我寧可<strong>沒有這些自由</strong>——因為一不小心，就容易沉迷其中。</p></blockquote><hr><h2 id="再論「人生管理系統」"><a href="#再論「人生管理系統」" class="headerlink" title="再論「人生管理系統」"></a>再論「人生管理系統」</h2><p>書中這兩段話讓我特別有感：</p><blockquote><p>你要是採用<strong>超級有雄心壯志的時間管理系統</strong>，也就是那種承諾能搞定整張待辦清單的方法，<strong>你最後大概沒機會處理清單上最重要的事項。</strong></p></blockquote><p>上述「超級有雄心壯志的時間管理系統」，不正是所謂的「<a href="https://blog.kyomind.tw/simple-notion/#%E8%AA%B0%E7%94%A8-Notion-%E7%AE%A1%E7%90%86%E4%BA%BA%E7%94%9F%EF%BC%9F">人生管理系統</a>」？</p><p>我在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉中不建議你用 Notion 建立一個大而全的「人生管理系統」，主要理由是它的「<strong>維護成本太高</strong>」。</p><p>維護成本太高，是我認為這類「人生管理系統」的<strong>第一個重大隱憂</strong>。</p><h3 id="第二個隱憂"><a href="#第二個隱憂" class="headerlink" title="第二個隱憂"></a>第二個隱憂</h3><p>而本書作者提出了一個「<strong>更加高級</strong>」的切入視角。</p><p>換句話說，縱使「人生管理系統」的維護成本為 0（這當然不可能，不過這樣的假設有助於你理解，這類系統的「<strong>危險</strong>」之處），擁有這樣的系統，<strong>也未必是全是好事</strong>。</p><blockquote><p>你愈是堅定地說服自己，有足夠時間做每一件事，<strong>你就愈不會感到有必要質疑</strong>，從事某項活動<strong>是不是</strong>善用你一部分時間的最佳方法。</p></blockquote><p>於是待辦事項愈堆愈多。</p><p>仔細想想，這不正是另一種——<a href="https://blog.kyomind.tw/simple-notion/#%E7%84%A1%E6%89%80%E4%B8%8D%E8%83%BD%E7%9A%84%E3%80%8C%E8%A9%9B%E5%92%92%E3%80%8D">無所不能的「詛咒」</a>？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UNr2AmS.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.books.com.tw/products/0010914255&quot;&gt;人生 4 千個禮拜&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上&lt;strong&gt;大量我個人的經驗與想法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我認為，如果你不是書中描寫的這類人——&lt;strong&gt;在某些方面、某種程度上對追求生產力有過一定追求的人&lt;/strong&gt;。那看本書很可能只覺得它像是&lt;strong&gt;一連串的高級雞湯文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如「接受人生有限」這樣的話，你可能早就聽過無數次，甚至已經麻木了。&lt;/p&gt;
&lt;p&gt;然而，作者在書中把這類人在「生產力追求路上」所伴隨的種種「&lt;strong&gt;荒謬&lt;/strong&gt;」與「&lt;strong&gt;弔詭&lt;/strong&gt;」之處，精準地勾勒出來，令人拍案叫絕。&lt;/p&gt;
&lt;p&gt;或許你不是這樣的人，沒關係，因為我（某種程度）是。&lt;/p&gt;
&lt;p&gt;所以我會試著把這樣的努力與隨之而來的困境，盡可能展現出來，好比是種自嘲。就像〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉中的我。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/UNr2AmS.png" type="image"/>
    
    
    <category term="書評" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="閱讀心得" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="系列：人生 4 千個禮拜" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%BA%E7%94%9F-4-%E5%8D%83%E5%80%8B%E7%A6%AE%E6%8B%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python 開發：Ruff Linter、Formatter 介紹 + 設定教學</title>
    <link href="https://blog.kyomind.tw/ruff/"/>
    <id>https://blog.kyomind.tw/ruff/</id>
    <published>2023-12-17T17:41:36.000Z</published>
    <updated>2024-01-06T19:34:59.641Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/klPlw0x.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p><a href="https://github.com/astral-sh/ruff">Ruff</a> 從去年（2022）6 月正式開源起算，已過去一年半，知道此工具的開發者也愈來愈多。雖然在去年就聽過它，但我卻一直沒有任何行動。</p><p>隨著前陣子 <a href="https://github.com/astral-sh/ruff/releases/tag/v0.1.0">v0.1.0</a> 的發布（先別覺得這版本號怎麼乍看像早期測試版本🤣，畢竟前一版可是 v0.0.292），我覺得時機已到，所以進行了一番研究、嘗試，於是有了本文的誕生。</p><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E7%B7%A3%E8%B5%B7">緣起</a></li><li><a href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85">本文主旨與目標讀者</a></li><li><a href="#Why-Ruff%EF%BC%9F">Why Ruff？</a></li><li><a href="#%E6%9C%AC%E6%96%87%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC">本文範例程式碼</a></li><li><a href="#Ruff-%E4%BB%8B%E7%B4%B9%E7%AF%87">Ruff 介紹篇</a></li><li><a href="#Linter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Flake8-%E8%88%87-isort-%E7%AD%89%E7%AD%89">Linter 部分：取代 Flake8 與 isort 等等</a></li><li><a href="#Formatter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Black">Formatter 部分：取代 Black</a></li><li><a href="#%E5%96%AE%E3%80%81%E9%9B%99%E5%BC%95%E8%99%9F%E8%AD%B0%E9%A1%8C">單、雙引號議題</a></li><li><a href="#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87">Ruff 設定篇</a></li><li><a href="#pyproject-toml-%E8%A8%AD%E5%AE%9A">pyproject.toml 設定</a></li><li><a href="##Ruff-VS-Code-%E5%A5%97%E4%BB%B6%E8%A8%AD%E5%AE%9A">Ruff VS Code 套件設定</a></li><li><a href="#pre-commit-%E8%A8%AD%E5%AE%9A">pre-commit 設定</a></li><li><a href="#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87%E5%B0%8F%E7%B5%90">Ruff 設定篇小結</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1">工作上我還未採用 Ruff 的理由</a></li><li><a href="#%E7%B5%90%E8%AA%9E%EF%BC%9ATime-to-Ruff">結語：Time to Ruff</a></li></ol><span id="more"></span><hr><h2 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h2><p>工作上，我們團隊使用的 linter、formatter 分別是常見的 Flake8、isort、yapf。這在以往的文章有多次提及。</p><p>隨著 Ruff 的聲量與能見度日漸提高，作為一個 <a href="https://blog.kyomind.tw/tags/Code-Formatting/">Code Formatting</a> 愛好者，我自然也是躍躍欲試——最好是能夠直接應用到工作開發上！</p><p>因為團隊還不大（含我共 3 個後端開發者），所以改用 Ruff 是完全有可能的。</p><p>不過經過一番研究與考慮，我還是暫時推遲了工作上對 Ruff 的採用（只是把 formatter 從 yapf 換成 Black），原因會在<a href="#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1">文末說明</a>。</p><p>但是！我還是很推薦，<strong>從現在就開始使用 Ruff 作為你「個人開發」的預設 linter 甚至 formatter</strong>。而 Ruff 究竟有哪些吸引人之處？且容我娓娓道來。</p><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>我在〈<a href="https://blog.kyomind.tw/pre-commit/">pre-commit 設定 Git Hooks 教學：以 Flake8、isort、yapf 為例</a>〉曾提過：</p><blockquote><p>考慮到「pre-commit」這個主題已經有數篇文章珠玉在前，我下筆前都已拜讀完。<strong>本文的論述重心會盡可能與這些文章錯開，或乾脆直接引用，以降低不必要的重複感。</strong></p></blockquote><p>而 Ruff 也是如此，推薦你先讀過這篇〈<a href="https://myapollo.com.tw/blog/python-linter-ruff/">新世代的 Python Linter - Ruff</a>〉，然後再繼續閱讀本文，將有助於獲得<strong>更全面的理解</strong>。</p><p>接下來對 Ruff 的介紹，會有不同的側重與著墨，與更多的設定細節。</p><h3 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h3><p>本文主要分為三大部分：</p><ol><li>前言。</li><li>Ruff 介紹篇。</li><li>Ruff 設定篇。</li></ol><p>一開始不免俗地先講述我研究與使用 Ruff 的動機與理由，接著介紹 Ruff 的主要功能——linter 與 formatter。這也是它的最大賣點。</p><p>而「設定篇」著重的，則是在初步了解 Ruff 之後，如果真要採用它，我們還需要處理好哪些環節，才能在開發中流暢地使用它。</p><p>畢竟，<strong>開發工具的設定與整合</strong>，可算是本站文章的一大類型。☺️</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文的目標讀者有三：</p><ol><li>Python 開發中還沒有認真用過 linter、formatter 作為規範工具，想要開始導入，並希望用 Ruff 一次解決的人。</li><li>長期使用「<strong>Flake8 + isort + Black</strong>」這套 Python 開發經典組合，對 Ruff 有高度興趣，想要試試看的人。</li><li>Code Formatting in Python 愛好者。</li></ol><p>這篇文章是寫給「已經用 Python 開發一段時間」的人，而非 Python 初學者。</p><p>不過話說回來，如果初學者一開始就肯使用 Ruff 好好規範自己所寫的 Python code，不正是一個絕佳的開端嗎？😎</p><hr><h2 id="Why-Ruff？"><a href="#Why-Ruff？" class="headerlink" title="Why Ruff？"></a>Why Ruff？</h2><p>什麼是 Ruff，一句話說就是：</p><blockquote><p>An extremely fast Python linter and code formatter, written in Rust.</p></blockquote><p>而我認為採用 Ruff 主要基於下面兩大理由。</p><h3 id="一、快，就是快"><a href="#一、快，就是快" class="headerlink" title="一、快，就是快"></a>一、快，就是快</h3><p>下圖來自 <a href="https://github.com/astral-sh/ruff">Ruff 的 GitHub 首頁</a>，很好表達了為何要採用 Ruff——因為快。</p><p><img src="https://i.imgur.com/rjPXQg4.png"></p><p>用 Rust 寫的，快，自然不在話下。</p><p>而「極致的快」在很多時候會大幅改變你做事的方式——不過這對於大型專案可能才更有感。</p><p>對於中、小型專案，我覺得以下第二個理由更加重要。</p><h3 id="二、All-in-One：整合眾多套件"><a href="#二、All-in-One：整合眾多套件" class="headerlink" title="二、All-in-One：整合眾多套件"></a>二、All-in-One：整合眾多套件</h3><p>不止是速度，Ruff 的「整合」能力也不可小覷。</p><p>按照官方文件，有了 Ruff 後，以下的工具都不必再安裝了：</p><ul><li><a href="https://pypi.org/project/flake8/">Flake8</a> 和一堆 Flake8 外掛</li><li><a href="https://github.com/psf/black">Black</a></li><li><a href="https://pypi.org/project/isort/">isort</a></li><li><a href="https://pypi.org/project/pydocstyle/">pydocstyle</a></li><li><a href="https://pypi.org/project/pyupgrade/">pyupgrade</a></li><li><a href="https://pypi.org/project/autoflake/">autoflake</a></li><li>還有更多！</li></ul><p>想想是不是有一點「<a href="https://blog.kyomind.tw/pyproject-toml/#pyproject-toml-%E4%BB%8B%E7%B4%B9">pyproject.toml</a>」的味道呢？</p><p>上述這些工具，尤其是最常用的 Flake8、isort、Black，如果現在只需要用一個工具就能實現，而且還更快、更好。</p><p>那我們何樂而不為？</p><h2 id="本文範例程式碼"><a href="#本文範例程式碼" class="headerlink" title="本文範例程式碼"></a>本文範例程式碼</h2><p>本文中所提到的 Ruff 設定具體內容，包括 pyproject、VS Code、pre-commit 部分，都會加到 <a href="https://github.com/kyomind/Django-Tutorial">Django-Tutorial</a> 這個專案中。</p><p>它是我「<a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a>」系列文章的範例程式碼，恰好也適合作為其它教學文章的實際素材展示。</p><p><code>git clone</code>本專案後，可以直接<code>git checkout</code>到<code>02-ruff</code>分支。這個分支所在的 commit，就是本文的具體設定內容與改動。</p><p>你也可以直接在 GitHub 上查看 <a href="https://github.com/kyomind/Django-Tutorial/commit/42a5a678ba5fbcc38f4463f593fad024636941ec">commit 內容</a>。</p><hr><p>前言結束，接下來我們進入正題。首先是對 Ruff 的整體介紹。</p><h2 id="Ruff-介紹篇"><a href="#Ruff-介紹篇" class="headerlink" title="Ruff 介紹篇"></a>Ruff 介紹篇</h2><p>Ruff 是一個 Python linter + formatter，雖然大部分人可能只使用它的 linter 部分，因為 formatter 還處於 beta 階段。</p><p>Ruff formatter 是一個相對獨立的功能，在開源後才開始建構。你完全可以只用 Ruff 的 linter，而依舊使用 Black 或 yapf 來格式化程式碼。</p><p>不過，即使只看 Ruff 的 linter 部分，它也並不是一個「單純的 linter」而已。因為它的實際行為超過了<strong>靜態分析</strong>（static analysis）。</p><p>所以，想要全面了解 Ruff，我們需要具體知曉：它究竟能夠做到哪些事、取代哪些工具。</p><h2 id="Linter-部分：取代-Flake8-與-isort-等等"><a href="#Linter-部分：取代-Flake8-與-isort-等等" class="headerlink" title="Linter 部分：取代 Flake8 與 isort 等等"></a>Linter 部分：取代 Flake8 與 isort 等等</h2><p>Ruff 的核心部分就是它的 linter，這點無庸置疑。</p><p>而 Flake8 作為 Python 開發中最流行的 linter，自然是 Ruff 首要取代的目標。所以 Ruff 連錯誤代碼都盡可能與 Flake8 一致，也是考慮到遷移的成本。</p><h3 id="Autofix-功能"><a href="#Autofix-功能" class="headerlink" title="Autofix 功能"></a>Autofix 功能</h3><p>不僅如此，Ruff 還能取代一眾「<strong>帶有 formatter 功能的 linter</strong>」，isort 就是其中的代表。而常見的 <a href="https://github.com/asottile/pyupgrade">pyupgrade</a> 也是。</p><p>這就有趣了，從這點可知，即使你沒有使用 Ruff 的 formatter 功能，它的 linter 部分還是<strong>帶有一定的 format 能力</strong>——其實就是 <a href="https://docs.astral.sh/ruff/linter/#fixes">autofix</a>。</p><p>這個特性<strong>真的很方便</strong>，但也帶來了一定的複雜。</p><p>方便的是，你可以只安裝 Ruff linter，就<strong>獲得多種 linter 附帶的 format 行為</strong>。而複雜則在於：設定上的細節也比一般 linter 更多。</p><h3 id="簡易版-formatter"><a href="#簡易版-formatter" class="headerlink" title="簡易版 formatter"></a>簡易版 formatter</h3><p>我原本以為 Ruff（不考慮<code>ruff-format</code>部分）只是一個比較快的靜態分析工具，顯然事實並非如此。</p><p>總之，我們只要記得：<strong>Ruff linter 有著簡易 format（autofix）能力</strong>——它是個簡易版的 formatter。</p><p>這和 Flake8 只做單純的靜態分析不同，Ruff linter 在檢查過程中，<strong>能夠直接對程式碼進行修改</strong>。當然，如果你不喜歡，這功能是可以關閉的。</p><hr><h2 id="Formatter-部分：取代-Black"><a href="#Formatter-部分：取代-Black" class="headerlink" title="Formatter 部分：取代 Black"></a>Formatter 部分：取代 Black</h2><p>我相信從 Ruff 的開源之初，就已經想過要成為一個 All-in-One 工具。畢竟 Rust 這麼快，只做 linter 未免太可惜了！</p><p>和 linter 不同，formatter 具有<strong>強烈的排它性</strong>。不同的 formatter 之間，<strong>沒有相容可言</strong>。不像 linter 還可以疊加使用——如果你不嫌煩XD。</p><p>如果寫一個全新的 formatter，就必須要有足夠的理由，讓開發者願意放棄當前方案，採用你的新工具——這很不容易。</p><p>比較可行的做法，是<strong>相容並取代</strong>市場上現有的 formatter。</p><p>既然要選一個，那當然是選 <a href="https://github.com/psf/black">Black</a>——目前最流行的 Python formatter。</p><blockquote><p>Black Formatter 相關文章：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a></li><li><a href="https://blog.kyomind.tw/flake8-and-black/">VS Code：Python Flake8 與 Black Formatter 擴充套件快速上手</a></li></ul></blockquote><h3 id="和-Black-的相容性"><a href="#和-Black-的相容性" class="headerlink" title="和 Black 的相容性"></a>和 Black 的相容性</h3><p>因此，和對待 Flake8 一樣，Ruff formatter 必須與 Black 格式化後的結果，有<strong>高度的相容</strong>（一致）。否則你換了它的 formatter，卻帶來一堆格式化結果改動，絕對會造成遷移負擔與採用意願的下降。</p><p>按照官方文件中「<a href="https://docs.astral.sh/ruff/formatter/#black-compatibility">Black compatibility</a> 」這段可知：</p><blockquote><p>Specifically, the formatter is intended to emit near-identical output when run over Black-formatted code. When run over extensive Black-formatted projects like Django and Zulip, <strong>&gt; 99.9% of lines are formatted identically</strong>. When migrating an existing project from Black to Ruff, you should expect to see a few differences on the margins, <strong>but the vast majority of your code should be unchanged.</strong></p></blockquote><p>兩者的相容性（一致性）高達 99.9% 以上，基本可以放心遷移。</p><p>附帶一提，如果你是從 yapf 遷移到 Black，就能夠明顯感受到格式化風格差異所帶來的困擾——程式碼變動的地方太多了！</p><p>這種情況最好還是<strong>獨立一個分支或 commit，一次就把所有格式化差異都處理掉。</strong>而不要直接繼續開發，讓開發中的程式碼、檔案隨著開發進度被新 formatter 自動格式化，因為這會很影響 code review——格式化變動和開發變動混雜。</p><h3 id="還處於-Beta-階段"><a href="#還處於-Beta-階段" class="headerlink" title="還處於 Beta 階段"></a>還處於 Beta 階段</h3><blockquote><p>The Ruff formatter is available as a <a href="https://astral.sh/blog/the-ruff-formatter">production-ready Beta</a> as of Ruff v0.1.2.</p></blockquote><p>引言中的「<a href="https://astral.sh/blog/the-ruff-formatter">production-ready Beta</a>」超連結，指向 Ruff Formatter 的官方介紹文章與發展現況總結。</p><p>所謂的 beta 並不是還有很多 bug，更像是「設計與方向上」還沒有完全底定——比如下面要討論的「單、雙引號」議題。所以才會在前面加上「production-ready」。</p><p>如果你想要在個人的生產環境中使用，我相信是沒什麼問題。畢竟 <a href="https://github.com/tiangolo/fastapi/pull/10517">FastAPI 專案已經直接使用了</a>！</p><p>不過如果是公司專案，我還是會選擇觀望，不急於一時。</p><h2 id="單、雙引號議題"><a href="#單、雙引號議題" class="headerlink" title="單、雙引號議題"></a>單、雙引號議題</h2><p>Python 允許開發者自由選擇要在程式碼中使用單引號或雙引號。</p><p>只有在比如 docstring 這種<strong>連續使用 3 個引號</strong>的場景——即<code>&quot;&quot;&quot; &lt;內容&gt; &quot;&quot;&quot;</code>——時，慣例上要求使用雙引號。見 <a href="https://peps.python.org/pep-0257/#what-is-a-docstring">PEP 257</a>：</p><blockquote><p>For consistency, always use <code>&quot;&quot;&quot;triple double quotes&quot;&quot;&quot;</code> around docstrings.</p></blockquote><p>如果你對 Black 有一些了解，應該會知道，早期 Black 是<strong>完全不管</strong>你習慣用單引號還是雙引號，<strong>它一律把你的 Python 程式碼格式化為雙引號！</strong></p><p>這小小的硬性規則帶來了<strong>巨大的反彈</strong>，畢竟 Python 開發者中想必有不少人和我一樣，是「單引號」的支持者。</p><p>最後，Black 開發團隊也不得不妥協（這是 Black 少數的妥協，因為該工具本身就是以「不妥協」為賣點、slogan🤣），加入了<code>skip-string-normalization</code>選項。</p><h3 id="Ruff-Formatter-發展中"><a href="#Ruff-Formatter-發展中" class="headerlink" title="Ruff Formatter 發展中"></a>Ruff Formatter 發展中</h3><p>而 Ruff linter 作為 Black 的替代方案，也會遇到相同的「困境」。不同於 Black，目前 Ruff linter 提供的是<code>quote-style</code>這個選項：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quote-style = <span class="string">&quot;single&quot;</span></span><br></pre></td></tr></table></figure><p>即使你選了 single，在上述的慣例部分，Ruff 還是會格式化為雙引號，不用擔心。</p><p>至於要不要像 Black 加上<code>skip-string-normalization</code>，目前似乎還沒有定論。</p><p>整體而言，這個議題仍然在持續中，有興趣可以關注這個 <a href="https://github.com/astral-sh/ruff/issues/7615">GitHub Issue 討論串</a>。</p><p>這裡只是提醒你，採用 Ruff formatter 會有「單、雙引號」議題（而且和 Black 的處理方式不完全相同）。</p><p>至少對我而言，這非常重要。</p><hr><p>接下來，我們要進入 Ruff 的「<strong>設定篇</strong>」。</p><h2 id="Ruff-設定篇"><a href="#Ruff-設定篇" class="headerlink" title="Ruff 設定篇"></a>Ruff 設定篇</h2><p>當要採用一個新的 linter、formatter 時（尤其站在團隊開發考量），以下這三個部分的支援成熟度，是我一定會慎重考慮的。</p><h3 id="設定檔（pyproject-toml-支援）"><a href="#設定檔（pyproject-toml-支援）" class="headerlink" title="設定檔（pyproject.toml 支援）"></a>設定檔（pyproject.toml 支援）</h3><p>不用說，複雜的工具都一定有自己的設定檔，讓你可以客製化一些需求。如果能支援 pyproject.toml 則會更受到我的青睞。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pyproject-toml/">pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學</a></p></blockquote><h3 id="VS-Code-套件支援"><a href="#VS-Code-套件支援" class="headerlink" title="VS Code 套件支援"></a>VS Code 套件支援</h3><p>它能讓你在寫程式的同時，就能夠看到 linter 發出的警告，而不必等到 commit 之際才被 pre-commit 擋下來。</p><p>相較於 linter，<strong>formatter 更需要有自己的 VS Code 套件</strong>。讓你能直接在 VS Code 中進行格式化，而不用透過 CLI 指令或等到 pre-commit 時才自動修正。</p><p>而且，雖然你可以只用 Ruff 的 linter 功能，但因為有「autofix」存在，本質上它也是一個<strong>簡易（附帶）的格式化器</strong>，所以最好有 VS Code 整合。</p><h3 id="pre-commit-支援"><a href="#pre-commit-支援" class="headerlink" title="pre-commit 支援"></a>pre-commit 支援</h3><p>pre-commit 是團隊協作中一道重要的關卡，我在「<a href="https://blog.kyomind.tw/pre-commit/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E4%BD%BF%E7%94%A8-pre-commit%EF%BC%9F">為什麼要使用 pre-commit？</a>」中已有相當的闡述。</p><p>對於一個開發工具，我們主要關心的是：「它是否提供 pre-commit hook？」</p><hr><p>以上 3 點，Ruff 都有完整支援。下面就來一一解說。</p><h2 id="pyproject-toml-設定"><a href="#pyproject-toml-設定" class="headerlink" title="pyproject.toml 設定"></a>pyproject.toml 設定</h2><p>Ruff 總共支援三種設定檔：<code>pyproject.toml</code>、<code>ruff.toml</code>、<code>.ruff.toml</code>。</p><p>如果設定不算多，那我一律推薦放<code>pyproject.toml</code>。反之如果有大量的客製，那獨立一個設定檔可能是比較好的選擇。</p><p>如果不知道怎麼開始，參考<a href="https://docs.astral.sh/ruff/configuration/">文件</a>是最快上手的方式。文件中的範例內容同時有著註解式的解說。</p><p><strong>不過大部分時候，我們只需要設定一些基本的項目</strong>。比如以下是我目前的設定，包含了 linter 與 formatter 部分：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff]</span></span><br><span class="line"><span class="attr">line-length</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">select</span> = [<span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;UP&quot;</span>]</span><br><span class="line"><span class="attr">target-version</span> = <span class="string">&quot;py310&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.format]</span></span><br><span class="line"><span class="attr">quote-style</span> = <span class="string">&quot;single&quot;</span></span><br></pre></td></tr></table></figure><h3 id="設定解說"><a href="#設定解說" class="headerlink" title="設定解說"></a>設定解說</h3><p>首先，因為在<code>pyproject.toml</code>中，所以設定的 key 定是<code>[tool.xxx]</code>格式。</p><p>Linter 部分，一些基本的設定比如<code>line-length</code>和 Flake8 類似。其中<code>select</code>和沒有列出的<code>ignore</code>相對重要。</p><p>Ruff 預設只會顯示 <code>E</code> 和 <code>F</code> 系列的錯誤訊息（而 Flake8 還有 <code>W</code> 系列）。想要增加或排除特定部分的錯誤訊息警示（包含 autofix），就得透過上述兩個欄位調整。比如：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff.lint]</span></span><br><span class="line"><span class="comment"># 1. Enable flake8-bugbear (`B`) rules, in addition to the defaults.</span></span><br><span class="line"><span class="attr">select</span> = [<span class="string">&quot;E4&quot;</span>, <span class="string">&quot;E7&quot;</span>, <span class="string">&quot;E9&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Avoid enforcing line-length violations (`E501`)</span></span><br><span class="line"><span class="attr">ignore</span> = [<span class="string">&quot;E501&quot;</span>]</span><br></pre></td></tr></table></figure><p>在我的設定中，<code>select</code>加上了<code>I</code>和<code>UP</code>。分別代表了 isort 和 pyupgrade。一旦你開啟了它們，Ruff 就會提示相關錯誤，並在有錯誤時自動修正。（autofix 預設為開啟）</p><p>因為開啟了<code>UP</code>，所以我必須設定<code>target-version</code>（這裡為<code>py310</code>），意味著 Ruff 會將程式碼中<strong>舊的寫法</strong>自動轉換（autofix）為 Python 3.10 的寫法。</p><p>總之，可設定的項目非常豐富。</p><hr><h2 id="Ruff-VS-Code-套件設定"><a href="#Ruff-VS-Code-套件設定" class="headerlink" title="Ruff VS Code 套件設定"></a>Ruff VS Code 套件設定</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=charliermarsh.ruff">Ruff 的 VS Code 套件</a>在 2022 年 12 月首次發表。</p><p>說真的，如果一個全新的 linter 或 formatter 沒有相關的 VS Code 套件，我絕不會考慮使用。</p><p>套件的重要性前面有提過，在此再次闡述：</p><ul><li>Linter：在 IDE 中有直接的提示，不必等到 commit 才發現錯誤。</li><li>Formatter：直接執行格式化（尤其配合「<strong>存檔時格式化</strong>」），不需透過指令。</li></ul><p>絕大部分情況下，linter 提示的錯誤都會直接被 formatter 自動修正，感覺上沒有開啟 linter 提示似乎也無妨？</p><p>但是，兩者在少數時候會有<strong>不同的行為</strong>，所以我認為 linter 的提示仍是必要的。</p><p>當然，另一方面也因為我已習慣看 linter 提示👀——沒有會很不自在！</p><h3 id="安裝與設定-Ruff-套件"><a href="#安裝與設定-Ruff-套件" class="headerlink" title="安裝與設定 Ruff 套件"></a>安裝與設定 Ruff 套件</h3><p>套件安裝後就可以直接使用，如果你的專案中已有專屬的 Ruff 設定檔，我覺得<strong>不需要再特別設定</strong> VS Code Ruff 套件部分。</p><p>不過還是提供我的設定：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ruff.lint.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;--line-length=100&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.organizeImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.fixAll&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.showNotifications&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onError&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="建議設定-Python-行為"><a href="#建議設定-Python-行為" class="headerlink" title="建議設定 Python 行為"></a>建議設定 Python 行為</h3><p>Ruff 套件我覺得不設定也沒關係，有設定檔就夠了。</p><p>除非你不想要為每個專案一一建立 Ruff 設定檔，那就還是得弄一下（會套用到每一個專案）。同時也要考慮不同專案間的設定衝突問題——使用者全局設定 vs 專案設定。</p><p>相對的，VS Code 的 Python 部分則建議一定要設定。</p><p>這部分的具體內容，Ruff 套件首頁也有完整說明。我們直接看最完整的版本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;[python]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;source.organizeImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;charliermarsh.ruff&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>效果：</p><ol><li><code>editor.formatOnSave</code>：存檔時自動格式化（對所有 formatter 都有效）。</li><li><code>source.fixAll</code>：存檔時自動 fix。（類似 pre-commit 時，hook 的自動修正）</li><li><code>source.organizeImports</code>：存檔時自動排序 imports。</li></ol><p>我想上述這些 Python 設定才是 Ruff 在 VS Code 中流暢使用的重點。</p><h3 id="不同專案間切換"><a href="#不同專案間切換" class="headerlink" title="不同專案間切換"></a>不同專案間切換</h3><p>還有一個小細節，就是專案之間的切換問題。</p><p>因為不一定每個專案都用 Ruff。比如我，只在個人專案使用 Ruff，但工作上還沒有。或是相反的情況。</p><p>此時記得要把可能發生衝突的 VS Code 套件（主要是 linter 和 isort）在「工作區」範圍內停用！做法如下圖。不然 linter 部分很可能一起運作，產生意料之外的結果。</p><p><img src="https://i.imgur.com/lknGhsJ.png"></p><p>Formatter 部分，因為每個專案只能選定一種格式化器，比較沒有衝突問題。</p><hr><h2 id="pre-commit-設定"><a href="#pre-commit-設定" class="headerlink" title="pre-commit 設定"></a>pre-commit 設定</h2><p>pre-commit 設定相對單純，更細部的行為，hook 會自動讀取設定檔中的內容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/astral-sh/ruff-pre-commit</span></span><br><span class="line">  <span class="attr">rev:</span> <span class="string">v0.1.4</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--fix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff-format</span></span><br></pre></td></tr></table></figure><p>這裡只要注意版本和 hook 的 id 即可。</p><hr><h2 id="Ruff-設定篇小結"><a href="#Ruff-設定篇小結" class="headerlink" title="Ruff 設定篇小結"></a>Ruff 設定篇小結</h2><p>Ruff 的設定真的滿多樣且可以很複雜——儘管它的預設值已能滿足大多數人。</p><p>如果你不清楚究竟有哪些項目可以調整，又想了解更多。除了研究官方文件、Github 首頁的 README 外，去看看那些<a href="https://github.com/astral-sh/ruff?tab=readme-ov-file#whos-using-ruff">已經採用了 Ruff  的開源專案</a>的設定檔，也是很好的學習！</p><p>比如，我就習慣參考 <a href="https://github.com/tiangolo/fastapi/blob/master/pyproject.toml#L125">FastAPI 的 Ruff 設定</a>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff]</span></span><br><span class="line"><span class="attr">select</span> = [</span><br><span class="line">    <span class="string">&quot;E&quot;</span>,  <span class="comment"># pycodestyle errors</span></span><br><span class="line">    <span class="string">&quot;W&quot;</span>,  <span class="comment"># pycodestyle warnings</span></span><br><span class="line">    <span class="string">&quot;F&quot;</span>,  <span class="comment"># pyflakes</span></span><br><span class="line">    <span class="string">&quot;I&quot;</span>,  <span class="comment"># isort</span></span><br><span class="line">    <span class="string">&quot;C&quot;</span>,  <span class="comment"># flake8-comprehensions</span></span><br><span class="line">    <span class="string">&quot;B&quot;</span>,  <span class="comment"># flake8-bugbear</span></span><br><span class="line">    <span class="string">&quot;UP&quot;</span>,  <span class="comment"># pyupgrade</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="attr">ignore</span> = [</span><br><span class="line">    <span class="string">&quot;E501&quot;</span>,  <span class="comment"># line too long, handled by black</span></span><br><span class="line">    <span class="string">&quot;B008&quot;</span>,  <span class="comment"># do not perform function calls in argument defaults</span></span><br><span class="line">    <span class="string">&quot;C901&quot;</span>,  <span class="comment"># too complex</span></span><br><span class="line">    <span class="string">&quot;W191&quot;</span>,  <span class="comment"># indentation contains tabs</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.isort]</span></span><br><span class="line"><span class="attr">known-third-party</span> = [<span class="string">&quot;fastapi&quot;</span>, <span class="string">&quot;pydantic&quot;</span>, <span class="string">&quot;starlette&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.pyupgrade]</span></span><br><span class="line"><span class="comment"># Preserve types, even if a file imports `from __future__ import annotations`.</span></span><br><span class="line"><span class="attr">keep-runtime-typing</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>而且 FastAPI 真的很貼心，還加了註解！</p><hr><h2 id="工作上我還未採用-Ruff-的理由"><a href="#工作上我還未採用-Ruff-的理由" class="headerlink" title="工作上我還未採用 Ruff 的理由"></a>工作上我還未採用 Ruff 的理由</h2><p>結語之前，講講我在一番研究後，仍未建議團隊在此刻就採用 Ruff 的理由。</p><p>放到最後不是為了賣關子，而是看到這裡，你應該比較能夠理解其中的顧慮。</p><p>主要有三個。</p><h3 id="一、設定相對複雜"><a href="#一、設定相對複雜" class="headerlink" title="一、設定相對複雜"></a>一、設定相對複雜</h3><p>首先我覺得 Ruff 的設定太多樣了，畢竟它一口氣整合了這麼多的工具。</p><p>而且要同時考慮 pyproject.toml、VS Code、pre-commit 的整合，加上各種 linter 在設定上的開關，想想有點頭痛。</p><p>這會帶來一定的認知負擔，同事可能會覺得「搞這些真的有必要嗎？」——其實我也這麼想🤣</p><h3 id="二、需求不足"><a href="#二、需求不足" class="headerlink" title="二、需求不足"></a>二、需求不足</h3><p>我們目前的專案最多只能算中型，用「Flake8 + isort + Black Formatter」經典組合已能運作良好。改用 Ruff，可能看不出太大差別。</p><p>如果看不出差別，設定又要重新調整、學習，難免讓人卻步。</p><h3 id="三、讓子彈再飛一會兒"><a href="#三、讓子彈再飛一會兒" class="headerlink" title="三、讓子彈再飛一會兒"></a>三、讓子彈再飛一會兒</h3><p>說起來，前兩個理由並不算什麼重大阻礙，只是也沒有明顯的動力。</p><p>我打算等 Ruff formatter 的「beta」字樣拿掉後，直接「一換三」一次到位。</p><p>所以，不妨讓子彈再飛一會兒。</p><hr><h2 id="結語：Time-to-Ruff"><a href="#結語：Time-to-Ruff" class="headerlink" title="結語：Time to Ruff"></a>結語：Time to Ruff</h2><p>Ruff 現階段對我的重要性，顯然還遠不如 <a href="https://blog.kyomind.tw/python-poetry/">Poetry 套件管理器</a>。但這樣的工具依舊讓人興奮且充滿期待。</p><p>我並不認為目前的 Python 開發一定要用上 Ruff，但值得你嘗試一下。</p><p>如果你也是一個 Code Formatting 愛好者，那麼 Ruff 絕對是一個值得你花時間研究的工具。</p><p>更重要的是，由 Rust 所引發的 Python 生態革命，現在才剛剛開始。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/klPlw0x.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/astral-sh/ruff&quot;&gt;Ruff&lt;/a&gt; 從去年（2022）6 月正式開源起算，已過去一年半，知道此工具的開發者也愈來愈多。雖然在去年就聽過它，但我卻一直沒有任何行動。&lt;/p&gt;
&lt;p&gt;隨著前陣子 &lt;a href=&quot;https://github.com/astral-sh/ruff/releases/tag/v0.1.0&quot;&gt;v0.1.0&lt;/a&gt; 的發布（先別覺得這版本號怎麼乍看像早期測試版本🤣，畢竟前一版可是 v0.0.292），我覺得時機已到，所以進行了一番研究、嘗試，於是有了本文的誕生。&lt;/p&gt;
&lt;h3 id=&quot;本文目錄&quot;&gt;&lt;a href=&quot;#本文目錄&quot; class=&quot;headerlink&quot; title=&quot;本文目錄&quot;&gt;&lt;/a&gt;本文目錄&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B7%A3%E8%B5%B7&quot;&gt;緣起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85&quot;&gt;本文主旨與目標讀者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Why-Ruff%EF%BC%9F&quot;&gt;Why Ruff？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC&quot;&gt;本文範例程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E4%BB%8B%E7%B4%B9%E7%AF%87&quot;&gt;Ruff 介紹篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Linter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Flake8-%E8%88%87-isort-%E7%AD%89%E7%AD%89&quot;&gt;Linter 部分：取代 Flake8 與 isort 等等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Formatter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Black&quot;&gt;Formatter 部分：取代 Black&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%96%AE%E3%80%81%E9%9B%99%E5%BC%95%E8%99%9F%E8%AD%B0%E9%A1%8C&quot;&gt;單、雙引號議題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87&quot;&gt;Ruff 設定篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pyproject-toml-%E8%A8%AD%E5%AE%9A&quot;&gt;pyproject.toml 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;##Ruff-VS-Code-%E5%A5%97%E4%BB%B6%E8%A8%AD%E5%AE%9A&quot;&gt;Ruff VS Code 套件設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pre-commit-%E8%A8%AD%E5%AE%9A&quot;&gt;pre-commit 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87%E5%B0%8F%E7%B5%90&quot;&gt;Ruff 設定篇小結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1&quot;&gt;工作上我還未採用 Ruff 的理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B5%90%E8%AA%9E%EF%BC%9ATime-to-Ruff&quot;&gt;結語：Time to Ruff&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    <content src="https://i.imgur.com/klPlw0x.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Flake8" scheme="https://blog.kyomind.tw/tags/Flake8/"/>
    
    <category term="isort" scheme="https://blog.kyomind.tw/tags/isort/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
    <category term="Black Formatter" scheme="https://blog.kyomind.tw/tags/Black-Formatter/"/>
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
    <category term="Ruff" scheme="https://blog.kyomind.tw/tags/Ruff/"/>
    
  </entry>
  
  <entry>
    <title>24，收回「發文計畫」</title>
    <link href="https://blog.kyomind.tw/weekly-review-24/"/>
    <id>https://blog.kyomind.tw/weekly-review-24/</id>
    <published>2023-11-03T18:22:04.000Z</published>
    <updated>2024-01-02T02:45:59.835Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/mmEzb21.png"></p><p>你現在看網站的選單，已經沒有「發文計畫」了。</p><p>至於那是什麼，可以參考上一期〈<a href="https://blog.kyomind.tw/weekly-review-23/">23，Blog 新增「發文計畫」與我的思路</a>〉。</p><p>這篇就來解釋，為什麼它失敗了，與我的一點想法。</p><span id="more"></span><hr><h2 id="結束的理由"><a href="#結束的理由" class="headerlink" title="結束的理由"></a>結束的理由</h2><p>先簡單回顧一下，發文計畫的兩大初衷：</p><ol><li>可預見性。</li><li>公開承諾。</li></ol><p>從這一個多月的實施結果來看，上述這兩件事情，基本都搞砸了。</p><h3 id="可預見但不可信"><a href="#可預見但不可信" class="headerlink" title="可預見但不可信"></a>可預見但不可信</h3><p>首先是可預見，這確實有一定的效果。畢竟我把接下來的要寫的東西，都先公開其中。</p><p>但是，很多文章（尤其是較長的內容）的發文日期，卻是一延再延，如此一來，即使可預見，也沒有太大的參考價值。</p><h3 id="無法兌現的承諾"><a href="#無法兌現的承諾" class="headerlink" title="無法兌現的承諾"></a>無法兌現的承諾</h3><p>既然文章發布日可以一延再延，那公開承諾就沒有了原來想像的拘束力（至少在心理上沒有足夠的拘束力）。</p><p>如此一來，想透過公開承諾培養一定紀律的期待，也就落了空。</p><h2 id="收穫與反省"><a href="#收穫與反省" class="headerlink" title="收穫與反省"></a>收穫與反省</h2><p>其實，並不是所有的文章都是一延再延。</p><h3 id="意料之外的收穫"><a href="#意料之外的收穫" class="headerlink" title="意料之外的收穫"></a>意料之外的收穫</h3><p>有一部分文章，反而因為有了這份「發文行事曆」，而事先完成了！這實在超乎了我的預料，可謂意外的驚喜。</p><blockquote><p>這是我少數能感受到「計畫」強大威力的時刻。</p></blockquote><p>不過，即使已經完稿，我通常還是會等到上面寫的發文日期才正式公開。</p><p>這是好的部分。</p><h3 id="問題反省"><a href="#問題反省" class="headerlink" title="問題反省"></a>問題反省</h3><p>但是，那些真正「困難」的文章（主要是技術相關的長篇文章），我卻還是一拖再拖，直接架空了這個行事曆。</p><p>我也真正了解到，除非我有辦法真正降低這些主題的寫作門檻，或許找到其它更有效的創作手段。</p><p>不然面對這些棘手的主題，常常就是一逃再逃。</p><p>本來我是這麼說的：</p><blockquote><p>公開承諾會<strong>強化其中的痛苦</strong>，讓我對這樣的拖延感到壓力。</p></blockquote><p>確實如此，但從結果看來，這樣的壓力，還是不足以讓我按時完成！</p><hr><p>既然事與願違，索性還是撤掉了。</p><p>此外，網站的選單部分我一向是寸土寸金，捨不得增加太多雜訊。</p><p>既然發文計畫無法達到當初的期待，又佔據了選單列表，我還是選擇拿掉。不再公開。</p><h2 id="行事曆是好東西"><a href="#行事曆是好東西" class="headerlink" title="行事曆是好東西"></a>行事曆是好東西</h2><p>儘管如此，我發現「發文行事曆」確實是很棒的規劃工具，尤其是可以「拖曳」這個特性，令人愛不釋手。</p><p>一直把日期後延，對讀者很不好意思，所以我只能「關門」。但如果只有我自己的話，行事曆仍不失為稱手好用的發文管理利器！</p><p>這和「僅把待發表文章列在清單中」的感覺，截然不同。推薦你也試試。</p><hr><h2 id="總結與重新思考"><a href="#總結與重新思考" class="headerlink" title="總結與重新思考"></a>總結與重新思考</h2><p>整體而言，我目前的寫作還是略嫌發散了，主要受到三股勢力的牽引：</p><ol><li><strong>有流量的內容</strong>：主要就是筆記軟體類的文章。當然，我也確實熱衷於此。</li><li><strong>我感興趣的內容</strong>：通常是個人價值觀的闡述。</li><li><strong>我認為自己可以寫好，也值得好好寫的內容</strong>：程式類文章。</li></ol><p>上述三者雖然不算涇渭分明，但仍有一定的排它性。</p><p>然而時間就這麼多，我必須有所取捨。而現在的我，還做得不夠好。</p><blockquote><p><strong>講白了就是太貪心！</strong></p></blockquote><p>所以我應該會<strong>減少發文量</strong>。把主要精力集中在<strong>中長篇內容</strong>，尤其是那些我常常想要逃避的主題。</p><p>這類文章往往需要很大的心力來創作，但也是真正具有「<a href="https://blog.kyomind.tw/a-mind-for-blogs/#%E4%BA%8C%E3%80%81%E5%8F%96%E6%8D%A8%E4%BB%A5%E7%AA%81%E9%A1%AF">自我代表性</a>」的作品。</p><p>至於發文頻率，則不再強求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mmEzb21.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;你現在看網站的選單，已經沒有「發文計畫」了。&lt;/p&gt;
&lt;p&gt;至於那是什麼，可以參考上一期〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-23/&quot;&gt;23，Blog 新增「發文計畫」與我的思路&lt;/a&gt;〉。&lt;/p&gt;
&lt;p&gt;這篇就來解釋，為什麼它失敗了，與我的一點想法。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/mmEzb21.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>《Python 功力提升的樂趣》筆記（三）函式、註解、docstring</title>
    <link href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/"/>
    <id>https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/</id>
    <published>2023-10-21T08:46:34.000Z</published>
    <updated>2024-01-11T13:32:19.972Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/tS78Ke0.png" alt="Python 功力提升的樂趣"><span class="cap">Python 功力提升的樂趣</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務</a>》閱讀筆記的第 3 篇，也是最後一篇。</p><p>你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>本文整理書中的第 10、11 章，而且篇幅幾乎集中在前者。畢竟無論什麼語言，「<strong>寫好函式</strong>」這件事總是如此重要，Python 自然也不例外。</p><h3 id="系列：Python-功力提升的樂趣"><a href="#系列：Python-功力提升的樂趣" class="headerlink" title="系列：Python 功力提升的樂趣"></a>系列：Python 功力提升的樂趣</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a></li><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-02/">《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱</a></li><li><strong>《Python 功力提升的樂趣》筆記（三）函式、註解、docstring</strong></li></ol></blockquote><hr><h2 id="第-10-章：寫出有效率的函式"><a href="#第-10-章：寫出有效率的函式" class="headerlink" title="第 10 章：寫出有效率的函式"></a>第 10 章：寫出有效率的函式</h2><p>有效率的函式（或說「<strong>好的</strong>」函式）需要你在「<strong>命名、規模大小（行數）、參數數量和複雜性</strong>」之間，做出許多決定和<strong>取捨</strong>。</p><p>這無疑是極具挑戰的事——尤其是取捨。</p><p>人生之難，就難在取捨。</p><p>本章探討的正是這些取捨之間的利弊得失，以及編寫函式的重要原則。不用說，絕對是關鍵的一章。</p><span id="more"></span><hr><h2 id="函式的規模：小就是好？"><a href="#函式的規模：小就是好？" class="headerlink" title="函式的規模：小就是好？"></a>函式的規模：小就是好？</h2><p>我們都聽過「函式應該盡可能簡單、一次只做一次件事」之類的建言，也表示認同。從這個精神出發，太大或太複雜的函式就應該要進行拆分。</p><p>但！事實是，有效拆分函式是一件耗神、講究細節，且沒有標準答案的事。以致於我們即使知道，也很難完全貫徹，包括我自己。</p><p>出於各種原因，我們常常對現實世界作出一定的妥協。</p><h3 id="小函式的優點"><a href="#小函式的優點" class="headerlink" title="小函式的優點"></a>小函式的優點</h3><p>有些人覺得任何函式都不應該超過 20 行，甚至 10、5 行😂。因為函式「短」往往有下面這些優點：</p><ul><li>單一函式容易理解</li><li>較少的參數（這確實非常重要！）</li><li>易於測試與除錯</li></ul><h3 id="小函式的缺點"><a href="#小函式的缺點" class="headerlink" title="小函式的缺點"></a>小函式的缺點</h3><p>但小也有缺點：</p><ul><li>一樣的邏輯，更小的函式也意味著「更多」的小函式</li><li>函式愈多，結構就愈複雜。即「函式間」的關係會變得更加複雜</li><li>愈多函式，函式間的精準命名將成為巨大的挑戰——這真的很困難！</li></ul><p>這些「缺點」往往也解釋了為何我們不一定那麼積極拆分函式，讓每一個函式都符合「一次只做一件事」原則。</p><p>尤其是小函式造成的大量命名問題，對於命名很講究的我而言，有時確實感到棘手。</p><h3 id="小結：小不等於短"><a href="#小結：小不等於短" class="headerlink" title="小結：小不等於短"></a>小結：小不等於短</h3><p>函式原則上還是應該要盡可能單純一點，該拆就要拆，但不一定要很短。而且其中必然會有很多挑戰。</p><p>從「功能」上去劃分界限、拆分函式，會更有意義與指導性，與可行性。</p><p>作者認為，一味追求短函式，確實可以讓各別函式變得簡單，但卻很可能讓程式的「整體」變得複雜，適得其反。</p><p>他的經驗是，理想情況下，函式最好少於 30 行，最多不超過 200 行。<strong>讓函式在合理情況下盡可能短少</strong>，但不只是為了短少而縮減。</p><hr><h2 id="返回值（return）應該都要有相同的資料型別"><a href="#返回值（return）應該都要有相同的資料型別" class="headerlink" title="返回值（return）應該都要有相同的資料型別"></a>返回值（return）應該都要有相同的資料型別</h2><p>對此，我想說：</p><blockquote><p><strong>這真的好重要啊！</strong>（吶喊）</p></blockquote><p>卻常常沒有被好好遵守。</p><p>簡言之，為確保函式的「<strong>可預測性</strong>」，我們應該努力讓函式只回傳「<strong>單一資料型別</strong>」的值。比如<strong>總是</strong>回傳整數或字串，而不要有時回傳字串，有時則回傳布林值。</p><p>這不一定容易做到，但我更常遇到的情況是：<strong>明明有替代方案讓回傳型別單一化，卻沒有善用。</strong></p><h3 id="以False代替raise"><a href="#以False代替raise" class="headerlink" title="以False代替raise"></a>以<code>False</code>代替<code>raise</code></h3><p>最常見的例子就是：<strong>該拋出錯誤時候，卻只用<code>return False</code> 替代</strong>。</p><p>意即，當函式正常執行時，回傳一般正常的 output 值。但當執行失敗時，卻是回傳<code>False</code>——這簡直令人髮指，而且我相信你一定看過這樣的函式。</p><p>必須說明，發生錯誤時不拋出而選擇<code>return False</code>未必總是不好的，就像 Django REST framework 序列化器的<code>is_valid</code>方法，預設也是返回一個布林值（可以用<code>raise_exception=True</code>參數改為直接拋出錯誤），方便你進行更多後續操作。</p><p>不過，<strong>如果你選擇在遇到錯誤時<code>return False</code>，則應該在函式正確執行時，<code>return True</code>，</strong>以保持回傳型別的一致性。</p><p>而且<strong>函式命名</strong>也要跟著配合，讓人一看就知曉<strong>該函式、方法會返回一個布林值</strong>，比如上述的<code>is_valid</code>，或常見的<code>has_permission</code>、<code>is_authenticated</code>等。這些都是常見的最佳實踐。</p><h3 id="錯誤示範"><a href="#錯誤示範" class="headerlink" title="錯誤示範"></a>錯誤示範</h3><p>我們看一下這個錯誤示範：假設我們有一個函式，其目的是從一個<code>JSON</code>文件中讀取配置資訊。如果讀取成功，它會返回一個 Python 字典；如果讀取失敗，它會捕捉異常並返回<code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_config_from_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            config = json.load(f)</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 這裡是問題所在</span></span><br></pre></td></tr></table></figure><p>這個函式在<code>except</code>區塊裡面直接返回<code>False</code>，這會導致以下問題：</p><ol><li><strong>資料型別不一致</strong>：正常情況下返回一個字典，異常情況下返回<code>False</code>（布林值）。</li><li><strong>誤導函式使用者</strong>：使用者可能會誤以為<code>False</code>是一個有效的配置，進而嘗試在其上進行操作，這會導致更多的錯誤。</li><li><strong>後續處理困難</strong>：函式使用者必須額外檢查返回值是否為<code>False</code>，然後再決定是否進行後續的操作。</li></ol><hr><p>其實「<code>return</code>型別不確定」肯定不只發生在例外處理，但它<strong>確實「很常發生」在例外處理</strong>，因為我看過<strong>不止一次</strong>類似的真實案例。</p><p>很多人本能地會這樣寫，這往往是因為不習慣、不擅長處理錯誤，所以想要用自己平常更熟悉的<code>False</code>。</p><p>除此之外，還有「函式正常執行回傳一個類別物件，失敗時回傳一個 Python tuple——包含錯誤代碼和錯誤訊息」這種非常<strong>反直覺</strong>的設計。彷彿是在告訴我們：</p><blockquote><p>這個函式的回傳值，可能是一個物件，也可能是一個 tuple，<strong>你自己判斷吧！</strong></p></blockquote><p>會寫出這樣的函式，原因諸多——工作很忙、重構太麻煩了，要新增什麼功能我直接「加上去」就好！</p><p><strong>充滿了技術債味的寫法。</strong></p><h2 id="技術債與認知負擔"><a href="#技術債與認知負擔" class="headerlink" title="技術債與認知負擔"></a>技術債與認知負擔</h2><p>這類「<strong>雙型別 return</strong>」的函式，對於<strong>函式使用者</strong>（有可能是你的同事）的認知，有著「<strong>更高的要求</strong>」——呼叫方必須很了解這個函式的<strong>怪異行為</strong>，才能正確使用與處理後續衍生的問題。</p><p>這在多行或有多個 return 值的<strong>複雜函式時，真是一場災難。</strong></p><blockquote><p>期望他人知道自己做了什麼「特別的事」，不是我所知曉的軟體開發之道。</p></blockquote><p>當函式具有這種「雙型別 return」的特性時，會明顯增加呼叫方的「<strong>認知負擔</strong>」。</p><p>這使得程式<strong>不僅難以閱讀和維護，也容易出錯</strong>，因為未來的維護者或其他團隊成員<strong>很可能不知道</strong>這個函式的「獨特」行為。</p><p>無論何時，我們都不應該寫這樣的程式。</p><hr><h2 id="我對寫好函式的基本看法"><a href="#我對寫好函式的基本看法" class="headerlink" title="我對寫好函式的基本看法"></a>我對寫好函式的基本看法</h2><p>寫好函式的重點實在太多了，而本文的篇幅有限，只能擇要為之。</p><p>我也講講我認為函式的撰寫中，最重要的兩點。</p><p>至少遵守這兩點，你的同事會很感激你。</p><h2 id="Docstring-真的很重要"><a href="#Docstring-真的很重要" class="headerlink" title="Docstring 真的很重要"></a>Docstring 真的很重要</h2><p>其一是盡可能地寫 docstring，這不容易，畢竟維護 docstring 也需要心力。</p><blockquote><p>Docstring 就跟所有開發文件一樣——自己很懶得寫，但如果我想調用別人寫好的程式時，卻希望它們越詳細越好。</p></blockquote><p>而且 docstring 也不是有寫就行，還需要從「<strong>讀者</strong>（也就是你的同事）」的角度去思考與表達。不然看起來會很像開發者的自言自語——沒人看得懂。</p><p>然而我也承認，為所有的模組、類別、函式寫 docstring，未免有點不切實際。在眾多函式中，下列兩種是我認為<strong>一定要寫 docstring</strong> 的：</p><ol><li><strong>專案「自定義」成份濃厚</strong>：除了開發者本人，沒人知道這段程式在幹什麼。這通常源於特殊的業務需求，而且往往行數超多、邏輯超手刻，各種 if&#x2F;else、for 迴圈滿天飛，aka——<strong>沒人想看的程式碼</strong>。</li><li><strong>流程相對複雜</strong>的函式：愈複雜就愈難理解，這時候 docstring 就是你的好朋友。用文字描述函式的<strong>輸入、輸出、邏輯</strong>，能大大提升我們理解程式碼的效率。</li></ol><p>畢竟，看<strong>有描述性的文字</strong>，總比看一長串程式碼，要簡單且友善得多。</p><p>關於我對 docstring 的其它討論，可以參考這兩個部分：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E8%A8%BB%E8%A7%A3%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%EF%BC%9F">註解是不需要的？</a></li><li><a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a></li></ul><p>我的觀點一向如此：<strong>不寫好 docstring，就稱不上是一流的 Python 開發者。</strong></p><hr><h2 id="函式的行為與命名要一致"><a href="#函式的行為與命名要一致" class="headerlink" title="函式的行為與命名要一致"></a>函式的行為與命名要一致</h2><p>其二，好的函式要「言行一致」。</p><p>你可能會想：</p><blockquote><p>這不是理所當然的嗎？</p></blockquote><p>對，它<strong>「本應該」是理所當然</strong>的，畢竟這不就是函式命名的基本目的？——用來描述函式的行為。</p><p>但我們可以回想一下自己在工作中遇到的各式各樣函式，究竟有多少比例，是真正做到「言行一致」？我覺得可能只有一半。</p><p>或許你會認為「一半」也太誇張了！但我並不這麼想。</p><p>「言行不一致」通常有下面幾種症狀：</p><ol><li>函式名稱只表達了函式「<strong>部分</strong>」的行為。也就是函式做了超過它宣稱要做的事，比如「驗證欄位」函式，竟然還把驗證資料格式化了！</li><li>函式名稱「<strong>言過其實</strong>」，說要驗證加格式化，結果只做了一半。</li><li>名稱太模糊、缺乏業務邏輯描述、濫用技術詞彙等等，<strong>根本看不懂它在說什麼</strong>，更別說言行一致了。</li></ol><p>如果你不能從一個函式的名稱中<strong>有效理解並推測</strong>它應有的行為，那麼這個函式基本上就是失敗（或不健康）的。</p><p>很多時候，函式<strong>最初</strong>可能是「言行一致」的，但隨著後來的修改、刪除、擴充，實際上做的事情變更了，但命名卻沒有跟著改變、重構。</p><p>這些言行不一的函式，充滿<strong>誤導性</strong>，不斷地挑戰著你的認知、推理能力，更增加了維護成本。</p><p>這樣的例子還少嗎？恐怕每天都在發生。</p><hr><h2 id="第-11-章：注釋、docstring-和-type-hints"><a href="#第-11-章：注釋、docstring-和-type-hints" class="headerlink" title="第 11 章：注釋、docstring 和 type hints"></a>第 11 章：注釋、docstring 和 type hints</h2><p>這章我只摘錄書中的一段話——我特別欣賞與認同的部分：</p><blockquote><p>好的注釋對程式設計師在未來閱讀並理解程式碼作用時提供了簡潔、有用和準確的資訊。這些注釋應該<strong>用來解說程式設計師原本的意圖，並總結某程式碼的作用，而不是只對某行程式碼進行解說。</strong></p></blockquote><blockquote><p>注釋有時會詳細描述程式設計師在編寫程式碼時<strong>所得到的經驗教訓，這些寶貴的資訊可以讓將來的維護者不必再次經歷這些苦難。</strong></p></blockquote><p>說的太好了！</p><p>團隊寫程式，是關於溝通的藝術，畢竟《<a href="https://www.books.com.tw/products/0010254508">人月神話</a>》已經告訴我們：人多不一定比較快。</p><p>溝通不止發生在會議、Jira、Slack 和規格文件上，程式之內也有著大量的溝通，註解是如此，docstring 亦是如此。</p><p>永遠不要低估「對這些細節的用心」所帶能來的巨大影響力。</p><p>優秀的工程師絕不可能輕忽它們。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tS78Ke0.png&quot; alt=&quot;Python 功力提升的樂趣&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務&lt;/a&gt;》閱讀筆記的第 3 篇，也是最後一篇。&lt;/p&gt;
&lt;p&gt;你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;本文整理書中的第 10、11 章，而且篇幅幾乎集中在前者。畢竟無論什麼語言，「&lt;strong&gt;寫好函式&lt;/strong&gt;」這件事總是如此重要，Python 自然也不例外。&lt;/p&gt;
&lt;h3 id=&quot;系列：Python-功力提升的樂趣&quot;&gt;&lt;a href=&quot;#系列：Python-功力提升的樂趣&quot; class=&quot;headerlink&quot; title=&quot;系列：Python 功力提升的樂趣&quot;&gt;&lt;/a&gt;系列：Python 功力提升的樂趣&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/&quot;&gt;《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-02/&quot;&gt;《Python 功力提升的樂趣》筆記（二）Pythonic、行話、陷阱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;《Python 功力提升的樂趣》筆記（三）函式、註解、docstring&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;第-10-章：寫出有效率的函式&quot;&gt;&lt;a href=&quot;#第-10-章：寫出有效率的函式&quot; class=&quot;headerlink&quot; title=&quot;第 10 章：寫出有效率的函式&quot;&gt;&lt;/a&gt;第 10 章：寫出有效率的函式&lt;/h2&gt;&lt;p&gt;有效率的函式（或說「&lt;strong&gt;好的&lt;/strong&gt;」函式）需要你在「&lt;strong&gt;命名、規模大小（行數）、參數數量和複雜性&lt;/strong&gt;」之間，做出許多決定和&lt;strong&gt;取捨&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這無疑是極具挑戰的事——尤其是取捨。&lt;/p&gt;
&lt;p&gt;人生之難，就難在取捨。&lt;/p&gt;
&lt;p&gt;本章探討的正是這些取捨之間的利弊得失，以及編寫函式的重要原則。不用說，絕對是關鍵的一章。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/tS78Ke0.png" type="image"/>
    
    
    <category term="書評" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="閱讀心得" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="系列：Python 功力提升的樂趣" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%8A%9F%E5%8A%9B%E6%8F%90%E5%8D%87%E7%9A%84%E6%A8%82%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>2023 那些我已不可或缺的「付費訂閱」推薦</title>
    <link href="https://blog.kyomind.tw/essential-subscriptions-2023/"/>
    <id>https://blog.kyomind.tw/essential-subscriptions-2023/</id>
    <published>2023-10-10T16:12:10.000Z</published>
    <updated>2024-01-02T02:45:59.820Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/MDQYOVd.png" alt="DALL·E 3"><span class="cap">DALL·E 3</span></p><p>這篇要來講述，2023 年的當下，對我而言「具有一定重要性」的付費訂閱。</p><p>這屬於完全個人化的心得，我會列出那些不可或缺的訂閱項目，並解釋它們對我的重要性所在。</p><p>所謂的「不可或缺」，意思是一旦我停止訂閱，我的工作和生活都會出現挑戰。而挑戰的大小，就是這些訂閱項目對我的影響力與價值。</p><p>以下排名同時也是重要性排名，就讓我們從最重要的開始吧！</p><span id="more"></span><hr><h2 id="一、ChatGPT-Plus"><a href="#一、ChatGPT-Plus" class="headerlink" title="一、ChatGPT Plus"></a>一、ChatGPT Plus</h2><p>論重中之重，<a href="https://openai.com/blog/chatgpt-plus">ChatGPT Plus</a> 捨我其誰？</p><p>作為一個求知欲旺盛的軟體工程師，ChatGPT 對我而言可不是僅僅「提高工作效率」這麼簡單。</p><p>任何大大小小的事都能問它，而且總能給你一個<strong>相對明確</strong>的回答。在沒有它之前，這是我們無法奢求的。</p><p>所以，它帶給我的遠不只是效率，更是智識上的愉悅與滿足。</p><p>隨著 Plus 附加的功能愈來愈多，更別說最近加入的<a href="https://help.openai.com/en/articles/6825453-chatgpt-release-notes#h_e3a2ee7903">影像辨識</a>（<a href="https://openai.com/research/gpt-4v-system-card">GPT-4V</a>），與整合了 DALL·E 3 的<a href="https://www.ithome.com.tw/news/158860">繪圖功能</a>，我感覺這每月 20 美元的價值實在太過誇張。</p><p>如果你問我，我對這個服務目前為止的定價接受度上限為何？我可能會說是每月 40 美元——可見我確實離不開它。</p><h2 id="二、Setapp"><a href="#二、Setapp" class="headerlink" title="二、Setapp"></a>二、Setapp</h2><p><a href="https://setapp.com/">Setapp</a> 是訂閱制軟體服務，月付 10 美元，可以使用與之有合作的眾多軟體。</p><p>作為一個長期在 Mac 上開發的軟體工程師，Setapp 有好幾樣工具是我的日常必備。而且，考慮到「寫作」也是對我十分重要的生產活動，那它的價值就更加不言而喻了。目前我最常用的 app 有下：</p><ul><li><a href="https://cleanshot.com/">CleanShot X</a>：寫作截圖必備。</li><li><a href="https://www.popclip.app/">PopClip</a>：可以開發自己的外掛！</li><li><a href="https://www.macbartender.com/">Bartender</a>：Mac 上的工具列管理。</li><li><a href="https://pasteapp.io/">Paste</a>：剪貼簿大師！</li><li><a href="https://rapidapi.com/">RapidAPI</a>：Postman 替代品，目前個人使用已經免費。</li><li><a href="https://tableplus.com/">TablePlus</a>：SQL client，而且支持 MongoDB。</li></ul><p>我常用的 Setapp 軟體大概有十幾項，但提這些就足夠了。它們加起來的重要性，已經足以讓 Setapp 名列第二。</p><p>有興趣可以使用<a href="https://go.setapp.com/invite/ga4xxrhb">我的邀請連結</a>註冊，你、我皆可<strong>額外獲得一個月訂閱</strong>：</p><blockquote><p>If you continue with Setapp after your trial ends, <strong>both you and the friend who invited you will get a free month</strong>. That’s our referral program reward.</p></blockquote><h2 id="三、GitHub-Copilot"><a href="#三、GitHub-Copilot" class="headerlink" title="三、GitHub Copilot"></a>三、GitHub Copilot</h2><p>AI 寫程式助手，每月 10 美元，年付為 100 美元。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/github-copilot/">GitHub Copilot 心得——寫文章的利器？</a></p></blockquote><p>我自認不算非常充分利用它，即靠「大量寫註解提示」來讓它幫我生產大部分的程式碼——我不習慣如此。但它還是成為了我現在開發的不可或缺。</p><p>考慮到「寫程式」是我人生中的重要部分，我給它第三名。</p><p>如果不想花錢，可以考慮下面這個免費的替代方案：</p><ul><li><a href="https://codeium.com/">Codeium · Free AI Code Completion &amp; Chat</a></li></ul><h2 id="四、YouTube-Premium"><a href="#四、YouTube-Premium" class="headerlink" title="四、YouTube Premium"></a>四、YouTube Premium</h2><p>沒想到這東西會排第四吧！全因我是一個重度 YouTube 成癮者。</p><p>雖然我也有訂 Netflix，但它對我來說相對可有可無。</p><p>大概是現代生活的節奏讓我沒有足夠的耐心慢慢看一部劇了。</p><h2 id="五、TPASS（北北基桃）"><a href="#五、TPASS（北北基桃）" class="headerlink" title="五、TPASS（北北基桃）"></a>五、TPASS（北北基桃）</h2><p>行政院通勤月票，北北基桃版的月費為 1200 台幣。</p><p>今年 7 月入坑，我感覺這東西真該早點推出的！它帶來了「通勤自由」——我很喜歡這種感覺。曾經寫了一篇<a href="https://www.facebook.com/kyomind/posts/pfbid0jWRm5mfV9ZvN63sfm7j8b8bcWzLmavrjNFHXh1MqQieEjkJoi9DGCFJsAexHVinhl">臉書文</a>講述我的購買（訂閱）動機，可供參考。</p><p>使用至今 3 個月，我很滿意。</p><h2 id="六、Whoscall"><a href="#六、Whoscall" class="headerlink" title="六、Whoscall"></a>六、Whoscall</h2><p>由今年剛在台股上市的 <a href="https://gogolook.com/en">Gogolook</a>（走著瞧股份有限公司）出品，為手機過濾、警示來電號碼的服務。</p><p>作為一個接到推銷電話總是不好意思中斷對方發言的人，這工具對我著實不可或缺。</p><p>一樣，不想付錢的話，Android 手機使用者有 Google 提供的免費替代選項：</p><ul><li><a href="https://play.google.com/store/apps/details?id=com.google.android.dialer&hl=zh_TW">Google 開發的「電話」- 來電顯示和騷擾電話阻擋功能</a></li></ul><h2 id="七、DigitalOcean-VM"><a href="#七、DigitalOcean-VM" class="headerlink" title="七、DigitalOcean VM"></a>七、DigitalOcean VM</h2><p>開發者總是需要一台可以 24 小時對外連線的 VM，來部署一些 side project 或簡易服務，比如之前提到的〈<a href="https://blog.kyomind.tw/weekly-review-21/">21，在 VM 上部署 Umami 替代 GA4</a>〉。</p><p>接下來我會部署更多小專案在上面，所以十分必要。</p><h2 id="八、Google-One"><a href="#八、Google-One" class="headerlink" title="八、Google One"></a>八、Google One</h2><p>Gmail 信箱、Google 相簿等檔案太佔空間，免費額度滿了，訂了最小的 100 GB。</p><p>除非勤刪檔，不然不訂也不行。我選擇後者。</p><h2 id="九、Bear"><a href="#九、Bear" class="headerlink" title="九、Bear"></a>九、Bear</h2><p>筆記軟體 <a href="https://bear.app/">Bear</a> 對我來算是一個「超級加分項」，雖然不算絕對必要，但我願意訂閱，因為它讓我的生活更美好。</p><p>值得一提的是，它的「<strong>同步方案</strong>」採用 Apple 提供的 <a href="https://developer.apple.com/icloud/cloudkit/">CloudKit</a>，在<strong>個人隱私保護</strong>部分明顯優於 Notion、Evernote 等服務。</p><p>有興趣可以看<a href="https://www.reddit.com/r/bearapp/comments/porntu/is_bear_more_secure_than_apple_notes/">這則討論</a>。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/bear/">Evernote 最佳替代方案——筆記軟體 Bear 2 升級心得</a></p></blockquote><h2 id="十、Medium"><a href="#十、Medium" class="headerlink" title="十、Medium"></a>十、Medium</h2><p>主要就是看程式文章用！</p><p>Medium 雖然不是一個開發者平台，但上面還是有許多優質的程式類文章。</p><p>尤其和 <a href="https://dev.to/">DEV Community</a> 這類偏開發者的平台相比，Medium 的文章有一個比較明顯的特色，那就是不完全純技術取向，也有多軟體趨勢、職涯類的文件。</p><p>要說缺點，我認為有很多標題都太聳動了！點進去看，根本雷聲大雨點小，真的是很會「騙」讀者。😈</p><h2 id="十一、Microsoft-365"><a href="#十一、Microsoft-365" class="headerlink" title="十一、Microsoft 365"></a>十一、Microsoft 365</h2><p>訂這個主要是擔心需要開 Office 類檔案——但實際上我似乎完全沒有這類檔案的開啟需求。</p><p>目前對我的實際作用，只有那 1 TB 的 OneDrive。</p><p>因為是家庭方案，不算貴，所以聊勝於無。</p><h2 id="十二、極客時間超級會員"><a href="#十二、極客時間超級會員" class="headerlink" title="十二、極客時間超級會員"></a>十二、極客時間超級會員</h2><p>來自中國的線上學習平台，聚焦在軟體開發，主要以聲音和文字檔為媒介，相當於程式版的「得到 app」。</p><p>前 2 年推出了「<a href="https://time.geekbang.org/hybrid/next/pvip/home">超級會員</a>」這個「吃到飽」服務，可以存取平台 8 成以上的課程。但沒過多久就大幅漲價了（人民幣 499&#x2F;699→2999），還好我也陸續聽了幾十個課程。雖然不算很認真聽，但至少知道哪些課適合自己，以後可以單買。</p><p>考慮到漲價後已然太貴，而且該聽的課其實都差不多了，之後不會再續訂。</p><p>用聽聲音、看文字稿學習程式，當然不是一個特別有效的做法。主要作為「吸收新知」的手段，我覺得還算不錯。</p><hr><h2 id="「內容創作型」付費訂閱"><a href="#「內容創作型」付費訂閱" class="headerlink" title="「內容創作型」付費訂閱"></a>「內容創作型」付費訂閱</h2><p>扣除 Medium 這種「平台式」的內容創作訂閱。在《科技島讀》之後，就沒有我特別感興趣的「<strong>持續性個人創作</strong>」付費訂閱。</p><p>得到 app 上的萬維鋼《精英日課》我每一季都有訂，個人評價也非常高。不過嚴格來說，這只能算是「一次付費、分批交付」而已，稱不上真正的「訂閱制」。</p><p>作為一個文字創作者，想靠純文字吸引我來掏錢，說真的難度不低——我對文字內容含金量的敏感度很高。</p><p>換句話說，我在看一段付費內容時，會去思考：如果我來寫，需要花多少時間？來判斷這錢我付得值不值。</p><p>當然，文字只是一個載體，大部分主題沒有一定背景、資料準備是寫不出來的，比如金融、AI，也包括前述的《科技島讀》。</p><p>此時我的判斷基準則回歸最簡單的「知識愉悅與滿足感」。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/MDQYOVd.png&quot; alt=&quot;DALL·E 3&quot;&gt;&lt;/p&gt;
&lt;p&gt;這篇要來講述，2023 年的當下，對我而言「具有一定重要性」的付費訂閱。&lt;/p&gt;
&lt;p&gt;這屬於完全個人化的心得，我會列出那些不可或缺的訂閱項目，並解釋它們對我的重要性所在。&lt;/p&gt;
&lt;p&gt;所謂的「不可或缺」，意思是一旦我停止訂閱，我的工作和生活都會出現挑戰。而挑戰的大小，就是這些訂閱項目對我的影響力與價值。&lt;/p&gt;
&lt;p&gt;以下排名同時也是重要性排名，就讓我們從最重要的開始吧！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/MDQYOVd.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
    <category term="Medium" scheme="https://blog.kyomind.tw/tags/Medium/"/>
    
    <category term="DigitalOcean" scheme="https://blog.kyomind.tw/tags/DigitalOcean/"/>
    
    <category term="Bear" scheme="https://blog.kyomind.tw/tags/Bear/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="付費訂閱" scheme="https://blog.kyomind.tw/tags/%E4%BB%98%E8%B2%BB%E8%A8%82%E9%96%B1/"/>
    
    <category term="開箱評論" scheme="https://blog.kyomind.tw/tags/%E9%96%8B%E7%AE%B1%E8%A9%95%E8%AB%96/"/>
    
    <category term="極客時間" scheme="https://blog.kyomind.tw/tags/%E6%A5%B5%E5%AE%A2%E6%99%82%E9%96%93/"/>
    
    <category term="Setapp" scheme="https://blog.kyomind.tw/tags/Setapp/"/>
    
  </entry>
  
  <entry>
    <title>別依賴「試誤法」寫程式</title>
    <link href="https://blog.kyomind.tw/stop-trial-and-error/"/>
    <id>https://blog.kyomind.tw/stop-trial-and-error/</id>
    <published>2023-10-04T17:42:55.000Z</published>
    <updated>2024-01-11T16:12:54.834Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/cr4Ay4E.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>這個情況真的太普遍，尤其是知識不夠紮實（指<strong>為開發所做的功課太少</strong>）的開發者。但如下所述，這其實是一個「<strong>開發習慣</strong>」議題。</p><p>無論如何，我不得不為此發聲：「<strong>請停止用『試誤法』來寫程式</strong>！」</p><p>我們先看看維基百科對於「<a href="https://zh.wikipedia.org/zh-tw/%E5%B0%9D%E8%AF%95%E9%94%99%E8%AF%AF%E6%B3%95">試誤法</a>」的闡述：</p><blockquote><p><strong>嘗試錯誤法</strong>，又稱<strong>試誤法</strong>（英語：trial and error），簡稱<strong>試錯</strong>，是用來解決問題、獲取知識。此種方法可以視為簡易解決問題的方法中的一種，與使用洞察力／直覺或理論推理的方法正好相反。</p></blockquote><p>就像這句「此種方法可以視為簡易解決問題的方法中的一種」說的，在我看來，試誤法常常會得到 workaround（雖不能根本解決，但能<strong>暫時繞過問題</strong>的替代方法）等級的答案——這肯定不是好事。</p><p>首先我得說，「試誤」在軟體開發中，是一個常見且實用的手段。</p><p>我自己寫一些邏輯時，也常常在 jupyter notebook 先執行嘗試執行一下程式碼片段，看看結果，以確保我的想法沒錯。<strong>但，這只是一種輔助。</strong></p><p>本文想強調的是：<strong>不要以「試誤」作為開發的基調，或解決問題的主要方式</strong>。換言之，<strong>不要濫用試誤</strong>。</p><p>否則那將是一場災難。</p><p>無數次 trial and error，看起來勤勤懇懇，實際上是<strong>最低效的開發手段</strong>。我覺得，試個兩、三次行不通，就應該<strong>重新思考問題的本質——而非繼續嘗試。</strong></p><span id="more"></span><p>以下我們從除錯（debug）與開發（develop）兩個角度，來看看「濫用試誤法」帶來的悲劇。</p><hr><h2 id="Debug-時的試誤"><a href="#Debug-時的試誤" class="headerlink" title="Debug 時的試誤"></a>Debug 時的試誤</h2><p>Debug 和試誤法似乎挺搭的，不是嗎？一步一步嘗試，直接全都正確了為止。</p><p>看似如此，但實際上<strong>正好相反</strong>。</p><p><strong>把試誤心態用在 debug，恰恰是讓 bug 不斷滋生的主要原因。</strong></p><p>試誤的基本心態是「結果好，一切好」，但我們 debug 往往不僅是為了把當下的錯誤消除掉而已。</p><p>更多時候，<strong>我們想要知曉錯誤發生的「原因」為何</strong>，以及是否存在會引發相關錯誤的其它原由——這些都是試誤法不關心的。</p><p>所以，debug 時，試誤只能作一種<strong>很次要的輔助手段</strong>，我們的目標應該是「<strong>找出錯誤的原因，並想辦法防止同類型錯誤的發生</strong>」。</p><p>只要找不到問題的本源，那後續可有的「試」了。</p><h2 id="開發時的試誤"><a href="#開發時的試誤" class="headerlink" title="開發時的試誤"></a>開發時的試誤</h2><p>別想說只有 debug 才容易讓人陷入試誤的濫用。以「試誤心態」進行開發，我認為也非常普遍！</p><p>這樣的開發者的什麼樣的<strong>習性</strong>？以開發一個新功能為例，常常有以下流程：</p><ul><li>想到什麼就寫什麼——單純把自然語言的需求，翻譯成程式碼，我稱之為「<strong>機器翻譯</strong>」</li><li>從頭到尾寫完，然後看看程式運行會不會出錯（寫完也不重構一下，就像文章草稿完成後，直接發表）</li><li>發現執行結果有錯，看一下錯誤訊息，調整一下程式碼</li><li>可以了！好，下一個功能</li></ul><p>這樣的開發方式有什麼問題？看起來好像也不算太差呀？</p><p>確實，在簡單的需求時，這種開發方式（或說心態、習性）可能是「效率最高」的做法！——姑且不論程式碼品質。</p><h2 id="試誤處理不了變化與複雜"><a href="#試誤處理不了變化與複雜" class="headerlink" title="試誤處理不了變化與複雜"></a>試誤處理不了變化與複雜</h2><p>但只要需求變化、複雜化，包括後續的擴充，這樣的開發方式就不太妙了。</p><p>因為缺乏<strong>全局觀</strong>與開發工具相關（套件、框架）重要知識——<strong>講白了就是文件看太少</strong>，畢竟之前的開發成果主要是靠「試」出來的。</p><p>此時「試誤型開發者」會陷入一個迴圈：</p><ol><li>發現程式執行結果不如預期（未必是無法執行，但就是不如預期）</li><li>不確定原因為何（因為常常都是靠「試誤」在解決問題）</li><li>不斷調整寫法、不斷觀察程式執行結果</li><li>回到前述 1</li></ol><p>隨著專案愈來愈複雜，程式碼行數不斷擴張，這種情況也將隨之增加。</p><p>一言以蔽之，試誤無法有效處理複雜。處理複雜，需要你有系統地思考、更全面的知識——最好多看文件、多問 ChatGPT。而非簡單的試誤。</p><p>但在簡單的需求下，試誤卻是一個<strong>快速完成開發的誘人捷徑</strong>。總是依賴試誤法開發，在複雜的情況就容易原形畢露。</p><hr><h2 id="試誤依賴的根本問題"><a href="#試誤依賴的根本問題" class="headerlink" title="試誤依賴的根本問題"></a>試誤依賴的根本問題</h2><p>現在有了 ChatGPT 這個強力工具，理論上我們的開發水準都在相應提升。</p><p>但是，我必須說，對於依賴試誤開發的人而言，ChatGPT 對他們帶來的提升，<strong>可能是最小的——why</strong>？</p><p>因為這類人很容易把試誤心態帶入 ChatGPT 的使用習慣，所以就變成了「向 ChatGPT 要答案」：</p><ul><li>可以了！→下一題</li><li>不行耶！→修改問題再問一次、補充內容</li></ul><p>反正我要的就是答案，至於原理是什麼，暫且不論。</p><p>沒錯，這只是<strong>另一種方式的試誤</strong>而已。（或許我們可以稱之為「<strong>AI 輔助試誤法</strong>」）</p><p>這樣做絕對可以讓開發變得更快，卻未必能變得「更好」。</p><hr><h2 id="小結：試誤是機器的事"><a href="#小結：試誤是機器的事" class="headerlink" title="小結：試誤是機器的事"></a>小結：試誤是機器的事</h2><p>試誤是機器的事，因為機器擅長此道。沒有人能夠在 1 秒內發出 1000 個請求，但機器卻能輕鬆辦到。</p><p>直白地說，如果軟體工程師終有一天會被 AI 取代，那我相信第一波被取代的，肯定是這些「<strong>只把 AI 當作試誤工具</strong>」的人。</p><p>這樣的用法，相當於把自己當「試誤機器」在運作——但人終究不是機器。</p><p>在快速試誤的競賽中，人和機器，誰更有機會勝出呢？</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-18/">18，論軟體工程師常見的「路徑依賴」問題（上）</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/cr4Ay4E.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;這個情況真的太普遍，尤其是知識不夠紮實（指&lt;strong&gt;為開發所做的功課太少&lt;/strong&gt;）的開發者。但如下所述，這其實是一個「&lt;strong&gt;開發習慣&lt;/strong&gt;」議題。&lt;/p&gt;
&lt;p&gt;無論如何，我不得不為此發聲：「&lt;strong&gt;請停止用『試誤法』來寫程式&lt;/strong&gt;！」&lt;/p&gt;
&lt;p&gt;我們先看看維基百科對於「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%B0%9D%E8%AF%95%E9%94%99%E8%AF%AF%E6%B3%95&quot;&gt;試誤法&lt;/a&gt;」的闡述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;嘗試錯誤法&lt;/strong&gt;，又稱&lt;strong&gt;試誤法&lt;/strong&gt;（英語：trial and error），簡稱&lt;strong&gt;試錯&lt;/strong&gt;，是用來解決問題、獲取知識。此種方法可以視為簡易解決問題的方法中的一種，與使用洞察力／直覺或理論推理的方法正好相反。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就像這句「此種方法可以視為簡易解決問題的方法中的一種」說的，在我看來，試誤法常常會得到 workaround（雖不能根本解決，但能&lt;strong&gt;暫時繞過問題&lt;/strong&gt;的替代方法）等級的答案——這肯定不是好事。&lt;/p&gt;
&lt;p&gt;首先我得說，「試誤」在軟體開發中，是一個常見且實用的手段。&lt;/p&gt;
&lt;p&gt;我自己寫一些邏輯時，也常常在 jupyter notebook 先執行嘗試執行一下程式碼片段，看看結果，以確保我的想法沒錯。&lt;strong&gt;但，這只是一種輔助。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文想強調的是：&lt;strong&gt;不要以「試誤」作為開發的基調，或解決問題的主要方式&lt;/strong&gt;。換言之，&lt;strong&gt;不要濫用試誤&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;否則那將是一場災難。&lt;/p&gt;
&lt;p&gt;無數次 trial and error，看起來勤勤懇懇，實際上是&lt;strong&gt;最低效的開發手段&lt;/strong&gt;。我覺得，試個兩、三次行不通，就應該&lt;strong&gt;重新思考問題的本質——而非繼續嘗試。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/cr4Ay4E.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="工作心得" scheme="https://blog.kyomind.tw/tags/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>Django Tutorial：系列介紹與導讀</title>
    <link href="https://blog.kyomind.tw/django-tutorial/"/>
    <id>https://blog.kyomind.tw/django-tutorial/</id>
    <published>2023-09-30T08:48:35.000Z</published>
    <updated>2024-01-09T15:44:00.668Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a> 系列的第 0 篇——<strong>序言</strong>。主要說明整個系列的寫作動機、文章規劃，並介紹 GitHub 倉庫的使用方式。</p><p>本站所有 Django 教學文章，已整理於 <a href="https://blog.kyomind.tw/django/">Django 文章總覽</a>。</p><p>嘗試寫作這樣「單一主題長系列連載」的靈感，源於下列二者：</p><ul><li><a href="https://www.maxlist.xyz/2020/01/01/author/">Max 行銷誌</a>的 <a href="https://www.maxlist.xyz/2020/05/01/flask-list/">2023 Flask 入門指南</a></li><li><a href="https://blog.aotoki.me/">蒼時弦也</a>的<a href="https://blog.aotoki.me/series/">系列連載</a></li></ul><p>兩位都是「<strong>既能做又能寫</strong>」的優秀開發者，值得我們學習。</p><hr><h2 id="系列寫作動機"><a href="#系列寫作動機" class="headerlink" title="系列寫作動機"></a>系列寫作動機</h2><p>雖然 blog 上本來就有少數被我歸類為「系列」的文章，比如 <a href="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion/">Simple Notion 系列</a>。但最多就是 3-4 篇，這是我有意控制的結果，希望整個創作週期不要拉得太長。</p><p>而且用 3-4 篇呈現、表達一個我認為重要的主題，通常也足夠了。</p><p>後來想到自己雖然在工作上寫了 2 年 Django，對 Django 的文章介紹卻非常少。讓我不免覺得，自己有違作為一個 Django 開發者的「義務」。</p><p>所以起心動念，想說至少寫個「Django Models」三部曲，也就是目前整個系列中，在時間軸上第一篇發表的文章〈<a href="https://blog.kyomind.tw/django-models/">Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</a>〉。</p><p>寫完後又沉寂了好一段時間，才有了這篇序言。</p><span id="more"></span><h2 id="從-Django-Models-到-Django-API"><a href="#從-Django-Models-到-Django-API" class="headerlink" title="從 Django Models 到 Django API"></a>從 Django Models 到 Django API</h2><p>Django models 可以說是 Django 最常見的議題（它確實非常重要），網路上的介紹文章已經不少。</p><p>所以即使寫完這三部曲，我覺得恐怕對讀者的助益仍是有限，想到這裡難免有點動搖，於是遲遲不見第二篇。</p><p>後來又思考了一番，既然如此，那我乾脆把工作中常見的 Django 實作加入這個系列，無疑會更有價值、更完整。</p><p>尤其繁體中文世界對於 Django 的介紹，大多停留在<strong>製作整個網站</strong>（主要介紹模板、Form、View、Model），而不是開發 API——用 Django 開發 API 的相關教材太少了。</p><p>這個現象不難理解，因為在台灣使用 Django 作為產品主要後端的公司相對有限，所以文章分享自然就不是那麼多。</p><p>但工作中你幾乎不太可能直接用 Django 來開發整個網站，畢竟這是個前後端分離的年代。</p><p>想到這裡，寫作 Django 系列教學的動力又回升了！這或許就是我的使命。</p><h2 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h2><p>因此，這系列文章主要針對那些已有 Python 基礎，但想要進一步了解 Django 網頁開發，尤其是「<strong>用 Django 開發 Web API</strong>」的讀者。</p><p>畢竟開發 API 才是我的 Django 日常。</p><p>所以我不得不遺憾地表示，這個系列將不會有任何關於「Django 模板、表單」元件等介紹，也不會討論上述元件與 Django View 的整合議題。</p><p>而是完全以「API」為核心。</p><hr><h2 id="文章規劃"><a href="#文章規劃" class="headerlink" title="文章規劃"></a>文章規劃</h2><p>目前計畫分成三大部分，多個系列，每個系列有多篇文章。</p><h3 id="一、Django-ORM-外鍵入門"><a href="#一、Django-ORM-外鍵入門" class="headerlink" title="一、Django ORM 外鍵入門"></a>一、Django ORM 外鍵入門</h3><p>無論全端還是前後端分離，<strong>Django ORM 的重要性與地位都不會有任何影響</strong>，所以 ORM 三部曲自然還是要一一介紹。</p><p>而且會放在整個系列的最靠前部分。</p><p>目前規劃的文章為：</p><ol><li>Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</li><li>Django ORM：一對一、一對多外鍵教學（中）反向關聯</li><li>Django ORM：一對一、一對多外鍵教學（下）查詢篇</li></ol><p>而且，整個 Django 框架中，我最愛的部分就是 Django ORM——它<strong>強大而優雅</strong>。</p><h3 id="二、pytest-單元測試"><a href="#二、pytest-單元測試" class="headerlink" title="二、pytest 單元測試"></a>二、pytest 單元測試</h3><p>我相信，沒有單元測試的開發，是「不健全」的開發。</p><p>自己的程式自己測，優秀的開發者不會把「低級錯誤」留給 QA，讓 QA 當保姆。</p><p>哪怕只是最基本的，為每一個 API 加上 200 回傳值的單元測試，都遠比沒有來得強。有了測試，再來就是覆蓋率報告。</p><p>文章預計有下：</p><ol><li>Django 測試指南：用 pytest 撰寫 API 單元測試——環境設定篇</li><li>Django 測試指南：用 pytest 撰寫 API 單元測試——Fixtures 篇</li><li>Django 測試指南：使用 pytest + pytest-cov 計算 Test Coverage</li></ol><h3 id="三、Django-API"><a href="#三、Django-API" class="headerlink" title="三、Django API"></a>三、Django API</h3><p>講到 Django API，就不得不提 <a href="https://www.django-rest-framework.org/">Django REST framework</a>（下稱 DRF），尤其是它提供的 <a href="https://www.django-rest-framework.org/api-guide/views/">API view</a>（無論 <a href="https://ithelp.ithome.com.tw/articles/10205779">CBV 或 FBV</a>）與<a href="https://www.django-rest-framework.org/api-guide/serializers/">序列化器</a>。</p><p>當然，時代在變遷，如今開發 Django API 並非只能選擇 DRF，後起之秀 <a href="https://django-ninja.rest-framework.com/">Django Ninja</a> 也值得一試。</p><p>尤其它支援 <a href="https://docs.pydantic.dev/latest/">Pydantic</a>，可以<strong>依程式碼自動生成 API 文件</strong>。你可以簡單想成，它就像是「Django 版的 FastAPI」。</p><p>不過我們的教學還是會以 DRF 為主。</p><p>預計主題有下，目前文章標題皆未定：</p><ul><li>用 DRF 開發 Django API</li><li>DRF 序列化器</li><li>檔案上傳</li><li>國際化（i18n）</li><li>DRF 分頁（Pagination）</li><li>logging</li></ul><p>如你所見，<strong>這並不是一個「大而全」的 Django 教學</strong>，而是<strong>以我自己的實務經驗為主</strong>，介紹我認為最重要且相對熟悉的部分。</p><p>主要的目標是讓讀者可以<strong>快速上手</strong>，並了解 Django API 開發的基本概念。</p><h3 id="非屬系列的-Django-教學"><a href="#非屬系列的-Django-教學" class="headerlink" title="非屬系列的 Django 教學"></a>非屬系列的 Django 教學</h3><p>Blog 的 <a href="https://blog.kyomind.tw/categories/Django/">Django 分類</a>，還是會寫一些和 Django 相關的文章，但不屬於這個大主題的一部分，所以沒有納入系列文章中。</p><p>比如現有的：</p><ul><li><a href="https://blog.kyomind.tw/django-request-headers/">Django：以 request.headers 而非 META 獲取 HTTP header 資訊</a></li><li><a href="https://blog.kyomind.tw/django-mongoengine/">Django 專案 ORM 存取 MongoDB：MongoEngine 設定教學</a></li></ul><hr><h2 id="GitHub-專案介紹"><a href="#GitHub-專案介紹" class="headerlink" title="GitHub 專案介紹"></a>GitHub 專案介紹</h2><p>最後，介紹與整個系列教學直接相關的 GitHub repository——<a href="https://github.com/kyomind/Django-Tutorial">Django Tutorial</a> 專案。</p><p>這個專案的核心定位是「讓有讀者實際程式碼可以參考」。所以基本上是拿來「看」的。</p><p>但實際上我會讓它也能夠真正運行，以方便想要自己動手嘗試的讀者。</p><p>所以會為你準備相對應的 db 資料（使用 Django fixtures）。讓你可以在運行起這個專案後，使用 Postman 等 api client，直接呼叫該 api 親身驗證結果。</p><p>我相信這對學習大有幫助。</p><h3 id="分支的功能"><a href="#分支的功能" class="headerlink" title="分支的功能"></a>分支的功能</h3><p>專案中會有許多分支，採<code>&lt;流水號-文章slug&gt;</code>的模式命名，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01-django-models</span><br></pre></td></tr></table></figure><p>分支主要是作為歷史記錄之用，以及快速查看該分支所對應的<strong>程式碼修改</strong>。</p><p>每個分支所在的 commit 與上一個分支的結束，基本就是整個分支的變更內容（除了我直接在<code>main</code>分支進行修改，比如更新 <code>README</code>）。也就是文章教學中，對專案程式碼新增的部分。</p><p>附帶一提，<strong>分支記錄並非只限 Django Tutorial 系列文章</strong>，別的相關文章可能也會有！</p><p>比如我某篇文章要講解「專案容器化」，用現有的專案來進行示範無疑再好不過，所以也會變動專案程式碼並留下分支記錄。</p><h2 id="為何需要「教學用專案」"><a href="#為何需要「教學用專案」" class="headerlink" title="為何需要「教學用專案」"></a>為何需要「教學用專案」</h2><p>如前所述，<strong>讓系列中的每篇文章，有相應的程式碼可供參考，而且可以實際運行，是我為何特地建立這個專案的核心理由。</strong></p><p>不得不說，維護這樣的專案比單純寫文章來得辛苦。因為如此一來，這些文章中的程式碼舉例，都需要<strong>圍繞著專案而設計</strong>——不能隨意為之，且須有一定的「連貫性」。</p><p>但這麼做的價值是顯而易見的，專案讓這些教學更有<strong>整體感</strong>，與<strong>真實感</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;https://blog.kyomind.tw/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 系列的第 0 篇——&lt;strong&gt;序言&lt;/strong&gt;。主要說明整個系列的寫作動機、文章規劃，並介紹 GitHub 倉庫的使用方式。&lt;/p&gt;
&lt;p&gt;本站所有 Django 教學文章，已整理於 &lt;a href=&quot;https://blog.kyomind.tw/django/&quot;&gt;Django 文章總覽&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;嘗試寫作這樣「單一主題長系列連載」的靈感，源於下列二者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.maxlist.xyz/2020/01/01/author/&quot;&gt;Max 行銷誌&lt;/a&gt;的 &lt;a href=&quot;https://www.maxlist.xyz/2020/05/01/flask-list/&quot;&gt;2023 Flask 入門指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.aotoki.me/&quot;&gt;蒼時弦也&lt;/a&gt;的&lt;a href=&quot;https://blog.aotoki.me/series/&quot;&gt;系列連載&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;兩位都是「&lt;strong&gt;既能做又能寫&lt;/strong&gt;」的優秀開發者，值得我們學習。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;系列寫作動機&quot;&gt;&lt;a href=&quot;#系列寫作動機&quot; class=&quot;headerlink&quot; title=&quot;系列寫作動機&quot;&gt;&lt;/a&gt;系列寫作動機&lt;/h2&gt;&lt;p&gt;雖然 blog 上本來就有少數被我歸類為「系列」的文章，比如 &lt;a href=&quot;https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion/&quot;&gt;Simple Notion 系列&lt;/a&gt;。但最多就是 3-4 篇，這是我有意控制的結果，希望整個創作週期不要拉得太長。&lt;/p&gt;
&lt;p&gt;而且用 3-4 篇呈現、表達一個我認為重要的主題，通常也足夠了。&lt;/p&gt;
&lt;p&gt;後來想到自己雖然在工作上寫了 2 年 Django，對 Django 的文章介紹卻非常少。讓我不免覺得，自己有違作為一個 Django 開發者的「義務」。&lt;/p&gt;
&lt;p&gt;所以起心動念，想說至少寫個「Django Models」三部曲，也就是目前整個系列中，在時間軸上第一篇發表的文章〈&lt;a href=&quot;https://blog.kyomind.tw/django-models/&quot;&gt;Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定&lt;/a&gt;〉。&lt;/p&gt;
&lt;p&gt;寫完後又沉寂了好一段時間，才有了這篇序言。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>重啟了 Twitter 與我的理由</title>
    <link href="https://blog.kyomind.tw/return-to-twitter/"/>
    <id>https://blog.kyomind.tw/return-to-twitter/</id>
    <published>2023-09-27T17:15:14.000Z</published>
    <updated>2024-01-11T13:34:28.867Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>上個月重新登入了塵封一段時間的 Twitter（下稱推特）帳戶。也開始在上面發一些零星的推文——幾乎都是程式相關。</p><p>一直以來我都稱不上推特的重度用戶，如果有一個社群平台是我獲取資訊的來源，那主要還是臉書。</p><p>但我們知道，臉書在幾波隱私相關的大事件後，演算法有了較為明顯的改動。很多人——包括我在內——都覺得臉書的推薦內容不再像過去那般有趣、實用。</p><p>於是在轉職後的這幾年，我也開始看推特。</p><hr><h2 id="Cal-Newport-對推特的看法"><a href="#Cal-Newport-對推特的看法" class="headerlink" title="Cal Newport 對推特的看法"></a>Cal Newport 對推特的看法</h2><p>如果你看比較多 Cal Newport 的內容（主要是 Podcast），你會發現，他雖然沒有任何社群平台帳戶，但他對推特的討論與關注，遠遠超過對其它平台的討論，比如臉書、Substack。</p><p>〈<a href="https://www.thedeeplife.com/podcasts/episodes/ep-241-the-virality-trap/">EP. 241: The Virality Trap</a>〉這集有一定的代表性。</p><span id="more"></span><p>他的基本論調是「推特的影響力被高估了」，大概用詞則是（ChatGPT 整理）：</p><blockquote><p>這是虛榮的販賣機——卻不一定能帶來真實價值。</p></blockquote><blockquote><p>他認為，這些社交媒體平台<strong>只是在吸收用戶的注意力</strong>，並將其轉化為收益，而不是真正的為用戶提供有價值的內容。</p></blockquote><blockquote><p>最後，他強調了一個觀點，那就是最好的策略是遠離這些社交媒體平台，並將注意力集中在更深入、更有價值的事情上。</p></blockquote><p>哈哈，Cal Newport 最後的結論總是「遠離這些平台」。</p><h2 id="我對推特的看法"><a href="#我對推特的看法" class="headerlink" title="我對推特的看法"></a>我對推特的看法</h2><p>我基本認同上述 Cal Newport 觀點，只不過，因為推特並非我的主要舞台，所以我可能不太容易掉入這個「陷阱」中。</p><p>儘管如此，推特還是有一些我不喜歡（或說不適應）的特色。</p><h3 id="一、快速表達帶來的喧囂"><a href="#一、快速表達帶來的喧囂" class="headerlink" title="一、快速表達帶來的喧囂"></a>一、快速表達帶來的喧囂</h3><p>因為每一則都很短，所以用戶常常是想到什麼都趕緊發一推，這讓我感覺有點太喧囂。不過說真的，連我自己都不禁受到平台的影響，也變成類似的發文模式。</p><p>而我對抗這個「引力」的簡單做法就是，限制可以存取的時間。</p><h3 id="二、政治元素太多"><a href="#二、政治元素太多" class="headerlink" title="二、政治元素太多"></a>二、政治元素太多</h3><p>政治味最重的平台，無人能出其右。你也可以說，意識形態非常濃厚。</p><p>我使用推特主要是為了看程式相關的內容，所以總是盡可能把這些聲音 mute 掉。</p><p>並非我不關心政治，只是我「不想在這裡關心」——這裡有我更感興趣的主題。</p><h2 id="離開推特的原因"><a href="#離開推特的原因" class="headerlink" title="離開推特的原因"></a>離開推特的原因</h2><p>我不登入推特超過了半年時間，那時覺得不想再使用它，主要還是因為——<strong>成癮性</strong>。</p><p>我覺得推特的成癮力比臉書更甚，可以說是<strong>文字成癮界的霸主！</strong></p><p>可不是只有我這麼覺得，《<a href="https://www.books.com.tw/products/0010914255">人生4千個禮拜</a>》作者 Oliver Burkeman 在書中也有這麼一段自白：</p><blockquote><p>我自己大概是個好例子。我有段不堪的過往，不過我猜我只是典型的一般人。我曾經對推特成癮，不過即便在我依賴推特的高峰期（我現在正在戒），我黏在螢幕前的時間，一天也很少超過兩小時。<a href="https://www.books.com.tw/products/0010914255">然而，推特占據我注意力的程度，遠遠不只是兩小時的問題而已</a>。</p></blockquote><p>比起臉書，我比較難穩健控制對推特的使用。哪怕給自己訂了一些規則，它也都有足夠的力量，讓我打破規則。</p><p>而且這些社交平台的手機 app 使用體驗都設計得非常棒（用起來非常流暢、絲滑），讓你動不動就想要打開。</p><p>很難想像我還只是一個<strong>中輕度用戶</strong>，成癮性就如此之強。</p><p>就在我某次搭公車，公車搖來搖去但我仍不斷忍著暈眩刷推時，我終於受夠了，刪除了 Twitter app。</p><hr><h2 id="重啟了-Twitter-與我的理由"><a href="#重啟了-Twitter-與我的理由" class="headerlink" title="重啟了 Twitter 與我的理由"></a>重啟了 Twitter 與我的理由</h2><p>理由主要有兩個。</p><h3 id="一、需要一個發表程式類內容的地方"><a href="#一、需要一個發表程式類內容的地方" class="headerlink" title="一、需要一個發表程式類內容的地方"></a>一、需要一個發表程式類內容的地方</h3><p>程式相關內容，發在個人臉書，總讓我覺得猶豫，畢竟我的臉友普遍不是軟體產業的人。</p><p>之前有期待過 <a href="https://www.threads.net/">Threads</a>，但因為要綁 Instagram 帳戶，而且沒有網頁版，讓我意興闌珊。</p><p>重啟了推特後，我發現，過去這些追尋都是多餘的，推特就是最適合的舞台！</p><h3 id="二、我想要看更多有趣的開發資訊"><a href="#二、我想要看更多有趣的開發資訊" class="headerlink" title="二、我想要看更多有趣的開發資訊"></a>二、我想要看更多有趣的開發資訊</h3><p>這點臉書就真的遠遠比不上，只有少數軟體工程師會經營臉書的粉專，但很多軟體工程師都有推特帳戶！且樂於分享開發相關的資訊。</p><p>比起單純的教學文章，這些推文往往帶有更多「經驗與價值偏好」，我覺得這也是推特最吸引我的地方。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上個月重新登入了塵封一段時間的 Twitter（下稱推特）帳戶。也開始在上面發一些零星的推文——幾乎都是程式相關。&lt;/p&gt;
&lt;p&gt;一直以來我都稱不上推特的重度用戶，如果有一個社群平台是我獲取資訊的來源，那主要還是臉書。&lt;/p&gt;
&lt;p&gt;但我們知道，臉書在幾波隱私相關的大事件後，演算法有了較為明顯的改動。很多人——包括我在內——都覺得臉書的推薦內容不再像過去那般有趣、實用。&lt;/p&gt;
&lt;p&gt;於是在轉職後的這幾年，我也開始看推特。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Cal-Newport-對推特的看法&quot;&gt;&lt;a href=&quot;#Cal-Newport-對推特的看法&quot; class=&quot;headerlink&quot; title=&quot;Cal Newport 對推特的看法&quot;&gt;&lt;/a&gt;Cal Newport 對推特的看法&lt;/h2&gt;&lt;p&gt;如果你看比較多 Cal Newport 的內容（主要是 Podcast），你會發現，他雖然沒有任何社群平台帳戶，但他對推特的討論與關注，遠遠超過對其它平台的討論，比如臉書、Substack。&lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;https://www.thedeeplife.com/podcasts/episodes/ep-241-the-virality-trap/&quot;&gt;EP. 241: The Virality Trap&lt;/a&gt;〉這集有一定的代表性。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="數位斷捨離" scheme="https://blog.kyomind.tw/tags/%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
    <category term="Twitter" scheme="https://blog.kyomind.tw/tags/Twitter/"/>
    
  </entry>
  
</feed>
