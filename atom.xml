<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-04-29T05:14:02.132Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django HttpRequest 常用屬性介紹</title>
    <link href="https://blog.kyomind.tw/django-request/"/>
    <id>https://blog.kyomind.tw/django-request/</id>
    <published>2024-04-28T07:08:53.000Z</published>
    <updated>2024-04-29T05:14:02.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="/tags/Django-Tutorial/">Django Tutorial</a> 系列連載的第 3 篇。</p><p>範例程式碼可參考我的 <a href="https://github.com/kyomind/Django-Tutorial">GitHub 專案</a>，更多教學請見「<a href="https://blog.kyomind.tw/django/">Django 文章總覽</a>」。</p><hr><p>如〈<a href="https://blog.kyomind.tw/django-tutorial/">Django Tutorial：系列介紹與導讀</a>〉所言，這個系列主要是圍繞著「Django API」教學展開的。</p><p>但無論是用 Django 建立全端網站，還是開發 API，Django 的 <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/">HttpRequest</a>——也就是我們熟悉的<code>request</code>參數——都是必不可少的元素。</p><p><code>HttpRequest</code>封裝了來自前端的 HTTP 請求，而 Django 會將<code>HttpRequest</code>物件自動帶入 view 函式的<strong>第一位置參數</strong>（通常就叫<code>request</code>），讓我們可以直接使用。</p><h2 id="為何需要了解-HttpRequest-物件"><a href="#為何需要了解-HttpRequest-物件" class="headerlink" title="為何需要了解 HttpRequest 物件"></a>為何需要了解 <code>HttpRequest</code> 物件</h2><p>在我剛開始寫 Django 的時候，根本不太清楚<code>HttpRequest</code>具體有哪些屬性。</p><p>通常是看教學或為了實作某個功能而 Google 的時候，看到範例程式碼使用某個屬性，然後才知道這個屬性的存在。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">    do_something_else()</span><br></pre></td></tr></table></figure><p>看到這段，才知道<code>request</code>有一個<code>method</code>屬性。</p><p>這樣學當然可以，但如果一開始就對常用的<code>HttpRequest</code>屬性有<strong>基本了解</strong>，會讓你在學習 Django 的路上<strong>更加踏實</strong>。</p><span id="more"></span><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>基於上述考量，我覺得還是有必要整理一下，對於 Django 初學者而言，最常用或需要了解的<code>HttpRequest</code>屬性。</p><p>不求多深，或知悉所有屬性的具體用法。面對<code>HttpRequest</code>這樣內容豐富的物件，我們掌握 80&#x2F;20 法則，了解其中<strong>最重要的幾個</strong>，往往就能很有收獲。</p><p>至少，如果讓我重來，我會希望自己一開始就對這些屬性有一定認識。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文的目標讀者，是 <strong>Django 初學者</strong>。</p><p>無論想寫 Django 全端網站（也就是會用到 <a href="https://docs.djangoproject.com/en/5.0/topics/forms/">Django Form</a> 與 <a href="https://docs.djangoproject.com/en/5.0/ref/templates/language/">Template</a>），還是開發 API。這些屬性都相對重要，或至少要知道它有何「替代品」。</p><p>因此，我還會適時補充，使用框架（DRF、Django Ninja）開發 API 時，這些屬性是否被框架提供的新屬性取代。</p><hr><p>本文對<code>HttpRequest</code>屬性與介紹內容，主要整理自<a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#httprequest-objects">官方文件</a>，<strong>我會適度引用原文，並加上我的經驗、看法。</strong></p><p>提醒你：</p><ol><li>看完之後，如果<strong>依舊覺得不熟悉</strong>這些屬性，那也無妨，<strong>有基本的認識就很好了！</strong></li><li>所有的例示以 FBV（function-based view）為主，這是 Django 初學者最常接觸的 view 寫法。</li></ol><hr><p>以下依各個屬性在文件中出現的順序，一一介紹。</p><h2 id="一、HttpRequest-method"><a href="#一、HttpRequest-method" class="headerlink" title="一、HttpRequest.method"></a>一、HttpRequest.method</h2><blockquote><p>A string representing the HTTP method used in the request. This is guaranteed to be uppercase.</p></blockquote><p>表示請求所使用的 HTTP 方法，有兩個重點：</p><ol><li>型別為字串。</li><li>而且字串值一定是全大寫。比如<code>&quot;GET&quot;</code>、<code>&quot;POST&quot;</code>等。</li></ol><p>這或許是新手一開始最常呼叫的屬性XD。當然，前提是你寫的是 FBV（function-based view）。</p><p>在 view 函式中的用法前面已經提過：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">    do_something_else()</span><br></pre></td></tr></table></figure><hr><h2 id="二、HttpRequest-GET"><a href="#二、HttpRequest-GET" class="headerlink" title="二、HttpRequest.GET"></a>二、HttpRequest.GET</h2><blockquote><p>A dictionary-like object containing all given HTTP GET parameters. See the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.QueryDict"><code>QueryDict</code></a> documentation below.</p></blockquote><p>用來獲得 HTTP request 的「<strong>URL 參數</strong>」內容，比如你透過 GET 方法存取下列網址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.books.com/search?category=novel&amp;author=Asimov</span><br></pre></td></tr></table></figure><p>這個屬性可取得<code>?</code>後面的「<code>category=novel&amp;author=Asimov</code>」這段資訊。</p><p>而且屬性值的資料型別，是一個<code>QueryDict</code>。</p><p>關於<code>QueryDict</code>，你目前只需要知道，它是一個類似字典的物件，而<strong>值</strong>主要是<strong>字串</strong>，或<strong>元素為字串的 Python list</strong>——如果一個 key 有多個值。</p><p>以下是用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_books</span>(<span class="params">request</span>):</span><br><span class="line">    category = request.GET.get(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">    author = request.GET.get(<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="不限於-GET-方法"><a href="#不限於-GET-方法" class="headerlink" title="不限於 GET 方法"></a>不限於 GET 方法</h3><p>雖然叫做<code>GET</code>，但實際上這個屬性不限於 GET 方法，只要是 URL 參數，都可以透過這個屬性取得。</p><p>畢竟除了 GET 方法，還有 DELETE、PATCH 等方法，也都可以透過 URL 參數傳遞資訊。只是因為 GET 方法最常見，所以這個屬性叫做<code>GET</code>。</p><p>我覺得這個命名<strong>多少有點誤導性</strong>，但不算是大問題。</p><h3 id="使用-DRF-框架"><a href="#使用-DRF-框架" class="headerlink" title="使用 DRF 框架"></a>使用 DRF 框架</h3><p>在 DRF（<a href="https://www.django-rest-framework.org/">Django REST framework</a>）的 <a href="https://www.django-rest-framework.org/api-guide/requests/#request-parsing">request</a> 中，官方推薦你使用 <a href="https://www.django-rest-framework.org/api-guide/requests/#query_params">query_params</a> 屬性代替<code>GET</code>屬性：</p><blockquote><p>For clarity inside your code, we recommend using <code>request.query_params</code> instead of the Django’s standard <code>request.GET</code>.</p></blockquote><p>如前所述，<code>GET</code>屬性名稱有點誤導性，而 DRF 的<code>query_params</code>確實比較合理。</p><p>至於是不是要遵守這個建議，我覺得最大的重點是「整個專案的<strong>一致性</strong>」——不要有人寫<code>query_params</code>、有人寫<code>GET</code>。</p><p>而 <a href="https://django-ninja.dev/">Django Ninja</a> 則沒有這個問題（不需要用到<code>GET</code>屬性），以後介紹 Django Ninja 再詳談。</p><hr><h2 id="三、HttpRequest-POST"><a href="#三、HttpRequest-POST" class="headerlink" title="三、HttpRequest.POST"></a>三、HttpRequest.POST</h2><blockquote><p>A dictionary-like object containing all given HTTP <strong>POST</strong> parameters, providing that the request contains <strong>form data</strong>.</p></blockquote><blockquote><p>See the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.QueryDict"><code>QueryDict</code></a> documentation below.</p></blockquote><blockquote><p>If you need to access raw or non-form data posted in the request, access this through the <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.body"><code>HttpRequest.body</code></a> attribute instead.</p></blockquote><blockquote><p><code>POST</code> does <strong>not</strong> include file-upload information. See <a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.FILES"><code>FILES</code></a>.</p></blockquote><p>我故意把一段原文分 4 段引用，因為它有下列重點：</p><ol><li>這個<code>POST</code>屬性，必須你的 HTTP 請求是 POST 方法。（對應第一段）</li><li>內容是 POST 請求中附帶的「表單資訊（form data）」。（對應第一段，這是最重要的一點！）</li><li>值的型別也是<code>QueryDict</code>。如前所述，值必為字串。（對應第二段）</li><li>如果想取得 form data 以外的內容，要使用<code>HttpRequest.body</code>。（對應第三段）</li><li>不包含上傳的檔案。因為已經有<code>FILES</code>屬性。（對應第四段）</li></ol><h3 id="只限-form-data"><a href="#只限-form-data" class="headerlink" title="只限 form data"></a>只限 form data</h3><p>簡單來說，這個屬性值對應 POST 請求中的 body，但 header 的<code>Content-Type</code>必須為<code>application/x-www-form-urlencoded</code>才行。</p><p>即 body <strong>必須是 form data</strong>，否則<code>POST</code>屬性不會有值。</p><p>不得不說，這屬性名稱也一樣<strong>有點誤導</strong>，因為它<strong>只限於 form data。</strong></p><p>當<code>Content-Type</code>是<code>application/json</code>或其他非表單的類型時，<code>HttpRequest.POST</code> 將會是<strong>空的</strong>，因為 Django 不會自動解析這些類型的資訊到 <code>POST</code> 屬性中。</p><h3 id="只限-POST-方法"><a href="#只限-POST-方法" class="headerlink" title="只限 POST 方法"></a>只限 POST 方法</h3><p>和<code>GET</code>屬性不同，<code>POST</code>屬性「<strong>只限</strong>」使用 POST 方法，這點要特別注意。</p><p>可是，其餘帶有 body 的方法，比如 PUT、PATCH、DELETE，<strong>也可能有 form data</strong>，但 Django 也不會自動解析到<code>POST</code>屬性中。此時該怎麼辦？</p><p>答案是：使用<code>request.body</code>屬性，自行解析。</p><h3 id="HttpRequest-body"><a href="#HttpRequest-body" class="headerlink" title="HttpRequest.body"></a>HttpRequest.body</h3><p>上述的<code>request.POST</code>有一定的限制，而<code>body</code>屬性更加全面。它也是代表 HTTP 請求 body 資料，不限於 POST 方法，且不限於 form data。</p><p>不過，<strong>它的屬性值型別是 bytestring：</strong></p><blockquote><p>The raw HTTP request body as a bytestring.</p></blockquote><p>你需要<strong>手動處理</strong>這個 bytestring，比如使用<code>json.loads()</code>解析 JSON 格式 body。</p><p>所以，實際上我們比較少用到<code>request.body</code>，而是用 DRF 的 <a href="https://www.django-rest-framework.org/api-guide/requests/#data">request.data</a> 屬性，或 Django Ninja 的 <a href="https://django-ninja.dev/guides/input/body/">Schema</a>。</p><p>它們會自動解析 body 資料，並轉換成 Python 物件。</p><h3 id="程式碼實例"><a href="#程式碼實例" class="headerlink" title="程式碼實例"></a>程式碼實例</h3><p>想像一個申請表單：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">submit_form</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        name = request.POST.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        email = request.POST.get(<span class="string">&#x27;email&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其中要注意的是，HTTP POST 方法才會有<code>request.POST</code>屬性值，所以一定要先檢查方法：<code>if request.method == &#39;POST&#39;</code>。</p><p>並且如上所述，即使是 POST 方法，如果請求 body 不是 form data，<code>request.POST</code>依舊是空的。</p><h3 id="實務使用建議"><a href="#實務使用建議" class="headerlink" title="實務使用建議"></a>實務使用建議</h3><p>上述細節可能會新手有點眼花撩亂，不過別擔心，我們從一個更 high level 的角度看。</p><p>如果你寫的是「全端」Django，也就是包括了 Django Form 和模板，那這個<code>POST</code>屬性應該會<strong>很常用</strong>。因為前端（也就是 Django 模板）會傳來大量的 form data。</p><p>但如果你是寫 API，則這個屬性基本上不會用到。因為 API 的前端請求，往往是 JSON 格式，即<code>Content-Type</code>為<code>application/json</code>，而不會是 form data。</p><p>簡言之：</p><ul><li>寫全端 Django 用<code>request.POST</code>屬性。</li><li>寫 API 則是用<strong>別的屬性</strong>，比如 DRF 的<code>request.data</code>。</li></ul><hr><h2 id="四、HttpRequest-FILES"><a href="#四、HttpRequest-FILES" class="headerlink" title="四、HttpRequest.FILES"></a>四、HttpRequest.FILES</h2><blockquote><p>A dictionary-like object containing all uploaded files. Each key in <code>FILES</code> is the <code>name</code> from the <code>&lt;input type=&quot;file&quot; name=&quot;&quot;&gt;</code>. Each value in <code>FILES</code> is an <a href="https://docs.djangoproject.com/en/5.0/ref/files/uploads/#django.core.files.uploadedfile.UploadedFile"><code>UploadedFile</code></a>.</p></blockquote><p>上傳檔案必備！</p><p>注意，這個<code>FILES</code>只是一個類字典，字典的每一個 key 的<strong>值</strong>才是你上傳的檔案。</p><blockquote><p><code>FILES</code> will only contain data if the request method was POST and the <code>&lt;form&gt;</code> that posted to the request had <code>enctype=&quot;multipart/form-data&quot;</code>. Otherwise, <code>FILES</code> will be a blank dictionary-like object.</p></blockquote><p>重點：</p><ol><li>必須使用 POST 方法。</li><li>而且<code>Content-Type</code>為<code>multipart/form-data</code>。</li></ol><p>至於在 view 函式中的操作與使用，較為複雜（牽涉到 <a href="https://docs.djangoproject.com/en/5.0/ref/models/fields/#filefield">FileField</a>），可自行參考<a href="https://docs.djangoproject.com/en/5.0/topics/files/">文件</a>，在此先略不介紹。</p><hr><h2 id="五、關於-Headers"><a href="#五、關於-Headers" class="headerlink" title="五、關於 Headers"></a>五、關於 Headers</h2><p><code>HttpRequest.META</code><a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.META">¶</a></p><blockquote><p>A dictionary containing all available HTTP headers.</p></blockquote><p><code>HttpRequest.headers</code><a href="https://docs.djangoproject.com/en/5.0/ref/request-response/#django.http.HttpRequest.headers">¶</a></p><blockquote><p>A case insensitive, dict-like object that provides access to all HTTP-prefixed headers (plus <code>Content-Length</code> and <code>Content-Type</code>) from the request.</p></blockquote><p>這部分我們已經有過專文介紹，可直接參考：</p><ul><li><a href="https://blog.kyomind.tw/django-request-headers/">Django：以 request.headers 而非 META 獲取 HTTP header 資訊</a></li></ul><h2 id="六、Attributes-set-by-middleware"><a href="#六、Attributes-set-by-middleware" class="headerlink" title="六、Attributes set by middleware"></a>六、Attributes set by middleware</h2><p>從 Django 的 middleware 整合而獲得的屬性，這些屬性的值「不屬於」HTTP 請求中的資料，而是 Django 基於方便開發，自動幫你加上去的。</p><p>比較重要且常用的是這兩個：</p><ul><li><code>HttpRequest.session</code></li><li><code>HttpRequest.user</code></li></ul><p>這些可以等用到相關 Django 模組時，再深入了解即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 系列連載的第 3 篇。&lt;/p&gt;
&lt;p&gt;範例程式碼可參考我的 &lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;GitHub 專案&lt;/a&gt;，更多教學請見「&lt;a href=&quot;https://blog.kyomind.tw/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如〈&lt;a href=&quot;https://blog.kyomind.tw/django-tutorial/&quot;&gt;Django Tutorial：系列介紹與導讀&lt;/a&gt;〉所言，這個系列主要是圍繞著「Django API」教學展開的。&lt;/p&gt;
&lt;p&gt;但無論是用 Django 建立全端網站，還是開發 API，Django 的 &lt;a href=&quot;https://docs.djangoproject.com/en/5.0/ref/request-response/&quot;&gt;HttpRequest&lt;/a&gt;——也就是我們熟悉的&lt;code&gt;request&lt;/code&gt;參數——都是必不可少的元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HttpRequest&lt;/code&gt;封裝了來自前端的 HTTP 請求，而 Django 會將&lt;code&gt;HttpRequest&lt;/code&gt;物件自動帶入 view 函式的&lt;strong&gt;第一位置參數&lt;/strong&gt;（通常就叫&lt;code&gt;request&lt;/code&gt;），讓我們可以直接使用。&lt;/p&gt;
&lt;h2 id=&quot;為何需要了解-HttpRequest-物件&quot;&gt;&lt;a href=&quot;#為何需要了解-HttpRequest-物件&quot; class=&quot;headerlink&quot; title=&quot;為何需要了解 HttpRequest 物件&quot;&gt;&lt;/a&gt;為何需要了解 &lt;code&gt;HttpRequest&lt;/code&gt; 物件&lt;/h2&gt;&lt;p&gt;在我剛開始寫 Django 的時候，根本不太清楚&lt;code&gt;HttpRequest&lt;/code&gt;具體有哪些屬性。&lt;/p&gt;
&lt;p&gt;通常是看教學或為了實作某個功能而 Google 的時候，看到範例程式碼使用某個屬性，然後才知道這個屬性的存在。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; request.method == &lt;span class=&quot;string&quot;&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do_something()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; request.method == &lt;span class=&quot;string&quot;&gt;&amp;quot;POST&amp;quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do_something_else()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;看到這段，才知道&lt;code&gt;request&lt;/code&gt;有一個&lt;code&gt;method&lt;/code&gt;屬性。&lt;/p&gt;
&lt;p&gt;這樣學當然可以，但如果一開始就對常用的&lt;code&gt;HttpRequest&lt;/code&gt;屬性有&lt;strong&gt;基本了解&lt;/strong&gt;，會讓你在學習 Django 的路上&lt;strong&gt;更加踏實&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="HTTP" scheme="https://blog.kyomind.tw/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>28，去了 2 個月圖書館之後</title>
    <link href="https://blog.kyomind.tw/weekly-review-28/"/>
    <id>https://blog.kyomind.tw/weekly-review-28/</id>
    <published>2024-04-24T09:26:27.000Z</published>
    <updated>2024-04-25T07:00:47.740Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>今年 2 月下旬，我決定晚上（下班後）去圖書館讀書！</p><p>原因很簡單，我在家不好讀書，主要有兩點：</p><ol><li>如你所知，房間誘惑較多。不過這點其實還好，畢竟我工作、學習都是在家，所以不是主因。</li><li>這才是主因，因為目前升降桌的燈光、螢幕都是為了「<strong>使用電腦</strong>」而設計，並不適合用來讀書。</li></ol><p>以前我有兩張桌子，直接切換，一張專門用來讀書，那樣比較合乎實際。但換了升降桌後，小小的租屋空間就不夠了，不得不把「書桌」丟棄。</p><p>一直都有勉強試著讀書，但效果真的好差！</p><p>因為過程很麻煩，要先移開鍵盤，如果滑鼠沒放好，螢幕不時會被喚醒。檯燈我用的是 BenQ 的 ScreenBar，看螢幕很棒，但讀書的話，光源距離桌面又有點太遠了！而且角度也需要再調整。</p><p>讀個書猶如<strong>愚公移山</strong>，最後，我決定放棄苦苦掙扎，乖乖去圖書館！</p><span id="more"></span><h2 id="圖書館是好東西"><a href="#圖書館是好東西" class="headerlink" title="圖書館是好東西"></a>圖書館是好東西</h2><p>沒想到，一個月過去，效果比我想像得好耶！</p><p>所以我不禁發了這篇<a href="https://www.facebook.com/kyomind/posts/pfbid02e1m3JC6jj8WBSUcMhP5CiPQotPyZs5rqA8S1U5edMRaAhx1vUvC7F4pKfNQL1JP9l">臉書</a>，讚嘆圖書館的偉大。</p><p>我對自己的<strong>期待</strong>是這樣：一星期就去個 3、4 次，而且每次大概就讀 1 個半小時左右，時間不夠就 1 小時即可。不求多，只求能持續為之。</p><p>這樣做有兩個好處：</p><ol><li><strong>壓力不會太大</strong>：雖然讀書沒有健身那麼讓我想逃避🐥，但它依舊不是一件輕鬆的事。既然如此，還是不要太求好心切，以免適得其反。</li><li><strong>保留彈性，容易長久</strong>：雖然目前為止，也才持續了 2 個月左右。但我相信，之所以能夠持續，正是因為我的要求不高！這是我喜歡的實踐風格：適度的努力——<strong>適度就好。</strong></li></ol><p>還有一個原因是：我往往讀 1 個半小時就會很想回家了！</p><p>總之，平日一到四的晚上如果沒事，我就會去圖書館。通常是 7 點到，9 點前離開，我很喜歡這樣的「<strong>固定感</strong>」。</p><h2 id="需要認真讀的書，其實不多"><a href="#需要認真讀的書，其實不多" class="headerlink" title="需要認真讀的書，其實不多"></a>需要認真讀的書，其實不多</h2><p>這兩個月，我有一個<strong>很直接的感受</strong>，那就是：大部分的書，可讀可不讀啦！</p><p>說真的，大部分的書，都很難，可惜，<strong>難不等於有用</strong>。</p><p>有沒有用，還是看<strong>自己所處的階段、狀態</strong>而定。當然，書寫得好也挺重要。</p><p>不過話說回來，雖然大部分的書，我認為並不值得細讀。但是，想要知道哪些書應該細讀，而哪些則否，基本上還是得把它們都「<strong>粗讀</strong>」過才行XD</p><p>這通常不會花太多時間，了不起幾個小時——或 5-10 小時🤣</p><p>我去圖書館的第 1 個月，基本上就是在對過去買的書進行粗讀。不過，粗歸粗，有些地方也很難速速帶過，還是得停下來思考才行。所以有時候幾個小時不夠。</p><p>而且，這種「<strong>有意識的節奏變換</strong>」，真的很需要練習，因為「忽快忽慢」的閱讀會讓人不太適應——我們總是本能地想要勻速前進。</p><h2 id="粗讀之後，是細讀"><a href="#粗讀之後，是細讀" class="headerlink" title="粗讀之後，是細讀"></a>粗讀之後，是細讀</h2><p>粗讀完之後，接下來就是細讀了。</p><p>在我看來，有<strong>兩種書</strong>需要細讀：</p><ol><li>有些書的「其中一部分」很重要，對這些重要部分進行細讀就好了。比如我已經寫了<a href="https://blog.kyomind.tw/robust-python-01/">第一篇筆記</a>的《<a href="https://www.tenlong.com.tw/products/9786263241015">強健的 Python</a>》，只有前 1&#x2F;3 我會再次細讀。</li><li>大部分都很重要的書。如前所述，這種書不多，但還是要再次強調，重要與否，與每個人的當前條件有關。對我來說，《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠</a>》和《<a href="https://www.tenlong.com.tw/products/9786263246331">流暢的 Python</a>》是值得<strong>整本細讀</strong>的好書。</li></ol><p>這些細讀，往往需要花<strong>很多時間</strong>。而且，<strong>最好</strong>（應該說「必須」）搭配<strong>實作</strong>，不然恐怕也是事倍功半。</p><p>而就我的經驗，<strong>寫文章</strong>也是一種不錯的實作方式唷！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;今年 2 月下旬，我決定晚上（下班後）去圖書館讀書！&lt;/p&gt;
&lt;p&gt;原因很簡單，我在家不好讀書，主要有兩點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如你所知，房間誘惑較多。不過這點其實還好，畢竟我工作、學習都是在家，所以不是主因。&lt;/li&gt;
&lt;li&gt;這才是主因，因為目前升降桌的燈光、螢幕都是為了「&lt;strong&gt;使用電腦&lt;/strong&gt;」而設計，並不適合用來讀書。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以前我有兩張桌子，直接切換，一張專門用來讀書，那樣比較合乎實際。但換了升降桌後，小小的租屋空間就不夠了，不得不把「書桌」丟棄。&lt;/p&gt;
&lt;p&gt;一直都有勉強試著讀書，但效果真的好差！&lt;/p&gt;
&lt;p&gt;因為過程很麻煩，要先移開鍵盤，如果滑鼠沒放好，螢幕不時會被喚醒。檯燈我用的是 BenQ 的 ScreenBar，看螢幕很棒，但讀書的話，光源距離桌面又有點太遠了！而且角度也需要再調整。&lt;/p&gt;
&lt;p&gt;讀個書猶如&lt;strong&gt;愚公移山&lt;/strong&gt;，最後，我決定放棄苦苦掙扎，乖乖去圖書館！&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="圖書館" scheme="https://blog.kyomind.tw/tags/%E5%9C%96%E6%9B%B8%E9%A4%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python API 開發：善用 Enum 的三大關鍵特性</title>
    <link href="https://blog.kyomind.tw/python-enum/"/>
    <id>https://blog.kyomind.tw/python-enum/</id>
    <published>2024-04-19T09:11:47.000Z</published>
    <updated>2024-04-21T09:49:12.717Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/5lvKO0a.jpeg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>想必你知道 Python 中有一個內建的特殊類別叫 <a href="https://docs.python.org/zh-tw/3.12/library/enum.html#enum.Enum">Enum</a>（來自 <a href="https://docs.python.org/zh-tw/3.12/library/enum.html">enum</a> 模組），專門用來處理「列舉」態型的資料集合。</p><p>如同 <a href="https://docs.python.org/zh-tw/3/library/collections.html">collection</a> 模組中的各種容器（比如：<a href="https://docs.python.org/zh-tw/3/library/collections.html#collections.deque"><code>deque</code></a>、<a href="https://docs.python.org/zh-tw/3/library/collections.html#collections.Counter"><code>Counter</code></a>），Enum 已經定義好很多「<strong>內建特性（屬性、方法、行為）</strong>」供你使用。這些特性會讓你在<strong>處理特定情境</strong>時非常順手。</p><p>但是，這些特性也使得 Enum 類別與一般類別<strong>有著很大的差異，增加了學習門檻</strong>。</p><p>如你所見，Enum 的特性頗多，這讓人在學習、使用之前，難免有點<strong>望之卻步</strong>——至少我是這樣！</p><h2 id="本文主旨與架構"><a href="#本文主旨與架構" class="headerlink" title="本文主旨與架構"></a>本文主旨與架構</h2><p>本文分享我最近才開始把 Enum 應用在 API 開發中的經驗——從它的三大特性入手，並輔以一個實際問題情境。</p><p>Enum 的特性不少，但只要知曉這三件事，就可以在遇到「列舉」欄位時，善用 Enum 來提升開發效率，同時增進程式碼的簡潔與穩健。</p><p>不過話說回來，即使不是開發 API，也不影響你對本文的理解。只是我的經驗是從後端開發而來。</p><h3 id="本文架構"><a href="#本文架構" class="headerlink" title="本文架構"></a>本文架構</h3><p>為了讓你感受 Enum 的強大與美妙，<strong>本文的架構經過精心設計。</strong>共分為<strong>三個部分</strong>：</p><ol><li><strong>問題情境</strong>：我會先提出一個<strong>問題情境</strong>，突顯舊方法的不足。</li><li>然後再介紹 Enum 的<strong>三大特性</strong>，帶你進入 Enum 的世界。</li><li>最後看 Enum 特性在問題情境中<strong>如何有效發揮</strong>，讓程式碼變得更加優雅——也就是它<strong>解決的痛點</strong>。</li></ol><p>藉由這個流程，相信你對 Enum 會有更進一步的理解。</p><span id="more"></span><hr><p>話不多說，先從問題情境開始。</p><h2 id="第一部分：問題情境"><a href="#第一部分：問題情境" class="headerlink" title="第一部分：問題情境"></a>第一部分：問題情境</h2><p>為了有效講解，舉個<strong>實例</strong>是必要的，但我會<strong>盡可能簡化</strong>，只著眼於能夠彰顯 Enum 價值的部分。</p><p>作為一個 Django API 開發者，不管是什麼專案，幾乎都會出現「列舉型」資料。此時 Django ORM 中對應的就是「<a href="https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.Field.choices">choices</a>」欄位。</p><p>假設我們現在要開發一個 Docker 相關的服務（這是我實際遇到的情境），其中一個 API 是「新增容器」。而容器有一個需要使用者輸入的設定是：restart policy。</p><p>從官方文件可知，Docker 容器的 restart policy <a href="https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy">總共就只有 4 種而已</a>——沒錯，它屬於<strong>列舉型資料</strong>！</p><h3 id="Django-Model-欄位設計"><a href="#Django-Model-欄位設計" class="headerlink" title="Django Model 欄位設計"></a>Django Model 欄位設計</h3><p>此時，我們的 Django model 欄位會長這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    RESTART_POLICIES = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">&#x27;no&#x27;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&#x27;always&#x27;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&#x27;unless-stopped&#x27;</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="string">&#x27;on-failure&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    restart_policy = models.PositiveSmallIntegerField(</span><br><span class="line">        choices=RESTART_POLICIES, default=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>為了方便講解與避免混淆，這裡我採用了「數字（0-3）」作為列舉成員。但實際工作中，我使用的是「字串」，也就是<code>&#39;no&#39;</code>、<code>&#39;always&#39;</code>等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    RESTART_POLICIES = (</span><br><span class="line">        (<span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;no&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;always&#x27;</span>, <span class="string">&#x27;always&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;unless-stopped&#x27;</span>, <span class="string">&#x27;unless-stopped&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;on-failure&#x27;</span>, <span class="string">&#x27;on-failure&#x27;</span>),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>這是一個<strong>重要的細節</strong>，以後會另篇討論：什麼時候列舉成員應該用數字，而什麼時候用字串更好。</p><p>為了專注於對 Enum 的學習，這裡採最常見的「數字」版本。</p><hr><h2 id="以往的做法"><a href="#以往的做法" class="headerlink" title="以往的做法"></a>以往的做法</h2><p>以前用 DRF（<a href="https://www.django-rest-framework.org/">Django REST framework</a>）開發 API 列舉資料時，除了在 model 增加了上述的 choices 限制，我並沒有使用 Enum。</p><p>這裡有一個問題：那前端人員怎麼知道列舉的「成員」<strong>有幾個、有哪些？</strong>當然只能靠 API 文件！</p><p>以往我們都是用 <a href="https://apiblueprint.org/">API Blueprint</a> 寫 API 文件。說真的，<strong>我不喜歡（我的後端同事們也都不喜歡XD）</strong>，太多手刻細節了——難怪它的普及率不高🙂‍↔️</p><p>雖然在 codebase 中看不到 Enum 的身影，但是，為了增加<strong>程式碼可讀性</strong>，我們還是會額外設計這樣的類別（這是為了後端開發者們在維護上的考慮）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如何使用這個類別？</p><p>一個典型的情境是，在 view 函式中<strong>將變數值與列舉成員進行比較</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> restart_policy == RestartPolicy.UNLESS_STOPPED</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>有了<code>RestartPolicy</code>，程式碼變得更加<strong>直觀</strong>，<strong>易讀</strong>。</p><p>換句話說，我們<strong>不會</strong>直接這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> restart_policy == <span class="number">2</span>  <span class="comment"># 咦，2 是什麼東西？</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><hr><h2 id="驗證列舉成員"><a href="#驗證列舉成員" class="headerlink" title="驗證列舉成員"></a>驗證列舉成員</h2><p>如果列舉資料只限於後端自行使用，那上述的寫法其實就足夠了。</p><p>但是，很多時候列舉資料是從<strong>前端（使用者輸入）</strong>來的。</p><p>此時你<strong>首先</strong>要驗證前端給的資料，<strong>是不是屬於這個列舉集合的成員</strong>！套用上面的寫法就會顯得囉嗦：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    RestartPolicy.NO,</span><br><span class="line">    RestartPolicy.ALWAYS,</span><br><span class="line">    RestartPolicy.UNLESS_STOPPED,</span><br><span class="line">    RestartPolicy.ON_FAILURE):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>為了不要讓程式這麼冗長，我們通常會幫這個類別加上一個簡單的<code>ALL</code>屬性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br><span class="line">    ALL = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>於是程式碼變成這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">not</span> <span class="keyword">in</span> RestartPolicy.ALL:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>好像還可以，不是嗎？——但這顯然<strong>不是最佳實踐</strong>。</p><p>雖然在這個例子中，restart policy 主要就這 4 種，而且也不太會變動。</p><p>但如果在別的列舉場合，偶爾甚至不時會增加成員時，我們的 ALL 屬性的值也要跟著修正，這會產生潛在的「同步」問題——<strong>忘記</strong>一併更新 ALL 屬性。</p><h3 id="使用序列化器驗證"><a href="#使用序列化器驗證" class="headerlink" title="使用序列化器驗證"></a>使用序列化器驗證</h3><p>話說回來，DRF 有<a href="https://www.django-rest-framework.org/api-guide/serializers/">序列化器模組</a>，作為驗證輸入資料正確性的手段。</p><p>只要你有寫序列化器，通常也不需要像上述程式碼一般手工驗證。</p><p>但畢竟寫序列化器需要一定的成本與維護，一些相對簡單的 POST API，你可能未必有相關的序列化器。</p><p>退萬步言，你就是要在某些自定義的邏輯進行手動驗證，上面的程式碼還是會出現。</p><h2 id="小結：目前寫法的問題"><a href="#小結：目前寫法的問題" class="headerlink" title="小結：目前寫法的問題"></a>小結：目前寫法的問題</h2><p>假設沒有序列化器輔助，要在程式碼中進行手動驗證，則上述寫法有兩個不妥之處：</p><ol><li>要驗證 input 資料是否為合法列舉成員，太囉嗦、冗長了。</li><li>如果加上<code>ALL</code>這類自定義屬性，雖然可以減緩程式碼冗長問題，又產生了潛在的同步問題。</li></ol><p>事實上，即使沒有<code>ALL</code>屬性，<strong>第一種寫法一樣存在同步問題</strong>。因為你要<strong>手動</strong>維護這個驗證條件。</p><p><code>ALL</code>屬性只是把這個「<strong>新增、刪除列舉成員</strong>」的<strong>同步議題</strong>從 view 函式中（或任何其它用到的地方）抽離出來，統一移到類別中控管。</p><p>這或許可以算是一個<strong>改進</strong>：當情況變動時，需要跟著修改的地方<strong>只剩下一個</strong>——<code>ALL</code>本身。<strong>但依舊不是最佳解法。</strong></p><hr><h2 id="第二部分：介紹-Python-Enum-的三大特性"><a href="#第二部分：介紹-Python-Enum-的三大特性" class="headerlink" title="第二部分：介紹 Python Enum 的三大特性"></a>第二部分：介紹 Python Enum 的三大特性</h2><p>自從寫 <a href="https://django-ninja.dev/">Django Ninja</a> 後，為了渲染出嚴謹的 API 文件，我不得不用 Enum 了（可參考文章最後的<a href="/python-enum/#%E8%A3%9C%E5%85%85%EF%BC%9AEnum-%E9%A1%9E%E5%88%A5%E5%9C%A8-Django-Ninja-%E4%B8%AD%E7%9A%84%E6%87%89%E7%94%A8">補充</a>部分），同時也感受到了它的強大！</p><p>我們來看看，採用 Enum 之後會有什麼改變。</p><p>在此之前，我們要先介紹 Enum 中，<strong>我認為最重要的三大特性</strong>。至少在我的例子中，知道這三個特性會<strong>非常有用</strong>。</p><p>我們看一下加入了 Enum 後的類別模樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestartPolicy</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    所有容器重啟策略</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    NO = <span class="number">0</span></span><br><span class="line">    ALWAYS = <span class="number">1</span></span><br><span class="line">    UNLESS_STOPPED = <span class="number">2</span></span><br><span class="line">    ON_FAILURE = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>我把<code>ALL</code>屬性移除了，因為它不再需要。</p><p>我們就以這個新類別為例，來看看 Enum 的三大特性。</p><hr><h2 id="一、Enum-類別可以用-for-迴圈迭代"><a href="#一、Enum-類別可以用-for-迴圈迭代" class="headerlink" title="一、Enum 類別可以用 for 迴圈迭代"></a>一、Enum 類別可以用 for 迴圈迭代</h2><p>一般的類別並不能以 for 迴圈迭代，因為沒有實作<code>__iter__</code>方法，但 Enum 有！</p><p>對於「列舉」這種有限成員的情況，能迭代它非常重要。</p><p>還記得原來的<code>ALL</code>屬性嗎？ <code>ALL = [0, 1, 2, 3]</code></p><p>這個<code>ALL</code>屬性的值，其實就是<strong>為了取得類別中的每一個屬性值</strong>。但有了 Enum，我們不用這麼麻煩了！</p><p>那我要怎麼取得 Enum 類別中的所有屬性值？這就要看下面第二個特性。</p><h2 id="二、了解-Enum-實例"><a href="#二、了解-Enum-實例" class="headerlink" title="二、了解 Enum 實例"></a>二、了解 Enum 實例</h2><p>這段特別長，因為它包含了<strong>三個子命題</strong>，都和 Enum 實例有關。</p><p>這裡要先問：<strong>如何取得 Enum 實例？</strong></p><h3 id="Enum-實例的建構與條件"><a href="#Enum-實例的建構與條件" class="headerlink" title="Enum 實例的建構與條件"></a>Enum 實例的建構與條件</h3><p>沒錯，和一般的類別相同，都是從建構與初始化開始，依舊使用上面的例子，我們可以像這樣獲得 Enum 實例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = RestartPolicy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>和一般類別<strong>不同</strong>的是，這裡的建構<strong>引數</strong>，<strong>只能</strong>是「<strong>任一 Enum 成員的屬性值</strong>」。也就是範例類別中的<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>。</p><p>這是 Enum 類別的<strong>限制</strong>，也是它的<strong>重要特性</strong>。</p><p>換句話說，<strong>所有 Enum 類別的實例，都一定是由 Enum 成員值（比如上述的 2）建構而來的</strong>。</p><p>此外，<strong>沒有引數也不行！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沒有引數會報錯</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy()</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">TypeError: EnumMeta.__call__() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure><p>而建構出的實例，就是<strong>「代表該成員」的 Enum 實例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>)</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Enum-類別屬性「就是」Enum-實例"><a href="#Enum-類別屬性「就是」Enum-實例" class="headerlink" title="Enum 類別屬性「就是」Enum 實例"></a>Enum 類別屬性「就是」Enum 實例</h2><blockquote><p><strong>這是 Enum 最重要的特性之一，也是最容易讓人困惑的地方。</strong></p></blockquote><p>除了透過建構，其實<strong>直接呼叫類別屬性</strong>，也能夠得到<strong>同一個</strong> Enum 成員實例！</p><p>這是一般類別所<strong>難以想像</strong>的，因為一般類別呼叫類別屬性後，只會得到單純的<strong>值</strong>，比如本文一開始的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這裡是非 Enum 版的 RestartPolicy</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>回到 Enum。換言之，下面兩種寫法，獲得的結果<strong>完全相同</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>)</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>不了解這個特性，會讓你對 Enum 的使用產生很大困惑。</strong></p><h3 id="單例模式"><a href="#單例模式" class="headerlink" title="單例模式"></a>單例模式</h3><p>更進一步說，Enum 類別的每一個成員實例，實際上都是<strong>單例</strong>。</p><p>這意味著對於每個成員，無論你在程式碼中呼叫多少次，<strong>都是指向「同一個」物件。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = RestartPolicy(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>p2 = RestartPolicy(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>p1 <span class="keyword">is</span> p2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) <span class="keyword">is</span> RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>了解這一點，就能夠更好地利用 Enum 來處理列舉資料。</p><hr><h2 id="Enum-實例的兩個屬性"><a href="#Enum-實例的兩個屬性" class="headerlink" title="Enum 實例的兩個屬性"></a>Enum 實例的兩個屬性</h2><p>所有 Enum 成員實例都有兩個內建的屬性：<code>name</code>與<code>value</code>。</p><p><code>name</code>是<strong>成員的名稱</strong>，也就是<strong>類別屬性名稱</strong>；<code>value</code>則是<strong>成員的值</strong>。</p><p>我們分別使用<strong>兩種不同的實例取得方式</strong>來呼叫這兩個屬性！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>).name</span><br><span class="line"><span class="string">&#x27;UNLESS_STOPPED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同於</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED.name</span><br><span class="line"><span class="string">&#x27;UNLESS_STOPPED&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy.UNLESS_STOPPED.value</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同於</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>).value</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>綜上所述，如果用 for 迴圈迭代<code>RestartPolicy</code>，你將得到（這裡使用<code>repr</code>突顯）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> RestartPolicy:</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="built_in">repr</span>(i))</span><br><span class="line"></span><br><span class="line">&lt;RestartPolicy.NO: <span class="number">0</span>&gt;</span><br><span class="line">&lt;RestartPolicy.ALWAYS: <span class="number">1</span>&gt;</span><br><span class="line">&lt;RestartPolicy.UNLESS_STOPPED: <span class="number">2</span>&gt;</span><br><span class="line">&lt;RestartPolicy.ON_FAILURE: <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>得到<code>RestartPolicy</code>的每一個成員實例。</strong></p><hr><h2 id="三、Enum-實例之間可以進行比較"><a href="#三、Enum-實例之間可以進行比較" class="headerlink" title="三、Enum 實例之間可以進行比較"></a>三、Enum 實例之間可以進行比較</h2><p>Enum 成員之間，支援身分比較（<code>is</code>）和等值（<code>==</code>）比較。</p><p>只不過，如前所述，每一個 Enum 成員都是「<strong>單例</strong>」。所以身分比較和等值比較對於 Enum 成員是<strong>等價</strong>的，也就是<strong>結果都相同</strong>。因為每個成員都是<strong>唯一</strong>的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) == RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">2</span>) <span class="keyword">is</span> RestartPolicy.UNLESS_STOPPED</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>我認為大部分時候，使用等值（<code>==</code>）比較就已經足夠了。</p><hr><h2 id="第三部分：使用-Enum-改進原有程式！"><a href="#第三部分：使用-Enum-改進原有程式！" class="headerlink" title="第三部分：使用 Enum 改進原有程式！"></a>第三部分：使用 Enum 改進原有程式！</h2><p>現在你對 Enum 的特性已經有了相當的了解。我們來看看原來的程式碼在使用 Enum 版本後，會發生什麼樣的變化。</p><p>回顧一下之前的問題：</p><ol><li>要驗證 input 資料是否為合法列舉成員，太囉嗦、冗長了。</li><li>如果加上<code>ALL</code>這類自定義屬性，雖然可以減緩程式碼冗長問題，又產生了潛在的同步問題。</li></ol><h3 id="對問題一的改善"><a href="#對問題一的改善" class="headerlink" title="對問題一的改善"></a>對問題一的改善</h3><p>現在，你想要驗證 input 值是否屬於列舉成員，可以這樣寫（我們假設 input 值為 2，代表<code>&#39;unless-stopped&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">in</span> [p.value <span class="keyword">for</span> p <span class="keyword">in</span> RestartPolicy]:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>因為 <code>RestartPolicy</code> 類別現在是可以用 <code>for</code> 迭代了！而每一個元素則是成員實例，需要透過<code>value</code>屬性取值，所以可以像上面那樣寫。</p><p>乍看之下，好像也沒有方便到哪去？確實如此😅，沒關係，我們還有<a href="#%E9%80%8F%E9%81%8E%E3%80%8C%E5%BB%BA%E7%AB%8B-Enum-%E5%AF%A6%E4%BE%8B%E3%80%8D%E9%80%B2%E8%A1%8C%E9%A9%97%E8%AD%89">後手</a>。</p><h3 id="Pydantic-預處理"><a href="#Pydantic-預處理" class="headerlink" title="Pydantic 預處理"></a>Pydantic 預處理</h3><p>如果你有用 Pydantic 對資料預處理（FastAPI、Django Ninja 等後端框架會自動做這件事），通常<code>payload.restart_policy</code>的值，就已經是一個 Enum 實例了。</p><blockquote><p>當然，如果有用 Pydantic 預處理，這個驗證根本不需要XD，這裡只是為了舉例。</p></blockquote><p>如此一來，驗證成員身分的寫法將<strong>異常簡單</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> payload.restart_policy <span class="keyword">in</span> RestartPolicy:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>對，就這麼簡單！</p><p>因為<code>in</code>運算子的內部，本來就會迭代後面接的物件了——所以<code>in</code>後面必須緊接一個 iterable，<strong>而 Enum 類別正是一個 iterable。</strong></p><hr><h2 id="透過「建立-Enum-實例」進行驗證"><a href="#透過「建立-Enum-實例」進行驗證" class="headerlink" title="透過「建立 Enum 實例」進行驗證"></a>透過「建立 Enum 實例」進行驗證</h2><p>但如果你的<code>payload.restart_policy</code>，就<strong>只是一般的值</strong>，而不是 Enum 成員。那該怎麼辦？難道真的要像上面那樣，寫落落長的<code>[p.value in p in RestartPolicy]</code>嗎？</p><p>當然不！其實做法一樣非常簡單，那就是「<strong>直接用這個值來建立實例</strong>」。</p><p><a href="#Enum-%E5%AF%A6%E4%BE%8B%E7%9A%84%E5%BB%BA%E6%A7%8B%E8%88%87%E6%A2%9D%E4%BB%B6">前面</a>說過，Enum 實例<strong>只能由 Enum 成員值建構而來</strong>。所以，如果你輸入的值不是<strong>合法</strong>的 Enum 成員，建構實例時就會拋出<code>ValueError</code>。</p><p>換句話說，<strong>只要能成功建立實例，就是合法的成員</strong>！所以你可以這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    RestartPolicy(payload.restart_policy)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果是不合法的，比如 4，則會拋出<code>ValueError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>RestartPolicy(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ValueError: <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid RestartPolicy</span><br></pre></td></tr></table></figure><p>總之，<strong>記得處理這個例外。</strong></p><h3 id="對問題二的改善"><a href="#對問題二的改善" class="headerlink" title="對問題二的改善"></a>對問題二的改善</h3><p>既然 Enum 類別本身就可以用 for 迭代以取得所有成員（甚至直接使用<code>in</code>運算子），那就<strong>完全沒必要</strong>再寫前面像<code>ALL</code>一樣的屬性，然後還要維護它。</p><p>由此可見，Enum 真的棒！</p><hr><h2 id="補充：Enum-類別在-Django-Ninja-中的應用"><a href="#補充：Enum-類別在-Django-Ninja-中的應用" class="headerlink" title="補充：Enum 類別在 Django Ninja 中的應用"></a>補充：Enum 類別在 Django Ninja 中的應用</h2><p>前面說到我會開始用 Enum，正是因為 Django Ninja。</p><p>Django Ninja 的 <a href="https://django-ninja.dev/guides/response/">Schema</a> 實際上就是 Pydantic 的 <a href="https://docs.pydantic.dev/latest/concepts/models/#validation">BaseModel</a>。</p><p>Schema 用來描述 API 輸入與輸出的資料結構。主要的功能有二：</p><ol><li><strong>驗證</strong>輸入資料是否符合規範。</li><li><strong>自動產生</strong> API 文件。</li></ol><p>我們看一下使用了 Enum 型別後的 Schema：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateContainerRequest</span>(<span class="title class_ inherited__">Schema</span>):</span><br><span class="line">    ...</span><br><span class="line">    restart_policy: RestartPolicy</span><br></pre></td></tr></table></figure><p>直接將<code>restart_policy</code>欄位型別標記為<code>RestartPolicy</code>，如此渲染出的 API 文件，不止能限定輸入資料的型別，連「<strong>值域</strong>」也會有<strong>明確標示</strong>：</p><p><img src="https://i.imgur.com/A8RgBlS.png" alt="型別：integer；值域：僅限 0、1、2、3"><span class="cap">型別：integer；值域：僅限 0、1、2、3</span></p><p>甚至還能把<code>RestartPolicy</code>類別中的<code>docstring</code><strong>直接渲染成欄位說明</strong>，太貼心了吧！偉哉 Pydantic！</p><p>好處不止如此，一旦你<strong>變更</strong>了<code>RestartPolicy</code>的內容（比如<strong>增加了成員選項</strong>），API 文件也會<strong>自動更新</strong>。</p><p>不必再手動修改 API 文件，也不必修改 Schema 的 type hints，完全省去了「同步」的煩惱。</p><hr><p>除了上述的「<strong>數字列舉</strong>」版，我同時再附上「<strong>字串列舉</strong>」版本，看圖你應該就能理解，為何我一開始說，有時候列舉資料用字串會更好。</p><p><img src="https://i.imgur.com/9eCQcFB.png"></p><p>直接採用字串選項，對前端人員更加友善——<strong>更容易了解每個選項代表的意義。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5lvKO0a.jpeg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;想必你知道 Python 中有一個內建的特殊類別叫 &lt;a href=&quot;https://docs.python.org/zh-tw/3.12/library/enum.html#enum.Enum&quot;&gt;Enum&lt;/a&gt;（來自 &lt;a href=&quot;https://docs.python.org/zh-tw/3.12/library/enum.html&quot;&gt;enum&lt;/a&gt; 模組），專門用來處理「列舉」態型的資料集合。&lt;/p&gt;
&lt;p&gt;如同 &lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html&quot;&gt;collection&lt;/a&gt; 模組中的各種容器（比如：&lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html#collections.deque&quot;&gt;&lt;code&gt;deque&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/zh-tw/3/library/collections.html#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt;），Enum 已經定義好很多「&lt;strong&gt;內建特性（屬性、方法、行為）&lt;/strong&gt;」供你使用。這些特性會讓你在&lt;strong&gt;處理特定情境&lt;/strong&gt;時非常順手。&lt;/p&gt;
&lt;p&gt;但是，這些特性也使得 Enum 類別與一般類別&lt;strong&gt;有著很大的差異，增加了學習門檻&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如你所見，Enum 的特性頗多，這讓人在學習、使用之前，難免有點&lt;strong&gt;望之卻步&lt;/strong&gt;——至少我是這樣！&lt;/p&gt;
&lt;h2 id=&quot;本文主旨與架構&quot;&gt;&lt;a href=&quot;#本文主旨與架構&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與架構&quot;&gt;&lt;/a&gt;本文主旨與架構&lt;/h2&gt;&lt;p&gt;本文分享我最近才開始把 Enum 應用在 API 開發中的經驗——從它的三大特性入手，並輔以一個實際問題情境。&lt;/p&gt;
&lt;p&gt;Enum 的特性不少，但只要知曉這三件事，就可以在遇到「列舉」欄位時，善用 Enum 來提升開發效率，同時增進程式碼的簡潔與穩健。&lt;/p&gt;
&lt;p&gt;不過話說回來，即使不是開發 API，也不影響你對本文的理解。只是我的經驗是從後端開發而來。&lt;/p&gt;
&lt;h3 id=&quot;本文架構&quot;&gt;&lt;a href=&quot;#本文架構&quot; class=&quot;headerlink&quot; title=&quot;本文架構&quot;&gt;&lt;/a&gt;本文架構&lt;/h3&gt;&lt;p&gt;為了讓你感受 Enum 的強大與美妙，&lt;strong&gt;本文的架構經過精心設計。&lt;/strong&gt;共分為&lt;strong&gt;三個部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;問題情境&lt;/strong&gt;：我會先提出一個&lt;strong&gt;問題情境&lt;/strong&gt;，突顯舊方法的不足。&lt;/li&gt;
&lt;li&gt;然後再介紹 Enum 的&lt;strong&gt;三大特性&lt;/strong&gt;，帶你進入 Enum 的世界。&lt;/li&gt;
&lt;li&gt;最後看 Enum 特性在問題情境中&lt;strong&gt;如何有效發揮&lt;/strong&gt;，讓程式碼變得更加優雅——也就是它&lt;strong&gt;解決的痛點&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;藉由這個流程，相信你對 Enum 會有更進一步的理解。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/5lvKO0a.jpeg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Django Ninja" scheme="https://blog.kyomind.tw/tags/Django-Ninja/"/>
    
    <category term="Enum" scheme="https://blog.kyomind.tw/tags/Enum/"/>
    
    <category term="Pydantic" scheme="https://blog.kyomind.tw/tags/Pydantic/"/>
    
    <category term="API 開發" scheme="https://blog.kyomind.tw/tags/API-%E9%96%8B%E7%99%BC/"/>
    
  </entry>
  
  <entry>
    <title>27，正式入手《流暢的 Python》第二版</title>
    <link href="https://blog.kyomind.tw/weekly-review-27/"/>
    <id>https://blog.kyomind.tw/weekly-review-27/</id>
    <published>2024-04-14T15:17:50.000Z</published>
    <updated>2024-04-15T01:20:54.993Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>Weekly Review 原則上著眼於「<strong>非程式類</strong>」內容，而這是一本程式相關的書，所以這期不會討論書中的技術細節，只聊聊<strong>我的主觀感受</strong>。</p><p>講它，是因為我對這本書的<strong>期待很高</strong>，它絕對有這個地位與份量，更別說它真的很厚！（量了一下有 5 公分厚，打算這星期拿去影印店<strong>拆成 3 本</strong>）</p><p>趁著清明連假的天瓏日（滿千折百活動），我總算入手了 Python 進階書籍中的口碑之作——《<a href="https://www.tenlong.com.tw/products/9786263246331">流暢的 Python</a>》，第二版。</p><p>還沒有開始讀，但先簡單分享一下<strong>我的看法與期待。</strong></p><span id="more"></span><h2 id="作為第一版讀者"><a href="#作為第一版讀者" class="headerlink" title="作為第一版讀者"></a>作為第一版讀者</h2><p>早在我開始 Python 軟體工程師職涯之前，即 2019 上半年準備轉職的期間，就讀過了《流暢的 Python》第一版——的一部分。</p><p>所以在面試 StreetVoice 寫程式測驗試題的時候（其中一題就是「以 mutable 資料作為函式參數預設值」的經典題目），立刻就想到了書中「幽靈公車」的例子。</p><p>不過，那時只讀了一部分，就早早束之高閣了。因為剩下部分對當時的我來說，還太過進階。</p><h2 id="2021-年，第二版消息與精讀計畫"><a href="#2021-年，第二版消息與精讀計畫" class="headerlink" title="2021 年，第二版消息與精讀計畫"></a>2021 年，第二版消息與精讀計畫</h2><p>2021，已經當了 2 年的 Python 工程師，這一年我總算把《流暢的 Python》讀完了。</p><p>但說真的，讀完也沒用。如果工作中用不到，這些東西，對我來說依舊是「書上的知識」，而不是我真實能力的一部分。</p><p>所以有點失落，不知該如何是好，想說是不是再認真細讀一次、兩次……結果下半年就得知了第二版正在撰寫中的消息。</p><p>喜新厭舊如我，自然不想再看舊書（以前對法律的參考書也是如此），想等中文版出了再說。於是這個「精讀」計畫就被無限期延後了。</p><h2 id="繁體中文版，正式出爐"><a href="#繁體中文版，正式出爐" class="headerlink" title="繁體中文版，正式出爐"></a>繁體中文版，正式出爐</h2><p>台灣中文版在英文出版後的一年內，遲遲沒有消息（我的判斷方式是繁中的第一版是否絕版不賣了），讓我不禁擔心：該不會不引進繁中版了吧？</p><p>還好，我想多了，應該只是第二版書更厚，翻譯花了更多時間而已。去年 10 月，本書的繁體中文版正式在台灣上市。</p><p><strong>但我並沒有在第一時間入手。</strong></p><h2 id="眾裡尋他千百度"><a href="#眾裡尋他千百度" class="headerlink" title="眾裡尋他千百度"></a>眾裡尋他千百度</h2><p>因為我不禁在想，是不是有「<strong>更好、更簡單</strong>」的選擇。</p><p>說來矛盾，明明是學 Python 的進階特性（也就是<strong>比較難</strong>的部分），我卻希望能「更簡單」。</p><p>但也不奇怪，這裡的更簡單，指的是「<strong>更容易上手、入門</strong>」——也就是<strong>更少痛苦</strong>。對於這些<strong>相對棘手</strong>的主題，我總是想找到一個「<strong>比較好啃</strong>」的方式。</p><p>所以我開始把期望寄託在其它書上，這些書本來就買了好多本，一直只是都沒讀！</p><p>所幸，過去一個多月的「<a href="https://www.facebook.com/kyomind/posts/pfbid02eQaYDFtE13cfsDofWPXZuiHjBuSqjr1nhBGiYpysGDktveGRiEVB9SxaKnJjy2zpl">圖書館時間</a>」，我基本把它們都翻完了。</p><p>並初步確認了每一本書對我的價值，以及後續還要投入多少時間。</p><h2 id="燈火闌珊處"><a href="#燈火闌珊處" class="headerlink" title="燈火闌珊處"></a>燈火闌珊處</h2><p>翻完這些書，我明白了一件事——《流暢的 Python》確實是最好的！</p><p>當然，無論《Python 精粹》或是《Python 神乎其技》，都有其可看之處。但《流暢的 Python》終歸還是 Python 進階書籍中的佼佼者。</p><p>正因為看過了其它書，所以我才更明白本書的精彩與不可取代。</p><p>前兩本書，我不會想從頭到尾精讀，但《流暢的 Python》有這個價值。</p><p>一言以蔽之，如果只打算好好讀一本 Python 進階書籍，就這本吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Weekly Review 原則上著眼於「&lt;strong&gt;非程式類&lt;/strong&gt;」內容，而這是一本程式相關的書，所以這期不會討論書中的技術細節，只聊聊&lt;strong&gt;我的主觀感受&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;講它，是因為我對這本書的&lt;strong&gt;期待很高&lt;/strong&gt;，它絕對有這個地位與份量，更別說它真的很厚！（量了一下有 5 公分厚，打算這星期拿去影印店&lt;strong&gt;拆成 3 本&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;趁著清明連假的天瓏日（滿千折百活動），我總算入手了 Python 進階書籍中的口碑之作——《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263246331&quot;&gt;流暢的 Python&lt;/a&gt;》，第二版。&lt;/p&gt;
&lt;p&gt;還沒有開始讀，但先簡單分享一下&lt;strong&gt;我的看法與期待。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>26，改用 Buttondown 作為文章訂閱服務</title>
    <link href="https://blog.kyomind.tw/weekly-review-26/"/>
    <id>https://blog.kyomind.tw/weekly-review-26/</id>
    <published>2024-04-10T14:22:04.000Z</published>
    <updated>2024-04-11T13:15:51.972Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>去年 2 月，部落格新增了「email 文章訂閱」功能，採用的方案是免費的 <a href="http://follow.it/">follow.it</a>。</p><p>它會把我的 RSS 新文章轉成 email，然後寄送給訂閱的讀者。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-12/">12，blog 新增文章訂閱功能——使用 follow.it</a></p></blockquote><p>如該篇中所言，「<strong>文章訂閱功能</strong>」確實是現代部落格的一大需求。</p><p>網路上的資訊眾多，我自己作為讀者，也常常感覺<strong>被淹沒</strong>。遇到一個喜歡的作者，想要追蹤，此時<strong>作者是否提供了訂閱功能，就至關重要。</strong></p><p>文章訂閱功能，可以由寫作平台提供，比如 Medium、Substack。不然就得自己來，因此我一開始就為 blog 提供了 RSS 訂閱。</p><p>但 RSS 畢竟不是一般人常用的資訊接收方式（<strong>我自己也不用</strong>），它只能滿足小眾人口的需求。所以最終我還是選擇了像 follow.it 這樣的「RSS to email」服務。</p><span id="more"></span><h2 id="為何選擇-follow-it"><a href="#為何選擇-follow-it" class="headerlink" title="為何選擇 follow.it"></a>為何選擇 follow.it</h2><p>用過電子報服務的都知道，這些服務<strong>真的不便宜！</strong></p><p>比如其中相對「高貴」的 ConvertKit，從它的 <a href="https://convertkit.com/pricing">pricing</a> 頁面可以看到，它的付費版僅僅 300 個訂戶，每月就要 9 美元！（而且這還是基於<strong>年繳</strong>的「優惠價」）</p><p>這也是為何很多人選擇在 Substack 上寫作，它對於需要發送「大量」電子報給讀者的創作者非常友好——<strong>不用錢。</strong></p><p>但我既已從 Medium 獨立，有了自己的 blog，自然不會再跑去 Substack 上寫作。選擇免費的 follow.it，也是情理之中。</p><blockquote><p>相關文章：</p><ul><li><a href="https://blog.kyomind.tw/my-own-blog-part-one/">我自架部落格的理由與選擇（上）理由篇</a></li><li><a href="https://blog.kyomind.tw/my-own-blog-part-two/">我自架部落格的理由與選擇（下）選擇篇</a></li></ul></blockquote><h2 id="改用-Buttondown"><a href="#改用-Buttondown" class="headerlink" title="改用 Buttondown"></a>改用 Buttondown</h2><p>一年過去，在佛系經營下（畢竟我的「電子報」就只是純粹的新文章通知，也不好意思鼓吹訂閱），訂戶也超過了 100 人，讓我不禁尋思更好的文章訂閱方案。</p><p>畢竟免費有一定<strong>代價</strong>，follow.it 的電子報會在你文章的開頭、結尾夾帶大量廣告。而且廣告的<strong>格調不高</strong>，讓人看了不禁有點<strong>傷眼</strong>🤡</p><p>那為何不一開始就採用電子報供應商的方案？主要有兩個原因：</p><ol><li>不是每家都有「RSS to email」功能，有提供這個功能的，都要花錢！</li><li>那時覺得 follow.it 就完全滿足我了。</li></ol><p>不過，此一時，彼一時。</p><p>就在今年 3 月上旬，我決定正式付費改用 <a href="https://buttondown.email/pricing">Buttondown</a>。</p><blockquote><p>如果你有興趣，可以考慮使用我的<a href="https://buttondown.email/refer/kyo">推薦連結</a>註冊。</p></blockquote><h2 id="為何選擇-Buttondown"><a href="#為何選擇-Buttondown" class="headerlink" title="為何選擇 Buttondown"></a>為何選擇 Buttondown</h2><p>知道它，以及決定選擇它，主要有兩個原因。</p><p>一方面，它是我有在 follow 的兩位作者都推薦過的電子報服務，可參考這兩篇文章：</p><ul><li><a href="https://vocus.cc/article/61a48a31fd89780001ed3b87">我念念不忘的電子報平台 Buttondown</a></li><li><a href="https://pinchlime.com/blog/first-impression-of-buttondown/">令人忍不住想掏錢支持的 Buttondown</a></li></ul><p>另一方面，以我預想的長期訂戶數量（5 年內不超過 1000 人）——也就是 1000 人以內，Buttondown 的價格<strong>還算是可接受的</strong>。</p><p>一年要價 90 美元（月付則是每個月 9 美元），雖然稱不上便宜，但相比於市面上其他常見選擇（必須有「RSS to email」功能），仍有一定的競爭力。</p><p>在嘗試性地付費了一個月、寄了 2 次信以後，我覺得不錯，就決定直接轉年費了。在達到 1000 訂戶以前，應該不會變動。</p><h2 id="一年-90-美元，值得嗎？"><a href="#一年-90-美元，值得嗎？" class="headerlink" title="一年 90 美元，值得嗎？"></a>一年 90 美元，值得嗎？</h2><p>一年 90 美元，相當於我租 DigitalOcean VM 一年的費用，值得嗎？</p><p>我想還是值得的，畢竟它帶來的好處<strong>非常直接</strong>——讓讀者透過電子報，第一時間收到你的文章內容。</p><p><strong>既沒有廣告，也不需要綁定任何創作平台，算是用金錢換來更大的「創作自由」。</strong></p><p>再說，我幾乎所有的文章，都需要等待 SEO 慢慢發酵。這過程往往須耗時數週到數月不等，說真的有點難熬，而且也不一定有亮眼的結果。</p><p>有了電子報文章通知，至少我能<strong>確信</strong>，在發文的當下，有<strong>一小部分人</strong>能夠立刻知曉。</p><p>對作者而言，這無疑能帶來一定的<strong>欣慰</strong>，與<strong>安全感</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年 2 月，部落格新增了「email 文章訂閱」功能，採用的方案是免費的 &lt;a href=&quot;http://follow.it/&quot;&gt;follow.it&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;它會把我的 RSS 新文章轉成 email，然後寄送給訂閱的讀者。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-12/&quot;&gt;12，blog 新增文章訂閱功能——使用 follow.it&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如該篇中所言，「&lt;strong&gt;文章訂閱功能&lt;/strong&gt;」確實是現代部落格的一大需求。&lt;/p&gt;
&lt;p&gt;網路上的資訊眾多，我自己作為讀者，也常常感覺&lt;strong&gt;被淹沒&lt;/strong&gt;。遇到一個喜歡的作者，想要追蹤，此時&lt;strong&gt;作者是否提供了訂閱功能，就至關重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章訂閱功能，可以由寫作平台提供，比如 Medium、Substack。不然就得自己來，因此我一開始就為 blog 提供了 RSS 訂閱。&lt;/p&gt;
&lt;p&gt;但 RSS 畢竟不是一般人常用的資訊接收方式（&lt;strong&gt;我自己也不用&lt;/strong&gt;），它只能滿足小眾人口的需求。所以最終我還是選擇了像 follow.it 這樣的「RSS to email」服務。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="電子報" scheme="https://blog.kyomind.tw/tags/%E9%9B%BB%E5%AD%90%E5%A0%B1/"/>
    
    <category term="部落格" scheme="https://blog.kyomind.tw/tags/%E9%83%A8%E8%90%BD%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>《強健的 Python》筆記（一）Type Hints 的成本與挑戰</title>
    <link href="https://blog.kyomind.tw/robust-python-01/"/>
    <id>https://blog.kyomind.tw/robust-python-01/</id>
    <published>2024-04-06T18:44:00.000Z</published>
    <updated>2024-04-09T04:48:43.315Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/nqKDYbc.png" alt="強健的 Python"><span class="cap">強健的 Python</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263241015">強健的 Python｜撰寫潔淨且可維護的程式碼</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>本書翻譯自《<a href="https://www.amazon.com/-/zh_TW/Patrick-Viafore/dp/1098100662">Robust Python: Write Clean and Maintainable Code</a>》，原文的副標題容易讓人以為這又是另一本關於「Clean Code in Python」的書。</p><p>實際上，本書所聚焦的，是 Python 的一大特性——<a href="https://docs.python.org/3/library/typing.html">type hints</a>。全書大半篇幅都圍繞著這個核心主軸。</p><p>所以它並非教你「如何寫出 Pythonic 程式碼」的書，而是介紹 type hints 寫法與使用相關工具（比如 Mypy）以確保 type hints 有效落實的作品。</p><p>如果你還不熟悉 Python type hints，本文也可以作為認識 type hints 的起點。</p><span id="more"></span><hr><h2 id="場景與緣由"><a href="#場景與緣由" class="headerlink" title="場景與緣由"></a>場景與緣由</h2><p>上個月，我在一個新的 Django 工作專案中加入了 Mypy，主要做了這兩件事：</p><ol><li>整合 Mypy VS Code 套件（包括 Mypy 設定檔），讓開發者在寫程式的當下，可以在編輯器中隨時收到來自 Mypy 的「提醒」。</li><li>設定 Mypy pre-commit hook。</li></ol><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a></p></blockquote><p>上述二者（主要是第二點），讓新專案真正落實了 Python type hints——這下子你不寫 type hints 也不行了。</p><p>不過還差 CI——預計今年上半年補完。</p><p>這個過程並不困難，但還是需要一番摸索才能順利到位，這部分我會另外寫成一篇文章作為教學。</p><p>本文的重點，在於<strong>專案落實 type hints 的挑戰</strong>。</p><h2 id="專案落實-type-hints-的真正難點"><a href="#專案落實-type-hints-的真正難點" class="headerlink" title="專案落實 type hints 的真正難點"></a>專案落實 type hints 的真正難點</h2><p>在為 Django 專案導入 Mypy 之前，我讀了本書——前後讀了兩次。</p><p>之所以寫這篇筆記，主要是深刻感受到，在工作上要落實 type hints、把它們加入到 Python 專案中，整個環節<strong>最難的部分</strong>，絕不是關於 type hints 語法的學習。</p><p>而是其它種種因素。</p><p>事實上，我去年就打算<a href="https://blog.kyomind.tw/weekly-review-08/#%E5%B0%8F%E7%B5%90%EF%BC%9A2023-%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9B%AE%E6%A8%99">為 Django 專案全面導入 type hints</a>，但是失敗了！直到本次的時機「更加成熟」，才下定決心推行。</p><p>本文藉由對書中內容的整理與我的經驗，好好介紹一下，為專案加入 type hints 時，<strong>你一定會遇到的困難</strong>，與對應的思考。</p><hr><h2 id="Python-type-hints-簡介"><a href="#Python-type-hints-簡介" class="headerlink" title="Python type hints 簡介"></a>Python type hints 簡介</h2><p>Python  3.5 首次導入了 type hints，詳情請見〈<a href="https://peps.python.org/pep-0484/">PEP 484 – Type Hints</a>〉，該 PEP 提案的共同發起人除了 Python 之父 Guido van Rossum，還有 Mypy 的作者。</p><p>接下來的每一版 Python，都少不了對 type hints 的擴充與增強。可以說，type hints 是經過「一系列」漫長的發展與迭代，才有了今日的氣象。</p><h2 id="Type-hints-的野心"><a href="#Type-hints-的野心" class="headerlink" title="Type hints 的野心"></a>Type hints 的野心</h2><p>Guido van Rossum 本人對 type hints 非常重視，從良葛格的〈<a href="https://www.ithome.com.tw/voice/116983">Type Hints 的野心</a>〉中這一段話可知：</p><blockquote><p>本來 Python 在動態定型語言中，相對來說，就是極為重視工程性的語言，然而曾經在某個地方看過的說法是，<strong>Guido 長年以來的野心，就是讓 Python 在工程性上更進一步</strong>，而在靜態分析工具上投入精力會是必要的。事實上，從 2000 年以來，Guido 一直想在 Python 中，加入可選的靜態定型，一直到 PEP 484、526 的實現，本人也在 PyCon 2015 親自上場講演〈<a href="https://goo.gl/wPZYWo">Type Hints</a>〉，似乎也印證了這點。</p></blockquote><h3 id="Type-hints-的價值"><a href="#Type-hints-的價值" class="headerlink" title="Type hints 的價值"></a>Type hints 的價值</h3><p>專案程式碼加入 type hints 的好處顯而易見，它們賦予 Python 在開發階段就能如靜態型別語言般，為變數、參數、回傳值<strong>明示型別</strong>的能力，從而提高專案的穩定性和可維護性——這在大型專案中尤其重要。</p><p>說真的，很多時候我光是看型別，對於程式碼的理解就有<strong>明顯的提升</strong>，這對於程式碼的<strong>閱讀、維護、重構</strong>都有<strong>很大的幫助</strong>。</p><p>搭配 Mypy 這類 type checker，加上 IDE 整合，更是妙不可言！</p><p>這直接提高了 Python 在團隊協作的競爭力，讓大型專案採用 Python 變得更加可能——當然，我知道，有些人並不這麼認為😎</p><h3 id="Type-hints-的代價"><a href="#Type-hints-的代價" class="headerlink" title="Type hints 的代價"></a>Type hints 的代價</h3><p>儘管 type hints 有種種好，但平心而論，它的<strong>代價也不小</strong>！（後面會提到）</p><p>所以有時候，你決定不採用 type hints，或許是「明智」的，尤其是在一些不需要長期維護的專案。</p><p>但是，要徹底了解 type hints 的優點與缺點，我們需要<strong>更加全面且務實</strong>的的觀點。</p><hr><p>呼，鋪陳有點長，以下才是本書的重點整理！</p><h2 id="Type-hints-的利弊分析"><a href="#Type-hints-的利弊分析" class="headerlink" title="Type hints 的利弊分析"></a>Type hints 的利弊分析</h2><p>關於採用 type hints 的利弊分析，本書的第 100 頁，有相對完整的論述。</p><p>利的部分上面已經說了，這裡我們主要關注導入 type hints 的「缺點」。</p><p>在此直接引用書中所舉的內容（我加上<strong>粗體</strong>作為<strong>重點標示</strong>），講述專案導入 type hints 的<strong>阻力與成本</strong>，包括：</p><blockquote><ul><li><strong>需要獲得支持</strong>。根據文化的不同，可能需要一些時間來<strong>說服</strong>一個組纖採用型別檢查。</li><li>一旦你獲得支持，就會有一個<strong>最初的採用成本</strong>。開發人員不會在一夜之間就能開始對他們的程式碼進行型別注釋，他們<strong>需要時間來掌握</strong>。他們<strong>需要學習和實驗</strong>，然後才能實際動手。</li><li>採用工具需要時間和努力。你需要某種形式的<strong>中央化檢查</strong>，而開發者<strong>需要熟悉工具作為他們工作流程一部分的執行。</strong></li><li>在你的專案中編寫型別注釋<strong>需要時間。</strong></li><li>隨著型別注釋開始受到檢查，開發人員將不得不習慣於<strong>與型別檢查器對抗所帶來的速度減慢</strong>。思考型別帶來了<strong>額外的認知負載。</strong></li></ul></blockquote><p>不愧是專門討論 Python type hints 的書，我只能說，每一條都非常真實！這也是為何我們在今年才成功導入，去年可以說還沒有準備好——但也不是毫無收獲。</p><p>如作者所言：</p><blockquote><p>這個問題從根本上說，就是一種雞和蛋的難題：你在專案中寫下<strong>足夠多</strong>的型別注釋之前，你<strong>不會看到</strong>注釋型別的好處。然而，在<strong>早期沒有效益</strong>的情況下，要讓人接受去撰寫型別是<strong>很困難的</strong>。</p></blockquote><p>綜上所述，為專案加上 type hints 看起來困難重重，難道我們要就此放棄嗎？</p><p>當然不。否則作者不需要寫這本書，而我也不需要寫這篇文章。</p><p>與之相反，我們不妨更早開始學習 type hints ，早點達到並跨過書中所謂的「投入與收益的平衡點」。</p><hr><h2 id="更早「收支平衡」"><a href="#更早「收支平衡」" class="headerlink" title="更早「收支平衡」"></a>更早「收支平衡」</h2><blockquote><p>為了使型別注釋的效益最大化，你需要更早取得價值或更早降低成本。這兩條曲線的交點是一個收支平衡點（break-even point），這就是你所付出的努力因為你所得到的價值而有報償的地方。</p></blockquote><p>Type hints 的投入與報酬關係，書中用了一張圖來說明，我重繪如下：</p><p><img src="https://i.imgur.com/y7RL42J.png"></p><p>作者解釋道：</p><blockquote><p>你的成本<strong>一開始會很高</strong>，但隨著採用率的提高會變得更和緩。你的效益一開始會很低，但隨著你注釋 codebase，你會看到更多的價值。<strong>在這兩條曲線相遇之前，你不會看到投資的回報。為了使價值最大化，你需要儘早達到這個交叉點。</strong></p></blockquote><p>講白了就是，寫愈多，阻力就會愈低。這雖然像是「廢話」，但也給了我們希望！🤣</p><p>對於這張圖，我的看法是：type hints 的收益<strong>絕對是累積出來的</strong>，但成本的下降<strong>不一定有這麼快</strong>。</p><p>畢竟每次寫 type hints，多少都需要思考（所幸我們有 GitHub Copilot 🥰），這個成本<strong>未必</strong>會隨著時間而<strong>快速</strong>降低——<strong>但肯定會逐漸降低</strong>，因為習慣了。</p><hr><p>文末我會提出自己對於「降低導入 type hints 阻力」的看法。我們先來看書中的建議。</p><h2 id="書中的一些建議"><a href="#書中的一些建議" class="headerlink" title="書中的一些建議"></a>書中的一些建議</h2><blockquote><p>你想在能維持前進動力的情況下，儘快達到這個點，以讓你的型別注釋帶來正面的影響。這裡有一些策略可以做到這一點。</p></blockquote><p>作者給出的大方向，就是先為「<strong>部分</strong>」——而非全部——程式碼加上 type hints。讓你可以早點感受到 type hints 帶來的好處。</p><p>那要「<strong>怎麼選擇</strong>」哪些程式碼應該優先加上 type hints？他的看法大概有下：</p><ul><li>只為<strong>新程式碼</strong>進行型別注釋（這裡的新程式碼包括了<strong>對舊程式碼的修改</strong>）</li><li>型別注釋「為你賺錢」的程式碼</li><li>型別注釋「經常變化」的程式碼</li><li>型別注釋「複雜」的程式碼</li></ul><p>以上這幾點取自書中的小標題，但我想說的是——這些看法雖然有道理，但其實<strong>大部分都很難操作！</strong></p><p>什麼叫賺錢的程式碼？怎麼樣才算複雜？書中並非沒有解釋，但這些都需要<strong>人為定義</strong>，而且有「<strong>標準浮動</strong>」之嫌，根本難以一體適用。</p><h3 id="為新程式碼加上-type-hints"><a href="#為新程式碼加上-type-hints" class="headerlink" title="為新程式碼加上 type hints"></a>為新程式碼加上 type hints</h3><p>「為新程式碼加上 type hints 」部分，是我唯一認為<strong>值得參考且可行</strong>的！</p><blockquote><p>考慮讓你當前未注釋的程式碼保持原樣，並<strong>根據這兩條規則</strong>來注釋程式碼：</p><ul><li>為你所寫的<strong>任何新程式碼</strong>進行注釋。</li><li>注釋你<strong>變更</strong>的任何<strong>舊程式碼</strong>。</li></ul></blockquote><p>對於已經完成的舊專案，我們就是採用這個策略！畢竟要把舊專案整個翻新成有 type hints 的版本，成本往往很高。</p><p>所以採<strong>折衷方案</strong>，比如修改舊函式的其中幾行、或寫一個全新的函式時，該函式就必須有完整的 type hints——我會在 code review 時進行檢查。</p><p>這樣的好處是標準清晰、判斷簡單，而且不用一次到位。</p><p>當然，想要透過慢慢更新，最終讓整個專案都可以通過 Mypy 檢查，還是不太現實的。這算是一種「對舊的、暫時無力全面適用 type hints 專案的<strong>折衷</strong>」。</p><h2 id="並非所有程式碼都要加上-type-hints"><a href="#並非所有程式碼都要加上-type-hints" class="headerlink" title="並非所有程式碼都要加上 type hints"></a>並非所有程式碼都要加上 type hints</h2><p>有件事必須<strong>釐清與強調</strong>，以免造成誤解。</p><p>所謂「<strong>完整</strong>」的 type hints，並不是把專案程式碼中的每一個地方都加上 type hints。</p><p>為<strong>變數</strong>加上 type hints 往往<strong>過於囉嗦而且實益不大</strong>（書中 39 頁也有提及），我們只會偶爾為之——因為大部分情況直譯器、IDE、type checker 都能夠<strong>自行推測</strong>了！</p><blockquote><p>那到底怎麼樣才算「<strong>完整</strong>」？</p></blockquote><p>一般而言，為所有的<strong>函式</strong>、類別中的<strong>方法</strong>加上 type hints，就已經很不錯。</p><p>不過，Mypy 畢竟提供了一個<strong>標準</strong>。讓你不必自己去判斷。只要使用 Mypy 的基本設定<strong>檢查整個專案</strong>而且不報錯，我認為就算完整了。</p><p>當然你可以排除檢查一些檔案，比如 Django 中的「資料庫遷移檔」。</p><hr><h2 id="我的經驗與看法"><a href="#我的經驗與看法" class="headerlink" title="我的經驗與看法"></a>我的經驗與看法</h2><p>去年想為 DRF 專案加入完整的 type hints（也就是要<strong>可以通過 Mypy 檢查</strong>的程度），最後放棄了。</p><p>主要有兩個原因：</p><ol><li>DRF 本身並不要求型別，而且專案誕生的早，也沒有完整的型別支援。不過現在有 stubs 套件（專門標示 type hints 的套件，比如 <a href="https://github.com/typeddjango/djangorestframework-stubs">djangorestframework-stubs</a>），這應該不至於成為關鍵難點。</li><li>這個才是我覺得最難的，那就是<strong>「不易說服」成員寫 type hints</strong>。儘管 type hints 肯定有好處，但我沒有信心，這好處會<strong>明顯超過</strong>投入的心力——尤其在一開始的時候。</li></ol><p>顯然我不太可能只是給同事看上面那張圖，就能輕易說服大家要開始寫 type hints 🐸</p><p>所以最後我還是放棄「完整」type hints 的企圖，只是要求大家要開始「試著」寫 type hints。（事實證明，這樣也不錯，至少大家開始有了 type hints 的概念）</p><h2 id="Django-Ninja-與-Pydantic"><a href="#Django-Ninja-與-Pydantic" class="headerlink" title="Django Ninja 與 Pydantic"></a>Django Ninja 與 Pydantic</h2><p>那怎樣才能讓我在「<strong>事前</strong>」就有足夠信心說服大家呢？</p><p>就是採用像 FastAPI、Django Ninja 這類，透過 Pydantic 來產生 API 文件的框架！</p><p>API 文件是後端開發的一大痛點，DRF 雖然也有 <a href="https://github.com/axnsan12/drf-yasg">drf-yasg</a> 這樣的套件，但說真的，和 Pydantic 這種原生採用 type hints 來產生 API 文件相比，肯定有所不及。</p><p>今年的新專案開始用了 Django Ninja，因此情況大不相同——即<strong>時機成熟</strong>了。</p><h3 id="Type-hints-輔助輪"><a href="#Type-hints-輔助輪" class="headerlink" title="Type hints 輔助輪"></a>Type hints 輔助輪</h3><p>寫 Django Ninja（或 FastAPI），你本來就要書寫大量 type hints，來產生正確、合理的 API 文件。那要求為專案的其餘部分，比如自定義的函式、類別加上 type hints，阻力相對就小得多。</p><p>這主要差別在於，大家能因為 API 文件的自動渲染，<strong>直接感受到 type hints 的價值！</strong></p><p>其實不止如此，剛學習 Django Ninja 時，我還發出過<a href="https://twitter.com/kyomind/status/1748007109646786873">這樣的讚嘆</a>：</p><blockquote><p>竟然可以充分運用 Python type hints 到這般程度，讓它不僅僅是為了型別安全而服務，而是融入到整個 api 流程中</p></blockquote><p>在我看來，這類採用了 Pydantic 框架所帶來的效應，就像腳踏車的輔助輪，在剛起步使用 type hints 時，有著明顯的正面引導效果。</p><hr><h2 id="小結與整理"><a href="#小結與整理" class="headerlink" title="小結與整理"></a>小結與整理</h2><p>然而，我並不是說，只有寫 FastAPI 或 Django Ninja 才能成功落實 type hints，只不過<strong>它們遇到的阻力會相對小</strong>。</p><p>如果能夠先有這類專案作為「甜頭」，那要在其餘專案落實可能會容易得多。因為要讓成員「相信」寫 type hints 有價值，確實不容易。</p><p>經過一段時間，目前我與我的同事們，都對 type hints 抱持著正面態度，因為很多錯誤可以在<strong>非常早的階段（也就是開發的當下）</strong>就被發現。（比如 Django ORM 物件的屬性根本寫錯了！）</p><p>省去了後續來回修正的時間浪費。</p><h3 id="個人看法"><a href="#個人看法" class="headerlink" title="個人看法"></a>個人看法</h3><p>最後，我再整理一下「<strong>降低導入 type hints 阻力</strong>」的一些個人看法：</p><ol><li>建議從<strong>全新的專案</strong>開始，因為要將舊專案改為「type hints 版本」會困難得多。</li><li>建議從 FastAPI、Django Ninja，或其它採用了 Pydantic 的專案開始，成員會<strong>更有動力</strong>。</li><li>雖然 type hints 對大專案有更顯著的效益，但建議<strong>從小型專案開始著手</strong>，以降低成員們<strong>練習、適應與接納</strong>的阻力。</li></ol><p>綜上所述，你可以看出，要落實 type hints，<strong>其實沒有多少「捷徑」可走。</strong></p><p>這也是為何我們需要<strong>了解其中的困難</strong>，才更可能<strong>適度地堅持</strong>，直到獲得 type hints 帶來的<strong>長期優勢</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nqKDYbc.png&quot; alt=&quot;強健的 Python&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263241015&quot;&gt;強健的 Python｜撰寫潔淨且可維護的程式碼&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;本書翻譯自《&lt;a href=&quot;https://www.amazon.com/-/zh_TW/Patrick-Viafore/dp/1098100662&quot;&gt;Robust Python: Write Clean and Maintainable Code&lt;/a&gt;》，原文的副標題容易讓人以為這又是另一本關於「Clean Code in Python」的書。&lt;/p&gt;
&lt;p&gt;實際上，本書所聚焦的，是 Python 的一大特性——&lt;a href=&quot;https://docs.python.org/3/library/typing.html&quot;&gt;type hints&lt;/a&gt;。全書大半篇幅都圍繞著這個核心主軸。&lt;/p&gt;
&lt;p&gt;所以它並非教你「如何寫出 Pythonic 程式碼」的書，而是介紹 type hints 寫法與使用相關工具（比如 Mypy）以確保 type hints 有效落實的作品。&lt;/p&gt;
&lt;p&gt;如果你還不熟悉 Python type hints，本文也可以作為認識 type hints 的起點。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/nqKDYbc.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Type Hints" scheme="https://blog.kyomind.tw/tags/Type-Hints/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>25，回歸原點的 Weekly Review</title>
    <link href="https://blog.kyomind.tw/weekly-review-25/"/>
    <id>https://blog.kyomind.tw/weekly-review-25/</id>
    <published>2024-03-20T18:39:31.000Z</published>
    <updated>2024-04-06T15:14:04.997Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>這是第 25 篇的 Weekly Review，距離<a href="https://blog.kyomind.tw/weekly-review-24/">上一期</a>已經非常久了！</p><p>我覺得，顯然的，我把整個 Weekly Review 寫「<strong>偏</strong>」了，失去了它原本的味道。</p><p>雖然我曾在第十期〈<a href="https://blog.kyomind.tw/weekly-review-10/">10，Weekly Review 寫滿 10 回：我的心得與改進</a>〉確立了一些想法。但也就是這些想法，讓整個系列走向愈來愈「<strong>笨重</strong>」的窘境。</p><p>比如其中提到「<a href="https://blog.kyomind.tw/weekly-review-10/#%E4%BA%8C%E3%80%81%E7%AF%87%E5%B9%85%E4%B8%8A%E9%99%90%EF%BC%9F%E5%BF%98%E4%BA%86%E5%90%A7%EF%BC%81">二、篇幅上限？忘了吧！</a>」，就相當於在心中暗示了自己，可以愈寫愈長、愈寫愈正經。</p><p>繼續往這個方向演化，Weekly Review 的<strong>調性</strong>就會<strong>逐漸向「<a href="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/">心得</a>」靠攏</strong>——而結果也是如此，同時讓我<strong>愈來愈難下筆。</strong></p><span id="more"></span><h2 id="Weekly-Review-三大特色"><a href="#Weekly-Review-三大特色" class="headerlink" title="Weekly Review 三大特色"></a>Weekly Review 三大特色</h2><p>對我而言，Weekly Review 不是心得。但兩者的<strong>內在區別</strong>，需要我自己去定義。畢竟如果兩者沒有明顯分別，那其實就不需要前者了。</p><p>所以，我要在此<strong>再次定義一下 Weekly Review 的三大特色：</strong></p><ol><li>與我個人感想、反省、心情有關，其中的著眼點在於「<strong>自己</strong>」。</li><li>有「<strong>時間軸</strong>」感，也就是「<strong>當下的自己、不同時期自己</strong>」的想法與經驗。</li><li><strong>簡短一點</strong>。保持簡單才能夠實現「<strong>輕快</strong>」，也才能夠確保一定的發文頻率。</li></ol><p>這 3 點是我對重新回歸的 Weekly Review 的要求與期待。</p><h2 id="新的助力"><a href="#新的助力" class="headerlink" title="新的助力"></a>新的助力</h2><p>光只是這樣，我可能還不敢號稱是「回歸原點」。</p><p>如果下一篇又是一、兩個月後，那就有點搞笑了。</p><p>我究竟要怎麼樣，才能相信自己有東西可以寫？而且不是正二八經的主題，而是和自己有關的心情或想法？</p><p>這真的不容易，不過自從 2 月下旬<a href="https://www.facebook.com/kyomind/posts/pfbid02TCX6gnu9hcDH1U6oN3r2m6N84mCnHgcpHWKE5wSk5L51PFDSiUBz367PKGEjS6pl">我開始用 memos 這個工具寫日記</a>後，我感覺可能性提高了不少。</p><p>截至今日，寫了 32 天的日記，已經有 129 篇長短不一的心情記事。關於 memos 與日記，我們另篇再談（我保證不會很久）。</p><p>這裡想說的是，有了這個工具與素材，我更容易「<strong>捕捉</strong>」不同時刻的我。參考這些日記的內容，把值得一提的部分，寫成 Weekly Review，這就是我初步的想法。</p><h2 id="更私人、更直白"><a href="#更私人、更直白" class="headerlink" title="更私人、更直白"></a>更私人、更直白</h2><p>簡單來說，我打算讓 Weekly Review 回歸它第一篇時我想做到的事。</p><p>而且最好是<strong>更任性、更直接</strong>的自我表達，同時<strong>更貼近我的日常生活</strong>。至於能夠做到什麼地步，我也不確定🐸</p><p>但發文頻率肯定不能像之前那樣，動輒一個月或更久。目前預計是 1、2 週一篇。</p><p>總之，盡力而為囉！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是第 25 篇的 Weekly Review，距離&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-24/&quot;&gt;上一期&lt;/a&gt;已經非常久了！&lt;/p&gt;
&lt;p&gt;我覺得，顯然的，我把整個 Weekly Review 寫「&lt;strong&gt;偏&lt;/strong&gt;」了，失去了它原本的味道。&lt;/p&gt;
&lt;p&gt;雖然我曾在第十期〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-10/&quot;&gt;10，Weekly Review 寫滿 10 回：我的心得與改進&lt;/a&gt;〉確立了一些想法。但也就是這些想法，讓整個系列走向愈來愈「&lt;strong&gt;笨重&lt;/strong&gt;」的窘境。&lt;/p&gt;
&lt;p&gt;比如其中提到「&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-10/#%E4%BA%8C%E3%80%81%E7%AF%87%E5%B9%85%E4%B8%8A%E9%99%90%EF%BC%9F%E5%BF%98%E4%BA%86%E5%90%A7%EF%BC%81&quot;&gt;二、篇幅上限？忘了吧！&lt;/a&gt;」，就相當於在心中暗示了自己，可以愈寫愈長、愈寫愈正經。&lt;/p&gt;
&lt;p&gt;繼續往這個方向演化，Weekly Review 的&lt;strong&gt;調性&lt;/strong&gt;就會&lt;strong&gt;逐漸向「&lt;a href=&quot;https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/&quot;&gt;心得&lt;/a&gt;」靠攏&lt;/strong&gt;——而結果也是如此，同時讓我&lt;strong&gt;愈來愈難下筆。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="心情" scheme="https://blog.kyomind.tw/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>《Python 工匠》筆記（二）對「單元測試」的看法與建議</title>
    <link href="https://blog.kyomind.tw/python-craftsman-02/"/>
    <id>https://blog.kyomind.tw/python-craftsman-02/</id>
    <published>2024-03-17T03:40:57.000Z</published>
    <updated>2024-04-08T09:25:42.756Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/beoEztr.png" alt="Python 工匠"><span class="cap">Python 工匠</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠｜案例、技巧與開發實戰</a>》筆記的第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>如第一篇所言，這是一本關於「Clean Code in Python」的書。</p><p>這二篇，我將整理書中第 13 章「<strong>有關單元測試的建議</strong>」的內容（以及我的看法）。我覺得真的寫得太好了，值得你了解。</p><p>話不多說，直接開始。</p><span id="more"></span><h3 id="系列：Python-工匠"><a href="#系列：Python-工匠" class="headerlink" title="系列：Python 工匠"></a>系列：Python 工匠</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/python-craftsman-01/">《Python 工匠》筆記（一）如何寫好註解</a></li><li><strong>《Python 工匠》筆記（二）對「單元測試」的看法與建議</strong></li></ol></blockquote><hr><p>作者一開始就點了出關於「單元測試」的一個<strong>奇特現象</strong>：</p><blockquote><p>雖然好像人人都認為單元測試很有用，但在實際工作中，有完善單元測試的專案仍然是個<strong>稀奇</strong>的東西。</p></blockquote><p>這一點也不誇張，甚至可以說是<strong>公開的秘密</strong>。</p><p>單元測試，大家都說重要，但真的有在寫的團隊、專案、公司，卻不如想像中多。<strong>往往都是靠 QA 把關</strong>——把整合測試當作單元測試在測😎（我就待過這樣的公司）</p><p>很多公司都是在<strong>口頭上</strong>強調單元測試的重要性，但實際的執行力度卻大打折扣，就像是那些年初設定的新年決心，<strong>說的比做的好聽。</strong></p><h3 id="不寫單元測試的「理由」"><a href="#不寫單元測試的「理由」" class="headerlink" title="不寫單元測試的「理由」"></a>不寫單元測試的「理由」</h3><p>姑且不說公司如何如何，其實就連<strong>開發者自己</strong>，也常常<strong>逃避</strong>寫單元測試。</p><p>書中舉出了實務上，開發人員不想寫單元測試的 3 個常見理由——以及這些「理由」<strong>為什麼不成立</strong>的理由：</p><blockquote><ol><li>「<strong>時程緊迫沒時間寫測試</strong>」：寫單元測試看上去要多花費時間，但其實會<strong>在未來節約你的時間</strong>。</li><li>「<strong>模組複雜沒辦法寫測試</strong>」：也許這正代表了<strong>你的程式設計有問題</strong>，需要調整。</li><li>「<strong>模組簡單不需要測試</strong>」：是否應該寫單元測試，和模組簡單或複雜<strong>沒有任何關係</strong>。</li></ol></blockquote><p>第一個理由無疑是我們<strong>最常聽到</strong>的說法，但我們都知道，它往往只是一個<strong>藉口</strong>——就算真的有時間，說這種話的人也不會寫測試的啦！</p><p>拋開這些<strong>似是而非</strong>，各種不寫測試的<strong>牽強</strong>藉口，作者提出了 5 個，寫單元測試前值得先有的<strong>重要理解</strong>。</p><p>接下來，讓我們一一說明。</p><hr><h2 id="一、寫單元測試不是浪費時間"><a href="#一、寫單元測試不是浪費時間" class="headerlink" title="一、寫單元測試不是浪費時間"></a>一、寫單元測試不是浪費時間</h2><p>寫單元測試可以節約你「<strong>整體</strong>」的開發時間。這個說法，我相信大部分的人應該都能夠接受——無論有沒有寫過測試。</p><p>那具體節約了哪些時間呢？主要有兩種：</p><ol><li>專案更新功能後，舊的程式碼被新功能邏輯影響而產生 bug，為了 debug 所耗費的時間！</li><li>重構所需要的時間。</li></ol><p>第一種情況，可謂<strong>天天都在發生——加了新東西，怎麼舊的就壞了！</strong></p><p>不少人計算自己開發時間的方式，是只算「自己寫程式、 完成新功能」的時間，至於後續的 debug（更別說自己寫的爛扣<strong>造成後續無數次 debug 的時間</strong>），這些都不算！</p><h3 id="QA-的日常"><a href="#QA-的日常" class="headerlink" title="QA 的日常"></a>QA 的日常</h3><p>你可能聽過下列對白：</p><blockquote><p>RD：「新功能我做完了，你測試一下吧！」</p></blockquote><blockquote><p>QA：「（經過一番測試）這 API 回傳不太對耶？還有這個參數好像少了一個？」</p></blockquote><blockquote><p>RD：「怎麼可能？」</p></blockquote><p>好一句「<strong>怎麼可能</strong>」。</p><p>此時，QA 心中想的應不是「測一下」，而是「測幹譙（台語）」。</p><p>作者相信，你因為沒寫單元測試而<strong>耗費去處理後續問題</strong>的時間，絕對<strong>遠遠超過</strong>你寫單元測試的時間——我完全認同。這也許是「<a href="https://init.engineer/cards/show/7234">扁鵲梗：軟體工程師版</a>」可以得到大量共鳴的原因。</p><p>當然，我也理解，寫單元測試通常不算是一件很有趣的事。但話說回來，當「有趣」和「重要」不可兼得的時候，我們也只能選擇後者。</p><p>誰叫我們是<strong>稱職的</strong>軟體工程師呢？</p><h3 id="重構的勇氣"><a href="#重構的勇氣" class="headerlink" title="重構的勇氣"></a>重構的勇氣</h3><p>有單元測試第二個重大好處，就是它給你重構的勇氣。</p><blockquote><p>假設你要對某個模組做大規模的重構，那麼，這個模組是否有單元測試，對應的重構難度天差地別。對於沒有任何單元測試的模組來說，重構是<strong>地獄難度</strong>。</p></blockquote><blockquote><p>在這種環境下，每當你調整任何程式，都必須仔細找到模組的每一個被引用處，小心翼翼地手動測試每一個場景。稍有不慎，重構就會引入新 bug，好心辦壞事。</p></blockquote><p>簡言之，對於複雜模組的重構，<strong>沒有單元測試是不可能的</strong>，這已經不是「有沒有時間」的問題了。</p><hr><h2 id="二、不要總想著「補」測試"><a href="#二、不要總想著「補」測試" class="headerlink" title="二、不要總想著「補」測試"></a>二、不要總想著「補」測試</h2><blockquote><p>「先幫我 review 下剛提交的這個 PR，功能已經全實現好了。單元測試我等等補上來！」</p></blockquote><p>這樣說法的背後，透露著一種思維：單元測試是「<strong>多</strong>」的，完全是「<strong>附屬</strong>」地位。所以可以事後再「<strong>補</strong>」。</p><blockquote><p>單元測試被當成了一種驗證正確性的<strong>事後工具</strong>，對開發功能程式<strong>沒有任何影響</strong>，因此，人們總是可以在完成開發後再補上測試。</p></blockquote><p>但作者不這麼看：</p><blockquote><p>但事實是，單元測試不光能驗證程式的正確性，<strong>還能極大地幫助你改進程式設計</strong>。但這種幫助有一個前提，那就是你必須在寫程式的<strong>同時</strong>寫單元測試。</p></blockquote><blockquote><p>當開發功能與寫測試同步進行時，你會來<strong>回切換自己的角色</strong>，分別作為程式的設計者和<strong>使用者</strong>，不斷從程式裡找出問題，調整設計。經過多次調整與打磨後，你的程式會變得更好、更具擴展性。</p></blockquote><p>好吧！我承認，我自己也沒有很好地做到這點。</p><p>雖然很少提出要「補」測試，但我的開發還是處於「先寫功能再寫測試」的傳統習慣——尤其是專案的早期，API 還沒有完全底定的時候。</p><p>但我也相信，帶著「<strong>測試思維</strong>」來寫程式，絕對能夠讓程式碼的品質更上一階，這點我並不懷疑。</p><p>而要帶著測試思維寫程式，最簡單的方法，就是<strong>一邊寫程式一邊寫測試</strong>！</p><h3 id="我應該用-TDD-嗎？"><a href="#我應該用-TDD-嗎？" class="headerlink" title="我應該用 TDD 嗎？"></a>我應該用 TDD 嗎？</h3><p>說到這裡，你應該很容易聯想到 <a href="https://zh.wikipedia.org/zh-tw/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">TDD</a>。</p><p>本書第 412 頁，作者寫了一個小專欄，專門討論他對 TDD 的看法。一言以蔽之就是：不一定要完全按照 TDD 的流程寫程式，但 TDD 的思維與習慣，值得你培養！</p><p>有興趣的讀者，可以自行參考書中內容。</p><hr><h2 id="三、難測試的程式就是爛程式"><a href="#三、難測試的程式就是爛程式" class="headerlink" title="三、難測試的程式就是爛程式"></a>三、難測試的程式就是爛程式</h2><p>如果你認同了前述「一、二」的核心看法，那這個道理應該是自然而然的。</p><p>那些<strong>難寫測試</strong>的程式，<strong>本身很可能就有問題</strong>！我們看書中的一個例子：</p><blockquote><p>當模組相依了一個全域物件時，寫單元測試就會變得很難。全域物件的基本特徵決定了它在記憶體中永遠只會存在一份。而在寫單元測試時，為了驗證程式在不同場景下的行為，我們需要用到多份不同的全域物件。這時，<strong>全域物件的唯一性就會成為寫測試最大的阻礙。</strong></p></blockquote><p>這類的例子真的多不勝數。大部分的時候，我們遇到這類情況，往往就是去「更改測試的邏輯」讓測試變得「<strong>剛好能夠通過</strong>」。</p><p>而帶來的結果往往是，測試的<strong>有效性降低</strong>！因為這個<strong>測試邏輯與方法</strong>和被測試的程式碼已經<strong>太過耦合</strong>了，可說是為了它「<strong>量身訂做</strong>」的測試。</p><p>如此一來，只要未來程式碼稍有變動，該測試也很可能就過不了。</p><p>現在我們知道，有時候不妨多想一下：「為什麼這麼難測試？」，並試著去重構原來的程式碼——而不是顧著修改測試函式本身。</p><blockquote><p>因此，每當你發現很難為程式寫測試時，就應該意識到<strong>程式設計可能存在問題，需要努力調整設計，讓程式變得更容易測試。</strong></p></blockquote><hr><h2 id="四、像應用程式一樣對待測試程式"><a href="#四、像應用程式一樣對待測試程式" class="headerlink" title="四、像應用程式一樣對待測試程式"></a>四、像應用程式一樣對待測試程式</h2><p>即使有在寫測試，這些測試程式碼，往往也被當作「<strong>二等公民</strong>」對待。</p><p>書中舉出了，把測試視為二等公民，因而「另眼看待（看輕）」它們的三個<strong>特徵</strong>：</p><ol><li>很能夠容忍測試程式碼<strong>大量重複</strong>。</li><li>很能夠容忍測試程式<strong>執行上的「不效率」</strong>。</li><li><strong>鮮少重構</strong>測試程式碼。</li></ol><p>其中潛藏並透露出的心態，用一句話來講就是：「測試的程式碼終究只是一個<strong>附屬品</strong>，所以程式碼品質<strong>差不多</strong>就好了，不要要求太多！」</p><p>作者當然不認同這樣的心態，並建議你：</p><blockquote><p>像應用程式一樣對待測試程式。</p></blockquote><p>和前述第二點一樣，我肯定認同這樣的看法，雖然還無法做到 100 分。</p><p>不過 80 分絕對是有的！</p><p>所以我在 code review 時，對於 <a href="https://docs.pytest.org/en/6.2.x/fixture.html">pytest 的 fixture</a> 設計，以及 fixtures 在測試函式中的引入與使用方式，會非常仔細審查。</p><p><strong>你知道，測試寫的爛，也是一種「業障」。</strong></p><p>總之，千萬別小看了測試程式碼。</p><hr><h2 id="五、避免教條主義"><a href="#五、避免教條主義" class="headerlink" title="五、避免教條主義"></a>五、避免教條主義</h2><p>我個人覺得這段非常非常精彩，哈哈哈！</p><blockquote><p>說起來很奇怪，在單元測試領域<strong>有非常多的理論與說法</strong>。人們總是<strong>樂於</strong>發表種對單元測試的見解，在文章、演講以及與同事的交談中，你常常能聽到這些話：</p></blockquote><ul><li>「只有 TDD 才是寫單元測試的正確方式，其他都不行！」</li><li>「TDD 已死，測試萬歲！」</li><li>「單元測試應該純粹，任何相依都應該被 mock 掉！」</li><li>「mock 是一種垃圾技術，mock 越多，表示程式越爛！」</li><li>「只有專案測試覆蓋率達到 100%，才算是合格！」</li><li>……</li></ul><p>看到書中的這段，我真的會笑死XDDD——因為<strong>這個「怪現象」竟是如此的真實</strong>。</p><p>從上述例子來看，這些立論不僅極端，而且往往還會<strong>互相矛盾</strong>。</p><p>哪怕還沒有開始寫測試之前，我就已經看過不少這類言論。說真的，這些言論——或者說「<strong>信仰</strong>」——恐怕或多或少<strong>增加</strong>了想要入門測試的人，在<strong>心理上的門檻</strong>。</p><p>好像你不把測試做到 100 分、盡善盡美，就乾脆不要寫測試了——我覺得這不是一種健康的姿態。</p><p>針對這現象，作者認為：</p><blockquote><p>這些觀點各自都有許多<strong>狂熱的追隨者</strong>，但我有個建議：<strong>你應該了解這些理論</strong>，越多越好，但是千萬<strong>不要陷入教條主義</strong>。</p></blockquote><blockquote><p>因為在現實世界裡，每個人參與的專案千差萬別，別人的理論不一定適用於你，如果盲目遵從，反而會給自己增加麻煩。</p></blockquote><h3 id="不必要的心理負擔"><a href="#不必要的心理負擔" class="headerlink" title="不必要的心理負擔"></a>不必要的心理負擔</h3><p>而我覺得，知曉有這個現象的存在，主要是為了「<strong>降低不必要的心理負擔</strong>」，進而認真看待自己已經寫好的測試，並對此感到<strong>欣慰</strong>。（但不自滿）</p><p>這很重要。</p><p>以我自己為例，目前工作上專案的測試覆蓋率大概在 60-75% 之間。而我清楚，想要從 75% 繼續再往上提升的話，必須要做很多「<strong>細節</strong>」工作。</p><p>比如為每一個自定義的 API 錯誤寫測試，確認錯誤訊息符合期待。（我們會適時地寫這些測試，但不是每一個都如此）</p><p>其中的投入與產出，不僅<strong>不成比例（投入多、效益有限）</strong>，而且還可能造成開發者<strong>對於「寫單元測試」這件事感到厭煩。</strong></p><p>所以並沒有嚴格要求覆蓋率要達到 100%——我想這也不太現實。</p><h3 id="正確不等於適合"><a href="#正確不等於適合" class="headerlink" title="正確不等於適合"></a>正確不等於適合</h3><p>然而，每次看到文章或教學中的「100% 主義」，我還是多少會擔心：「難道我們做的真的還不夠好嗎？」——現在看來，大可不必。</p><p>這並不是說它們沒有道理。這些理論在某方面都是對的，但<strong>不一定適合</strong>你的專案。</p><blockquote><p>單元測試領域的理論確實很多，這剛好<strong>說明了一件事，那就是要做好單元測試真的很難</strong>。要更好地實踐單元測試，你要做的第一件事就是<strong>拋棄教條主義，腳踏實地，不斷尋求最合適當前專案的測試方案</strong>，這樣才能最大地享受單元測試的好處。</p></blockquote><hr><p>但我還是不禁好奇！為什麼「測試」這領域，就是有這麼多<strong>狂熱信徒</strong>？</p><p>這個議題，我們直接看看 ChatGPT 怎麼說吧！</p><h2 id="狂熱信徒與他們的產地"><a href="#狂熱信徒與他們的產地" class="headerlink" title="狂熱信徒與他們的產地"></a>狂熱信徒與他們的產地</h2><p>以下內容整理自 ChatGPT（我劃了一些重點，以<strong>粗體字</strong>表示），我覺得分析得挺不錯，供有興趣的讀者參考。</p><p>這問題真是直擊核心，「測試」領域確實滋生了許多信仰狂熱者，原因有幾個方面：</p><ol><li><strong>人性的追尋絕對</strong>：在軟體開發這樣一個充滿不確定性的領域裡，人們往往尋求某種「萬靈丹」，希望找到一個可以解決所有問題的方法。<strong>當他們相信某種測試方法論能帶來開發上的救贖時</strong>，就很容易變成信仰狂熱者。</li><li><strong>成功案例的誤導</strong>：經常有人會分享他們使用特定測試方法論取得成功的案例，<strong>但很少有人會分享失敗的經驗</strong>。這種片面的資訊會誤導人們認為某種方法是萬能的，從而盲目追隨。</li><li><strong>社群與身分認同</strong>：一旦某人投入到特定的測試方法論中，<strong>他們很可能會加入相關的社群。在這樣的社群裡，方法論被當作教條</strong>，社群成員的身分認同也與這些信仰緊密相連。為了保護自己的身分認同，人們往往會變得更加狂熱。</li><li><strong>技術宗教戰爭的延伸</strong>：軟體開發領域充斥著各種技術宗教戰爭，無論是程式語言、開發框架，還是測試方法論。<strong>這些戰爭反映了人們對自我選擇的辯護</strong>，以及對他人選擇的攻擊。</li><li><strong>缺乏批判性思考</strong>：最後，也是最讓人頭疼的原因之一。很多人接受新的方法論時，缺乏批判性思考。他們不去評估這些方法論是否適合自己的專案，不考慮成本和收益，也不尋找可能的替代方案。</li></ol><p>這些原因綜合在一起，就創造了一個完美的環境，讓「測試」領域裡的信仰狂熱者茁壯成長。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/beoEztr.png&quot; alt=&quot;Python 工匠&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263245174&quot;&gt;Python 工匠｜案例、技巧與開發實戰&lt;/a&gt;》筆記的第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;如第一篇所言，這是一本關於「Clean Code in Python」的書。&lt;/p&gt;
&lt;p&gt;這二篇，我將整理書中第 13 章「&lt;strong&gt;有關單元測試的建議&lt;/strong&gt;」的內容（以及我的看法）。我覺得真的寫得太好了，值得你了解。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/beoEztr.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="系列：Python 工匠" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%B7%A5%E5%8C%A0/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>《人生 4 千個禮拜》筆記（二）抗拒「重要性中等」的誘惑</title>
    <link href="https://blog.kyomind.tw/four-thousand-weeks-02/"/>
    <id>https://blog.kyomind.tw/four-thousand-weeks-02/</id>
    <published>2024-03-04T09:11:47.000Z</published>
    <updated>2024-04-08T09:25:42.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/UNr2AmS.png" alt="人生 4 千個禮拜"><span class="cap">人生 4 千個禮拜</span></p><p>這是《<a href="https://www.books.com.tw/products/0010914255">人生 4 千個禮拜</a>》筆記的第 2 篇，你可以把它當作是一則重點整理，加上<strong>大量我個人的經驗與想法</strong>。</p><p>上一篇我們提到，「生產力」一詞在這個時代是如何地被重視——甚至有點扭曲。</p><p>以及如果你試圖用各種方法（尤其是那些筆記軟體與提升效率的工具）來增加生產力，反而很可能會掉入所謂的「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1">效率陷阱</a>」。</p><p>如果你也認同「<strong>過度追求效率很可能適得其反</strong>」這個命題，那很慶幸，我們已經達成了<strong>最重要的共識</strong>。這也是我給這本書高評價的原因。</p><span id="more"></span><h3 id="系列：人生-4-千個禮拜"><a href="#系列：人生-4-千個禮拜" class="headerlink" title="系列：人生 4 千個禮拜"></a>系列：人生 4 千個禮拜</h3><blockquote><ol><li><a href="/four-thousand-weeks-01/">《人生 4 千個禮拜》筆記（一）病態的生產力</a></li><li><strong>《人生 4 千個禮拜》筆記（二）抗拒「重要性中等」的誘惑</strong></li></ol></blockquote><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>如第一篇所言，本書可以認為是作者「<strong>對自己與『提高生產力』這個議題的重新觀察、自我反省</strong>」。</p><p>我希望這不是一篇普通的閱讀筆記或導讀，而是要強調我對本書<strong>最認同、最在乎</strong>的部分——我是如何在書中<strong>看到過去的自己。</strong>當然，這肯定包含了<strong>我自己的解讀</strong>。</p><p>因此，這篇文章，我想要<strong>繼續對作者追問</strong>：</p><blockquote><p>好，我現在知道過度追求生產力的可能代價了，那要<strong>怎麼想、怎麼做會更好？</strong></p></blockquote><p>本文整理自書中的第 3 到 4 章。</p><hr><h2 id="面對有限性"><a href="#面對有限性" class="headerlink" title="面對有限性"></a>面對有限性</h2><p>本書第 3 章的標題為「面對有限性」。</p><p>我知道，你可能會想：「噢！又來了！」然後皺起眉頭。心裡想到的是，在無數的書籍或文章中，那些提醒你要「<strong>珍惜現在、直面生命的有限</strong>」的雞湯內容。</p><p>好吧，至少我就是這樣覺得，覺得這個標題也未免太老生常談了！</p><p>但本文還是整理了其中的一段，因為我需要它，為接下來的內容作鋪墊。一言以蔽之，本章的重點就是：</p><blockquote><p>因為人生有限，你必須做出<strong>選擇</strong>。<strong>不能想要這個，又想要那個。</strong></p></blockquote><p>在這個前提下，作者是這麼說的：</p><blockquote><p>做選擇（從當前的選項中挑一個）成為一種<strong>肯定</strong>，根本算不上挫敗。這是一種<strong>正面的投入</strong>，你決定要用某段時間做這件事、<strong>不做那件事（不只一件，而是不計其數的其他事情）</strong>，因為你判定這件事是目前<strong>最重要</strong>的一件。</p></blockquote><p>請記得「最重要」三個字。</p><hr><h2 id="忽視應該忽視的事物"><a href="#忽視應該忽視的事物" class="headerlink" title="忽視應該忽視的事物"></a>忽視應該忽視的事物</h2><p>覺得自己事情太多，老是做不完，需要加強時間管理，或學習特定的生產力工具來提高產出嗎？先等等！看看作者怎麼說。</p><p>關於「時間管理」，到底怎麼做才稱得上「<strong>有效</strong>」，作者提出了一個有趣且令人信服的切入點：</p><blockquote><p>不論是哪一種間管理技巧，<strong>真正的有效評估指標</strong>是那項技巧<strong>是否協助你忽視應該忽視的事物。</strong></p></blockquote><p>我非常喜歡這個切入點。</p><blockquote><p>因此，重點不是根治拖延症，而是<strong>以更明智的方式選擇要延後哪些事，專注於眼前最重要的事。</strong></p></blockquote><p>當然，這樣的看法並不算新穎。但是，能夠把「<strong>有效忽略不夠重要事物</strong>」這個指標提升到時間管理方法論的「<strong>首要</strong>」考慮事項，我個人十分贊同。</p><hr><p>接下來的內容，會結合我個人的經驗、想法。</p><h2 id="生產力-KOL-們的承諾"><a href="#生產力-KOL-們的承諾" class="headerlink" title="生產力 KOL 們的承諾"></a>生產力 KOL 們的承諾</h2><p>還是要再提到「<a href="https://blog.kyomind.tw/less-is-more/#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D">人生管理系統</a>」，不過這次我們不需要了解其中的細節。</p><p>這種承諾你可以完成很多事的「生產力方法論」，也就是上述的「系統」，無疑是現代「生產力至上」這類價值觀的<strong>縮影</strong>。</p><p>你說它不好嗎？可能也不盡然。我相信這類「系統」確實可能讓你做完更多事情——但也僅止於此。</p><h3 id="美好的承諾"><a href="#美好的承諾" class="headerlink" title="美好的承諾"></a>美好的承諾</h3><p>這類系統與其背後的價值觀，可大致濃縮為：</p><blockquote><p>用厲害的方法，做完很多事。</p></blockquote><p>而推廣這類方法論的生產力 KOL 們，會不斷明示、暗示你：「一旦擁有<strong>能做完很多事的能力</strong>，你會從瞎忙中脫解，<strong>你的人生將從此不同</strong>。」</p><p>其實這樣的論述和更早開始流行的「時間管理」一樣，都是給你一個<strong>美好的承諾</strong>。</p><p>其中的<strong>差別</strong>或許是，他們更加強調「<strong>工具</strong>」的重要性——並提供一整套有關<strong>「如何善用工具」</strong>的<strong>學習方案</strong>。（可能是文章、書籍、影片、課程、社群，可能是免費或付費）</p><p>上述「多多益善」命題是否為真、是否有效，可以先不論。這裡想從另一個角度切入，說說我認為<strong>更值得推崇的看法。</strong></p><hr><h2 id="我認為「更好更有效」的做法"><a href="#我認為「更好更有效」的做法" class="headerlink" title="我認為「更好更有效」的做法"></a>我認為「更好更有效」的做法</h2><p>我的核心看法很簡單：<strong>放下「想做完很多事」的渴望</strong>。接受書中的核心觀點，理解人生有限，並做出取捨。<strong>然後專注於那些「最要緊」的事就好。</strong></p><p>必須強調，捨棄一部分重要的事情，<strong>這個過程可能會讓人很不舒服。</strong>如果你沒有這樣的感受，那可能是因為<strong>你還沒有真正做出取捨。</strong></p><p>對此，我要更進一步闡明：</p><blockquote><p><strong>我不認為「能做完很多事」的能力，能夠改變你的人生</strong>。相反的，能做出<strong>取捨</strong>，<strong>專注於關鍵事物</strong>的人，更有機會變得不同。</p></blockquote><p>換句話說，<strong>我認為「取捨」——與取捨後的「專注」——才是最重要的能力</strong>，而不是靠工具、系統、時間管理，試圖去完成更多事情。</p><p>而所謂<strong>取捨的能力</strong>，講白了，就是本段標題說的，「<strong>忽視應該忽視的事物</strong>」的能力。</p><h2 id="小而美的「局部實現」"><a href="#小而美的「局部實現」" class="headerlink" title="小而美的「局部實現」"></a>小而美的「局部實現」</h2><p>「忽視應該忽視的事物」的能力，究竟要<strong>如何培養</strong>？老實說，我自己也還在摸索、思考與歸納的路上。</p><p>我感覺自己還不是一個，能夠果斷取捨然後篤定前行的人——我總是太 FOMO。</p><p>不過，《<a href="https://blog.kyomind.tw/less-is-more/">為什麼你「不需要」所謂的人生管理系統</a>》中關於「<a href="https://blog.kyomind.tw/less-is-more/#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE">局部實現</a>」的闡述，仍然值得我們參考：</p><blockquote><p>局部實現，是一種<strong>心法或價值觀</strong>，說穿了沒什麼，就是「<strong>緊扣著需求尋找並選定方法，需要多少才投入多少</strong>」。</p></blockquote><p>想做多少再投入多少，確保自己做的事，都是真正重要的。這樣的思考與價值觀，或許更加簡潔、有力。</p><p>相信本書作者，也會認同這樣的觀點。</p><hr><h2 id="抗拒重要性中等的誘惑"><a href="#抗拒重要性中等的誘惑" class="headerlink" title="抗拒重要性中等的誘惑"></a>抗拒重要性中等的誘惑</h2><p>書中舉了一個例子（作者說，話是誰講的並不重要XD）來表達，為了真正做到取捨，你應該怎麼看待，那些「<strong>重要但不是最重要</strong>」的事情。</p><blockquote><p>據說這是股神巴菲特（Warren Buffett）的故事，反正有一次，巴菲特的私人駕駛請教他，怎樣才能排定優先順序。</p></blockquote><blockquote><p>他要駕駛找出人生最重要的二十五件事，接著依序排列，從最重要的排到最不重要的。巴菲特說，在規畫時間時，應該安排好單子上的前五名。</p></blockquote><blockquote><p>至於剩下的二十件事，和駕駛以為會聽到的建議不一樣。據說巴菲特解釋，那二十件事<strong>不是重要性居次、有機會就去做的事。</strong></p></blockquote><p>錯，錯，錯！</p><blockquote><p><strong>事實上，駕駛應該不惜一切代價，努力避免去做那二十件事</strong>，因為對那名駕駛而言，<strong>那二十個目標沒有重要到構成人生的核心，吸引力卻大到足以讓他分心，以至於沒去做最重要的事。</strong></p></blockquote><p>「沒有重要到構成人生的核心，吸引力卻大到足以讓他分心」，這真的是血淋淋的教訓！而且我相信，不論任何人，都一定能夠想起，自己曾經做過了多少這樣的事情。</p><hr><h2 id="放下妄念，減少分心"><a href="#放下妄念，減少分心" class="headerlink" title="放下妄念，減少分心"></a>放下妄念，減少分心</h2><p>當然，人生畢竟不是理論，縱使扣除休息與休閒，當我們想要「有所作為」的時候，也不可能真的只做最重要的五件事——太難了！</p><p>但是，至少每隔一段時間自我檢視、反省一次：「我是不是又把時間花在『<strong>重要但不是最重要</strong>』的事情上了？」，肯定會很有收獲。</p><p>但我還是想再次提醒你——也提醒自己。想要真心誠意，盡可能緊扣著「最重要」的事努力實踐。就要<strong>一定程度放下「我要做很多事」的渴望。</strong></p><blockquote><p><strong>也就是抗拒「重要性中等」的誘惑。</strong></p></blockquote><p>這並不容易！如前所述，<strong>真正的取捨是個讓人「不太舒服」的過程。</strong></p><p>因此，我能斗膽斷言：深信自己「可以透過學習工具、方法論，<strong>完成大量重要事情</strong>」的人，99% 都是要落空的。</p><h3 id="三種枉然"><a href="#三種枉然" class="headerlink" title="三種枉然"></a>三種枉然</h3><p>不過落空的結局有<strong>三個截然不同的版本</strong>：</p><ol><li>工具、方法的學習與維護成本太高，難以維持，<strong>最後放棄了！</strong>說真的，這是<strong>相對幸運</strong>的結局——因為你<strong>省下了時間</strong>，可以重新開始。</li><li>真的做了很多事，但同時也<strong>包含了一堆不夠重要的事</strong>——就像本書說的一樣。這就比較慘了，有句話說得好：「<strong>兢兢業業地把時間浪費了</strong>」。</li><li>真的做了很多事，但<strong>關鍵成效都不怎麼樣（很可能「瑣事」部分做得特別好）</strong>。正所謂「<strong>貪多嚼不爛</strong>」——尤其是最難啃的部分，哪怕你有神兵利器。</li></ol><p>上面提到的數字是 99% 而不是 100，看樣子，我還是相信有 1% 的人會成功？</p><p>是的！我確實相信，有極少數人能夠做到。但我奉勸你不要追求，企圖成為這鳳毛麟角的 1%——因為真的沒有必要。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UNr2AmS.png&quot; alt=&quot;人生 4 千個禮拜&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.books.com.tw/products/0010914255&quot;&gt;人生 4 千個禮拜&lt;/a&gt;》筆記的第 2 篇，你可以把它當作是一則重點整理，加上&lt;strong&gt;大量我個人的經驗與想法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上一篇我們提到，「生產力」一詞在這個時代是如何地被重視——甚至有點扭曲。&lt;/p&gt;
&lt;p&gt;以及如果你試圖用各種方法（尤其是那些筆記軟體與提升效率的工具）來增加生產力，反而很可能會掉入所謂的「&lt;a href=&quot;https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1&quot;&gt;效率陷阱&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;如果你也認同「&lt;strong&gt;過度追求效率很可能適得其反&lt;/strong&gt;」這個命題，那很慶幸，我們已經達成了&lt;strong&gt;最重要的共識&lt;/strong&gt;。這也是我給這本書高評價的原因。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/UNr2AmS.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="系列：人生 4 千個禮拜" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%BA%E7%94%9F-4-%E5%8D%83%E5%80%8B%E7%A6%AE%E6%8B%9C/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>《Python 工匠》筆記（一）如何寫好註解</title>
    <link href="https://blog.kyomind.tw/python-craftsman-01/"/>
    <id>https://blog.kyomind.tw/python-craftsman-01/</id>
    <published>2024-02-28T04:40:57.000Z</published>
    <updated>2024-04-12T16:12:03.407Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/beoEztr.png" alt="Python 工匠"><span class="cap">Python 工匠</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠｜案例、技巧與開發實戰</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>從書名推敲，我們並不容易知道本書的主題為何。事實上，和《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣</a>》類似，這是一本關於「<strong>Clean Code in Python</strong>」的書。</p><p>而且我認為它的<strong>難度適中</strong>（好吧，後半部難度比較高，而且本書<strong>「不適合」</strong>初學者），非常推薦看完《Python 功力提升的樂趣》後，想要更進一步寫出 Pythonic 程式碼的讀者與開發人員。</p><p>我覺得，兩本恰恰都是屬於「從書名看很容易被忽略」的好書。因此，作為喜歡本書的讀者，我覺得自己有<strong>義務</strong>，向你們轉述書中一些值得傳誦的內容。</p><p>這也是我寫「<strong>閱讀筆記</strong>」類文章的核心精神——分享書中那些我覺得<strong>特別精彩、贊同的部分，並加上自己的看法。</strong></p><span id="more"></span><h3 id="系列：Python-工匠"><a href="#系列：Python-工匠" class="headerlink" title="系列：Python 工匠"></a>系列：Python 工匠</h3><blockquote><ol><li><strong>《Python 工匠》筆記（一）如何寫好註解</strong></li><li><a href="https://blog.kyomind.tw/python-craftsman-02/">《Python 工匠》筆記（二）對「單元測試」的看法與建議</a></li></ol></blockquote><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E5%A6%82%E4%BD%95%E5%AF%AB%E5%A5%BD-Python-%E8%A8%BB%E8%A7%A3">如何寫好 Python 註解</a></li><li><a href="#Python-%E8%A8%BB%E8%A7%A3%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98">Python 註解基礎知識</a></li><li><a href="#%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E4%B8%89%E7%A8%AE%E8%A8%BB%E8%A7%A3%E9%8C%AF%E8%AA%A4">新手常犯的三種註解錯誤</a></li><li><a href="#%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E8%A8%BB%E8%A7%A3%E7%A8%8B%E5%BC%8F%E7%A2%BC">一、直接註解程式碼</a></li><li><a href="#%E4%BA%8C%E3%80%81%E5%83%85%E7%94%A8%E8%A8%BB%E8%A7%A3%E3%80%8C%E9%87%8D%E8%BF%B0%E3%80%8D%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A1%8C%E7%82%BA">二、僅用註解「重述」程式碼行為</a></li><li><a href="#%E6%8C%87%E5%BC%95%E5%9E%8B%E8%A8%BB%E8%A7%A3">指引型註解</a></li><li><a href="#%E6%8F%90%E7%85%89%E7%82%BA%E7%8D%A8%E7%AB%8B%E5%87%BD%E5%BC%8F">提煉為獨立函式</a></li><li><a href="#%E4%B8%89%E3%80%81%E5%BC%84%E9%8C%AF%E8%A8%BB%E8%A7%A3%E7%9A%84%E3%80%8C%E5%8F%97%E7%9C%BE%E3%80%8D">三、弄錯註解的「受眾」</a></li><li><a href="#%E8%87%AA%E8%A8%80%E8%87%AA%E8%AA%9E%E7%9A%84%E8%A8%BB%E8%A7%A3">自言自語的註解</a></li><li><a href="#Docstring-%E8%88%87%E8%AE%80%E8%80%85%E6%84%8F%E8%AD%98">Docstring 與讀者意識</a></li><li><a href="#%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E8%A8%BB%E8%A7%A3%EF%BC%9F">好的程式碼到底需不需要註解？</a></li><li><a href="#%E4%BD%9C%E8%80%85%E7%9A%84%E8%A7%80%E9%BB%9E%E8%88%87%E6%88%91%E7%9A%84%E7%9C%8B%E6%B3%95">作者的觀點與我的看法</a></li></ol><hr><h2 id="如何寫好-Python-註解"><a href="#如何寫好-Python-註解" class="headerlink" title="如何寫好 Python 註解"></a>如何寫好 Python 註解</h2><p>本文整理第一章的其中一部分——關於「如何寫好註解」的討論。</p><p>之所以要特別寫成筆記，是因為這是我目前看過的書中，討論註解時講最得好的一本。尤其是一些使用上的建議，和我的開發經驗與價值觀可謂非常吻合！</p><p>本書作者朱雷（<a href="https://github.com/piglei">piglei</a>），擁有超過 10 年的 Python 開發經驗，精通 Python 語言特性，對如何開發高品質的大型 Python 專案有獨到見解。</p><p>其實我一直也想整理一篇關於寫好註解的基本守則，但遲遲沒有行動。但現在有這本書，我只要整理書中的內容，並加上自己的看法即可。</p><p>有關 Python 註解或 docstring 的討論，我在過去多篇文章中都有提到，可參考如下：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/#%E4%B8%80%E3%80%81Docstring-%E7%9C%9F%E7%9A%84%E5%BE%88%E9%87%8D%E8%A6%81">Docstring 真的很重要</a></li><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E8%A8%BB%E8%A7%A3%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%EF%BC%9F">註解是不需要的？</a></li><li><a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a></li></ul><p>開始正文。</p><hr><h2 id="Python-註解基礎知識"><a href="#Python-註解基礎知識" class="headerlink" title="Python 註解基礎知識"></a>Python 註解基礎知識</h2><p>Python 中，一般我們講到註解，指的是程式碼中的註解，用<code>#</code>來實現。</p><p>而 <a href="https://en.wikipedia.org/wiki/Docstring">docstring</a> 則是另一種更具有 Python 特色的註解。主要寫在模組、類別、與函式的開頭，並透過物件的<code>__doc__</code>屬性，自然地化為程式碼的一部分。</p><p>書中提到了 docstring 的幾種常見風格（畢竟它本質只是一堆字串，所以怎麼寫都行），最常見的為 Sphinx 文件風格。而我個人在工作上最常用的，則是 <a href="https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html">Google 風格</a>。</p><p>簡言之，下面提到「註解」二字時，對上述兩種 Python 註解都適用。</p><h2 id="新手常犯的三種註解錯誤"><a href="#新手常犯的三種註解錯誤" class="headerlink" title="新手常犯的三種註解錯誤"></a>新手常犯的三種註解錯誤</h2><p>你可能聽過「很多註解都是爛註解」這種說法。不得不承認，這相當程度是對的！我確實看過很多爛註解——但這不是我們因此不寫註解的理由。</p><p>實務上會有很多爛註解，正是因為我們沒有正視註解的價值，認真學習如何寫好註解。</p><p>因此，<strong>就讓我們用書中所舉三種常見的註解錯誤，作為學習的切入點。</strong></p><p>書中提到的這三點——尤其是第 3 點，應盡可能避免。作者也提出了相應的解決之道，而我會適時補充我的看法。</p><p>附帶一提，本書是從作者過去的網路文章整理、出版——但內容增加了很多。而且作者也很大方，在網路上公開了部分的內容。而本文整理的部分恰恰是公開的部分。有興趣的話可以直接參考<a href="https://www.piglei.com/book/ch01_variables.html">本頁</a>。</p><p>當然，我還是強烈建議，為自己入手一本，你絕對不會後悔。</p><hr><h2 id="一、直接註解程式碼"><a href="#一、直接註解程式碼" class="headerlink" title="一、直接註解程式碼"></a>一、直接註解程式碼</h2><p>把已經寫完但暫不需要（以後是否需要還不確定）的程式碼，先註解起來，方便日後需要時可以快速「還原」，絕對是我們非常熟悉的手段。</p><p>我回想一下，不得不說，這類被註解的程式碼，<strong>十之八九都是不會再用到了！</strong>如果這類「程式碼註解」愈積愈多，真的會讓人看了很「阿雜」！</p><p>所以基本上，現在比較正規的做法，都是建議你直接刪除，以後真的需要時，再透過版控回復即可。</p><p>對此我基本認同，所以工作上 code review 時，我「不會」放行這種直接註解的程式碼。</p><h3 id="僅有的例外"><a href="#僅有的例外" class="headerlink" title="僅有的例外"></a>僅有的例外</h3><p>但，你我都知道，有時事情也沒那麼簡單。</p><p>用 Git 版控回復的前提是：你的團隊 commit 記錄要寫好！不然真的要「回復」的時候，你可能連它在哪一個 commit 都要找好一陣子。</p><p>所以，基於方便與實際考量，事實上我還是有<strong>一點點折衷</strong>：原則上不可以註解程式碼，但如果確定只是「<strong>暫時</strong>」用不到，等別的元件完成後，就會繼續開發、使用，例外可以暫時註解就好——但必須加上 <a href="https://peps.python.org/pep-0350/">codetag</a> 標記。</p><p>一般我們用 <code>TODO</code> 這個 codetag。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO 日後改回一對一時，請用下面方式重寫：</span></span><br><span class="line"><span class="comment"># user = User.objects.select_related(&#x27;oversee_tenant&#x27;)</span></span><br><span class="line"><span class="comment"># .prefetch_related(&#x27;oversee_projects&#x27;).get(user_uuid=user_uuid)</span></span><br></pre></td></tr></table></figure><p>不過<strong>大原則</strong>還是：</p><blockquote><p><strong>別註解了，刪除吧！</strong></p></blockquote><hr><h2 id="二、僅用註解「重述」程式碼行為"><a href="#二、僅用註解「重述」程式碼行為" class="headerlink" title="二、僅用註解「重述」程式碼行為"></a>二、僅用註解「重述」程式碼行為</h2><p>這應該是我們最常看到的爛註解的形式，也是你在所有討論程式碼註解的書中，一定會提及的。</p><p>而且它真的爛，沒有藉口。比如這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 x 為 0</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 x 是否小於 10</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="comment"># 印出 x 小於 10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is less than 10&quot;</span>)</span><br></pre></td></tr></table></figure><p>這當然是一個誇張的例子🤣。但在日常開發中，這種「脫褲子放屁」的註解還真的不算少見。</p><p>確實，如果我常常看到這樣的註解，恐怕真的會忍不住說出「你還別寫註解了吧！」</p><p>但，請不要放棄治療！</p><p>想避免這個問題，請遵守一個簡單且常見的大原則，如書中所言：</p><blockquote><p>應該儘量提供那些讀者<strong>無法</strong>從程式碼裡讀出來的資訊。描述程式<strong>為什麼</strong>要這麼做，而不是簡單複述程式碼本身。</p></blockquote><p>不過，光寫「為什麼」註解，有時候還是遠遠不夠的。</p><h2 id="指引型註解"><a href="#指引型註解" class="headerlink" title="指引型註解"></a>指引型註解</h2><p>因此，本書更進一步提出所謂的「<strong>指引性註解</strong>」：</p><blockquote><p>這種註解並不「直接」複述程式，而是簡明扼地概括程式碼功能，起到「<strong>程式碼導讀</strong>」的效果。</p></blockquote><p>書中的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化存取服務的 client 物件</span></span><br><span class="line">token = token_service.get_token()</span><br><span class="line">service_client = ServiceClient(token=token)</span><br><span class="line">service_client.ready()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 呼叫服務取得資料，然後進行過濾</span></span><br><span class="line">data = service_client.fetch_full_data()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> item.value &gt; SOME_VALUE:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>不難看出，這種描述「程式碼流程大綱」的指引型註解，<strong>很像 docstring 在做的事</strong>。從這個角度，我們可以說 docstring <strong>也是</strong>一種指引型註解。</p><p>但是，docstring 畢竟只出現在元件的「<strong>開頭</strong>」，對複雜的程式而言，在元件的內部，往往也需要這樣的註解，作為閱讀<strong>複雜程式碼</strong>的指引。</p><p>要寫好指引型註解，甚至知曉「什麼時候」應該要寫下指引型註解，需要你內心清楚——「這段程式碼的哪些部分，別人可能會看不懂！」</p><p>這是為什麼我總說，要寫好註解，就一定要培養好「<strong>讀者意識</strong>」的理由。</p><h3 id="指引型註解的價值"><a href="#指引型註解的價值" class="headerlink" title="指引型註解的價值"></a>指引型註解的價值</h3><p>前面提到，寫註解時「應該儘量提供那些讀者<strong>無法從程式碼裡讀出來</strong>的資訊」，這是我們寫註解的大原則。</p><p>但指引性註解和上述註解<strong>所有區別</strong>，它的<strong>獨特價值</strong>，如書中所言：</p><blockquote><p>指引性註解<strong>並不提供</strong>程式碼裡<strong>讀不到</strong>的東西——如果沒有註解，耐心讀完所有程式碼，你也能知道程式做了什麼事。指引性註解的主要作用是<strong>降低程式碼的認知成本</strong>，讓我們能<strong>更容易理解</strong>程式碼的<strong>意圖</strong>。</p></blockquote><p>說得非常好。</p><h2 id="提煉為獨立函式"><a href="#提煉為獨立函式" class="headerlink" title="提煉為獨立函式"></a>提煉為獨立函式</h2><p>對於複雜而冗長的程式流程，書寫「指引性註解」是一個協助閱讀理解的好方法。</p><p>而另一個有效的方法，就是把這些程式碼片段<strong>獨立成一個又一個的函式</strong>，透過<strong>有意義的函式名稱</strong>來描述流程、展現意圖，此時就可以刪除指引性註解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service_client = make_client()</span><br><span class="line">data = fetch_and_filter(service_client)</span><br></pre></td></tr></table></figure><p>其中的重點在於，你要能判斷，什麼時候該寫「指引性註解」，而什麼時候則適合獨立成函式、方法。</p><p>這當然需要經驗累積，但我們心中要先有這樣的意識，不是嗎？</p><hr><h2 id="三、弄錯註解的「受眾」"><a href="#三、弄錯註解的「受眾」" class="headerlink" title="三、弄錯註解的「受眾」"></a>三、弄錯註解的「受眾」</h2><p>本書這段主要適用的是 docstring，不過我覺得「指引型註解」也有類似議題，所以本段提到「註解」一詞時，皆包括這兩者。</p><p>註解的正確<strong>受眾</strong>，或說<strong>讀者</strong>，應該是誰？我想基本上是這兩種人：</p><ol><li><strong>未來</strong>的自己（注意「未來」二字）</li><li>專案<strong>協作者</strong>（同事、主管）</li></ol><p>我們先看看書中所舉的「反例」：（我直接引用<a href="https://www.piglei.com/book/ch01_variables.html">網頁</a>上的內容，所以技術名詞並非台灣用語，還請見諒）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resize_image</span>(<span class="params">image, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;將圖片縮放為指定尺寸，並返回新的圖片。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    該函數將使用 Pilot 模塊讀取文件對象，然後調用 .resize() 方法將其縮放為指定尺寸。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    但由於 Pilot 模塊自身限制，這個函數不能很好的處理尺寸過大的文件，當文件大小</span></span><br><span class="line"><span class="string">    超過 5MB 時，resize() 方法的性能就會因為內存分配問題急劇下降，詳見 Pilot 模塊的</span></span><br><span class="line"><span class="string">    Issue #007。因此，對於超過 5MB 的圖片文件，請使用 resize_big_image() 替代，後者</span></span><br><span class="line"><span class="string">    基於 Pillow 模塊開發，很好的解決了內存分配問題，性能更好。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param image: 圖片文件對象</span></span><br><span class="line"><span class="string">    :param size: 包含寬高的元組：（width, height）</span></span><br><span class="line"><span class="string">    :return: 新圖片對象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>這個例子的最大問題，是寫了太多「實作細節」，講白了就是提供了「太多」程式碼的讀者<strong>並不關心</strong>的內容！</p><blockquote><p>為什麼這樣是不妥的？細節不是很好嗎？</p></blockquote><p>對，但大部分時候，docstring 或「指引型註解」的主要寫作<strong>目的</strong>，是為了讓讀者<strong>不用一行一行閱讀程式碼</strong>，就能夠快速知道目前程式碼的<strong>流程與意圖</strong>。</p><p>這種過多細節的寫法，恰恰與這個目標<strong>背道而馳</strong>——增加了太多理解上的「<strong>雜訊</strong>」。</p><p>書中給出的改善版本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resize_image</span>(<span class="params">image, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;將圖片縮放為指定尺寸，並返回新的圖片。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意：當文件超過 5MB 時，請使用 resize_big_image()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param image: 圖片文件對象</span></span><br><span class="line"><span class="string">    :param size: 包含寬高的元組：（width, height）</span></span><br><span class="line"><span class="string">    :return: 新圖片對象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><p>以下主要是我自己的看法。</p><h2 id="自言自語的註解"><a href="#自言自語的註解" class="headerlink" title="自言自語的註解"></a>自言自語的註解</h2><p>你有沒有一個疑問，為什麼說註解寫了太多細節，是「弄錯受眾」？</p><p>我是這樣看的：留下這麼多細節的註解，與其說是註解，更像寫給自己看的<strong>筆記</strong>——而且是給「現在」的自己，真的就像在作筆記一樣！</p><p>我想強調，<strong>「現在的自己」並不是註解的受眾！</strong>因為現在的自己對程式細節非常清楚，即使沒有註解也能讀懂程式碼。</p><p>相反的，註解是為<strong>沒時間慢慢讀程式碼</strong>的人服務的。</p><p>未來的你，再回來看這段程式，絕對不會想要在 docstring 看到這麼多「<strong>廢話</strong>」。這種寫法無疑是搞錯了對象。</p><p>當然，你的同事也不會想看這麼多雜訊——同事往往更關心「這函式到底要怎麼用」！</p><h3 id="抽象層次混亂"><a href="#抽象層次混亂" class="headerlink" title="抽象層次混亂"></a>抽象層次混亂</h3><p>我覺得還有另一種「弄錯受眾」的註解也很經典，甚至更加常見！那就是混合底層實作與業務邏輯：</p><blockquote><p>註解中參雜了業務邏輯，又不時會出現底層實作的細節描述。</p></blockquote><p>事實上，我倒覺得實務中會願意寫一大串 docstring 的人，可以說是少之又少。大部分的問題其實是：有寫，但寫得「<strong>零零落落</strong>」。</p><h2 id="Docstring-與讀者意識"><a href="#Docstring-與讀者意識" class="headerlink" title="Docstring 與讀者意識"></a>Docstring 與讀者意識</h2><p>Docstring 絕對能看出一個人的<strong>基本寫作能力</strong>，以及是否具備「<strong>讀者意識</strong>」。</p><p>說真的，這不止是作為一個軟體工程師的核心技能——更是任何<strong>表達者</strong>的核心技能。而程式，只是表達的其中一種形式。</p><p>我很想要寫一篇「如何寫好 docstring」，這需要再構思一番。但常見的錯誤不外乎：</p><ol><li><strong>預知能力</strong>：知曉「函式以外」的事、不僅知道函式會怎麼、何時被調用，還會在 docstring 中寫下呼叫時的情境細節——<strong>你知道的太多了！</strong></li><li><strong>太多底層細節</strong>：跟前面的書中內容相似，只是我覺得現實中，往往是<strong>東寫一點、西寫一點</strong>，不會像寫筆記一般完整——所以讀起來更痛苦，真的是自言自語！除了開發者自己，誰能輕易讀懂那些細節？</li><li><strong>業務邏輯與底層實作的用詞混雜</strong>：一下子是「無法取得租戶資訊」一下子卻又是「防止 SQL insert 錯誤、RabbitMQ 如何如何」——讓人大腦很混亂。</li></ol><p>總的來說，無論是「自言自語」還是「抽象層次混亂」，它們的本質都差不多——這些註解都像是寫給「<strong>現在的自己</strong>」看的<strong>筆記</strong>。</p><p>但就像前面說的，現在的自己是<strong>最不需要看註解的人</strong>！所以才說是「弄錯受眾」了。</p><hr><p>最後不免俗地，我們要討論，提到「程式碼註解」就<strong>一定避不開的問題</strong>：</p><blockquote><p><strong>到底要不要寫註解</strong>？</p></blockquote><h2 id="好的程式碼到底需不需要註解？"><a href="#好的程式碼到底需不需要註解？" class="headerlink" title="好的程式碼到底需不需要註解？"></a>好的程式碼到底需不需要註解？</h2><p>寫程式到底要不要寫註解，一直有兩派說法，是個老掉牙又爭論不休的問題。我們先來看看這兩派的觀點。（ ChatGPT 整理）</p><h3 id="寫註解的一派"><a href="#寫註解的一派" class="headerlink" title="寫註解的一派"></a>寫註解的一派</h3><p>這派人認為註解是<strong>程式碼的一部分</strong>，應該寫註解，主要論點為：</p><ol><li><strong>可讀性提升</strong>：註解能夠幫助人們<strong>更快理解程式碼的意圖和複雜的邏輯</strong>，尤其是對於那些<strong>不那麼直觀的部分</strong>。</li><li><strong>溝通工具</strong>：註解被視為開發者之間的<strong>溝通方式</strong>，尤其在團隊協作時，能夠快速傳遞開發者的想法和注意事項。</li><li><strong>提醒與說明</strong>：註解可以用來提醒未來可能的問題，或是對程式碼中的決策提供背景說明。</li></ol><h3 id="不寫註解的一派"><a href="#不寫註解的一派" class="headerlink" title="不寫註解的一派"></a>不寫註解的一派</h3><p>相對的，這派人認為好的程式碼應該是<strong>自解釋</strong>的，不需要註解，主要論點為：</p><ol><li><strong>程式碼即文件</strong>：好的程式碼應該是自解釋的，如果你需要註解來解釋你的程式碼，那麼問題可能出在程式碼本身。</li><li><strong>增加維護難度</strong>：註解需要維護，<strong>不一致的註解比沒有註解更糟</strong>，因為它會導致誤解和混淆。</li><li><strong>過度依賴註解</strong>：過多的註解可能會讓開發者過度依賴於它們來理解程式碼，忽視了提高程式碼品質的重要性。</li></ol><hr><h2 id="作者的觀點與我的看法"><a href="#作者的觀點與我的看法" class="headerlink" title="作者的觀點與我的看法"></a>作者的觀點與我的看法</h2><p>細看這兩派的主張，我們可以看出，都有一定的道理——不然也不會爭論不休了。</p><h3 id="作者觀點"><a href="#作者觀點" class="headerlink" title="作者觀點"></a>作者觀點</h3><p>我們先來看看本書作者的觀點（引用難免斷章取義，完整上下文請見本書第 15 頁），下面內容主要是回應「不寫註解的一派」：</p><blockquote><p>但我倒是認為事情沒那麼絕對。<strong>無論程式碼寫得多好，多麼「自說明」，跟讀程式碼相比，讀註解通常讓人覺得更輕鬆</strong>。</p></blockquote><blockquote><p>註解會讓人們<strong>覺得親切</strong>（尤其當註解是中文時），<strong>高品質的指引性註解確實會讓程式碼更易讀</strong>。有時抽象一個新函式，不見得就一定比一行註解加上幾行程式碼更好。</p></blockquote><p>第一段引用，其實就跟我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a>」中的主張一致：</p><blockquote><p>在我看來，無論程式寫得如何簡潔易讀，對一些比較複雜的函式或類別而言，docstring 終究是不可少的。<strong>因為文字的詮釋能力和程式碼相比，絕不在同一個層次</strong>，相信這也是為何 docstring 會有屬於自己的獨立 PEP 加以規範的理由。</p></blockquote><h3 id="我的看法與結論"><a href="#我的看法與結論" class="headerlink" title="我的看法與結論"></a>我的看法與結論</h3><p>既然都寫了這篇文章，想當然爾我是「<strong>支持</strong>」寫註解的一派。</p><p>不過，反對派說註解會<strong>增加維護難度</strong>，以及可能讓人<strong>更加依賴註解</strong>而忽略了提升程式碼品質，我覺得這些擔憂也<strong>非常真實</strong>。</p><p>所以，對我來說，問題不在於「要不要寫註解？」，而是<strong>「怎麼樣才能寫好註解？」</strong>。這也是本文想回答的問題。</p><p>我的結論是：寫註解，<strong>但也要適度</strong>。並保持對「<strong>讀者意識</strong>」的敏感：<strong>不寫多餘的註解，也不寫自言自語的註解。</strong></p><h3 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h3><ul><li><a href="https://www.explainthis.io/zh-hant/swe/a-philosophy-of-software-design/part3">《A Philosophy of Software Design》心得 3 — 寫程式時該寫註解 (comments) 嗎？如果要的話該怎麼寫？</a></li><li><a href="https://www.facebook.com/darkthread.net/photos/a.345323768929153/1185728258222029/">【程序員的日常】程式註解該寫多細？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/beoEztr.png&quot; alt=&quot;Python 工匠&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263245174&quot;&gt;Python 工匠｜案例、技巧與開發實戰&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;從書名推敲，我們並不容易知道本書的主題為何。事實上，和《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣&lt;/a&gt;》類似，這是一本關於「&lt;strong&gt;Clean Code in Python&lt;/strong&gt;」的書。&lt;/p&gt;
&lt;p&gt;而且我認為它的&lt;strong&gt;難度適中&lt;/strong&gt;（好吧，後半部難度比較高，而且本書&lt;strong&gt;「不適合」&lt;/strong&gt;初學者），非常推薦看完《Python 功力提升的樂趣》後，想要更進一步寫出 Pythonic 程式碼的讀者與開發人員。&lt;/p&gt;
&lt;p&gt;我覺得，兩本恰恰都是屬於「從書名看很容易被忽略」的好書。因此，作為喜歡本書的讀者，我覺得自己有&lt;strong&gt;義務&lt;/strong&gt;，向你們轉述書中一些值得傳誦的內容。&lt;/p&gt;
&lt;p&gt;這也是我寫「&lt;strong&gt;閱讀筆記&lt;/strong&gt;」類文章的核心精神——分享書中那些我覺得&lt;strong&gt;特別精彩、贊同的部分，並加上自己的看法。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/beoEztr.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="系列：Python 工匠" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%B7%A5%E5%8C%A0/"/>
    
    <category term="讀書心得" scheme="https://blog.kyomind.tw/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
</feed>
