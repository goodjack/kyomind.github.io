<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2024-03-21T03:29:17.277Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>Kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>25，回歸原點的 Weekly Review</title>
    <link href="https://blog.kyomind.tw/weekly-review-25/"/>
    <id>https://blog.kyomind.tw/weekly-review-25/</id>
    <published>2024-03-20T18:39:31.000Z</published>
    <updated>2024-03-21T03:29:17.277Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/3auatX0.png"></p><p>這是第 25 篇的 Weekly Review，距離<a href="https://blog.kyomind.tw/weekly-review-24/">上一期</a>已經非常久了！</p><p>我覺得，顯然的，我把整個 Weekly Review 寫「<strong>偏</strong>」了，失去了它原本的味道。</p><p>雖然我曾在第十期〈<a href="https://blog.kyomind.tw/weekly-review-10/">10，Weekly Review 寫滿 10 回：我的心得與改進</a>〉確立了一些想法。但也就是這些想法，讓整個系列走向愈來愈「<strong>笨重</strong>」的窘境。</p><p>比如其中提到「<a href="https://blog.kyomind.tw/weekly-review-10/#%E4%BA%8C%E3%80%81%E7%AF%87%E5%B9%85%E4%B8%8A%E9%99%90%EF%BC%9F%E5%BF%98%E4%BA%86%E5%90%A7%EF%BC%81">二、篇幅上限？忘了吧！</a>」，就相當於在心中暗示了自己，可以愈寫愈長、愈寫愈正經。</p><p>繼續往這個方向演化，Weekly Review 的<strong>調性</strong>就會逐漸向「<a href="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/">心得</a>」靠攏——而結果也是如此，同時讓我<strong>愈來愈難下筆。</strong></p><span id="more"></span><h2 id="Weekly-Review-三大特色"><a href="#Weekly-Review-三大特色" class="headerlink" title="Weekly Review 三大特色"></a>Weekly Review 三大特色</h2><p>對我而言，Weekly Review 不是心得。但兩者的<strong>內在區別</strong>，需要我自己去定義。畢竟如果兩者沒有明顯分別，那其實就不需要前者了。</p><p>所以，我要在此<strong>再次定義一下 Weekly Review 的三大特色：</strong></p><ol><li>與我個人感想、反省、心情有關，其中的著眼點在於「<strong>自己</strong>」。</li><li>有「<strong>時間軸</strong>」感，也就是「不同時期自己」的想法、經驗。</li><li><strong>簡短一點</strong>。保持簡單才能夠實現「<strong>輕快</strong>」，也才能夠確保一定的發文頻率。</li></ol><p>這 3 點是我對重新回歸的 Weekly Review 的要求與期待。</p><h2 id="新的助力"><a href="#新的助力" class="headerlink" title="新的助力"></a>新的助力</h2><p>光只是這樣，我可能還不敢號稱是「回歸原點」。</p><p>如果下一篇又是一、兩個月後，那就有點搞笑了。</p><p>我究竟要怎麼樣，才能相信自己有東西可以寫？而且不是正二八經的主題，而是和自己有關的心情或想法？</p><p>這真的不容易，不過自從 2 月下旬<a href="https://www.facebook.com/kyomind/posts/pfbid02TCX6gnu9hcDH1U6oN3r2m6N84mCnHgcpHWKE5wSk5L51PFDSiUBz367PKGEjS6pl">我開始用 memos 這個工具寫日記</a>後，我感覺可能性提高了不少。</p><p>截至今日，寫了 32 天的日記，已經有 129 篇長短不一的心情記事。關於 memos 與日記，我們另篇再談（我保證不會很久）。</p><p>這裡想說的是，有了這個工具與素材，我更容易「<strong>捕捉</strong>」不同時刻的我。參考這些日記的內容，把值得一提的部分，寫成 Weekly Review，這就是我初步的想法。</p><h2 id="更私人、更直白"><a href="#更私人、更直白" class="headerlink" title="更私人、更直白"></a>更私人、更直白</h2><p>簡單來說，我打算讓 Weekly Review 回歸它第一篇時我想做到的事。</p><p>而且最好是<strong>更任性、更直接</strong>的自我表達，同時<strong>更貼近我的日常生活</strong>。至於能做到什麼地步，我也不確定🐸</p><p>但發文頻率肯定不能像之前那樣，動輒一個月或更久。目前預計是 1、2 週一篇。</p><p>總之，盡力而為囉！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3auatX0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是第 25 篇的 Weekly Review，距離&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-24/&quot;&gt;上一期&lt;/a&gt;已經非常久了！&lt;/p&gt;
&lt;p&gt;我覺得，顯然的，我把整個 Weekly Review 寫「&lt;strong&gt;偏&lt;/strong&gt;」了，失去了它原本的味道。&lt;/p&gt;
&lt;p&gt;雖然我曾在第十期〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-10/&quot;&gt;10，Weekly Review 寫滿 10 回：我的心得與改進&lt;/a&gt;〉確立了一些想法。但也就是這些想法，讓整個系列走向愈來愈「&lt;strong&gt;笨重&lt;/strong&gt;」的窘境。&lt;/p&gt;
&lt;p&gt;比如其中提到「&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-10/#%E4%BA%8C%E3%80%81%E7%AF%87%E5%B9%85%E4%B8%8A%E9%99%90%EF%BC%9F%E5%BF%98%E4%BA%86%E5%90%A7%EF%BC%81&quot;&gt;二、篇幅上限？忘了吧！&lt;/a&gt;」，就相當於在心中暗示了自己，可以愈寫愈長、愈寫愈正經。&lt;/p&gt;
&lt;p&gt;繼續往這個方向演化，Weekly Review 的&lt;strong&gt;調性&lt;/strong&gt;就會逐漸向「&lt;a href=&quot;https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/&quot;&gt;心得&lt;/a&gt;」靠攏——而結果也是如此，同時讓我&lt;strong&gt;愈來愈難下筆。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/3auatX0.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="心情" scheme="https://blog.kyomind.tw/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>《Python 工匠》筆記（二）對「單元測試」的看法與建議</title>
    <link href="https://blog.kyomind.tw/python-craftsman-02/"/>
    <id>https://blog.kyomind.tw/python-craftsman-02/</id>
    <published>2024-03-17T03:40:57.000Z</published>
    <updated>2024-03-17T17:24:21.797Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/beoEztr.png" alt="Python 工匠"><span class="cap">Python 工匠</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠｜案例、技巧與開發實戰</a>》筆記的第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>如第一篇所言，這是一本關於「Clean Code in Python」的書。</p><p>這二篇，我將整理書中第 13 章「<strong>有關單元測試的建議</strong>」的內容（以及我的看法）。我覺得真的寫得太好了，值得你了解。</p><p>話不多說，直接開始。</p><span id="more"></span><h3 id="系列：Python-工匠"><a href="#系列：Python-工匠" class="headerlink" title="系列：Python 工匠"></a>系列：Python 工匠</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/python-craftsman-01/">《Python 工匠》筆記（一）如何寫好註解</a></li><li><strong>《Python 工匠》筆記（二）對「單元測試」的看法與建議</strong></li></ol></blockquote><hr><p>作者一開始就點了出關於「單元測試」的一個<strong>奇特現象</strong>：</p><blockquote><p>雖然好像人人都認為單元測試很有用，但在實際工作中，有完善單元測試的專案仍然是個<strong>稀奇</strong>的東西。</p></blockquote><p>這一點也不誇張，甚至可以說是<strong>公開的秘密</strong>。</p><p>單元測試，大家都說重要，但真的有在寫的團隊、專案、公司，卻不如想像中多。<strong>往往都是靠 QA 把關</strong>——把整合測試當作單元測試在測😎（我就待過這樣的公司）</p><p>很多公司都是在<strong>口頭上</strong>強調單元測試的重要性，但實際的執行力度卻大打折扣，就像是那些年初設定的新年決心，<strong>說的比做的好聽。</strong></p><h3 id="不寫單元測試的「理由」"><a href="#不寫單元測試的「理由」" class="headerlink" title="不寫單元測試的「理由」"></a>不寫單元測試的「理由」</h3><p>姑且不說公司如何如何，其實就連<strong>開發者自己</strong>，也常常<strong>逃避</strong>寫單元測試。</p><p>書中舉出了實務上，開發人員不想寫單元測試的 3 個常見理由——以及這些「理由」<strong>為什麼不成立</strong>的理由：</p><blockquote><ol><li>「<strong>時程緊迫沒時間寫測試</strong>」：寫單元測試看上去要多花費時間，但其實會<strong>在未來節約你的時間</strong>。</li><li>「<strong>模組複雜沒辦法寫測試</strong>」：也許這正代表了<strong>你的程式設計有問題</strong>，需要調整。</li><li>「<strong>模組簡單不需要測試</strong>」：是否應該寫單元測試，和模組簡單或複雜<strong>沒有任何關係</strong>。</li></ol></blockquote><p>第一個理由無疑是我們<strong>最常聽到</strong>的說法，但我們都知道，它往往只是一個<strong>藉口</strong>——就算真的有時間，說這種話的人也不會寫測試的啦！</p><p>拋開這些<strong>似是而非</strong>，各種不寫測試的<strong>牽強</strong>藉口，作者提出了 5 個，寫單元測試前值得先有的<strong>重要理解</strong>。</p><p>接下來，讓我們一一說明。</p><hr><h2 id="一、寫單元測試不是浪費時間"><a href="#一、寫單元測試不是浪費時間" class="headerlink" title="一、寫單元測試不是浪費時間"></a>一、寫單元測試不是浪費時間</h2><p>寫單元測試可以節約你「<strong>整體</strong>」的開發時間。這個說法，我相信大部分的人應該都能夠接受——無論有沒有寫過測試。</p><p>那具體節約了哪些時間呢？主要有兩種：</p><ol><li>專案更新功能後，舊的程式碼被新功能邏輯影響而產生 bug，為了 debug 所耗費的時間！</li><li>重構所需要的時間。</li></ol><p>第一種情況，可謂<strong>天天都在發生——加了新東西，怎麼舊的就壞了！</strong></p><p>不少人計算自己開發時間的方式，是只算「自己寫程式、 完成新功能」的時間，至於後續的 debug（更別說自己寫的爛扣<strong>造成後續無數次 debug 的時間</strong>），這些都不算！</p><h3 id="QA-的日常"><a href="#QA-的日常" class="headerlink" title="QA 的日常"></a>QA 的日常</h3><p>你可能聽過下列對白：</p><blockquote><p>RD：「新功能我做完了，你測試一下吧！」</p></blockquote><blockquote><p>QA：「（經過一番測試）這 API 回傳不太對耶？還有這個參數好像少了一個？」</p></blockquote><blockquote><p>RD：「怎麼可能？」</p></blockquote><p>好一句「<strong>怎麼可能</strong>」。</p><p>此時，QA 心中想的應不是「測一下」，而是「測幹譙（台語）」。</p><p>作者相信，你因為沒寫單元測試而<strong>耗費去處理後續問題</strong>的時間，絕對<strong>遠遠超過</strong>你寫單元測試的時間——我完全認同。這也許是「<a href="https://init.engineer/cards/show/7234">扁鵲梗：軟體工程師版</a>」可以得到大量共鳴的原因。</p><p>當然，我也理解，寫單元測試通常不算是一件很有趣的事。但話說回來，當「有趣」和「重要」不可兼得的時候，我們也只能選擇後者。</p><p>誰叫我們是<strong>稱職的</strong>軟體工程師呢？</p><h3 id="重構的勇氣"><a href="#重構的勇氣" class="headerlink" title="重構的勇氣"></a>重構的勇氣</h3><p>有單元測試第二個重大好處，就是它給你重構的勇氣。</p><blockquote><p>假設你要對某個模組做大規模的重構，那麼，這個模組是否有單元測試，對應的重構難度天差地別。對於沒有任何單元測試的模組來說，重構是<strong>地獄難度</strong>。</p></blockquote><blockquote><p>在這種環境下，每當你調整任何程式，都必須仔細找到模組的每一個被引用處，小心翼翼地手動測試每一個場景。稍有不慎，重構就會引入新 bug，好心辦壞事。</p></blockquote><p>簡言之，對於複雜模組的重構，<strong>沒有單元測試是不可能的</strong>，這已經不是「有沒有時間」的問題了。</p><hr><h2 id="二、不要總想著「補」測試"><a href="#二、不要總想著「補」測試" class="headerlink" title="二、不要總想著「補」測試"></a>二、不要總想著「補」測試</h2><blockquote><p>「先幫我 review 下剛提交的這個 PR，功能已經全實現好了。單元測試我等等補上來！」</p></blockquote><p>這樣說法的背後，透露著一種思維：單元測試是「<strong>多</strong>」的，完全是「<strong>附屬</strong>」地位。所以可以事後再「<strong>補</strong>」。</p><blockquote><p>單元測試被當成了一種驗證正確性的<strong>事後工具</strong>，對開發功能程式<strong>沒有任何影響</strong>，因此，人們總是可以在完成開發後再補上測試。</p></blockquote><p>但作者不這麼看：</p><blockquote><p>但事實是，單元測試不光能驗證程式的正確性，<strong>還能極大地幫助你改進程式設計</strong>。但這種幫助有一個前提，那就是你必須在寫程式的<strong>同時</strong>寫單元測試。</p></blockquote><blockquote><p>當開發功能與寫測試同步進行時，你會來<strong>回切換自己的角色</strong>，分別作為程式的設計者和<strong>使用者</strong>，不斷從程式裡找出問題，調整設計。經過多次調整與打磨後，你的程式會變得更好、更具擴展性。</p></blockquote><p>好吧！我承認，我自己也沒有很好地做到這點。</p><p>雖然很少提出要「補」測試，但我的開發還是處於「先寫功能再寫測試」的傳統習慣——尤其是專案的早期，API 還沒有完全底定的時候。</p><p>但我也相信，帶著「<strong>測試思維</strong>」來寫程式，絕對能夠讓程式碼的品質更上一階，這點我並不懷疑。</p><p>而要帶著測試思維寫程式，最簡單的方法，就是<strong>一邊寫程式一邊寫測試</strong>！</p><h3 id="我應該用-TDD-嗎？"><a href="#我應該用-TDD-嗎？" class="headerlink" title="我應該用 TDD 嗎？"></a>我應該用 TDD 嗎？</h3><p>說到這裡，你應該很容易聯想到 <a href="https://zh.wikipedia.org/zh-tw/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">TDD</a>。</p><p>本書第 412 頁，作者寫了一個小專欄，專門討論他對 TDD 的看法。一言以蔽之就是：不一定要完全按照 TDD 的流程寫程式，但 TDD 的思維與習慣，值得你培養！</p><p>有興趣的讀者，可以自行參考書中內容。</p><hr><h2 id="三、難測試的程式就是爛程式"><a href="#三、難測試的程式就是爛程式" class="headerlink" title="三、難測試的程式就是爛程式"></a>三、難測試的程式就是爛程式</h2><p>如果你認同了前述「一、二」的核心看法，那這個道理應該是自然而然的。</p><p>那些<strong>難寫測試</strong>的程式，<strong>本身很可能就有問題</strong>！我們看書中的一個例子：</p><blockquote><p>當模組相依了一個全域物件時，寫單元測試就會變得很難。全域物件的基本特徵決定了它在記憶體中永遠只會存在一份。而在寫單元測試時，為了驗證程式在不同場景下的行為，我們需要用到多份不同的全域物件。這時，<strong>全域物件的唯一性就會成為寫測試最大的阻礙。</strong></p></blockquote><p>這類的例子真的多不勝數。大部分的時候，我們遇到這類情況，往往就是去「更改測試的邏輯」讓測試變得「<strong>剛好能夠通過</strong>」。</p><p>而帶來的結果往往是，測試的<strong>有效性降低</strong>！因為這個<strong>測試邏輯與方法</strong>和被測試的程式碼已經<strong>太過耦合</strong>了，可說是為了它「<strong>量身訂做</strong>」的測試。</p><p>如此一來，只要未來程式碼稍有變動，該測試也很可能就過不了。</p><p>現在我們知道，有時候不妨多想一下：「為什麼這麼難測試？」，並試著去重構原來的程式碼——而不是顧著修改測試函式本身。</p><blockquote><p>因此，每當你發現很難為程式寫測試時，就應該意識到<strong>程式設計可能存在問題，需要努力調整設計，讓程式變得更容易測試。</strong></p></blockquote><hr><h2 id="四、像應用程式一樣對待測試程式"><a href="#四、像應用程式一樣對待測試程式" class="headerlink" title="四、像應用程式一樣對待測試程式"></a>四、像應用程式一樣對待測試程式</h2><p>即使有在寫測試，這些測試程式碼，往往也被當作「<strong>二等公民</strong>」對待。</p><p>書中舉出了，把測試視為二等公民，因而「另眼看待（看輕）」它們的三個<strong>特徵</strong>：</p><ol><li>很能夠容忍測試程式碼<strong>大量重複</strong>。</li><li>很能夠容忍測試程式<strong>執行上的「不效率」</strong>。</li><li><strong>鮮少重構</strong>測試程式碼。</li></ol><p>其中潛藏並透露出的心態，用一句話來講就是：「測試的程式碼終究只是一個<strong>附屬品</strong>，<strong>差不多</strong>就好了，不要要求太多！」</p><p>作者當然不認同這樣的心態，並建議你：</p><blockquote><p>像應用程式一樣對待測試程式。</p></blockquote><p>和前述第二點一樣，我肯定認同這樣的看法，雖然還無法做到 100 分。</p><p>不過 80 分絕對是有的！</p><p>所以我在 code review 時，對於 <a href="https://docs.pytest.org/en/6.2.x/fixture.html">pytest 的 fixture</a> 設計，以及 fixtures 在測試函式中的引入與使用方式，會非常仔細審查。</p><p><strong>你知道，測試寫的爛，也是一種「業障」。</strong></p><p>總之，千萬別小看了測試程式碼。</p><hr><h2 id="五、避免教條主義"><a href="#五、避免教條主義" class="headerlink" title="五、避免教條主義"></a>五、避免教條主義</h2><p>我個人覺得這段非常非常精彩，哈哈哈！</p><blockquote><p>說起來很奇怪，在單元測試領域<strong>有非常多的理論與說法</strong>。人們總是<strong>樂於</strong>發表種對單元測試的見解，在文章、演講以及與同事的交談中，你常常能聽到這些話：</p></blockquote><ul><li>「只有 TDD 才是寫單元測試的正確方式，其他都不行！」</li><li>「TDD 已死，測試萬歲！」</li><li>「單元測試應該純粹，任何相依都應該被 mock 掉！」</li><li>「mock 是一種垃圾技術，mock 越多，表示程式越爛！」</li><li>「只有專案測試覆蓋率達到 100%，才算是合格！」</li><li>……</li></ul><p>看到書中的這段，我真的會笑死XDDD——因為<strong>這個「怪現象」竟是如此的真實</strong>。</p><p>哪怕還沒有開始寫測試之前，我就已經看過不少這類言論。說真的，這些言論——或者說「<strong>信仰</strong>」——恐怕或多或少<strong>增加</strong>了想要入門測試的人，在<strong>心理上的門檻</strong>。</p><p>好像你不把測試做到 100 分、盡善盡美，就乾脆不要寫測試了——我覺得這不是一種健康的姿態。</p><p>針對這現象，作者認為：</p><blockquote><p>這些觀點各自都有許多狂熱的追隨者，但我有個建議：你應該了解這些理論，越多越好，但是千萬不要陷入教條主義。</p></blockquote><blockquote><p>因為在現實世界裡，每個人參與的專案千差萬別，別人的理論不一定適用於你，如果盲目遵從，反而會給自己增加麻煩。</p></blockquote><h3 id="不必要的心理負擔"><a href="#不必要的心理負擔" class="headerlink" title="不必要的心理負擔"></a>不必要的心理負擔</h3><p>而我覺得，認知並了解到這個現象的存在，主要是為了「<strong>降低不必要的心理負擔</strong>」，進而認真看待自己已經寫好的測試，並對此感到<strong>欣慰</strong>。（但不自滿）</p><p>這很重要。</p><p>以我自己為例，目前工作上專案的測試覆蓋率大概在 60-75% 之間。而我清楚，想要從 75% 繼續再往上提升的話，必須要做很多「<strong>細節</strong>」工作。</p><p>比如為每一個自定義的 API 錯誤寫測試，確認錯誤訊息符合期待。（我們會適時地寫這些測試，但不是每一個都如此）</p><p>其中的投入與產出，不僅<strong>不成比例（投入多、效益有限）</strong>，而且還可能造成開發者<strong>對於「寫單元測試」這件事感到厭煩。</strong></p><p>所以並沒有嚴格要求覆蓋率要達到 100%——我想這也不太現實。</p><p>然而，每次看到文章或教學中的「100% 主義」，我還是多少會擔心：「難道我們做的真的還不夠好嗎？」——現在看來，大可不必。</p><blockquote><p>單元測試領域的理論確實很多，這剛好<strong>說明了一件事，那就是要做好單元測試真的很難</strong>。要更好地實踐單元測試，你要做的第一件事就是<strong>拋棄教條主義，腳踏實地，不斷尋求最合適當前專案的測試方案</strong>，這樣才能最大地享受單元測試的好處。</p></blockquote><hr><p>但我還是不禁好奇！為什麼「測試」這領域，就是有這麼多<strong>狂熱信徒</strong>？</p><p>這個議題，我們直接看看 ChatGPT 怎麼說吧！</p><h2 id="狂熱信徒與他們的產地"><a href="#狂熱信徒與他們的產地" class="headerlink" title="狂熱信徒與他們的產地"></a>狂熱信徒與他們的產地</h2><p>以下內容整理自 ChatGPT（我劃了一些重點，以<strong>粗體字</strong>表示），我覺得分析得挺不錯，供有興趣的讀者參考。</p><p>這問題真是直擊核心，「測試」領域確實滋生了許多信仰狂熱者，原因有幾個方面：</p><ol><li><strong>人性的追尋絕對</strong>：在軟體開發這樣一個充滿不確定性的領域裡，人們往往尋求某種「萬靈丹」，希望找到一個可以解決所有問題的方法。<strong>當他們相信某種測試方法論能帶來開發上的救贖時</strong>，就很容易變成信仰狂熱者。</li><li><strong>成功案例的誤導</strong>：經常有人會分享他們使用特定測試方法論取得成功的案例，<strong>但很少有人會分享失敗的經驗</strong>。這種片面的資訊會誤導人們認為某種方法是萬能的，從而盲目追隨。</li><li><strong>社群與身分認同</strong>：一旦某人投入到特定的測試方法論中，<strong>他們很可能會加入相關的社群。在這樣的社群裡，方法論被當作教條</strong>，社群成員的身分認同也與這些信仰緊密相連。為了保護自己的身分認同，人們往往會變得更加狂熱。</li><li><strong>技術宗教戰爭的延伸</strong>：軟體開發領域充斥著各種技術宗教戰爭，無論是程式語言、開發框架，還是測試方法論。<strong>這些戰爭反映了人們對自我選擇的辯護</strong>，以及對他人選擇的攻擊。</li><li><strong>缺乏批判性思考</strong>：最後，也是最讓人頭疼的原因之一。很多人接受新的方法論時，缺乏批判性思考。他們不去評估這些方法論是否適合自己的專案，不考慮成本和收益，也不尋找可能的替代方案。</li></ol><p>這些原因綜合在一起，就創造了一個完美的環境，讓「測試」領域裡的信仰狂熱者茁壯成長。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/beoEztr.png&quot; alt=&quot;Python 工匠&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263245174&quot;&gt;Python 工匠｜案例、技巧與開發實戰&lt;/a&gt;》筆記的第 2 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;如第一篇所言，這是一本關於「Clean Code in Python」的書。&lt;/p&gt;
&lt;p&gt;這二篇，我將整理書中第 13 章「&lt;strong&gt;有關單元測試的建議&lt;/strong&gt;」的內容（以及我的看法）。我覺得真的寫得太好了，值得你了解。&lt;/p&gt;
&lt;p&gt;話不多說，直接開始。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/beoEztr.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="閱讀筆記" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
    <category term="系列：Python 工匠" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%B7%A5%E5%8C%A0/"/>
    
  </entry>
  
  <entry>
    <title>《人生 4 千個禮拜》筆記（二）抗拒「重要性中等」的誘惑</title>
    <link href="https://blog.kyomind.tw/four-thousand-weeks-02/"/>
    <id>https://blog.kyomind.tw/four-thousand-weeks-02/</id>
    <published>2024-03-04T09:11:47.000Z</published>
    <updated>2024-03-07T05:30:21.096Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/UNr2AmS.png" alt="人生 4 千個禮拜"><span class="cap">人生 4 千個禮拜</span></p><p>這是《<a href="https://www.books.com.tw/products/0010914255">人生 4 千個禮拜</a>》筆記的第 2 篇，你可以把它當作是一則重點整理，加上<strong>大量我個人的經驗與想法</strong>。</p><p>上一篇我們提到，「生產力」一詞在這個時代是如何地被重視——甚至有點扭曲。</p><p>以及如果你試圖用各種方法（尤其是那些筆記軟體與提升效率的工具）來增加生產力，反而很可能會掉入所謂的「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1">效率陷阱</a>」。</p><p>如果你也認同「<strong>過度追求效率很可能適得其反</strong>」這個命題，那很慶幸，我們已經達成了<strong>最重要的共識</strong>。這也是我給這本書高評價的原因。</p><span id="more"></span><h3 id="系列：人生-4-千個禮拜"><a href="#系列：人生-4-千個禮拜" class="headerlink" title="系列：人生 4 千個禮拜"></a>系列：人生 4 千個禮拜</h3><blockquote><ol><li><a href="/four-thousand-weeks-01/">《人生 4 千個禮拜》筆記（一）病態的生產力</a></li><li><strong>《人生 4 千個禮拜》筆記（二）抗拒「重要性中等」的誘惑</strong></li></ol></blockquote><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>如第一篇所言，本書可以認為是作者「<strong>對自己與『提高生產力』這個議題的重新觀察、自我反省</strong>」。</p><p>我希望這不是一篇普通的閱讀筆記或導讀，而是要強調我對本書<strong>最認同、最在乎</strong>的部分——我是如何在書中<strong>看到過去的自己。</strong>當然，這肯定包含了<strong>我自己的解讀</strong>。</p><p>因此，這篇文章，我想要<strong>繼續對作者追問</strong>：</p><blockquote><p>好，我現在知道過度追求生產力的可能代價了，那要<strong>怎麼想、怎麼做會更好？</strong></p></blockquote><p>本文整理自書中的第 3 到 4 章。</p><hr><h2 id="面對有限性"><a href="#面對有限性" class="headerlink" title="面對有限性"></a>面對有限性</h2><p>本書第 3 章的標題為「面對有限性」。</p><p>我知道，你可能會想：「噢！又來了！」然後皺起眉頭。心裡想到的是，在無數的書籍或文章中，那些提醒你要「<strong>珍惜現在、直面生命的有限</strong>」的雞湯內容。</p><p>好吧，至少我就是這樣覺得，覺得這個標題也未免太老生常談了！</p><p>但本文還是整理了其中的一段，因為我需要它，為接下來的內容作鋪墊。一言以蔽之，本章的重點就是：</p><blockquote><p>因為人生有限，你必須做出<strong>選擇</strong>。<strong>不能想要這個，又想要那個。</strong></p></blockquote><p>在這個前提下，作者是這麼說的：</p><blockquote><p>做選擇（從當前的選項中挑一個）成為一種<strong>肯定</strong>，根本算不上挫敗。這是一種<strong>正面的投入</strong>，你決定要用某段時間做這件事、<strong>不做那件事（不只一件，而是不計其數的其他事情）</strong>，因為你判定這件事是目前<strong>最重要</strong>的一件。</p></blockquote><p>請記得「最重要」三個字。</p><hr><h2 id="忽視應該忽視的事物"><a href="#忽視應該忽視的事物" class="headerlink" title="忽視應該忽視的事物"></a>忽視應該忽視的事物</h2><p>覺得自己事情太多，老是做不完，需要加強時間管理，或學習特定的生產力工具來提高產出嗎？先等等！看看作者怎麼說。</p><p>關於「時間管理」，到底怎麼做才稱得上「<strong>有效</strong>」，作者提出了一個有趣且令人信服的切入點：</p><blockquote><p>不論是哪一種間管理技巧，<strong>真正的有效評估指標</strong>是那項技巧<strong>是否協助你忽視應該忽視的事物。</strong></p></blockquote><p>我非常喜歡這個切入點。</p><blockquote><p>因此，重點不是根治拖延症，而是<strong>以更明智的方式選擇要延後哪些事，專注於眼前最重要的事。</strong></p></blockquote><p>當然，這樣的看法並不算新穎。但是，能夠把「<strong>有效忽略不夠重要事物</strong>」這個指標提升到時間管理方法論的「<strong>首要</strong>」考慮事項，我個人十分贊同。</p><hr><p>接下來的內容，會結合我個人的經驗、想法。</p><h2 id="生產力-KOL-們的承諾"><a href="#生產力-KOL-們的承諾" class="headerlink" title="生產力 KOL 們的承諾"></a>生產力 KOL 們的承諾</h2><p>還是要再提到「<a href="https://blog.kyomind.tw/less-is-more/#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D">人生管理系統</a>」，不過這次我們不需要了解其中的細節。</p><p>這種承諾你可以完成很多事的「生產力方法論」，也就是上述的「系統」，無疑是現代「生產力至上」這類價值觀的<strong>縮影</strong>。</p><p>你說它不好嗎？可能也不盡然。我相信這類「系統」確實可能讓你做完更多事情——但也僅止於此。</p><h3 id="美好的承諾"><a href="#美好的承諾" class="headerlink" title="美好的承諾"></a>美好的承諾</h3><p>這類系統與其背後的價值觀，可大致濃縮為：</p><blockquote><p>用厲害的方法，做完很多事。</p></blockquote><p>而推廣這類方法論的生產力 KOL 們，會不斷明示、暗示你：「一旦擁有<strong>能做完很多事的能力</strong>，你會從瞎忙中脫解，<strong>你的人生將從此不同</strong>。」</p><p>其實這樣的論述和更早開始流行的「時間管理」一樣，都是給你一個<strong>美好的承諾</strong>。</p><p>其中的<strong>差別</strong>或許是，他們更加強調「<strong>工具</strong>」的重要性——並提供一整套有關<strong>「如何善用工具」</strong>的<strong>學習方案</strong>。（可能是文章、書籍、影片、課程、社群，可能是免費或付費）</p><p>上述「多多益善」命題是否為真、是否有效，可以先不論。這裡想從另一個角度切入，說說我認為<strong>更值得推崇的看法。</strong></p><hr><h2 id="我認為「更好更有效」的做法"><a href="#我認為「更好更有效」的做法" class="headerlink" title="我認為「更好更有效」的做法"></a>我認為「更好更有效」的做法</h2><p>我的核心看法很簡單：<strong>放下「想做完很多事」的渴望</strong>。接受書中的核心觀點，理解人生有限，並做出取捨。<strong>然後專注於那些「最要緊」的事就好。</strong></p><p>必須強調，捨棄一部分重要的事情，<strong>這個過程可能會讓人很不舒服。</strong>如果你沒有這樣的感受，那可能是因為<strong>你還沒有真正做出取捨。</strong></p><p>對此，我要更進一步闡明：</p><blockquote><p><strong>我不認為「能做完很多事」的能力，能夠改變你的人生</strong>。相反的，能做出<strong>取捨</strong>，<strong>專注於關鍵事物</strong>的人，更有機會變得不同。</p></blockquote><p>換句話說，<strong>我認為「取捨」——與取捨後的「專注」——才是最重要的能力</strong>，而不是靠工具、系統、時間管理，試圖去完成更多事情。</p><p>而所謂<strong>取捨的能力</strong>，講白了，就是本段標題說的，「<strong>忽視應該忽視的事物</strong>」的能力。</p><h2 id="小而美的「局部實現」"><a href="#小而美的「局部實現」" class="headerlink" title="小而美的「局部實現」"></a>小而美的「局部實現」</h2><p>「忽視應該忽視的事物」的能力，究竟要<strong>如何培養</strong>？老實說，我自己也還在摸索、思考與歸納的路上。</p><p>我感覺自己還不是一個，能夠果斷取捨然後篤定前行的人——我總是太 FOMO。</p><p>不過，《<a href="https://blog.kyomind.tw/less-is-more/">為什麼你「不需要」所謂的人生管理系統</a>》中關於「<a href="https://blog.kyomind.tw/less-is-more/#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE">局部實現</a>」的闡述，仍然值得我們參考：</p><blockquote><p>局部實現，是一種<strong>心法或價值觀</strong>，說穿了沒什麼，就是「<strong>緊扣著需求尋找並選定方法，需要多少才投入多少</strong>」。</p></blockquote><p>想做多少再投入多少，確保自己做的事，都是真正重要的。這樣的思考與價值觀，或許更加簡潔、有力。</p><p>相信本書作者，也會認同這樣的觀點。</p><hr><h2 id="抗拒重要性中等的誘惑"><a href="#抗拒重要性中等的誘惑" class="headerlink" title="抗拒重要性中等的誘惑"></a>抗拒重要性中等的誘惑</h2><p>書中舉了一個例子（作者說，話是誰講的並不重要XD）來表達，為了真正做到取捨，你應該怎麼看待，那些「<strong>重要但不是最重要</strong>」的事情。</p><blockquote><p>據說這是股神巴菲特（Warren Buffett）的故事，反正有一次，巴菲特的私人駕駛請教他，怎樣才能排定優先順序。</p></blockquote><blockquote><p>他要駕駛找出人生最重要的二十五件事，接著依序排列，從最重要的排到最不重要的。巴菲特說，在規畫時間時，應該安排好單子上的前五名。</p></blockquote><blockquote><p>至於剩下的二十件事，和駕駛以為會聽到的建議不一樣。據說巴菲特解釋，那二十件事<strong>不是重要性居次、有機會就去做的事。</strong></p></blockquote><p>錯，錯，錯！</p><blockquote><p><strong>事實上，駕駛應該不惜一切代價，努力避免去做那二十件事</strong>，因為對那名駕駛而言，<strong>那二十個目標沒有重要到構成人生的核心，吸引力卻大到足以讓他分心，以至於沒去做最重要的事。</strong></p></blockquote><p>「沒有重要到構成人生的核心，吸引力卻大到足以讓他分心」，這真的是血淋淋的教訓！而且我相信，不論任何人，都一定能夠想起，自己曾經做過了多少這樣的事情。</p><hr><h2 id="放下妄念，減少分心"><a href="#放下妄念，減少分心" class="headerlink" title="放下妄念，減少分心"></a>放下妄念，減少分心</h2><p>當然，人生畢竟不是理論，縱使扣除休息與休閒，當我們想要「有所作為」的時候，也不可能真的只做最重要的五件事——太難了！</p><p>但是，至少每隔一段時間自我檢視、反省一次：「我是不是又把時間花在『<strong>重要但不是最重要</strong>』的事情上了？」，肯定會很有收獲。</p><p>但我還是想再次提醒你——也提醒自己。想要真心誠意，盡可能緊扣著「最重要」的事努力實踐。就要<strong>一定程度放下「我要做很多事」的渴望。</strong></p><blockquote><p><strong>也就是抗拒「重要性中等」的誘惑。</strong></p></blockquote><p>這並不容易！如前所述，<strong>真正的取捨是個讓人「不太舒服」的過程。</strong></p><p>因此，我能斗膽斷言：深信自己「可以透過學習工具、方法論，<strong>完成大量重要事情</strong>」的人，99% 都是要落空的。</p><h3 id="三種枉然"><a href="#三種枉然" class="headerlink" title="三種枉然"></a>三種枉然</h3><p>不過落空的結局有<strong>三個截然不同的版本</strong>：</p><ol><li>工具、方法的學習與維護成本太高，難以維持，<strong>最後放棄了！</strong>說真的，這是<strong>相對幸運</strong>的結局——因為你<strong>省下了時間</strong>，可以重新開始。</li><li>真的做了很多事，但同時也<strong>包含了一堆不夠重要的事</strong>——就像本書說的一樣。這就比較慘了，有句話說得好：「<strong>兢兢業業地把時間浪費了</strong>」。</li><li>真的做了很多事，但<strong>關鍵成效都不怎麼樣（很可能「瑣事」部分做得特別好）</strong>。正所謂「<strong>貪多嚼不爛</strong>」——尤其是最難啃的部分，哪怕你有神兵利器。</li></ol><p>上面提到的數字是 99% 而不是 100，看樣子，我還是相信有 1% 的人會成功？</p><p>是的！我確實相信，有極少數人能夠做到。但我奉勸你不要追求，企圖成為這鳳毛麟角的 1%——因為真的沒有必要。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UNr2AmS.png&quot; alt=&quot;人生 4 千個禮拜&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.books.com.tw/products/0010914255&quot;&gt;人生 4 千個禮拜&lt;/a&gt;》筆記的第 2 篇，你可以把它當作是一則重點整理，加上&lt;strong&gt;大量我個人的經驗與想法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上一篇我們提到，「生產力」一詞在這個時代是如何地被重視——甚至有點扭曲。&lt;/p&gt;
&lt;p&gt;以及如果你試圖用各種方法（尤其是那些筆記軟體與提升效率的工具）來增加生產力，反而很可能會掉入所謂的「&lt;a href=&quot;https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1&quot;&gt;效率陷阱&lt;/a&gt;」。&lt;/p&gt;
&lt;p&gt;如果你也認同「&lt;strong&gt;過度追求效率很可能適得其反&lt;/strong&gt;」這個命題，那很慶幸，我們已經達成了&lt;strong&gt;最重要的共識&lt;/strong&gt;。這也是我給這本書高評價的原因。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/UNr2AmS.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="閱讀筆記" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
    <category term="系列：人生 4 千個禮拜" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%BA%E7%94%9F-4-%E5%8D%83%E5%80%8B%E7%A6%AE%E6%8B%9C/"/>
    
  </entry>
  
  <entry>
    <title>《Python 工匠》筆記（一）如何寫好註解</title>
    <link href="https://blog.kyomind.tw/python-craftsman-01/"/>
    <id>https://blog.kyomind.tw/python-craftsman-01/</id>
    <published>2024-02-28T04:40:57.000Z</published>
    <updated>2024-03-17T03:56:23.582Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/beoEztr.png" alt="Python 工匠"><span class="cap">Python 工匠</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9786263245174">Python 工匠｜案例、技巧與開發實戰</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><p>從書名推敲，我們並不容易知道本書的主題為何。事實上，和《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣</a>》類似，這是一本關於「<strong>Clean Code in Python</strong>」的書。</p><p>而且我認為它的<strong>難度適中</strong>（好吧，後半部難度比較高，而且本書<strong>「不適合」</strong>初學者），非常推薦看完《Python 功力提升的樂趣》後，想要更進一步寫出 Pythonic 程式碼的讀者與開發人員。</p><p>我覺得，兩本恰恰都是屬於「從書名看很容易被忽略」的好書。因此，作為喜歡本書的讀者，我覺得自己有<strong>義務</strong>，向你們轉述書中一些值得傳誦的內容。</p><p>這也是「<a href="/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/">閱讀筆記</a>」系列的核心精神。</p><span id="more"></span><h3 id="系列：Python-工匠"><a href="#系列：Python-工匠" class="headerlink" title="系列：Python 工匠"></a>系列：Python 工匠</h3><blockquote><ol><li><strong>《Python 工匠》筆記（一）如何寫好註解</strong></li><li><a href="https://blog.kyomind.tw/python-craftsman-02/">《Python 工匠》筆記（二）對「單元測試」的看法與建議</a></li></ol></blockquote><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E5%A6%82%E4%BD%95%E5%AF%AB%E5%A5%BD-Python-%E8%A8%BB%E8%A7%A3">如何寫好 Python 註解</a></li><li><a href="#Python-%E8%A8%BB%E8%A7%A3%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98">Python 註解基礎知識</a></li><li><a href="#%E6%96%B0%E6%89%8B%E5%B8%B8%E7%8A%AF%E7%9A%84%E4%B8%89%E7%A8%AE%E8%A8%BB%E8%A7%A3%E9%8C%AF%E8%AA%A4">新手常犯的三種註解錯誤</a></li><li><a href="#%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E8%A8%BB%E8%A7%A3%E7%A8%8B%E5%BC%8F%E7%A2%BC">一、直接註解程式碼</a></li><li><a href="#%E4%BA%8C%E3%80%81%E5%83%85%E7%94%A8%E8%A8%BB%E8%A7%A3%E3%80%8C%E9%87%8D%E8%BF%B0%E3%80%8D%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A1%8C%E7%82%BA">二、僅用註解「重述」程式碼行為</a></li><li><a href="#%E6%8C%87%E5%BC%95%E5%9E%8B%E8%A8%BB%E8%A7%A3">指引型註解</a></li><li><a href="#%E6%8F%90%E7%85%89%E7%82%BA%E7%8D%A8%E7%AB%8B%E5%87%BD%E5%BC%8F">提煉為獨立函式</a></li><li><a href="#%E4%B8%89%E3%80%81%E5%BC%84%E9%8C%AF%E8%A8%BB%E8%A7%A3%E7%9A%84%E3%80%8C%E5%8F%97%E7%9C%BE%E3%80%8D">三、弄錯註解的「受眾」</a></li><li><a href="#%E8%87%AA%E8%A8%80%E8%87%AA%E8%AA%9E%E7%9A%84%E8%A8%BB%E8%A7%A3">自言自語的註解</a></li><li><a href="#Docstring-%E8%88%87%E8%AE%80%E8%80%85%E6%84%8F%E8%AD%98">Docstring 與讀者意識</a></li><li><a href="#%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E8%A8%BB%E8%A7%A3%EF%BC%9F">好的程式碼到底需不需要註解？</a></li><li><a href="#%E4%BD%9C%E8%80%85%E7%9A%84%E8%A7%80%E9%BB%9E%E8%88%87%E6%88%91%E7%9A%84%E7%9C%8B%E6%B3%95">作者的觀點與我的看法</a></li></ol><hr><h2 id="如何寫好-Python-註解"><a href="#如何寫好-Python-註解" class="headerlink" title="如何寫好 Python 註解"></a>如何寫好 Python 註解</h2><p>本文整理第一章的其中一部分——關於「如何寫好註解」的討論。</p><p>之所以要特別寫成筆記，是因為這是我目前看過的書中，討論註解時講最得好的一本。尤其是一些使用上的建議，和我的開發經驗與價值觀可謂非常吻合！</p><p>本書作者朱雷（<a href="https://github.com/piglei">piglei</a>），擁有超過 10 年的 Python 開發經驗，精通 Python 語言特性，對如何開發高品質的大型 Python 專案有獨到見解。</p><p>其實我一直也想整理一篇關於寫好註解的基本守則，但遲遲沒有行動。但現在有這本書，我只要整理書中的內容，並加上自己的看法即可。</p><p>有關 Python 註解或 docstring 的討論，我在過去多篇文章中都有提到，可參考如下：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-03/#%E4%B8%80%E3%80%81Docstring-%E7%9C%9F%E7%9A%84%E5%BE%88%E9%87%8D%E8%A6%81">Docstring 真的很重要</a></li><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E8%A8%BB%E8%A7%A3%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%EF%BC%9F">註解是不需要的？</a></li><li><a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a></li></ul><p>開始正文。</p><hr><h2 id="Python-註解基礎知識"><a href="#Python-註解基礎知識" class="headerlink" title="Python 註解基礎知識"></a>Python 註解基礎知識</h2><p>Python 中，一般我們講到註解，指的是程式碼中的註解，用<code>#</code>來實現。</p><p>而 <a href="https://en.wikipedia.org/wiki/Docstring">docstring</a> 則是另一種更具有 Python 特色的註解。主要寫在模組、類別、與函式的開頭，並透過物件的<code>__doc__</code>屬性，自然地化為程式碼的一部分。</p><p>書中提到了 docstring 的幾種常見風格（畢竟它本質只是一堆字串，所以怎麼寫都行），最常見的為 Sphinx 文件風格。而我個人在工作上最常用的，則是 <a href="https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html">Google 風格</a>。</p><p>簡言之，下面提到「註解」二字時，對上述兩種 Python 註解都適用。</p><h2 id="新手常犯的三種註解錯誤"><a href="#新手常犯的三種註解錯誤" class="headerlink" title="新手常犯的三種註解錯誤"></a>新手常犯的三種註解錯誤</h2><p>你可能聽過「很多註解都是爛註解」這種說法。不得不承認，這相當程度是對的！我確實看過很多爛註解——但這不是我們因此不寫註解的理由。</p><p>實務上會有很多爛註解，正是因為我們沒有正視註解的價值，認真學習如何寫好註解。</p><p>因此，<strong>就讓我們用書中所舉三種常見的註解錯誤，作為學習的切入點。</strong></p><p>書中提到的這三點——尤其是第 3 點，應盡可能避免。作者也提出了相應的解決之道，而我會適時補充我的看法。</p><p>附帶一提，本書是從作者過去的網路文章整理、出版——但內容增加了很多。而且作者也很大方，在網路上公開了部分的內容。而本文整理的部分恰恰是公開的部分。有興趣的話可以直接參考<a href="https://www.piglei.com/book/ch01_variables.html">本頁</a>。</p><p>當然，我還是強烈建議，為自己入手一本，你絕對不會後悔。</p><hr><h2 id="一、直接註解程式碼"><a href="#一、直接註解程式碼" class="headerlink" title="一、直接註解程式碼"></a>一、直接註解程式碼</h2><p>把已經寫完但暫不需要（以後是否需要還不確定）的程式碼，先註解起來，方便日後需要時可以快速「還原」，絕對是我們非常熟悉的手段。</p><p>我回想一下，不得不說，這類被註解的程式碼，<strong>十之八九都是不會再用到了！</strong>如果這類「程式碼註解」愈積愈多，真的會讓人看了很「阿雜」！</p><p>所以基本上，現在比較正規的做法，都是建議你直接刪除，以後真的需要時，再透過版控回復即可。</p><p>對此我基本認同，所以工作上 code review 時，我「不會」放行這種直接註解的程式碼。</p><h3 id="僅有的例外"><a href="#僅有的例外" class="headerlink" title="僅有的例外"></a>僅有的例外</h3><p>但，你我都知道，有時事情也沒那麼簡單。</p><p>用 Git 版控回復的前提是：你的團隊 commit 記錄要寫好！不然真的要「回復」的時候，你可能連它在哪一個 commit 都要找好一陣子。</p><p>所以，基於方便與實際考量，事實上我還是有<strong>一點點折衷</strong>：原則上不可以註解程式碼，但如果確定只是「<strong>暫時</strong>」用不到，等別的元件完成後，就會繼續開發、使用，例外可以暫時註解就好——但必須加上 <a href="https://peps.python.org/pep-0350/">codetag</a> 標記。</p><p>一般我們用 <code>TODO</code> 這個 codetag。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO 日後改回一對一時，請用下面方式重寫：</span></span><br><span class="line"><span class="comment"># user = User.objects.select_related(&#x27;oversee_tenant&#x27;)</span></span><br><span class="line"><span class="comment"># .prefetch_related(&#x27;oversee_projects&#x27;).get(user_uuid=user_uuid)</span></span><br></pre></td></tr></table></figure><p>不過<strong>大原則</strong>還是：</p><blockquote><p><strong>別註解了，刪除吧！</strong></p></blockquote><hr><h2 id="二、僅用註解「重述」程式碼行為"><a href="#二、僅用註解「重述」程式碼行為" class="headerlink" title="二、僅用註解「重述」程式碼行為"></a>二、僅用註解「重述」程式碼行為</h2><p>這應該是我們最常看到的爛註解的形式，也是你在所有討論程式碼註解的書中，一定會提及的。</p><p>而且它真的爛，沒有藉口。比如這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 x 為 0</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 x 是否小於 10</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="comment"># 印出 x 小於 10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is less than 10&quot;</span>)</span><br></pre></td></tr></table></figure><p>這當然是一個誇張的例子🤣。但在日常開發中，這種「脫褲子放屁」的註解還真的不算少見。</p><p>確實，如果我常常看到這樣的註解，恐怕真的會忍不住說出「你還別寫註解了吧！」</p><p>但，請不要放棄治療！</p><p>想避免這個問題，請遵守一個簡單且常見的大原則，如書中所言：</p><blockquote><p>應該儘量提供那些讀者<strong>無法</strong>從程式碼裡讀出來的資訊。描述程式<strong>為什麼</strong>要這麼做，而不是簡單複述程式碼本身。</p></blockquote><p>不過，光寫「為什麼」註解，有時候還是遠遠不夠的。</p><h2 id="指引型註解"><a href="#指引型註解" class="headerlink" title="指引型註解"></a>指引型註解</h2><p>因此，本書更進一步提出所謂的「<strong>指引性註解</strong>」：</p><blockquote><p>這種註解並不「直接」複述程式，而是簡明扼地概括程式碼功能，起到「<strong>程式碼導讀</strong>」的效果。</p></blockquote><p>書中的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化存取服務的 client 物件</span></span><br><span class="line">token = token_service.get_token()</span><br><span class="line">service_client = ServiceClient(token=token)</span><br><span class="line">service_client.ready()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 呼叫服務取得資料，然後進行過濾</span></span><br><span class="line">data = service_client.fetch_full_data()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> item.value &gt; SOME_VALUE:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>不難看出，這種描述「程式碼流程大綱」的指引型註解，<strong>很像 docstring 在做的事</strong>。從這個角度，我們可以說 docstring <strong>也是</strong>一種指引型註解。</p><p>但是，docstring 畢竟只出現在元件的「<strong>開頭</strong>」，對複雜的程式而言，在元件的內部，往往也需要這樣的註解，作為閱讀<strong>複雜程式碼</strong>的指引。</p><p>要寫好指引型註解，甚至知曉「什麼時候」應該要寫下指引型註解，需要你內心清楚——「這段程式碼的哪些部分，別人可能會看不懂！」</p><p>這是為什麼我總說，要寫好註解，就一定要培養好「<strong>讀者意識</strong>」的理由。</p><h3 id="指引型註解的價值"><a href="#指引型註解的價值" class="headerlink" title="指引型註解的價值"></a>指引型註解的價值</h3><p>前面提到，寫註解時「應該儘量提供那些讀者<strong>無法從程式碼裡讀出來</strong>的資訊」，這是我們寫註解的大原則。</p><p>但指引性註解和上述註解<strong>所有區別</strong>，它的<strong>獨特價值</strong>，如書中所言：</p><blockquote><p>指引性註解<strong>並不提供</strong>程式碼裡<strong>讀不到</strong>的東西——如果沒有註解，耐心讀完所有程式碼，你也能知道程式做了什麼事。指引性註解的主要作用是<strong>降低程式碼的認知成本</strong>，讓我們能<strong>更容易理解</strong>程式碼的<strong>意圖</strong>。</p></blockquote><p>說得非常好。</p><h2 id="提煉為獨立函式"><a href="#提煉為獨立函式" class="headerlink" title="提煉為獨立函式"></a>提煉為獨立函式</h2><p>對於複雜而冗長的程式流程，書寫「指引性註解」是一個協助閱讀理解的好方法。</p><p>而另一個有效的方法，就是把這些程式碼片段<strong>獨立成一個又一個的函式</strong>，透過<strong>有意義的函式名稱</strong>來描述流程、展現意圖，此時就可以刪除指引性註解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service_client = make_client()</span><br><span class="line">data = fetch_and_filter(service_client)</span><br></pre></td></tr></table></figure><p>其中的重點在於，你要能判斷，什麼時候該寫「指引性註解」，而什麼時候則適合獨立成函式、方法。</p><p>這當然需要經驗累積，但我們心中要先有這樣的意識，不是嗎？</p><hr><h2 id="三、弄錯註解的「受眾」"><a href="#三、弄錯註解的「受眾」" class="headerlink" title="三、弄錯註解的「受眾」"></a>三、弄錯註解的「受眾」</h2><p>本書這段主要適用的是 docstring，不過我覺得「指引型註解」也有類似議題，所以本段提到「註解」一詞時，皆包括這兩者。</p><p>註解的正確<strong>受眾</strong>，或說<strong>讀者</strong>，應該是誰？我想基本上是這兩種人：</p><ol><li><strong>未來</strong>的自己（注意「未來」二字）</li><li>專案<strong>協作者</strong>（同事、主管）</li></ol><p>我們先看看書中所舉的「反例」：（我直接引用<a href="https://www.piglei.com/book/ch01_variables.html">網頁</a>上的內容，所以技術名詞並非台灣用語，還請見諒）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resize_image</span>(<span class="params">image, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;將圖片縮放為指定尺寸，並返回新的圖片。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    該函數將使用 Pilot 模塊讀取文件對象，然後調用 .resize() 方法將其縮放為指定尺寸。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    但由於 Pilot 模塊自身限制，這個函數不能很好的處理尺寸過大的文件，當文件大小</span></span><br><span class="line"><span class="string">    超過 5MB 時，resize() 方法的性能就會因為內存分配問題急劇下降，詳見 Pilot 模塊的</span></span><br><span class="line"><span class="string">    Issue #007。因此，對於超過 5MB 的圖片文件，請使用 resize_big_image() 替代，後者</span></span><br><span class="line"><span class="string">    基於 Pillow 模塊開發，很好的解決了內存分配問題，性能更好。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param image: 圖片文件對象</span></span><br><span class="line"><span class="string">    :param size: 包含寬高的元組：（width, height）</span></span><br><span class="line"><span class="string">    :return: 新圖片對象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>這個例子的最大問題，是寫了太多「實作細節」，講白了就是提供了「太多」程式碼的讀者<strong>並不關心</strong>的內容！</p><blockquote><p>為什麼這樣是不妥的？細節不是很好嗎？</p></blockquote><p>對，但大部分時候，docstring 或「指引型註解」的主要寫作<strong>目的</strong>，是為了讓讀者<strong>不用一行一行閱讀程式碼</strong>，就能夠快速知道目前程式碼的<strong>流程與意圖</strong>。</p><p>這種過多細節的寫法，恰恰與這個目標<strong>背道而馳</strong>——增加了太多理解上的「<strong>雜訊</strong>」。</p><p>書中給出的改善版本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resize_image</span>(<span class="params">image, size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;將圖片縮放為指定尺寸，並返回新的圖片。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意：當文件超過 5MB 時，請使用 resize_big_image()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param image: 圖片文件對象</span></span><br><span class="line"><span class="string">    :param size: 包含寬高的元組：（width, height）</span></span><br><span class="line"><span class="string">    :return: 新圖片對象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><p>以下主要是我自己的看法。</p><h2 id="自言自語的註解"><a href="#自言自語的註解" class="headerlink" title="自言自語的註解"></a>自言自語的註解</h2><p>你有沒有一個疑問，為什麼說註解寫了太多細節，是「弄錯受眾」？</p><p>我是這樣看的：留下這麼多細節的註解，與其說是註解，更像寫給自己看的<strong>筆記</strong>——而且是給「現在」的自己，真的就像在作筆記一樣！</p><p>我想強調，<strong>「現在的自己」並不是註解的受眾！</strong>因為現在的自己對程式細節非常清楚，即使沒有註解也能讀懂程式碼。</p><p>相反的，註解是為<strong>沒時間慢慢讀程式碼</strong>的人服務的。</p><p>未來的你，再回來看這段程式，絕對不會想要在 docstring 看到這麼多「<strong>廢話</strong>」。這種寫法無疑是搞錯了對象。</p><p>當然，你的同事也不會想看這麼多雜訊——同事往往更關心「這函式到底要怎麼用」！</p><h3 id="抽象層次混亂"><a href="#抽象層次混亂" class="headerlink" title="抽象層次混亂"></a>抽象層次混亂</h3><p>我覺得還有另一種「弄錯受眾」的註解也很經典，甚至更加常見！那就是混合底層實作與業務邏輯：</p><blockquote><p>註解中參雜了業務邏輯，又不時會出現底層實作的細節描述。</p></blockquote><p>事實上，我倒覺得實務中會願意寫一大串 docstring 的人，可以說是少之又少。大部分的問題其實是：有寫，但寫得「<strong>零零落落</strong>」。</p><h2 id="Docstring-與讀者意識"><a href="#Docstring-與讀者意識" class="headerlink" title="Docstring 與讀者意識"></a>Docstring 與讀者意識</h2><p>Docstring 絕對能看出一個人的<strong>基本寫作能力</strong>，以及是否具備「<strong>讀者意識</strong>」。</p><p>說真的，這不止是作為一個軟體工程師的核心技能——更是任何<strong>表達者</strong>的核心技能。而程式，只是表達的其中一種形式。</p><p>我很想要寫一篇「如何寫好 docstring」，這需要再構思一番。但常見的錯誤不外乎：</p><ol><li><strong>預知能力</strong>：知曉「函式以外」的事、不僅知道函式會怎麼、何時被調用，還會在 docstring 中寫下呼叫時的情境細節——<strong>你知道的太多了！</strong></li><li><strong>太多底層細節</strong>：跟前面的書中內容相似，只是我覺得現實中，往往是<strong>東寫一點、西寫一點</strong>，不會像寫筆記一般完整——所以讀起來更痛苦，真的是自言自語！除了開發者自己，誰能輕易讀懂那些細節？</li><li><strong>業務邏輯與底層實作的用詞混雜</strong>：一下子是「無法取得租戶資訊」一下子卻又是「防止 SQL insert 錯誤、RabbitMQ 如何如何」——讓人大腦很混亂。</li></ol><p>總的來說，無論是「自言自語」還是「抽象層次混亂」，它們的本質都差不多——這些註解都像是寫給「<strong>現在的自己</strong>」看的<strong>筆記</strong>。</p><p>但就像前面說的，現在的自己是<strong>最不需要看註解的人</strong>！所以才說是「弄錯受眾」了。</p><hr><p>最後不免俗地，我們要討論，提到「程式碼註解」就<strong>一定避不開的問題</strong>：</p><blockquote><p><strong>到底要不要寫註解</strong>？</p></blockquote><h2 id="好的程式碼到底需不需要註解？"><a href="#好的程式碼到底需不需要註解？" class="headerlink" title="好的程式碼到底需不需要註解？"></a>好的程式碼到底需不需要註解？</h2><p>寫程式到底要不要寫註解，一直有兩派說法，是個老掉牙又爭論不休的問題。我們先來看看這兩派的觀點。（ ChatGPT 整理）</p><h3 id="寫註解的一派"><a href="#寫註解的一派" class="headerlink" title="寫註解的一派"></a>寫註解的一派</h3><p>這派人認為註解是<strong>程式碼的一部分</strong>，應該寫註解，主要論點為：</p><ol><li><strong>可讀性提升</strong>：註解能夠幫助人們<strong>更快理解程式碼的意圖和複雜的邏輯</strong>，尤其是對於那些<strong>不那麼直觀的部分</strong>。</li><li><strong>溝通工具</strong>：註解被視為開發者之間的<strong>溝通方式</strong>，尤其在團隊協作時，能夠快速傳遞開發者的想法和注意事項。</li><li><strong>提醒與說明</strong>：註解可以用來提醒未來可能的問題，或是對程式碼中的決策提供背景說明。</li></ol><h3 id="不寫註解的一派"><a href="#不寫註解的一派" class="headerlink" title="不寫註解的一派"></a>不寫註解的一派</h3><p>相對的，這派人認為好的程式碼應該是<strong>自解釋</strong>的，不需要註解，主要論點為：</p><ol><li><strong>程式碼即文件</strong>：好的程式碼應該是自解釋的，如果你需要註解來解釋你的程式碼，那麼問題可能出在程式碼本身。</li><li><strong>增加維護難度</strong>：註解需要維護，<strong>不一致的註解比沒有註解更糟</strong>，因為它會導致誤解和混淆。</li><li><strong>過度依賴註解</strong>：過多的註解可能會讓開發者過度依賴於它們來理解程式碼，忽視了提高程式碼品質的重要性。</li></ol><hr><h2 id="作者的觀點與我的看法"><a href="#作者的觀點與我的看法" class="headerlink" title="作者的觀點與我的看法"></a>作者的觀點與我的看法</h2><p>細看這兩派的主張，我們可以看出，都有一定的道理——不然也不會爭論不休了。</p><h3 id="作者觀點"><a href="#作者觀點" class="headerlink" title="作者觀點"></a>作者觀點</h3><p>我們先來看看本書作者的觀點（引用難免斷章取義，完整上下文請見本書第 15 頁），下面內容主要是回應「不寫註解的一派」：</p><blockquote><p>但我倒是認為事情沒那麼絕對。<strong>無論程式碼寫得多好，多麼「自說明」，跟讀程式碼相比，讀註解通常讓人覺得更輕鬆</strong>。</p></blockquote><blockquote><p>註解會讓人們<strong>覺得親切</strong>（尤其當註解是中文時），<strong>高品質的指引性註解確實會讓程式碼更易讀</strong>。有時抽象一個新函式，不見得就一定比一行註解加上幾行程式碼更好。</p></blockquote><p>第一段引用，其實就跟我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a>」中的主張一致：</p><blockquote><p>在我看來，無論程式寫得如何簡潔易讀，對一些比較複雜的函式或類別而言，docstring 終究是不可少的。<strong>因為文字的詮釋能力和程式碼相比，絕不在同一個層次</strong>，相信這也是為何 docstring 會有屬於自己的獨立 PEP 加以規範的理由。</p></blockquote><h3 id="我的看法與結論"><a href="#我的看法與結論" class="headerlink" title="我的看法與結論"></a>我的看法與結論</h3><p>既然都寫了這篇文章，想當然爾我是「<strong>支持</strong>」寫註解的一派。</p><p>不過，反對派說註解會<strong>增加維護難度</strong>，以及可能讓人<strong>更加依賴註解</strong>而忽略了提升程式碼品質，我覺得這些擔憂也<strong>非常真實</strong>。</p><p>所以，對我來說，問題不在於「要不要寫註解？」，而是<strong>「怎麼樣才能寫好註解？」</strong>。這也是本文想回答的問題。</p><p>我的結論是：寫註解，<strong>但也要適度</strong>。並保持對「<strong>讀者意識</strong>」的敏感：<strong>不寫多餘的註解，也不寫自言自語的註解。</strong></p><h3 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h3><ul><li><a href="https://www.explainthis.io/zh-hant/swe/a-philosophy-of-software-design/part3">《A Philosophy of Software Design》心得 3 — 寫程式時該寫註解 (comments) 嗎？如果要的話該怎麼寫？</a></li><li><a href="https://www.facebook.com/darkthread.net/photos/a.345323768929153/1185728258222029/">【程序員的日常】程式註解該寫多細？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/beoEztr.png&quot; alt=&quot;Python 工匠&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263245174&quot;&gt;Python 工匠｜案例、技巧與開發實戰&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;p&gt;從書名推敲，我們並不容易知道本書的主題為何。事實上，和《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣&lt;/a&gt;》類似，這是一本關於「&lt;strong&gt;Clean Code in Python&lt;/strong&gt;」的書。&lt;/p&gt;
&lt;p&gt;而且我認為它的&lt;strong&gt;難度適中&lt;/strong&gt;（好吧，後半部難度比較高，而且本書&lt;strong&gt;「不適合」&lt;/strong&gt;初學者），非常推薦看完《Python 功力提升的樂趣》後，想要更進一步寫出 Pythonic 程式碼的讀者與開發人員。&lt;/p&gt;
&lt;p&gt;我覺得，兩本恰恰都是屬於「從書名看很容易被忽略」的好書。因此，作為喜歡本書的讀者，我覺得自己有&lt;strong&gt;義務&lt;/strong&gt;，向你們轉述書中一些值得傳誦的內容。&lt;/p&gt;
&lt;p&gt;這也是「&lt;a href=&quot;/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/&quot;&gt;閱讀筆記&lt;/a&gt;」系列的核心精神。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/beoEztr.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="閱讀筆記" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
    <category term="系列：Python 工匠" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%B7%A5%E5%8C%A0/"/>
    
  </entry>
  
  <entry>
    <title>為什麼你「不需要」所謂的人生管理系統</title>
    <link href="https://blog.kyomind.tw/less-is-more/"/>
    <id>https://blog.kyomind.tw/less-is-more/</id>
    <published>2024-01-21T20:33:14.000Z</published>
    <updated>2024-01-31T13:40:50.826Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/PwPTWYK.jpg" alt="by Myriam Wares"><span class="cap">by Myriam Wares</span></p><p>在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉一文與其所屬的「<a href="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion/">Simple Notion 系列</a>」中，我已用不少幅篇，明確表達我對這類「<strong>大而全</strong>」生產力系統的<strong>隱憂</strong>與<strong>質疑</strong>。</p><p>在其它文章中，也有過類似討論：</p><ul><li><a href="https://blog.kyomind.tw/four-thousand-weeks-01/">《人生 4 千個禮拜》筆記（一）病態的生產力</a></li><li><a href="https://blog.kyomind.tw/weekly-review-11/">11，我絕不當資訊的聚合者</a></li></ul><p>本文將進行一次「<strong>總結式</strong>」的整理，重新闡述<strong>不用這類系統的三大理由</strong>。並提出我認為相對可行的<strong>替代方案：局部實現</strong>。</p><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85">本文主旨與目標讀者</a></li><li><a href="#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D">所謂的「人生管理系統」</a></li><li><a href="#%E5%A4%A7%E7%B3%BB%E7%B5%B1%E7%9A%84%E5%85%A9%E5%80%8B%E7%89%B9%E5%BE%B5">大系統的兩個特徵</a></li><li><a href="#%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E8%A6%81%E9%80%99%E9%BA%BC%E7%94%A8">為什麼不要這麼用</a></li><li><a href="#3-%E5%80%8B%E3%80%8C%E4%B8%8D%E3%80%8D%E7%9A%84%E7%90%86%E7%94%B1">3 個「不」的理由</a></li><li><a href="#%E4%B8%80%E3%80%81%E6%88%90%E6%9C%AC%E9%81%8E%E9%AB%98%EF%BC%9A%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8%E7%9A%84%E4%BB%A3%E5%83%B9">一、成本過高：神兵利器的代價</a></li><li><a href="#%E4%BA%8C%E3%80%81%E9%81%A9%E5%BE%97%E5%85%B6%E5%8F%8D%EF%BC%9A%E5%81%9A%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%91%A3%E4%BA%8B">二、適得其反：做了更多瑣事</a></li><li><a href="#%E4%B8%89%E3%80%81%E7%B3%BB%E7%B5%B1%E6%9C%83%E8%A7%B8%E7%99%BC%E4%BD%A0%E3%80%8C%E8%BF%BD%E6%B1%82%E5%AE%8C%E6%95%B4%E3%80%8D%E7%9A%84%E6%9C%AC%E8%83%BD">三、系統會觸發你「追求完整」的本能</a></li><li><a href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%82%96%E8%AB%96">完整的悖論</a></li><li><a href="#%E8%88%89%E4%BE%8B%EF%BC%9ANotion-%E9%96%B1%E8%AE%80%E7%AE%A1%E7%90%86">舉例：Notion 閱讀管理</a></li><li><a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D">不必要的欄位</a></li><li><a href="#%E5%86%8D%E8%AB%96%E7%94%9F%E7%94%A2%E5%8A%9B%E9%81%94%E4%BA%BA">再論生產力達人</a></li><li><a href="#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE">更適合一般人的做法：局部實現</a></li><li><a href="#%E7%94%A8%E3%80%8C%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE%E3%80%8D%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1">用「局部實現」取代人生管理系統</a></li><li><a href="#%E7%B5%90%E8%AA%9E%EF%BC%9A%E6%8E%A5%E5%8F%97%E6%AE%98%E7%BC%BA%E8%88%87%E9%81%BA%E6%86%BE">結語：接受殘缺與遺憾</a></li></ol><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文想表達一個<strong>核心看法</strong>：打造大而全的<strong>人生管理系統</strong>，期望它全面提升你的生產力，<strong>可能不是一個好主意。</strong></p><p>我知道，在這個資訊爆炸、快速變遷的時代，<strong>追求生產力</strong>幾乎可說是一種「<strong>顯學</strong>」。</p><p>這類系統也許為「<strong>少部分人</strong>」帶來了可觀的成就、自我掌控感，甚至是<strong>安全感</strong>。</p><p>因此他們能夠<strong>信誓旦旦</strong>地告訴你：「相信我！這是一個超棒的方法，而且你也能夠！」</p><p>老實說，連我自己都很難完全抗拒「高效、生產力」這類的主題，我想這是所有懷抱著自我期許之人的本能吧！</p><p>所以我並不打算阻止你去追求、建立屬於自己的<strong>生產力方法論</strong>。本文想要<strong>提醒</strong>的是——這些方法<strong>最好不要</strong>是「大而全」的那種，而是要能夠做到「<strong>取捨</strong>」。</p><p>不過，人生之難，就難在取捨。</p><span id="more"></span><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文目標讀者有二：</p><ol><li>像我一樣，已經一定程度地追逐過所謂「生產力工作流」的人，卻因此<a href="https://blog.kyomind.tw/simple-notion/#%E3%80%8C%E8%B3%A6%E8%83%BD%E5%BC%8F%E6%8C%AB%E6%95%97%E3%80%8D">感到失望或懷疑</a>，覺得<strong>並沒有從中獲得真正的提升</strong>。</li><li><strong>想提高生產力，還在這條路上摸索，尋找自己適合工具、方法的人。</strong></li></ol><p>對於這兩類讀者，我希望通過<strong>我的經驗和觀察</strong>，提供一個<strong>不同於「<a href="https://www.google.com/search?q=%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1">主流</a>」的視角</strong>。</p><p>一言以蔽之，我相信對大部分人而言，真正有效的提升並不在於建立一個龐大而複雜的系統。<strong>反而一些簡單的做法，往往更有效。</strong></p><hr><h2 id="所謂的「人生管理系統」"><a href="#所謂的「人生管理系統」" class="headerlink" title="所謂的「人生管理系統」"></a>所謂的「人生管理系統」</h2><p>文章一開始，我們需要對本文中提到的這類「<strong>系統</strong>」——或者應該稱為「<strong>提高生產力的方法論</strong>」，做出基本的定義。</p><p>從上古時期的 <a href="https://en.wikipedia.org/wiki/Getting_Things_Done">GTD</a>、到現在的 <a href="https://fortelabs.com/blog/para/">PARA</a>，以至於你在網路上、YouTube 影片中，所看到任何關於建立一套「<strong>流程</strong>」來<strong>組織與管理</strong>你的<strong>生產力活動</strong>（比如工作、學習、寫作），都算。</p><p>這些系統、方法論，往往都不打算只解決你一、兩個小問題，而是雄心壯志地宣稱<strong>可以改變你的人生</strong>。</p><p>藉由<strong>全方位自我管理</strong>，帶給你不同於以往的<strong>全新做事思維</strong>，讓你從<strong>混亂、瞎忙、事情做不完</strong>的焦頭爛額中<strong>解脫</strong>出來。</p><p>從此過上「<strong>高效、優雅、有目標</strong>」的充實生活。</p><p>聽起來對我們的人生真的很有幫助呢！☺️</p><p>所以我們姑且稱它為「人生管理系統」。</p><p>在這個強調終身學習的時代，這類系統也很常以「<strong>個人知識管理系統</strong>」的形式活躍，從 GTD（把事情做完）到 PARA（整理知識、有效學習），能看出時代的變遷。</p><hr><h2 id="大系統的兩個特徵"><a href="#大系統的兩個特徵" class="headerlink" title="大系統的兩個特徵"></a>大系統的兩個特徵</h2><p>這些方法論，往往具備<strong>兩個特徵</strong>，這也是它們可以自稱為「系統」的主要原因。</p><h3 id="一、複雜"><a href="#一、複雜" class="headerlink" title="一、複雜"></a>一、複雜</h3><p>所謂的複雜，指的是<strong>你幾乎很難一看就學會</strong>。往往還需要<strong>看書、上課，或者看一堆教學影片</strong>，才能慢慢領略其中具體的做法與精神。</p><p>總之，<strong>這個「系統」本身就是一套需要學習的方法。</strong></p><p>毫無疑問，在這個自媒體時代，這類系統的「<strong>最佳代言人</strong>」，就是眾多<strong>生產力 KOL</strong>。可能是一個 YouTuber，或生產力部落客。</p><p>他們會在 YouTube 或自己的部落格上，分享關於「<strong>如何建立與使用</strong>」這類系統的文章影片。再多一點，則是會有自己的<strong>課程</strong>或<strong>書籍</strong>。</p><h3 id="二、流程化"><a href="#二、流程化" class="headerlink" title="二、流程化"></a>二、流程化</h3><p>除了複雜，這類系統的另一個明顯的特徵——「<strong>流程化</strong>」。</p><p>遵循一定的規則、順序、條件，就像生產線一樣，把知識——或任何其它你需要處理、學習的事物——當作原料，透過<strong>一套完整的工具使用流程</strong>，讓它們變成「你的東西」，或產出相對應的成果。</p><p>想當然爾，<strong>這不會是簡單的幾個步驟</strong>，而是一整套理論（甚至說是「<strong>信仰</strong>」可能也不為過），加上各式各樣實踐上的細節、建議所組成。</p><p>什麼！GTD、PARA 你都沒聽過？沒關係，因為本文要討論的，不是任何具體的生產力方法，也不是它們究竟有沒有效，而是<strong>更高層次的價值觀議題</strong>。</p><hr><h2 id="為什麼不要這麼用"><a href="#為什麼不要這麼用" class="headerlink" title="為什麼不要這麼用"></a>為什麼不要這麼用</h2><p>如「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E7%94%9F%E7%94%A2%E5%8A%9B%E8%BB%9F%E9%AB%94%E7%9A%84%E6%88%B0%E5%9C%8B%E6%99%82%E4%BB%A3">生產力軟體的戰國時代</a>」中所說，上述的系統或方法論，無一例外都是透過某一款<strong>筆記軟體</strong>（有時甚至是一整套工具）來實現，無論是 Notion 或 Evernote。</p><p>這可以理解，畢竟理論終歸是理論，還是需要工具來落實。以前可能是紙筆，但在這個時代，軟體、app 才是我們最常用的工具。</p><p>而本文要強調的則是「為什麼<strong>不要這麼用</strong>」這些軟體——<strong>不要</strong>在這些軟體之上，或好些軟體之間，建立一個<strong>複雜的工作流程</strong>。</p><blockquote><p><strong>不要在這些軟體之上，或好些軟體之間，建立一個複雜的工作流程。</strong></p></blockquote><hr><h2 id="3-個「不」的理由"><a href="#3-個「不」的理由" class="headerlink" title="3 個「不」的理由"></a>3 個「不」的理由</h2><p><strong>為什麼不？</strong></p><p>開頭的 3 篇文章中，都有提到不這麼做的理由，讓我搭配引述，重新為你疏理一番。</p><p>歸納起來，主要有下列 3 個理由。</p><p>特別提醒：用來落實本文中「系統」的工具，<strong>並不限於 Notion</strong>，只不過 Notion 可能是最常被使用、提及的工具而已。</p><h2 id="一、成本過高：神兵利器的代價"><a href="#一、成本過高：神兵利器的代價" class="headerlink" title="一、成本過高：神兵利器的代價"></a>一、成本過高：神兵利器的代價</h2><p>在「<a href="https://blog.kyomind.tw/simple-notion/#%E7%B6%AD%E6%8C%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8C%81%E7%BA%8C%E9%81%8B%E8%BD%89%EF%BC%8C%E6%98%AF%E5%80%8B%E3%80%8C%E9%AB%94%E5%8A%9B%E6%B4%BB%E3%80%8D">維持工作流持續運轉，是個『體力活』</a>」中，我是這麼說的：</p><blockquote><p>很遺憾，<strong>對這套「系統」每一天的落實、記錄，大多仍須由你「手動」執行</strong>。<br>　<br>哪怕 Notion 有 <strong>API 整合</strong>，可以省下一些時間。網路上也有眾多<strong>模板</strong>，供你直接套用。但是，你設計出來的工作流，<strong>其中最核心的部分，往往只能由你自己——手動維護。</strong></p></blockquote><p>而這些手動的功夫，勢必將帶來大量的時間、精力的消耗。<strong>系統愈大、愈是精巧，成本就愈高。</strong></p><p>我認為對大部分人而言，如此巨大的投入，<strong>幾乎很難獲得「相應」的回報。</strong></p><blockquote><p><strong>為什麼？</strong></p></blockquote><p>因為你其實<strong>不需要</strong>這麼多回報。</p><p>大部分時候，產出價值的關鍵在於「<strong>把事情做好</strong>」，而不是「做<strong>好多</strong>事情」。</p><p><strong>而就我所知，要把一些事情做好，並不需要太複雜的工具或管理技巧。</strong></p><p>不過話說回來，如果你的野心更大，想要「<strong>把好多事情都做好</strong>」，那可能確實需要這類系統。</p><p>然而，這樣的想法，也有其背後的<strong>隱憂</strong>——讓我們看第二個理由。</p><hr><h2 id="二、適得其反：做了更多瑣事"><a href="#二、適得其反：做了更多瑣事" class="headerlink" title="二、適得其反：做了更多瑣事"></a>二、適得其反：做了更多瑣事</h2><p><strong>時間成本</strong>，是採用「人生管理系統」的<strong>一大門檻</strong>，而且光是需要投入的時間成本，<strong>其實就足以勸退一半以上的嘗試者。</strong></p><p>其中的理由可想而知：<strong>因為太累了嘛！</strong>🤣</p><p>但是！如果你動力過人、積極實踐，並沒有因為成本而卻步。那第二個理由則是我們<strong>更需要關心的。</strong></p><p>我在「<a href="https://blog.kyomind.tw/four-thousand-weeks-01/#%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1">效率陷阱</a>」中提到：</p><blockquote><p>有時候，這些<strong>額外增加的效率</strong>（生產力）就像是超商的「<strong>第二件 6 折</strong>」零食。平時你知道零食不健康，所以不會多買。<br>　<br>但有了這個折扣，我們往往忍不住，買更多——內心還覺得很划算。<br>　<br>正如前述，這些事如果不是「必須的」，那「提高對此事的生產力」，往往只是讓你花費更多時間，做那些<strong>本來就不需要做的事</strong>！——就像<strong>多吃了一堆零食</strong>。</p></blockquote><p>換句話說，如果你真的能「把好多事情都做好」，那你<strong>也</strong>很可能——<strong>且幾乎不可避免地</strong>——會增加做「<strong>不重要瑣事</strong>」的<strong>數量與比例</strong>。</p><p>而這些瑣事對<strong>整體產出的價值，當然是「有害」的！</strong></p><hr><p>你乍聽可能覺得：「會嗎？事情是否重要，我一直都是<strong>了然於心</strong>的啊！」</p><p>但我想說，現實恐怕沒有這般美好。</p><p>接下來的第三個理由，將會一定程度論證這一點：<strong>我們對事物重要性的判斷，並不總是那麼敏感。</strong></p><h2 id="三、系統會觸發你「追求完整」的本能"><a href="#三、系統會觸發你「追求完整」的本能" class="headerlink" title="三、系統會觸發你「追求完整」的本能"></a>三、系統會觸發你「追求完整」的本能</h2><p>還記得十多年前，超商非常流行的「<a href="https://www.foodnext.net/column/columnist/paper/5357454895">集點公仔收集</a>」活動嗎？</p><p>年輕的讀者可能沒什麼印象，這個熱潮當時真的流行了好幾年才慢慢消退。</p><p>仔細想想，為什麼會這麼流行？是因為這些公仔、飾品真的很吸引人嗎？這只是一部分原因。當然，也不乏對特定主題本來就有興趣的愛好者。</p><p>但其中一個<strong>不容忽視的要素</strong>是——<strong>我們對於「事物完整性」的本能追求</strong>：</p><blockquote><p>而純喫茶則是運用包裝上的瓢蟲元素，推出了一系列不同品種花紋的公仔，<strong>不少人也是特別去購買產品來完成收集的目標</strong>。</p></blockquote><p>「完成收集目標」意謂著，<strong>為什麼收集</strong>並不那麼重要，重要的是它<strong>必須被完成</strong>。</p><p>可想而知，對<strong>完整性</strong>的本能偏好，很可能會讓我們<strong>忽略</strong>，追求完整<strong>究竟是為了什麼？</strong></p><h3 id="系統讓人想要「更完整」"><a href="#系統讓人想要「更完整」" class="headerlink" title="系統讓人想要「更完整」"></a>系統讓人想要「更完整」</h3><p>那這個本能和「系統」有什麼關係？</p><p>系統，<strong>特別是那些複雜的「人生管理系統」</strong>，它的設計往往<strong>很容易激發</strong>我們追求完整的本能。</p><p>回顧一下我在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉提過的，那些鼓吹你入坑「人生管理系統」的<strong>迷人標語</strong>：</p><ul><li>我用 Notion <strong>高效管理工作與生活</strong>，告別瞎忙，重新找回人生主導權。</li><li>透過 Notion「<strong>打造○○系統、輕鬆整合✕✕</strong>」，讓我可以<strong>一站式管理一切</strong>。</li><li>Notion 幫助我<strong>實現夢想，完成目標</strong>，創造屬於我的美好人生。</li></ul><p>就算沒有真的實踐過，我們光看這些宣傳詞，<strong>想必也能合理推測：</strong></p><blockquote><p>這樣的系統，勢必要追求<strong>一定的完整性，才能有效應對不同面向上的各種需求</strong>——畢竟它可是要<strong>改變你的人生</strong>！</p></blockquote><p>結合不同功能模組（在 Notion 中就是許多 database），形成一套<strong>完整的「工作流」、「系統」</strong>，正是它們主要的<strong>設計思路</strong>。</p><hr><h2 id="完整的悖論"><a href="#完整的悖論" class="headerlink" title="完整的悖論"></a>完整的悖論</h2><p>這種大而全的設計思路，讓我們不自覺地想要<strong>填滿每一個環節上的空白、講究每一個角落的細節——即使這些細節對我們的整體目標並不重要。</strong></p><p>就像那些公仔收集活動一樣，系統<strong>觸發</strong>了我們對「完整性」的<strong>渴望</strong>，讓我們陷入了一種<strong>錯誤的追求方向</strong>——「我要把它們都收集完！」</p><p>在大系統中，我們可能花很多時間思考<strong>系統本身的設計、優化管理方法</strong>，而忽略了<strong>真正對我們重要的事情</strong>，也就是<strong>系統「本來」想達到的目的。</strong></p><p>追求完整的本能，再結合複雜的系統設計，<strong>最終可能導致我們的生產力「下降」，而非提升。</strong></p><p>到頭來，我們花費了太多時間在維護、優化系統，而非利用它來提升我們的生活品質或工作效率。</p><blockquote><p>這是<strong>我曾有過的經驗</strong>，不知你是否也熟悉？</p></blockquote><p>因此，與其說是<strong>完整的悖論</strong>，或許更適合稱之為——完整的「<strong>詛咒</strong>」。</p><hr><h2 id="舉例：Notion-閱讀管理"><a href="#舉例：Notion-閱讀管理" class="headerlink" title="舉例：Notion 閱讀管理"></a>舉例：Notion 閱讀管理</h2><p>我們舉一個<strong>典型且普遍</strong>的例子來感受一下，「追求完整」導致你花時間在鎖事上，真的<strong>比想像中的更容易發生。</strong></p><p>「<strong>用 Notion 做閱讀書籍的管理</strong>」這個需求場景，絕對是一搜尋就一大堆。在 YouTube 上搜尋「Notion 閱讀筆記」之類的關鍵字，能找到的相關影片更是多不勝數。</p><p>甚至不用搜尋，Notion 官方已經幫你收集了大量用戶提供的模板，供你直接套用：</p><ul><li><a href="https://www.notion.so/templates/category/books">Books templates</a></li></ul><p>並不是說，用 Notion 整理自己的閱讀清單、筆記有什麼問題。<strong>這絕對是好事。</strong></p><p>但如果你也有過類似的嘗試——用 Notion database 管理自己的閱讀清單。應該很容易發現，這個過程一不小心就可能會「<strong>走火入魔</strong>」。</p><p>一開始是書名、作者這類基本欄位，但隨著這個「系統」愈來感完整，<strong>你會很想要為它加入更多「點綴式」的資訊欄位</strong>，包括一些與排版設計有關的元素，比如封面、icon、顏色等等。</p><h2 id="不必要的欄位"><a href="#不必要的欄位" class="headerlink" title="不必要的欄位"></a>不必要的欄位</h2><p>簡言之，基於一種「完整記錄」的偏好，你可能會增加一些<strong>實際上沒多少用處</strong>，但會「<strong>讓人感覺很好、很完整</strong>」的欄位。</p><p>這些欄位在 Notion 閱讀管理資料庫中<strong>經常出現</strong>，但它們更多是<strong>為了追求「完整性」</strong>，而非<strong>實際的閱讀效益</strong>而設計，比如：</p><ol><li><strong>書籍封面圖片</strong>：封面圖片可以讓整個資料庫看起來<strong>更生動</strong>，但對於實際的閱讀和理解並沒有太大幫助。</li><li><strong>購買、借閱、開始、完成日期</strong>：記錄對這本書相關行動的時間點。</li><li><strong>出版資訊</strong>：包括出版社、出版年份等。</li><li><strong>多重標籤系統</strong>：例如創建多個標籤來分類書籍的主題、風格、情緒等，這增加了管理的複雜性，實際上的用處有限——<strong>不過確實讓人感覺很好XD</strong></li><li><strong>閱讀狀態</strong>：例如「想讀」、「正在讀」、「已讀」等狀態，這一定程度上有助於組織，但太複雜則會變成負擔，比如狀態有 5、6 種之多。</li><li><strong>引用和摘錄</strong>：對書中的特定段落或引言進行詳細記錄。我知道很多人喜歡！我也喜歡。對於學術工作或深入研究比較有用，但對於一般閱讀者而言，很可能只是增加了不必要的工作量。</li></ol><p>這些欄位雖然可以讓你的閱讀資料庫<strong>看起來很全面</strong>，但實際上，對<strong>提升閱讀體驗</strong>或<strong>增進理解</strong>往往<strong>沒有太大幫助</strong>（甚至可以說<strong>毫無關係</strong>）。反而讓你<strong>花費更多時間在製作、管理這些數據，而非真正的閱讀思考。</strong></p><p>讀書本來沒那麼複雜，不外乎<strong>明白一些事，然後有所行動</strong>。但工具可能讓它<strong>變得複雜</strong>，而「<strong>系統</strong>」更是如此。</p><p><img src="https://i.imgur.com/drRrybF.png" alt="工具可能讓閱讀變得複雜，而系統更是如此"><span class="cap">工具可能讓閱讀變得複雜，而系統更是如此</span></p><p><strong>最壞</strong>的情況是，我們被這些強大系統所<strong>吞噬</strong>，淪為「<strong>為系統工作</strong>」的人，而非利用系統的人。</p><hr><p>當然，上述只是最壞情況，而且情況總是在變動，不能一概而論。</p><p>但話說回來，那些知名的生產力達人，他們好像並沒有這樣的困擾？</p><p>確實，因為這些人是「凌駕於系統之上」的人。</p><p>下一段我們要討論，這類人和一般人，<strong>究竟有什麼不同。</strong></p><h2 id="再論生產力達人"><a href="#再論生產力達人" class="headerlink" title="再論生產力達人"></a>再論生產力達人</h2><p>下面舉例的瓦基和電腦玩物，都是我認為「<a href="https://blog.kyomind.tw/simple-notion/#%E5%81%A5%E5%BA%B7%E8%88%87%E7%97%85%E6%85%8B%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B">健康</a>」的生產力達人。以他們為例，有助於我們理解「生產力達人」的<strong>特質</strong>，以及<strong>為什麼——你可能無法成為他們。</strong></p><p>在「<a href="https://blog.kyomind.tw/simple-notion/#%E4%BD%A0%E6%98%AF%E5%93%AA%E4%B8%80%E7%A8%AE%E4%BA%BA%EF%BC%9F">你是哪一種人？</a>」中，我使用了「生產力狂魔」一詞來形容那些擁有強大生產力且<strong>能持續貫徹</strong>的人：</p><blockquote><p>你得承認，有些人就是<strong>紀律良好且生產力過人</strong>，一樣時間他們能產出數倍成果，且品質有保證。比如<a href="https://readingoutpost.com/">閱讀前哨站</a>站長「<a href="https://readingoutpost.com/about/">瓦基</a>」，在台積電當工程師時，他能利用下班時間完成大量書籍閱讀與心得輸出，週而復始，筆耕不綴，進而<a href="https://crossing.cw.com.tw/article/15467">實踐了自己的志業</a>。</p></blockquote><p>這裡改用「生產力達人」這個詞彙，更加中性。</p><p>上述的瓦基，或我們熟悉的<a href="https://www.playpcesor.com/">電腦玩物</a>站長，他們都擁有驚人的生產力，更可貴的是——<strong>持續產出</strong>的能力。</p><p>我相信，他們不太會受困於系統，因為：</p><blockquote><p>這樣的人有著<strong>很強的自我調節能力，能持續地調整自己的行為，讓自己不斷進步</strong>——近乎<strong>本能</strong>。</p></blockquote><p>相比於一般人，他們擁有「<strong>更遠大的目標</strong>」，他們是「<strong>利用系統</strong>」的人。</p><blockquote><p>不過，我同時也相信，<strong>這樣的人，只是少數</strong>。</p></blockquote><p>沒錯，我真心認為，這樣的人只是少數，而且<strong>只會是少數。</strong></p><h3 id="生產力達人終究只是少數"><a href="#生產力達人終究只是少數" class="headerlink" title="生產力達人終究只是少數"></a>生產力達人終究只是少數</h3><p>生產力達人<strong>當然不是天生的</strong>，但必定是經過<strong>不斷自我追求、精進而煉成。</strong>（不然這世界也太不公平😂）</p><p>而我認為，這種<strong>不斷追求</strong>生產力的<strong>動力與本能——很大程度是天生的。</strong></p><p><strong>這是一種非常強烈的價值觀偏好。</strong></p><p>對我們這些普通人來說，要達到生產力達人的輸出量，肯定相當困難，<strong>但並非不可能。</strong>然而，如果要「<strong>持續</strong>」為之，沒有一定的動力與本能，恐怕還是不行的。</p><blockquote><p><strong>大部分人對生產力的渴求，並沒有那麼強烈。</strong></p></blockquote><p>這就是為什麼我們需要<strong>更實用、更適合自己</strong>的管理方法，而非盲目追求那些<strong>「強大」</strong>的系統。</p><p>畢竟，最有效的生產力提升方法，應該是能幫助我們<strong>專注於真正重要的事情</strong>，而不是讓我們陷入<strong>無止境的系統維護、資訊收集和管理壓力</strong>中。</p><hr><h2 id="更適合一般人的做法：局部實現"><a href="#更適合一般人的做法：局部實現" class="headerlink" title="更適合一般人的做法：局部實現"></a>更適合一般人的做法：局部實現</h2><p><strong>絕對有人需要大系統，而且能利用它們做的很好。</strong>只不過，大部分人如果也想按照相同的方式來提升生產力，基於上述三大理由，恐怕將<strong>適得其反</strong>。</p><p>因此，我相信，對大多數人來說，一個<strong>更現實且可行</strong>的方法是「<strong>局部實現</strong>」。</p><h3 id="局部實現：不完整，但更有效"><a href="#局部實現：不完整，但更有效" class="headerlink" title="局部實現：不完整，但更有效"></a>局部實現：不完整，但更有效</h3><p>局部實現，是一種<strong>心法或價值觀</strong>，說穿了沒什麼，就是「<strong>緊扣著需求尋找並選定方法，需要多少才投入多少</strong>」。</p><p>更具體地說，它有兩大核心內涵。</p><h3 id="一、方法改進宜適可而止"><a href="#一、方法改進宜適可而止" class="headerlink" title="一、方法改進宜適可而止"></a>一、方法改進宜適可而止</h3><p>如果當前方法<strong>已能做出 80 分成果，一定程度滿足需求了</strong>，就<strong>不要</strong>再繼續追尋「更有效方法」——宜適可而止。</p><p>必須強調，這裡不是指結果一律只追求 80 分就好。</p><p>而是，如果結果已經有 80 分，但你想要進一步提升，<strong>建議不要試圖從「手段、方法」上去改進。更不需要去建立一個複雜的系統。</strong></p><p>無論什麼系統，對於已有 80 分的產出結果，<strong>很可能已不構成影響</strong>。再從方法上改進，企圖更進一步提升產出品質，往往只是緣木求魚。</p><h3 id="二、分別而非整體：謹慎關聯"><a href="#二、分別而非整體：謹慎關聯" class="headerlink" title="二、分別而非整體：謹慎關聯"></a>二、分別而非整體：謹慎關聯</h3><p>「系統」二字最讓我<strong>害怕</strong>的，就是它隱約<strong>暗示</strong>著系統的各個元件之間，存在著<strong>巧妙的「關聯」</strong>，所以它們能共同組合成一個「工作流」。</p><p>我的建議是：<strong>謹慎關聯</strong>。</p><p>可以的話，<strong>不要關聯，因為所有關聯都是有「代價」的。</strong></p><p>我還是要用 Notion 舉例，因為我比較熟。Notion 的資料庫關聯，無疑是強大的功能，但真的不宜濫用。</p><p>何謂濫用？那就是本來一個 db 就能完成的需求，因為可以「關聯」，所以你決定把它拆成兩個甚至更多 db 來做，因為這樣<strong>更條理分明</strong>，也更有「<strong>組合後的整體美感</strong>」——我就幹過這種事！而且還不止一次。</p><p>最後我往往還是把 db 砍到剩 1 個。因為<strong>實在太煩了</strong>。</p><blockquote><p>相關內容：</p><ul><li><a href="https://blog.kyomind.tw/stumbling-on-notion/#%E9%81%8E%E5%BA%A6%E8%A8%AD%E8%A8%88%EF%BC%9A%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E7%AD%86%E8%A8%98%E6%9E%B6%E6%A7%8B%E5%B8%AB">過度設計：人人都是筆記架構師</a></li><li><a href="https://blog.kyomind.tw/notion-database/#%E8%B3%87%E6%96%99%E5%BA%AB%E5%A4%AA%E5%A4%9A%E4%BA%86%EF%BC%81">資料庫太多了！</a></li></ul></blockquote><h3 id="對關聯的渴望"><a href="#對關聯的渴望" class="headerlink" title="對關聯的渴望"></a>對關聯的渴望</h3><p>為什麼總是<strong>忍不住</strong>想要關聯呢？</p><p>我想你也看出來了，對「關聯」的渴望，正是「追求完整」的本能所致——我們<strong>很喜歡</strong>事物看起來是一個<strong>整體</strong>，更甚於只是一堆<strong>零散的部分</strong>。</p><blockquote><p><strong>所以必須把它們關聯起來。</strong></p></blockquote><p>追求完整往往帶來不必要的複雜，<strong>而「關聯」正是複雜小惡魔們誕生的溫床😈</strong></p><p>在我看來，對付複雜的最佳思維就是：<strong>各個擊破就好</strong>——不關聯，不整體。方法簡單、有效，<strong>能「恰如其分」解決問題</strong>，就是足夠好的方法。</p><p>當然，這會破壞一個大系統的「<strong>美感與整體感</strong>」，使之<strong>不再完整。</strong></p><p>對，我<strong>就是要</strong>破懷這樣的美感。</p><p>因為這種美感，正是讓我們「<strong>感覺良好</strong>」的來源，卻也是<strong>陷入困境</strong>的開端。</p><hr><h2 id="用「局部實現」取代人生管理系統"><a href="#用「局部實現」取代人生管理系統" class="headerlink" title="用「局部實現」取代人生管理系統"></a>用「局部實現」取代人生管理系統</h2><p>接下來<strong>以我自己為例</strong>，再聊聊更多「局部實現」的<strong>具體實作</strong>。</p><p><a href="https://blog.kyomind.tw/bear/#%E6%88%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E6%AC%BE%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94">我目前的主力筆記軟體</a>包括了 Notion 與 Logseq。說真的，這兩款軟體，都能創造出非常複雜的系統——它們在功能上皆強大而靈活。</p><p>但無論 Notion 還是 Logseq，「局部實現」策略都是可行的。</p><p>這意味著你可以在這些平台上建立<strong>特定的、專注於某一個或幾個目標的小流程</strong>，而不是一個涵蓋所有事情的龐大系統。</p><h3 id="我在-Notion-的局部實現"><a href="#我在-Notion-的局部實現" class="headerlink" title="我在 Notion 的局部實現"></a>我在 Notion 的局部實現</h3><p>Notion 中，我目前有在用的，<strong>只有一個</strong> database。用來管理我的寫作（主要）與個人 side project。</p><p><img src="https://i.imgur.com/BjE4elR.png" alt="Notion 寫作管理看板"><span class="cap">Notion 寫作管理看板</span></p><p>Notion 的簡易看板對我來說完全夠用，我不需要 Trello 這類更專業的專案管理軟體。</p><p>附帶一提，如果你有<strong>更加專業</strong>的「看板」需求，尤其是<strong>工作上的專案管理</strong>，千萬不要用 Notion，<strong>會很痛苦</strong>。</p><blockquote><p>我怎麼知道？望向工作上的 Notion 看板……🥲</p></blockquote><p>關於這個看板與 Notion 寫作，可參考：</p><ul><li><a href="https://www.facebook.com/kyomind/posts/pfbid03Zbm1vC5QGPVVeoH9YmhUBdmL88CW5whKtcwj2QssHHUyBT8oReRdSoytL3H2p1Gl">靠「看板」吧！</a>（臉書貼文，講述該看板誕生緣由）</li><li><a href="https://blog.kyomind.tw/my-markdown-writing-flow/">Notion + VS Code：我的 Markdown 寫作工作流</a>（講述我用 Notion 寫作部分，而且已經融入上述看板了）</li></ul><p>沒了，我主要就用 Notion 管理與進行「<strong>寫作</strong>」這一件事而已。</p><p>我以前也把很多事塞進 Notion，但我發現<strong>它能勝任的部分不多</strong>。很多事它都能做，但<strong>做的不是特別好</strong>——尤其是學習。</p><p>現在這樣的 Notion 用法，讓我非常喜歡且滿意。而設計上述看板需花多久的時間呢？<strong>應該不到半小時。</strong></p><p>使用看板的過程中，我嘗試過上述的「<strong>把一個資料庫拆成兩個，再互相關聯</strong>」，但始終<strong>沒有成功</strong>。（前後還試了兩次！😱）</p><p>用了一個月左右，我發現這樣簡單的看板，<strong>效果竟超乎想像的好——我的「發文紀律」明顯提升了！</strong></p><p>既然如此，這方法已經足夠，依「<strong>局部實現</strong>」思維，<strong>我也該適可而止了。</strong></p><h3 id="我在-Logseq-的局部實現"><a href="#我在-Logseq-的局部實現" class="headerlink" title="我在 Logseq 的局部實現"></a>我在 Logseq 的局部實現</h3><p>前面提到，Notion 對我的學習效果不是很好。</p><p>但我做筆記，最大的訴求就是學習，尤其是學習程式。所以我後來改用了 Logseq。</p><p>把<strong>學習用筆記軟體</strong>從 Notion 換成 Logseq 的具體緣由，我會再另篇討論。</p><p>而我現在用 Logseq 的學習方式，也很簡單：</p><ol><li>用 Logseq 寫學習筆記。大部分是<strong>程式相關</strong>，記錄實作時的<strong>踩坑經驗、重要知識、歸納與心得</strong>。認真寫筆記，對我<strong>幫助很大</strong>，可參考<a href="https://www.facebook.com/kyomind/posts/pfbid0sotiMpKkNWAR9w6kTyLeZj3LAF29qEhbiAfBWfHWyGU46EzAiozc3475ixYU47Azl">這篇臉書貼文</a>。</li><li>把上述筆記做成<strong>閃卡</strong>，按時複習。卡片的<strong>具體模樣</strong>，可參考<a href="https://www.facebook.com/fomo.kyo/posts/pfbid0KMyv8WAyMJSQBz8kvVQsmhXmHRspVknx3wwCcdjwvNJrH22bpZKZPMxcEZHECVJVl">這篇臉書貼文</a>。</li></ol><p>容我引用第二篇中的一段：</p><blockquote><p>程式開發時勤做筆記，把筆記切成一張張閃卡（flashcard），每天複習一些卡片。不用多，10-20 張就夠了<br>　<br>對我而言，是不錯的學習方式（我以前還很不以為然呢 XD）<br>　<br>經實測，它有助於我於更靈活運用這些開發知識。簡言之，我比以前「更容易想起」實作上要注意的細節，與其中的原理——因為我踩過這些坑、做了筆記，然後用閃卡複習</p></blockquote><p>Logseq 對我當然還有別的重要使用方式，比如記錄我的晚餐與當次用餐心得！但主要的大目標，就只有<strong>學習</strong>。</p><p>我從來不覺得自己正在使用什麼「系統」。</p><p>對我來說，<strong>筆記就只是筆記而已。</strong></p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a></p></blockquote><hr><h3 id="局部實現更可能讓工具為你所用，而不是被系統束縛"><a href="#局部實現更可能讓工具為你所用，而不是被系統束縛" class="headerlink" title="局部實現更可能讓工具為你所用，而不是被系統束縛"></a>局部實現更可能讓工具為你所用，而不是被系統束縛</h3><p>上述這些方法，說真的，都滿「<strong>平淡</strong>」的。我也不知道怎麼樣才能把它們寫得更 fancy 一點——可能是因為<strong>我沒有「系統」可言。</strong></p><p>採用「局部實現」思維，意味著你可以選擇最適合當前需求的工具和方法，從而使工具真正為你所用。<strong>因為這些方法都比較「小」，要用不用，皆操之在己。</strong></p><p>雖然系統提倡者們都不約而同地宣稱：精緻而完善的系統，能使人找回生活的主導權！（此時文案旁通常還要搭配一則<strong>漂亮的圖表</strong>，讓你感受「<strong>系統的整體之美</strong>」）</p><p><strong>但我不這麼看。</strong></p><p>我認為，相比於大系統，使用小方法的局部實現，更容易讓我專注於<strong>事物的本質</strong>，而非被系統所束縛。</p><p>回想一下，學習所謂「人生管理系統」的過程中，你是否曾有過這樣的<strong>自我懷疑</strong>：</p><blockquote><p><strong>我覺得這東西真的很棒！但是我不夠認真，所以還用不好。</strong></p></blockquote><p><strong>相信我——</strong></p><blockquote><p><strong>那很可能不是你的問題。</strong></p></blockquote><p>我誠摯認為，<strong>不值得</strong>再花費時間精力去維護那些「<strong>看起來很棒</strong>」，但<strong>實際效果極其有限</strong>的功能模組。比如上述「<a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D">不必要的欄位</a>」。</p><p><strong>人生苦短</strong>，你完全可以把精力集中在<strong>真正重要的事情</strong>上，<strong>直接提高</strong>結果的品質。</p><hr><h2 id="結語：接受殘缺與遺憾"><a href="#結語：接受殘缺與遺憾" class="headerlink" title="結語：接受殘缺與遺憾"></a>結語：接受殘缺與遺憾</h2><p>我本來想要使用「<strong>擁抱</strong>」這個詞，但這詞常常被濫用在一些心靈雞湯中，情感上也不是非常協調。</p><p>因為殘缺或遺憾，<strong>都不是我們喜歡的東西（我們喜歡完整）</strong>，要「擁抱」它們，本身就已<strong>違反人性</strong>——太虛假。</p><p>而「<strong>接受</strong>」一詞則更貼切些，<strong>帶有幾分不捨，與幾分坦然</strong>，很適合。</p><p>我相信，我們面對「大系統」的心態，也是如此。</p><h3 id="「完整性」的誘惑"><a href="#「完整性」的誘惑" class="headerlink" title="「完整性」的誘惑"></a>「完整性」的誘惑</h3><p>前面講的我自己的局部實現案例，可以說，沒什麼特別之處，任何人都能做到。</p><p>不過連我自己在這個過程中，<strong>都還是很容易受到「完整性」的誘惑。</strong></p><p>我可是寫了這篇七千字長文，不斷提醒你要小心「完整性誘惑」的作者，但我自己還是會受到誘惑。只能說，<strong>本能的力量，真的很強大。</strong></p><p>當然我並非「系統愛好者」，所以不太可能被誘惑到去建立一個完整的系統。<strong>但不得不承認，我也常常很想要去「優化方法」。</strong></p><p>在此，我想要再次告訴你，<strong>也提醒我自己：方法真的沒那麼重要。</strong></p><p>大系統、工作流，<strong>真正讓人著迷的</strong>，往往是這些系統「<strong>本身</strong>」，而非其產出的結果。</p><p>人生管理系統就像一座<strong>壯麗的城堡，它的外觀、內部設計、各個房間的佈置，無不讓人陶醉其中。</strong>但這座城堡的<strong>主人</strong>——也就是你——<strong>卻未必快樂。</strong></p><h3 id="畫框與畫作"><a href="#畫框與畫作" class="headerlink" title="畫框與畫作"></a>畫框與畫作</h3><p>就像畫框與畫的關係，我們被<strong>精緻的畫框</strong>所吸引，甚至忘記了畫框的存在目的，是為了<strong>襯托畫作</strong>。</p><p>當然，話說回來，<strong>沒有方法確實不妥</strong>，但方法的改進，應適可而止。</p><p>上述看板就是很好的例子，它實在很簡單，簡單到不值一提，但對我寫作紀律的提升，大概從 0 分提高到了 60 分。</p><p>我還要<strong>繼續改進</strong>這個看板嗎？或許可以，或許不必。</p><p>寫文章並不是我的工作，如果能擁有 60 分的寫作紀律，且能夠持續保持，那我已<strong>相當自豪。</strong>這意味著我的「<strong>寫作畫框</strong>」已經<strong>足夠好了。</strong></p><h3 id="殘缺與遺憾"><a href="#殘缺與遺憾" class="headerlink" title="殘缺與遺憾"></a>殘缺與遺憾</h3><p>我認為，保持方法的殘缺與遺憾，是一種「<strong>高明的妥協</strong>」。</p><p>小方法比大系統更容易掌握，更可能讓我們<strong>專注於「畫作」本身</strong>。</p><p>接受殘缺並不意味著放棄進步，而是在進步的過程中，<strong>試著學會區分：哪些只是手段，而哪些才是本質。</strong></p><blockquote><p><strong>手段可以殘缺。唯有本質的完整，才值得我們一心追求——至死方休。</strong></p></blockquote><p>擺脫對系統的「<strong>依賴</strong>」後，甚至會發現，我們的生產力<strong>其實已經有了顯著的提升</strong>。這樣的提升，<strong>來自於我們對「自身局限」的理解和接受。</strong></p><p>這種心態的轉變，不僅提高了生產力，更重要的是：<strong>減少了不必要的壓力和焦慮。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/PwPTWYK.jpg&quot; alt=&quot;by Myriam Wares&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉一文與其所屬的「&lt;a href=&quot;https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ASimple-Notion/&quot;&gt;Simple Notion 系列&lt;/a&gt;」中，我已用不少幅篇，明確表達我對這類「&lt;strong&gt;大而全&lt;/strong&gt;」生產力系統的&lt;strong&gt;隱憂&lt;/strong&gt;與&lt;strong&gt;質疑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在其它文章中，也有過類似討論：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/four-thousand-weeks-01/&quot;&gt;《人生 4 千個禮拜》筆記（一）病態的生產力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-11/&quot;&gt;11，我絕不當資訊的聚合者&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文將進行一次「&lt;strong&gt;總結式&lt;/strong&gt;」的整理，重新闡述&lt;strong&gt;不用這類系統的三大理由&lt;/strong&gt;。並提出我認為相對可行的&lt;strong&gt;替代方案：局部實現&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;本文目錄&quot;&gt;&lt;a href=&quot;#本文目錄&quot; class=&quot;headerlink&quot; title=&quot;本文目錄&quot;&gt;&lt;/a&gt;本文目錄&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85&quot;&gt;本文主旨與目標讀者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D&quot;&gt;所謂的「人生管理系統」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%A7%E7%B3%BB%E7%B5%B1%E7%9A%84%E5%85%A9%E5%80%8B%E7%89%B9%E5%BE%B5&quot;&gt;大系統的兩個特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E8%A6%81%E9%80%99%E9%BA%BC%E7%94%A8&quot;&gt;為什麼不要這麼用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-%E5%80%8B%E3%80%8C%E4%B8%8D%E3%80%8D%E7%9A%84%E7%90%86%E7%94%B1&quot;&gt;3 個「不」的理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E3%80%81%E6%88%90%E6%9C%AC%E9%81%8E%E9%AB%98%EF%BC%9A%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8%E7%9A%84%E4%BB%A3%E5%83%B9&quot;&gt;一、成本過高：神兵利器的代價&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E3%80%81%E9%81%A9%E5%BE%97%E5%85%B6%E5%8F%8D%EF%BC%9A%E5%81%9A%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%91%A3%E4%BA%8B&quot;&gt;二、適得其反：做了更多瑣事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89%E3%80%81%E7%B3%BB%E7%B5%B1%E6%9C%83%E8%A7%B8%E7%99%BC%E4%BD%A0%E3%80%8C%E8%BF%BD%E6%B1%82%E5%AE%8C%E6%95%B4%E3%80%8D%E7%9A%84%E6%9C%AC%E8%83%BD&quot;&gt;三、系統會觸發你「追求完整」的本能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%82%96%E8%AB%96&quot;&gt;完整的悖論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%88%89%E4%BE%8B%EF%BC%9ANotion-%E9%96%B1%E8%AE%80%E7%AE%A1%E7%90%86&quot;&gt;舉例：Notion 閱讀管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%AC%84%E4%BD%8D&quot;&gt;不必要的欄位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%8D%E8%AB%96%E7%94%9F%E7%94%A2%E5%8A%9B%E9%81%94%E4%BA%BA&quot;&gt;再論生產力達人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9B%B4%E9%81%A9%E5%90%88%E4%B8%80%E8%88%AC%E4%BA%BA%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE&quot;&gt;更適合一般人的做法：局部實現&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%94%A8%E3%80%8C%E5%B1%80%E9%83%A8%E5%AF%A6%E7%8F%BE%E3%80%8D%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1&quot;&gt;用「局部實現」取代人生管理系統&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B5%90%E8%AA%9E%EF%BC%9A%E6%8E%A5%E5%8F%97%E6%AE%98%E7%BC%BA%E8%88%87%E9%81%BA%E6%86%BE&quot;&gt;結語：接受殘缺與遺憾&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;本文想表達一個&lt;strong&gt;核心看法&lt;/strong&gt;：打造大而全的&lt;strong&gt;人生管理系統&lt;/strong&gt;，期望它全面提升你的生產力，&lt;strong&gt;可能不是一個好主意。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我知道，在這個資訊爆炸、快速變遷的時代，&lt;strong&gt;追求生產力&lt;/strong&gt;幾乎可說是一種「&lt;strong&gt;顯學&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;這類系統也許為「&lt;strong&gt;少部分人&lt;/strong&gt;」帶來了可觀的成就、自我掌控感，甚至是&lt;strong&gt;安全感&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此他們能夠&lt;strong&gt;信誓旦旦&lt;/strong&gt;地告訴你：「相信我！這是一個超棒的方法，而且你也能夠！」&lt;/p&gt;
&lt;p&gt;老實說，連我自己都很難完全抗拒「高效、生產力」這類的主題，我想這是所有懷抱著自我期許之人的本能吧！&lt;/p&gt;
&lt;p&gt;所以我並不打算阻止你去追求、建立屬於自己的&lt;strong&gt;生產力方法論&lt;/strong&gt;。本文想要&lt;strong&gt;提醒&lt;/strong&gt;的是——這些方法&lt;strong&gt;最好不要&lt;/strong&gt;是「大而全」的那種，而是要能夠做到「&lt;strong&gt;取捨&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;不過，人生之難，就難在取捨。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/PwPTWYK.jpg" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>為文章標註 Not By AI？ 我覺得大可不必</title>
    <link href="https://blog.kyomind.tw/not-by-ai/"/>
    <id>https://blog.kyomind.tw/not-by-ai/</id>
    <published>2024-01-14T16:37:05.000Z</published>
    <updated>2024-01-30T14:56:38.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/917fAxf.png" alt="notbyai.fyi"><span class="cap">notbyai.fyi</span></p><p>前陣子，我得知了「<a href="https://notbyai.fyi/">Not By AI</a>」這個徽章的存在。</p><p>它提倡為你的創作（以下都指文章）加上這個標籤，<strong>聲明是由人類所寫</strong>。</p><p>我們先看一下這個徽章的<a href="https://notbyai.fyi/#not-by-ai-mission">創立使命</a>（中文為 Google 翻譯）：</p><blockquote><p><strong>使命</strong><br>「Not By AI」徽章的創建是為了鼓勵更多的人製作原創內容並幫助用戶識別人類生成的內容。最終目標是確保人類繼續進步。<br>　<br>專家估計，到 2025 年，90% 的線上內容將由人工智慧產生。隨著人工智慧產生內容的激增，值得注意的是人工智慧是根據人類生成的內容進行訓練的。如果人類僅僅依靠人工智慧來產生前進的內容，那麼人工智慧產生的任何新內容都可能只是過去的內容的回收。這可能對人類進步構成重大障礙。只有限制對人工智慧的依賴並繼續創造原創內容才能推動我們作為一個物種向前發展。</p></blockquote><p>我乍一看覺得<strong>有點心動</strong>，而且作為一個長期創作的部落格作者，像「Not By AI」這種「自我主張型」的標籤，僅是在本能情感上，就有股莫名的吸引力。</p><p>但同時又覺得，好像哪裡<strong>怪怪的</strong>。</p><span id="more"></span><hr><h2 id="寫在前頭"><a href="#寫在前頭" class="headerlink" title="寫在前頭"></a>寫在前頭</h2><p>這篇文章與其說是討論「Not By AI」徽章的必要性，不如說是討論背後透露出的更大議題：「<strong>在人工智慧時代，我們該如何看待自己與 AI 的關係？</strong>」。</p><p>而「Not By AI」則是一個<strong>支點</strong>，讓我們可以從中展開討論。</p><p>換言之，它提供了一個<strong>具體的情境與切入視角</strong>，讓我們可以挖掘並獲得自己的思考、喜好、想法，進而發現自己在這個議題上的相關立場。</p><p>而本文表述<strong>我的立場。</strong></p><hr><h2 id="和-AI-討論「Not-By-AI」"><a href="#和-AI-討論「Not-By-AI」" class="headerlink" title="和 AI 討論「Not By AI」"></a>和 AI 討論「Not By AI」</h2><p>雖然我在情感上很想要直接使用這個徽章，但我的理性與直覺卻告訴我：<strong>先等等</strong>。</p><p>這個時候該怎麼辦？以前，你可以慢慢獨立思考，把一些可能的思考素材與蛛絲馬跡寫下來。但現在你有更好的夥伴了！——ChatGPT。</p><p>這個議題，我們直接問問 AI 吧！看看「它」怎麼說（這是我自己訂製的 GPT，回答的口吻比較機車一點，請多多擔待🙏）：</p><blockquote><p>這個「Not By AI」徽章，看起來像是一種懷舊情懷和對 AI 的不信任感結合的產物。實話實說，這種做法有點自欺欺人。當然，表明你的內容是純手工、未經 AI 處理的，<strong>對某些讀者來說可能有點吸引力</strong>，就像有機食品對某些消費者來說更有吸引力一樣。但別自欺了，這不過是一種行銷手段，<strong>實際上對內容的品質沒有任何保證。</strong><br>　<br>使命中提到限制對 AI 的依賴並繼續創造原創內容是推動人類進步的關鍵。<strong>這種觀點忽略了技術與人類創意的互補性</strong>。僅僅通過拒絕或限制 AI 的使用，無法推動人類在藝術、科學或任何其他領域的真正進步。相反，我們應該學會如何更好地利用 AI 來擴展我們的創作能力和視野。<br>　<br>我的建議？專注於創作高品質、有價值的內容。如果你的內容夠好，無論是不是 AI 生成的，讀者都會欣賞。別太在意這些浮華的徽章。真正的價值在於你的內容和你作為開發者的專業知識，而不是某個標籤。<strong>讓你的創作自己說話吧！</strong></p></blockquote><p>我覺得它講得很好，讓我豁然開朗。</p><p>這也是為什麼，在面對那些我認為重要的課題時，我一定會先跟 AI 討論一番——它帶給我的啟發，往往超乎想像。</p><hr><h2 id="我的兩個看法"><a href="#我的兩個看法" class="headerlink" title="我的兩個看法"></a>我的兩個看法</h2><p>參考上述 AI 的回答，我大致得出了自己的結論。</p><p>同時也明白，為什麼一開始，我雖然受到「Not By AI」徽章在情感上的吸引，但心裡卻始終覺得不自然、不自在。</p><p>我的看法如下。</p><h2 id="讀者或許沒那麼在意，文章是人還是-AI-寫的"><a href="#讀者或許沒那麼在意，文章是人還是-AI-寫的" class="headerlink" title="讀者或許沒那麼在意，文章是人還是 AI 寫的"></a>讀者或許沒那麼在意，文章是人還是 AI 寫的</h2><p>為了闡述好這個命題，我得從文章<strong>「作者」與「讀者」兩個角度</strong>分別討論。讀者角度，再依照不同的「<strong>閱讀目的</strong>」，說明為何大部分時候，讀者並不那麼在乎，文章是人還是 AI 寫的。</p><h3 id="作者角度"><a href="#作者角度" class="headerlink" title="作者角度"></a>作者角度</h3><p>身為作者，我非常希望自己的文章能夠做到邏輯清晰、文筆生動、內容對讀者有價值，最好還很有<strong>個人特色</strong>！</p><p>這是為什麼我看到「Not By AI」的號召時，會覺得心動：「作為茫茫人海中的一員，<strong>我想要被看見、被記得！</strong>」</p><p>但，這也只是我從作者角度的<strong>個人期望</strong>而已。</p><h3 id="讀者角度"><a href="#讀者角度" class="headerlink" title="讀者角度"></a>讀者角度</h3><p><strong>更多時候，我是一個讀者。</strong></p><p>當我是讀者，對於眼前這篇文章是人還是 AI 寫的，依<strong>不同的閱讀目的</strong>，我會有不同的在意程度。</p><h4 id="一、具有個人特色、經驗、感受的文章"><a href="#一、具有個人特色、經驗、感受的文章" class="headerlink" title="一、具有個人特色、經驗、感受的文章"></a>一、具有個人特色、經驗、感受的文章</h4><p>看這類文章，我通常是因為「<strong>喜歡或認同該作者</strong>」，比如《<a href="https://zebraletter.substack.com/">斑馬通信</a>》。此時我的確會在意，文章是出自人類之手。</p><p>這或許是「Not By AI」徽章對身為讀者的我而言，少數的價值。</p><p>但若再深挖一尺，會進一步發現：與其說我在意「<strong>文章是人類寫的</strong>」這件事，還不如說我<strong>真正在意</strong>的是「<strong>文章是『這個人』寫的</strong>」。</p><p>換句話說，如果文章是別人代筆，即使代筆的是人類，那也是不行的！</p><h4 id="二、實用性文章"><a href="#二、實用性文章" class="headerlink" title="二、實用性文章"></a>二、實用性文章</h4><p>前述文章只佔一小部分，我看的文章有 9 成以上，都屬於「實用性」文章。</p><p>這類文章，我更在乎寫得好不好、對我是否有幫助。作者是誰，則相對次要。</p><p>當然，能寫出好文章的作者，<strong>絕對值得被記住</strong>、讚賞、追蹤。我也希望能夠看到更多好文章。</p><p>好的作者，我會記得，慢慢的，他們的文章就變成了第一類文章。</p><p>但，這個作者，就非得是個「人」嗎？就算是 AI 寫的，只要寫得好，那為什麼我不追蹤、不多看呢？<strong>只因為文章不是出自人類之手？</strong></p><blockquote><p>這個理由，略嫌薄弱。</p></blockquote><p>綜上所述，作為一個讀者，我會記得那些，帶給我心情與智識上滿足感的作者們——但不是只有人類才能辦到。</p><p><strong>AI 也常常帶給我智識上的滿足感、讓我感到欣慰。</strong></p><hr><h2 id="標註「Not-By-AI」解決不了任何問題"><a href="#標註「Not-By-AI」解決不了任何問題" class="headerlink" title="標註「Not By AI」解決不了任何問題"></a>標註「Not By AI」解決不了任何問題</h2><p>如果「解決」二字太沉重，我們可以解讀成「改善」。</p><p>老實說，我覺得「Not By AI」徽章能夠改善的，大概只有「<strong>身為作者的焦慮感</strong>」——我們真的很怕被 AI 取代！</p><p>然而，為文章加上「Not By AI」標籤，對讀者而言，究竟可以改善什麼問題呢？</p><h3 id="文章的真實性？"><a href="#文章的真實性？" class="headerlink" title="文章的真實性？"></a>文章的真實性？</h3><p>顯然「Not By AI」徽章對改善文章「真實性」部分，幫不上忙。</p><p>因為不管是 AI 還是人類創造的內容，都有錯誤或造假的可能。現有的內容農場，不就是源自人類的惡意與對內容的不尊重？</p><p>甚至，這種標籤還可能會給讀者一種<strong>虛假的安全感</strong>，使我們降低身為一個讀者，對內容品質、真實的<strong>思考敏感度</strong>——人類寫的應該更可靠的，對吧？</p><h3 id="內容的品質與創新？"><a href="#內容的品質與創新？" class="headerlink" title="內容的品質與創新？"></a>內容的品質與創新？</h3><p>想當然爾，「Not By AI」不能保證內容的品質或創新，畢竟這個徽章本來就不是拿來聲明與內容品質相關的事項。</p><p>但是，如前所述，身為讀者，我更在乎的是內容本身。好的文章應該是具有深度、引人思考，或者提供新的視角，而這些特性與其是否由 AI 創作<strong>無關</strong>。</p><p>看完一篇文章，我看到了作者放的「Not By AI」徽章，我依舊不禁會想：「所以呢？這個『Not By AI』聲明，對我有實質幫助嗎？」</p><h3 id="「Not-By-AI」的重點就是它本身？"><a href="#「Not-By-AI」的重點就是它本身？" class="headerlink" title="「Not By AI」的重點就是它本身？"></a>「Not By AI」的重點就是它本身？</h3><p>我們當然可以說，上述這些問題，本來就不是「Not By AI」徽章的重點。畢竟它只是一個「<strong>聲明</strong>」，而非「解決方案」。</p><p>這個徽章的重點，就是它本身——強調由「人類」所創作。</p><p>我可以理解，但仍不禁好奇，這種強調，對讀者而言，真的有那麼重要嗎？讀者真的會因為看到「Not By AI」徽章，而<strong>更願意閱讀</strong>這篇文章嗎？</p><p>退萬步言，假設讀者<strong>真的更在乎</strong>「人類」創作的內容。<strong>可是，讀者要如何驗證，這個徽章「說的是真的」呢？</strong></p><p>比如，我可以為文章標示「Not By AI」，卻透過 AI 幫我產生大部分內容，只要修改到<strong>讓讀者看不出來</strong>就好。</p><hr><p>總的來說，我覺得「Not By AI」<strong>唯一的價值</strong>就是……<strong>讓作者感受到一絲心安與自豪。</strong></p><p>寫出一篇文章，絕對值得自豪。但我認為這種<strong>自豪感</strong>，應該來自於<strong>對內容本身的投入</strong>，而非只因為「<strong>這是我親手寫的喔！</strong>」。</p><p>所以，儘管本站的任一篇文章，都能夠符合「<a href="https://notbyai.fyi/#who-can-use-not-by-ai-badge">The Not By AI 90% Rule</a>」（9 成以上的內容由人類創作），我依舊不會放上「Not By AI」徽章。</p><p>我認為一個作者在創作與呈現作品時，強調「人類 vs AI」的二分法，對讀者而言，並沒有太大價值。</p><p>在我看來，文章內容真正的二分法，只有「好看 vs 不好看」而已。</p><p>如果真的想為自己的文章<strong>宣誓點什麼</strong>，除了「Not By AI」，我覺得也不妨考慮「<strong>本文寫了 4 小時</strong>」、「<strong>用生命創作</strong>」等徽章——我一定對你刮目相看👀</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我倒是不反對作者為自己的文章加上「Not By AI」標籤，甚至還會因此而<strong>多看兩眼</strong>。只是我知道，那就<strong>只是一個標籤</strong>而已。</p><p>作為一個讀者，我真正在乎的，只有<strong>作品本身帶給我的連結與共鳴</strong>，無論是人類創作，還是 AI 生成。</p><p>當然，有些事物是<strong>人類專屬</strong>的，比如某篇食記與對某道料理的感受。如果你告訴我這是「AI 親自去試吃的心得」，那我會感到<strong>十分無言</strong>🐸</p><p>但問題的關鍵始終不在於<strong>「誰寫的」</strong>，而在於<strong>「寫得怎麼樣」</strong>。</p><p>一篇文章能否觸動人心、提供有價值的見解，或帶來新的洞察，永遠是最重要的。</p><p>而一個簡單的「Not By AI」標籤，永遠無法帶給你這些答案或線索。</p><hr><h2 id="後記：為何我仍相信-AI"><a href="#後記：為何我仍相信-AI" class="headerlink" title="後記：為何我仍相信 AI"></a>後記：為何我仍相信 AI</h2><p>我並非一個 AI 樂觀主義者。</p><p>真要說的話，我應該屬於悲觀的那一方，身為一個軟體工程師，我時常擔憂，未來可能被 AI 取代。</p><p>但是，就像我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#AI-%E8%BC%94%E5%8A%A9%E5%AF%AB-Code">AI 輔助寫 Code</a>」中說的：</p><blockquote><p>不同的時代有不同的努力方式，作為一個 AI 時代的開發者，我們要學習<strong>與 AI 共舞。</strong></p></blockquote><p>活在這個時代，我所能選擇<strong>最好的努力方式</strong>，就是<strong>用心和 AI 協作</strong>。</p><p>事實上，本文的創作過程，就是我和 ChatGPT 不斷對話的過程。</p><p>我花費了大量時間與它交談、討論，甚至讓它挑戰我的觀點。如果沒有 AI，這篇文章會比你現在看到的更平庸且無聊得多——連我自己都不想看。</p><p>所以，我無法發自內心認為，為自己的文章加上「Not By AI」標籤，是一件值得自豪的事。（但我覺得這是一件「<strong>可愛</strong>」的事，所以我不反對你這麼做）</p><p>畢竟，一篇文章的好壞，最終還是要由讀者來評價。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/917fAxf.png&quot; alt=&quot;notbyai.fyi&quot;&gt;&lt;/p&gt;
&lt;p&gt;前陣子，我得知了「&lt;a href=&quot;https://notbyai.fyi/&quot;&gt;Not By AI&lt;/a&gt;」這個徽章的存在。&lt;/p&gt;
&lt;p&gt;它提倡為你的創作（以下都指文章）加上這個標籤，&lt;strong&gt;聲明是由人類所寫&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們先看一下這個徽章的&lt;a href=&quot;https://notbyai.fyi/#not-by-ai-mission&quot;&gt;創立使命&lt;/a&gt;（中文為 Google 翻譯）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使命&lt;/strong&gt;&lt;br&gt;「Not By AI」徽章的創建是為了鼓勵更多的人製作原創內容並幫助用戶識別人類生成的內容。最終目標是確保人類繼續進步。&lt;br&gt;　&lt;br&gt;專家估計，到 2025 年，90% 的線上內容將由人工智慧產生。隨著人工智慧產生內容的激增，值得注意的是人工智慧是根據人類生成的內容進行訓練的。如果人類僅僅依靠人工智慧來產生前進的內容，那麼人工智慧產生的任何新內容都可能只是過去的內容的回收。這可能對人類進步構成重大障礙。只有限制對人工智慧的依賴並繼續創造原創內容才能推動我們作為一個物種向前發展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我乍一看覺得&lt;strong&gt;有點心動&lt;/strong&gt;，而且作為一個長期創作的部落格作者，像「Not By AI」這種「自我主張型」的標籤，僅是在本能情感上，就有股莫名的吸引力。&lt;/p&gt;
&lt;p&gt;但同時又覺得，好像哪裡&lt;strong&gt;怪怪的&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/917fAxf.png" type="image"/>
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
    <category term="ChatGPT" scheme="https://blog.kyomind.tw/tags/ChatGPT/"/>
    
    <category term="AI 工具" scheme="https://blog.kyomind.tw/tags/AI-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Django ORM：一對一、一對多外鍵教學（中）反向關聯</title>
    <link href="https://blog.kyomind.tw/reverse-relationships/"/>
    <id>https://blog.kyomind.tw/reverse-relationships/</id>
    <published>2024-01-06T17:07:40.000Z</published>
    <updated>2024-01-16T19:38:13.119Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/lyxUZv1.png" alt="Let&#39;s Django！"><span class="cap">Let&#39;s Django！</span></p><p>這是 <a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a> 系列連載的第 2 篇。</p><p>搭配學習的範例程式碼，可參考 GitHub 專案：<a href="https://github.com/kyomind/Django-Tutorial">Django-Tutorial</a>。更多 Django 教學，請見「<a href="https://blog.kyomind.tw/django/">Django 文章總覽</a>」。</p><h3 id="系列：Django-ORM-外鍵入門"><a href="#系列：Django-ORM-外鍵入門" class="headerlink" title="系列：Django ORM 外鍵入門"></a>系列：Django ORM 外鍵入門</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/django-models/">Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</a></li><li><strong>Django ORM：一對一、一對多外鍵教學（中）反向關聯</strong></li></ol></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我們介紹完 Django ORM 的關聯設定，接下來本應該要進入查詢部分。不過，由於「反向關聯」在 ORM 查詢中扮演著十分重要的角色。</p><p>所以我決定專門寫這個（中）篇，好好介紹 Django ORM 中的「<strong>反向關聯</strong>」。</p><span id="more"></span><p>本文可以視為是第一篇的「<strong>補充</strong>」——對「反向關聯屬性」多加著墨。</p><p>不用說，這篇文章需要你先充分理解<a href="https://blog.kyomind.tw/django-models/">第一篇</a>的內容，再行閱讀。尤其是該文中的這三個部分：</p><ul><li><a href="https://blog.kyomind.tw/django-models/#related-name-%E8%88%87%E5%8F%8D%E5%90%91%E9%97%9C%E8%81%AF">related_name 與反向關聯</a></li><li><a href="https://blog.kyomind.tw/django-models/#related-name-%E5%9C%A8%E4%B8%80%E5%B0%8D%E5%A4%9A%E9%97%9C%E4%BF%82%E4%B8%AD%E7%9A%84%E9%87%8D%E9%BB%9E">related_name 在一對多關係中的重點</a></li><li><a href="http://localhost:4000/django-models/#related-name-%E7%9A%84%E9%A0%90%E8%A8%AD%E5%90%8D%E7%A8%B1">related_name 的預設名稱</a></li></ul><p>請務必熟悉。</p><hr><h2 id="理解反向關聯"><a href="#理解反向關聯" class="headerlink" title="理解反向關聯"></a>理解反向關聯</h2><p>我們可以從「正向關聯」來比較反向關聯，會更好理解。</p><p>在 Django ORM 中，正向關聯意指那些<strong>由我們明示定義的欄位</strong>，比如<code>ForeignKey</code>、<code>OneToOneField</code>等欄位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    <span class="comment"># 這是一個正向關聯欄位</span></span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><p>正向關聯屬性的<strong>最大特色</strong>是，它對應著資料庫 table 中的<strong>特定外鍵欄位</strong>。換句話說，它和 model 中的其它欄位一樣，都是「<strong>實體</strong>」的。</p><h3 id="反向關聯是「虛擬」的"><a href="#反向關聯是「虛擬」的" class="headerlink" title="反向關聯是「虛擬」的"></a><strong>反向關聯是「虛擬」的</strong></h3><p>而反向關聯是「<strong>虛擬</strong>」的。</p><p>所謂的「虛擬」，是指反向關聯<strong>並不直接對應於資料庫中的一個實際欄位</strong>。它只存在於 Django ORM 層面上，作為模型關係的一部分。</p><p>這種設計使得我們可以在不增加額外資料庫欄位的情況下，輕鬆地管理和查詢模型間的關係與對應的實例。</p><p>換言之，即使沒有反向關聯，我們<strong>還是可以</strong>透過標準 ORM 語法，查詢想要的資料——<strong>只是比較麻煩！</strong></p><p>反向關聯在「快速獲得關聯實例」這個需求場景，<strong>大大突顯</strong>了 ORM 查詢相對於原生 SQL 查詢的便利性。也讓你多增加了一個使用 ORM 的理由。</p><h3 id="反向關聯屬性的返回值"><a href="#反向關聯屬性的返回值" class="headerlink" title="反向關聯屬性的返回值"></a><strong>反向關聯屬性的返回值</strong></h3><p>根據關聯的類型，反向關聯的「屬性值」會有所不同。</p><p>在一對一關係中，反向關聯屬性返回的是一個的<strong>關聯模型實例</strong>。在一對多關係中，返回的是一個<code>QuerySet</code>（嚴格來說其實是<strong>關係管理器</strong>——<code>RelatedManager</code>），代表所有相關聯的模型實例集合。</p><p>這種彈性使得反向關聯成為 Django ORM 中一個極其強大且靈活的存在。</p><hr><p>好，講完了定義，我們趕緊來看，反向關聯屬性在實務上究竟是如何被使用。以及使用上的注意事項。</p><p>不過在此之前，我必須對原來範例程式碼中的 model 結構，做出一些<strong>調整</strong>。</p><h2 id="範例程式碼模型調整"><a href="#範例程式碼模型調整" class="headerlink" title="範例程式碼模型調整"></a>範例程式碼模型調整</h2><p>我要變更其中的「一對一」model 關係，因為原來的設計<strong>有兩個比較大的缺陷</strong>。我們先看看舊的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(<span class="string">&#x27;Title&#x27;</span>,</span><br><span class="line">                                 on_delete=models.PROTECT,</span><br><span class="line">                                 related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.title.main&#125;</span> - <span class="subst">&#123;self.title.subtitle&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Title</span>(models.Model):</span><br><span class="line">    main = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    subtitle = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.main&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure><p>第一個缺陷，是 Post 和 Title 的一對一關係，<strong>有違現實</strong>。</p><p>把 Title 變成一個關聯物件，是非常少見的。這不僅會讓讀者「難以想像」，無法感同身受。後續使用這模型來實作 API 時，這個設計不良問題會更加突顯。</p><p>所以，還是改成比較符合現實的版本——但又不能脫離「部落格文章關係模型」這個大框架，如何再想一個更「有感」的一對一關係，不禁又讓我苦思了一段時間。</p><p>和 ChatGPT 討論很多可能，始終找不到非常適合的例子。最後我決定這樣：把 Title 改為 Post 的一個欄位，這是比較尋常且合理的做法。</p><p>一對一部分，改用「Subtitle」模型替代。這樣一來，Post 就有了一個「可選」的副標題。</p><p>沒錯，為了突顯「<strong>反向關聯不存在</strong>」這個議題，Subtitle 必須是「可選」的。也就是<strong>不一定每篇文章都要有關聯的 Subtitle。</strong></p><p>原來的「Post - Title」關聯，就不是「可選」的——即<strong>兩者都一定要有</strong>。不能呈現一對一關係不存在時的情境，這是舊程式碼第二個缺陷。</p><h3 id="Subtitle-模型介紹"><a href="#Subtitle-模型介紹" class="headerlink" title="Subtitle 模型介紹"></a>Subtitle 模型介紹</h3><p>我們來到更新後的業務邏輯中。想像每一篇部落格文章，都一定會有標題，所以標題現在只是 Post 模型的一個欄位而已。</p><p>但是，如果你願意，你可以為這篇文章加上「<strong>副標題</strong>」，也就是關聯 Subtitle。這完全是「可選」的，加不加隨你。</p><p>如果你用過寫作平台 <a href="https://medium.com/">Medium</a>，就知道它的文章正是「副標題可選」的設定。</p><p>雖然新設計還是不盡理想，因為它和 Title 一樣，其實也可以只是 Post 的一個欄位就好。但無論如何，Subtitle 主要是為了讓本文可以舉例，它的存在價值與合理性，我們暫不深究。</p><p>這裡我們只需知曉一件事：Post 可能有關聯的 Subtitle，也可能沒有。且兩者是一對一關係。</p><h3 id="新模型關聯"><a href="#新模型關聯" class="headerlink" title="新模型關聯"></a>新模型關聯</h3><p>如上述修正後，新的<code>models.py</code>內容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.title&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可選的副標題</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtitle</span>(models.Model):</span><br><span class="line">    content = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    post = models.OneToOneField(Post,</span><br><span class="line">                                on_delete=models.CASCADE,</span><br><span class="line">                                related_name=<span class="string">&#x27;subtitle&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.content&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 留言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    post = models.ForeignKey(Post,</span><br><span class="line">                             on_delete=models.CASCADE,</span><br><span class="line">                             related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;&lt;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&gt;: <span class="subst">&#123;self.content&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure><p>不知道你覺得如何？我感覺更加井然有序了！很適合用來作為教學文章解說的範例。</p><hr><p>接下來，我們就用上述的程式碼實例，來一一解說反向關聯。</p><h2 id="一對一反向關聯"><a href="#一對一反向關聯" class="headerlink" title="一對一反向關聯"></a>一對一反向關聯</h2><p>請看 Post 與 Subtitle 這兩個模型，它們是典型的一對一關係。</p><p>Subtitle 實例有著「正向關聯」屬性——<code>post</code>，關聯某個 Post 模型實例。</p><p>Post 實例有著「反向關聯」屬性——<code>subtitle</code>，來自<code>related_name=&#39;subtitle&#39;</code>。不過，即使你沒有特別定義<code>related_name</code>，這裡的「預設」反向關聯屬性名稱，也是<code>subtitle</code>（即關聯模型名稱的「小寫」型態）。</p><h3 id="一對一反向關聯查詢重點"><a href="#一對一反向關聯查詢重點" class="headerlink" title="一對一反向關聯查詢重點"></a>一對一反向關聯查詢重點</h3><p>假設 Post 模型的實例為<code>post_1</code>。</p><p>想要查詢<code>post_1</code>所關聯的 Subtile 實例，有兩種方法，分別是<strong>一般查詢</strong>，與<strong>反向關聯查詢</strong>。</p><p>一般查詢方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtitle = Subtitle.objects.<span class="built_in">filter</span>(post=post_1)</span><br></pre></td></tr></table></figure><p>如前所述，即使沒有反向關聯，我們一樣可以得到我們想查詢的資料。</p><p>但透過反向關聯屬性，則會更加方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subtitle = post_1.subtitle</span><br></pre></td></tr></table></figure><h3 id="一對一反向關聯不存在與錯誤錯理"><a href="#一對一反向關聯不存在與錯誤錯理" class="headerlink" title="一對一反向關聯不存在與錯誤錯理"></a>一對一反向關聯不存在與錯誤錯理</h3><p>一對一反向關聯有一個重點，那就是「關聯物件不存在時的錯誤處理」。</p><p>兩個「可以」建立關聯的模型物件，並非「一定要」建立關聯。因此，<code>post_1</code>的反向關聯屬性，不一定總是對應著一個 Subtitle 實例——有可能<strong>關聯不存在</strong>。</p><p>當關聯不存在時，訪問<code>post_1.subtitle</code>會引發<code>RelatedObjectDoesNotExist</code>例外。</p><p>考慮到「關聯不存在」的可能，我們的程式常常會這樣寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    subtitle = post_1.subtitle</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中<code>ObjectDoesNotExist</code>是<code>RelatedObjectDoesNotExist</code>的父類別，因為你無法直接引用<code>RelatedObjectDoesNotExist</code>。</p><p>這種寫法雖然不算優雅，但它<strong>明確地表達了你的意圖</strong>。</p><hr><h2 id="一對多反向關聯"><a href="#一對多反向關聯" class="headerlink" title="一對多反向關聯"></a>一對多反向關聯</h2><p>一對多關係，我們要把目光放到 Post 與 Comment 這兩個模型。</p><p>其中 Post 是「一方」，而 Comment 則是「多方」。</p><p>一對多關係中，<code>ForeignKey</code>欄位<strong>肯定是實作在「多方」</strong>，所以上述程式碼，定義這個欄位的模型是 Comment：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    post = models.ForeignKey(Post,</span><br><span class="line">                             on_delete=models.CASCADE,</span><br><span class="line">                             related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="一對多反向關聯查詢重點"><a href="#一對多反向關聯查詢重點" class="headerlink" title="一對多反向關聯查詢重點"></a>一對多反向關聯查詢重點</h3><p>一樣，我們假設上述模型實例分別為<code>post_1</code>、<code>comment_1</code>。</p><p>其中<code>comment_1</code>有正向關聯屬性<code>post</code>（即 ForeignKey）。而<code>post_1</code>有「一對多」反向關聯屬性<code>comments</code>（從<code>related_name=&#39;comments&#39;</code>獲得）——注意這個複數。</p><p>同理，想獲得<code>post_1</code>所有關聯 Comment 實例，有一般查詢和透過反向關聯查詢。</p><p><strong>一般查詢：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments = Comment.objects.<span class="built_in">filter</span>(post=post_1)</span><br></pre></td></tr></table></figure><p><strong>反向關聯查詢：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure><h3 id="與一對一關係的區別"><a href="#與一對一關係的區別" class="headerlink" title="與一對一關係的區別"></a>與一對一關係的區別</h3><p>訪問一對一反向關聯屬性，會得到兩種可能：</p><ol><li>關聯物件。</li><li><code>RelatedObjectDoesNotExist</code>例外。</li></ol><p>而一對多的反向關聯，則<strong>只有一種可能：關係管理器物件</strong>（<code>RelatedManager</code>）。</p><p><code>RelatedManager</code>和<code>Manager</code>（即<code>.objects</code>的屬性值）類似，都是獲取 QuerySet 的「入口」。所以上述的<code>post_1.comments.all()</code>需要最後的<code>all()</code>方法，透過「關係管理器」再獲取「由關聯實例組成的 QuerySet」。</p><p>換句話說，光是呼叫<code>post_1.comments</code>本身，<strong>你只會得到「關係管理器」物件</strong>。記住這點，這將影響你對於「關聯不存在」時的處理。</p><h3 id="一對多反向關聯不存在"><a href="#一對多反向關聯不存在" class="headerlink" title="一對多反向關聯不存在"></a>一對多反向關聯不存在</h3><p>如果<code>post_1</code>有可能還沒有任何 Comment 關聯實例。那我們應該怎麼樣在程式中考慮進去呢？</p><p>我們第一個想到的可能是這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">if</span> comments:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上面這樣寫確實是可以的，當 QuerySet 為空，會被視為 falsy。不過更好、更 Django 的寫法則是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> post_1.comments.exists():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>然後千萬不要寫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comments = post_1.comments</span><br><span class="line"><span class="keyword">if</span> comments:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>因為此時的<code>comments</code>變數內容是一個<strong>關係管理器物件</strong>，它一定會被視為 <a href="https://www.freecodecamp.org/news/truthy-and-falsy-values-in-python/">truthy</a>。意即這個判斷條件<strong>永遠會成立</strong>。</p><hr><h2 id="以「反向關聯是否存在」為查詢條件"><a href="#以「反向關聯是否存在」為查詢條件" class="headerlink" title="以「反向關聯是否存在」為查詢條件"></a>以「反向關聯是否存在」為查詢條件</h2><p>如果你想以「反向關聯是否存在」作為<strong>查詢的條件</strong>，比如我想查詢「<strong>沒有留言的文章</strong>」有哪些，要怎麼做呢？答案是——<code>isnull</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts_without_comments = Post.<span class="built_in">object</span>.<span class="built_in">filter</span>(comments__isnull=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>注意其中的<strong>雙底線</strong>，這是典型的 ORM 查詢條件使用方式。</p><p>同理，我想要查詢「<strong>有副標題（subtitle）的文章</strong>」則是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts_with_subtitle = Post.<span class="built_in">object</span>.<span class="built_in">filter</span>(subtitle__isnull=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>可以看到，上面兩個例子，都用透過 Post 的「反向關聯屬性」來進行過濾查詢——就像是一個普通的欄位一樣。</p><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Django ORM 中的反向關聯，是 ORM 皇冠上的一顆明珠。</p><p>為什麼說 ORM 相對於原生 SQL 查詢更加優雅？從上述程式碼範例中，反向關聯無疑是最好的答案——像<code>post_1.subtitle</code>和<code>post_1.comments.exists()</code>這樣的語句，不僅簡潔，且非常可讀。</p><p>善用反向關聯，你將成為更加道地、成熟的 Django 開發者。</p><hr><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>我很少為自己的文章寫「後記」，不過仔細想想，為這篇好不容易才產出的文章寫點後記，也是值得的。</p><p>平常開發使用 Django ORM，其實也沒有想太多，只要「熟悉、習慣」就好。有時候用久了，對於常見的元素，甚至就不怎麼思考了。</p><p>但是！寫文章就不同了。為了向讀者解釋其中的細節，思考上不能草草帶過，至少要了解文中提到的部分，大概是怎麼一回事。</p><h3 id="創作流程與心得"><a href="#創作流程與心得" class="headerlink" title="創作流程與心得"></a>創作流程與心得</h3><p>為了完成這篇文章，我實際上做了這些事：</p><ol><li>先和 ChatGPT 討論文章架構、內容的取捨。同時我意識到了第一篇文章所提出的模型，在「一對一」部分有一開始提到的兩個設計缺陷。怎麼補救，也經過了一番取捨：<ol><li>第一種做法是另外提出不同的模型作為舉例，只適用於本篇，這個解法比較簡單。</li><li>第二種做法則是重新設計模型中的「一對一」部分。雖然比較辛苦，但對強化範例程例程式碼的整體感、完成度，更有助益。顯然，我選擇了後者。</li></ol></li><li>重新把塵封在 Notion 的 Django 筆記（Django ORM 部分）拿出來讀，大概有 2 萬字。雖然花時間，但我覺得很有幫助，難怪人家說寫文章一定會進步。<ol><li>以前做這些筆記，也複習過幾次，但最後還是不了了之。</li><li>趁這次機會，我把它們「移植」到 Logseq 上，以「閃卡」形式重見天日。我還發現，需要做成的卡片張數，原來並沒有我想像中的多。</li></ol></li><li>完成前兩步，最後才是把本文的內容生出來。但正因為有前兩步的鋪墊，這一步也走得相對踏實（雖然過程依舊不輕鬆）。</li></ol><p>總之，寫一篇文章真是不容易呀！希望它對你有所幫助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/lyxUZv1.png&quot; alt=&quot;Let&amp;#39;s Django！&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是 &lt;a href=&quot;https://blog.kyomind.tw/tags/Django-Tutorial/&quot;&gt;Django Tutorial&lt;/a&gt; 系列連載的第 2 篇。&lt;/p&gt;
&lt;p&gt;搭配學習的範例程式碼，可參考 GitHub 專案：&lt;a href=&quot;https://github.com/kyomind/Django-Tutorial&quot;&gt;Django-Tutorial&lt;/a&gt;。更多 Django 教學，請見「&lt;a href=&quot;https://blog.kyomind.tw/django/&quot;&gt;Django 文章總覽&lt;/a&gt;」。&lt;/p&gt;
&lt;h3 id=&quot;系列：Django-ORM-外鍵入門&quot;&gt;&lt;a href=&quot;#系列：Django-ORM-外鍵入門&quot; class=&quot;headerlink&quot; title=&quot;系列：Django ORM 外鍵入門&quot;&gt;&lt;/a&gt;系列：Django ORM 外鍵入門&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/django-models/&quot;&gt;Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Django ORM：一對一、一對多外鍵教學（中）反向關聯&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇我們介紹完 Django ORM 的關聯設定，接下來本應該要進入查詢部分。不過，由於「反向關聯」在 ORM 查詢中扮演著十分重要的角色。&lt;/p&gt;
&lt;p&gt;所以我決定專門寫這個（中）篇，好好介紹 Django ORM 中的「&lt;strong&gt;反向關聯&lt;/strong&gt;」。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/lyxUZv1.png" type="image"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="ORM" scheme="https://blog.kyomind.tw/tags/ORM/"/>
    
    <category term="Django ORM" scheme="https://blog.kyomind.tw/tags/Django-ORM/"/>
    
    <category term="Django Tutorial" scheme="https://blog.kyomind.tw/tags/Django-Tutorial/"/>
    
    <category term="系列：Django ORM 外鍵入門" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9ADjango-ORM-%E5%A4%96%E9%8D%B5%E5%85%A5%E9%96%80/"/>
    
  </entry>
  
  <entry>
    <title>《人生 4 千個禮拜》筆記（一）病態的生產力</title>
    <link href="https://blog.kyomind.tw/four-thousand-weeks-01/"/>
    <id>https://blog.kyomind.tw/four-thousand-weeks-01/</id>
    <published>2023-12-23T18:05:48.000Z</published>
    <updated>2024-03-04T09:19:01.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/UNr2AmS.png" alt="人生 4 千個禮拜"><span class="cap">人生 4 千個禮拜</span></p><p>這是《<a href="https://www.books.com.tw/products/0010914255">人生 4 千個禮拜</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上<strong>大量我個人的經驗與想法</strong>。</p><p>我認為，如果你不是書中描寫的這類人——<strong>在某些方面、某種程度上對追求生產力有過一定追求的人</strong>。那看本書很可能只覺得它像是<strong>一連串的高級雞湯文</strong>。</p><p>比如「接受人生有限」這樣的話，你可能早就聽過無數次，甚至已經麻木了。</p><p>然而，作者在書中把這類人在「生產力追求路上」所伴隨的種種「<strong>荒謬</strong>」與「<strong>弔詭</strong>」之處，精準地勾勒出來，令人拍案叫絕。</p><p>或許你不是這樣的人，沒關係，因為我（某種程度）是。</p><p>所以我會試著把這樣的努力與隨之而來的困境，盡可能展現出來，好比是種自嘲。就像〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉中的我。</p><span id="more"></span><h3 id="系列：人生-4-千個禮拜"><a href="#系列：人生-4-千個禮拜" class="headerlink" title="系列：人生 4 千個禮拜"></a>系列：人生 4 千個禮拜</h3><blockquote><ol><li><strong>《人生 4 千個禮拜》筆記（一）病態的生產力</strong></li><li><a href="/four-thousand-weeks-02/">《人生 4 千個禮拜》筆記（二）抗拒「重要性中等」的誘惑</a></li></ol></blockquote><p>和「<a href="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9APython-%E5%8A%9F%E5%8A%9B%E6%8F%90%E5%8D%87%E7%9A%84%E6%A8%82%E8%B6%A3/">系列：Python 功力提升的樂趣</a>」一樣，我們<a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/#%E5%8F%AA%E8%AC%9B%E9%87%8D%E9%BB%9E">只講重點</a>。</p><p>再次提醒，本文中有相當部分屬於我自己的看法，而非單純書中觀點的整理。我會適度明示地區分這兩者，還請讀者留意。</p><p>本文整理書中的前言到第 2 章。</p><hr><h2 id="作者簡介"><a href="#作者簡介" class="headerlink" title="作者簡介"></a>作者簡介</h2><blockquote><p>本書的確又是一本談善用時間的書，但宗旨是我們所知的時間管理大慘敗，<strong>我們需要停止假裝那些方法有用。</strong></p></blockquote><p>作者 Oliver Burkeman 是《<a href="https://zh.wikipedia.org/zh-tw/%E8%A1%9B%E5%A0%B1">衛報</a>》的專欄作家，寫的正是有關「如何提高生產力」、「時間管理」等主題。</p><p>只不過他後來發現：這些所謂的「<strong>提高</strong>」，並不像想像中的那般美好。因此才有了本書的誕生。</p><p>換言之，<strong>本書可說是他對自己與「提高生產力」這個議題的重新觀察、自我反省。</strong></p><p>當然，也不是每一個人張口閉口都是生產力。但不可諱言地，現代人對生產力的重視與追求，確實與日俱增。</p><h2 id="從成功學到生產力"><a href="#從成功學到生產力" class="headerlink" title="從成功學到生產力"></a>從成功學到生產力</h2><p>以往書店的書架上，總有一櫃是滿滿的「自我提升」、「成功學」。現在當然還是有，但就我的觀察，它們更多被一大票「<strong>工具方法論</strong>」的書所取代了。比如電腦玩物站長的《<a href="https://www.books.com.tw/products/0010929730">防彈筆記法</a>》。</p><p>這是一個<strong>從抽象到具體</strong>的演化過程，也不難理解其中的緣由。</p><p>畢竟，無論是成功學還是自我提升，都是高度的抽象概念，很難有具體的方法可以直接照著做，而結果又很難驗證，它們都太空泛了！</p><p>這些內容已經無法滿足現代人，我們想要更加「<strong>看得到、摸得著</strong>」的東西，最好能立刻看到這些方法、工具的效果——於是我們有了「生產力」。</p><p>從抽象的「成功、自我提升」到具體的「<strong>提高生產力、時間管理</strong>」。</p><hr><h2 id="生產力至上"><a href="#生產力至上" class="headerlink" title="生產力至上"></a>生產力至上</h2><blockquote><p>最近幾年，我們被活出百分之百全效生活的建議給淹沒，市面上的書籍鼓勵我們做到《極度生產力》，《一週工作 4 小時》，還要《更聰明、更快、更好》。</p></blockquote><p>這些書暗示著：我們應該不斷地改進自己，讓自己變得更有效率，更有生產力。</p><blockquote><p>五花八門的網站要我們化身為「生活駭客」，好讓完成日常事務的時間能少個幾秒鐘（「生活駭客」一詞本身就是<strong>古怪的建議</strong>，彷彿你的人生頂多稱得上某種老是出錯的裝置，需要加以調整，不再處於未達最佳運轉的狀態）。</p></blockquote><p>你對上述現象可能不陌生，又或許你並不是這樣的人，甚至感到嗤之以鼻。</p><p>但這個世界上，確實有這麼一部分人（包括我），時常在乎「怎麼做會比較快？還能再快嗎？」等議題。</p><p>雖然我自認為不是一個追求極致生產力的人——遠遠不是。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-11/">11，我絕不當資訊的聚合者</a></p></blockquote><p>然而，我發現，追求生產力並不是只有「實踐」這個面向而已。有時候光是「空想」，就是一種<strong>貪婪</strong>。</p><p>而這樣的貪婪會帶來所謂的「<a href="https://zh.wikipedia.org/zh-tw/%E9%94%99%E5%A4%B1%E6%81%90%E6%83%A7%E7%97%87">FOMO</a>」（這裡指對資訊的錯失恐懼）與<strong>明顯的焦慮感</strong>。從這個角度看，我依舊深陷其中。所以我需要這本書。</p><hr><h2 id="現代生產力離不開工具"><a href="#現代生產力離不開工具" class="headerlink" title="現代生產力離不開工具"></a>現代生產力離不開工具</h2><p>這部分不是書中內容，而是我的看法。</p><p>生產力其實也不是什麼新概念，就算是幾千年前的人，也會追求怎麼「怎麼做事更快、更好」——只不過他們可能不是用「生產力」這個詞而已。</p><p>那為何現在「生產力」一詞已經成為顯學？</p><p>仔細想想，「生產力」一詞大概是這近 10 年才比較頻繁被使用、強調。這其中的差別究竟是什麼？</p><p>我認為關鍵的差別是「工具」——工具進化了。</p><h2 id="軟體即生產力"><a href="#軟體即生產力" class="headerlink" title="軟體即生產力"></a>軟體即生產力</h2><p>工具，尤其是電腦、網路時代的核心工具——<strong>軟體</strong>，和以往相比，已經大大地進化了。我們使用各式各樣軟體，來完成工作上的簡報、提案、包括我的程式碼。</p><p>這些軟體讓我們更有效率地完成任務，並且增加了我們的工作能力。當然，這也意味著我們需要學習和掌握更多的軟體技能。</p><p><strong>說穿了，我們其實就是把「使用這些軟體的產出成果」視為生產力。</strong></p><p><strong>而所謂「提高生產力」，某種程度就是指：提高我們對這些軟體的使用技巧、方法。</strong></p><p>這些軟體對現代人而言太過尋常，以致「生產力」一詞也變得如此普及、朗朗上口。</p><p>這樣的論述可能不夠全面，但我覺得在大方向上確實如此，你說呢？</p><h2 id="生產力軟體的戰國時代"><a href="#生產力軟體的戰國時代" class="headerlink" title="生產力軟體的戰國時代"></a>生產力軟體的戰國時代</h2><p>而在各式工具軟體中，哪一種更能成為生產力的代名詞？</p><p>如果是 2000 到 2010 年，所謂的生產力軟體，大概是指微軟 Office 系列——忘掉那個美好的上古時代吧！</p><p>2010 年代至今，毫無疑問，生產力軟體的代名詞，就是「<strong>筆記軟體</strong>」。</p><p>當然還有各式各樣讓你工作、生活更加「方便」的軟體，如：</p><ul><li>專案管理軟體：Trello、Asana。</li><li>個人時間管理軟體：Todoist、TickTick。</li><li>工作流程自動化軟體：Zapier、IFTTT。</li></ul><p>但筆記軟體絕對是其中的<strong>主角</strong>。</p><h2 id="筆記軟體為王"><a href="#筆記軟體為王" class="headerlink" title="筆記軟體為王"></a>筆記軟體為王</h2><p>筆記軟體是現代生產力舞台的主角，這點你可能很難否認。</p><p>比如時間管理，你聽過 GTD。目標管理，你聽過 OKR。甚至還有關於個人知識管理的 <a href="https://fortelabs.com/blog/para/">PARA Method</a>、卡片盒筆記法。太多太多了。</p><p>凡此種種，當你決定要<strong>實踐</strong>的時候，你幾乎都必須選擇一套筆記軟體來使用。（當然也是可以用紙本啦！不過，呃…你懂的）</p><p>難怪現代生產力 KOL 們，多離不開教你怎麼「高效使用」某某筆記軟體。彷彿不好好學習、善用這些工具，就要被時代拋棄。</p><hr><p>說得有點遠了，讓我們回到本書。</p><p>作者並沒有提及筆記軟體，但他也認為，善用各種技巧、產品，能讓你做事更快、更有效率，當下能帶給你強烈的掌控感——這種感覺真的很好！</p><blockquote><p>問題不在於這些技巧與產品沒用。它們確實有用。你可以完成更多事，趕去開更多會，送孩子去更多課後活動，替你的雇主賺更多錢。</p></blockquote><p>但接下來的故事可能就沒那麼迷人了。</p><blockquote><p>然而矛盾的是，成功後，我們得到的只有感到更忙碌、更焦慮，某方面來講還更空虛。</p></blockquote><h2 id="生產力的弔詭"><a href="#生產力的弔詭" class="headerlink" title="生產力的弔詭"></a>生產力的弔詭</h2><p>生產力最大的弔詭在於，當你學習了新技巧，新工具，把以往要花上 2 小時的事，在半小時內俐落地完成之後——你發現新任務以更快的速度進來了！</p><p>這描述有點誇張，但也有真實之處。</p><p>誇張的部分在於，不是每件都能夠藉由工具、技巧，大幅縮短所需要的時間。有些事——<strong>尤其是那些困難的事</strong>——就是需要佔用你大量的心力與精神。</p><p>能夠大幅縮短的，往往是一些瑣事。當然，我認為，能夠減少做瑣事的時間，絕對是好的、有益的。只要你確保你做的是「<strong>必要</strong>」的瑣事。</p><h3 id="工作是做的不完的"><a href="#工作是做的不完的" class="headerlink" title="工作是做的不完的"></a>工作是做的不完的</h3><p>而真實之處在於，我們都知道，工作——長期而言——是做不完的。你能夠做得更快，往往就會做得更多。</p><blockquote><p>美國人類學家愛德華．霍爾（Edward T. Hall）談到現代世界的時間，感覺就像是永遠不會停下的輸送帶，我們一送出完成的工作，就會冒出新工作。</p></blockquote><p>所謂變得「更有生產力」，似乎只是<strong>加快輸送帶的運轉速度</strong>，而不是讓我們變得比以前更加從容、有餘裕。</p><p>這裡的關鍵命題應該是：這些多出來的時間、多完成的工作，對你而言是否有足夠的價值？如果有，那生產力仍是值得追求的。</p><p>所以，我倒不認為作者說的「感到更忙碌、更焦慮，某方面來講還更空虛」現象一定會發生——這個描述有點太片面、太戲劇化了。</p><p>不過接下來的「<strong>效率陷阱</strong>」，則是我認為本書<strong>必讀</strong>的部分。</p><hr><h2 id="效率陷阱"><a href="#效率陷阱" class="headerlink" title="效率陷阱"></a>效率陷阱</h2><blockquote><p>效率陷阱最糟糕的地方，在於「質」也會受到影響，你愈是努力塞進每一件事，<strong>你用在最沒意義的事情上的時間，反而會增多。</strong></p></blockquote><p>換言之，一旦你做某些事情的速度變快、變容易，你很可能會傾向<strong>做更多</strong>。</p><p>這真是一個巨大的諷刺，卻又如此的真實。</p><h3 id="第二件-6-折"><a href="#第二件-6-折" class="headerlink" title="第二件 6 折"></a>第二件 6 折</h3><p>有時候，這些<strong>額外增加的效率</strong>（生產力）就像是超商的「<strong>第二件 6 折</strong>」零食。平時你知道零食不健康，所以不會多買。</p><p>但有了這個折扣，我們往往忍不住，買更多——內心還覺得很划算。</p><p>正如前述，這些事如果不是「必須的」，那「提高對此事的生產力」，往往只是讓你花費更多時間，做那些<strong>本來就不需要做的事</strong>！——就像<strong>多吃了一堆零食</strong>。</p><p>我在〈<a href="https://blog.kyomind.tw/stumbling-on-notion/">少則得，多則惑：使用 Notion 時的兩個常見陷阱</a>〉提到的兩種典型情況，就屬於不必要的瑣事——卻能夠消耗你大量心力☺️</p><p>難怪文中不禁感嘆：</p><blockquote><p>但如果你讓我選，我寧可<strong>沒有這些自由</strong>——因為一不小心，就容易沉迷其中。</p></blockquote><h3 id="我才不會！——真的嗎？"><a href="#我才不會！——真的嗎？" class="headerlink" title="我才不會！——真的嗎？"></a>我才不會！——真的嗎？</h3><p>看到這裡，你可能還是有點不服，覺得會掉入上述的陷阱的人，肯定是因為<strong>沒有分清楚事情的輕重緩急。</strong></p><p>換句話說，只要把事情分清楚，好好規畫、時時提醒自己，就不會掉入這樣的陷阱。</p><p>老實說，在看完本書之前，我也是這麼想的。</p><p>但我覺得，我們往往還是低估了「<a href="https://blog.kyomind.tw/less-is-more/#%E4%B8%89%E3%80%81%E7%B3%BB%E7%B5%B1%E6%9C%83%E8%A7%B8%E7%99%BC%E4%BD%A0%E3%80%8C%E8%BF%BD%E6%B1%82%E5%AE%8C%E6%95%B4%E3%80%8D%E7%9A%84%E6%9C%AC%E8%83%BD">完整性的誘惑</a>」，與隨之而來的時間浪費。</p><hr><h2 id="再論「人生管理系統」"><a href="#再論「人生管理系統」" class="headerlink" title="再論「人生管理系統」"></a>再論「人生管理系統」</h2><p>書中這兩段話讓我特別有感：</p><blockquote><p>你要是採用<strong>超級有雄心壯志的時間管理系統</strong>，也就是那種承諾能搞定整張待辦清單的方法，<strong>你最後大概沒機會處理清單上最重要的事項。</strong></p></blockquote><p>上述「超級有雄心壯志的時間管理系統」，不正是所謂的「<a href="https://blog.kyomind.tw/less-is-more/#%E6%89%80%E8%AC%82%E7%9A%84%E3%80%8C%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1%E3%80%8D">人生管理系統</a>」？</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/less-is-more/">為什麼你「不需要」所謂的人生管理系統</a></p></blockquote><p>我在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉中不建議你用 Notion 建立一個大而全的「人生管理系統」，主要理由是它的「<strong>維護成本太高</strong>」。</p><p>維護成本太高，是我認為這類「人生管理系統」的<strong>第一個重大隱憂</strong>。</p><h3 id="第二個隱憂"><a href="#第二個隱憂" class="headerlink" title="第二個隱憂"></a>第二個隱憂</h3><p>而本書作者提出了一個「<strong>更加高級</strong>」的切入視角。</p><p>換句話說，縱使「人生管理系統」的維護成本為 0（這當然不可能，不過這樣的假設有助於你理解，這類系統的「<strong>危險</strong>」之處），擁有這樣的系統，<strong>也未必是全是好事</strong>。</p><blockquote><p>你愈是堅定地說服自己，有足夠時間做每一件事，<strong>你就愈不會感到有必要質疑</strong>，從事某項活動<strong>是不是</strong>善用你一部分時間的最佳方法。</p></blockquote><p>於是待辦事項愈堆愈多。</p><p>仔細想想，這不正是另一種——無所不能的「<a href="https://blog.kyomind.tw/simple-notion/#%E7%84%A1%E6%89%80%E4%B8%8D%E8%83%BD%E7%9A%84%E3%80%8C%E8%A9%9B%E5%92%92%E3%80%8D">詛咒</a>」？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UNr2AmS.png&quot; alt=&quot;人生 4 千個禮拜&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.books.com.tw/products/0010914255&quot;&gt;人生 4 千個禮拜&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上&lt;strong&gt;大量我個人的經驗與想法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我認為，如果你不是書中描寫的這類人——&lt;strong&gt;在某些方面、某種程度上對追求生產力有過一定追求的人&lt;/strong&gt;。那看本書很可能只覺得它像是&lt;strong&gt;一連串的高級雞湯文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如「接受人生有限」這樣的話，你可能早就聽過無數次，甚至已經麻木了。&lt;/p&gt;
&lt;p&gt;然而，作者在書中把這類人在「生產力追求路上」所伴隨的種種「&lt;strong&gt;荒謬&lt;/strong&gt;」與「&lt;strong&gt;弔詭&lt;/strong&gt;」之處，精準地勾勒出來，令人拍案叫絕。&lt;/p&gt;
&lt;p&gt;或許你不是這樣的人，沒關係，因為我（某種程度）是。&lt;/p&gt;
&lt;p&gt;所以我會試著把這樣的努力與隨之而來的困境，盡可能展現出來，好比是種自嘲。就像〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉中的我。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/UNr2AmS.png" type="image"/>
    
    
    <category term="書評 × 筆記" scheme="https://blog.kyomind.tw/categories/%E6%9B%B8%E8%A9%95-%C3%97-%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="人生管理系統" scheme="https://blog.kyomind.tw/tags/%E4%BA%BA%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="生產力" scheme="https://blog.kyomind.tw/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="閱讀筆記" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="系列：人生 4 千個禮拜" scheme="https://blog.kyomind.tw/tags/%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BA%BA%E7%94%9F-4-%E5%8D%83%E5%80%8B%E7%A6%AE%E6%8B%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python 開發：Ruff Linter、Formatter 介紹 + 設定教學</title>
    <link href="https://blog.kyomind.tw/ruff/"/>
    <id>https://blog.kyomind.tw/ruff/</id>
    <published>2023-12-17T17:41:36.000Z</published>
    <updated>2024-01-20T07:22:11.398Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/klPlw0x.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p><a href="https://github.com/astral-sh/ruff">Ruff</a> 從去年（2022）6 月正式開源起算，已過去一年半，知道此工具的開發者也愈來愈多。雖然在去年就聽過它，但我卻一直沒有任何行動。</p><p>隨著前陣子 <a href="https://github.com/astral-sh/ruff/releases/tag/v0.1.0">v0.1.0</a> 的發布（先別覺得這版本號怎麼乍看像早期測試版本🤣，畢竟前一版可是 v0.0.292），我覺得時機已到，所以進行了一番研究、嘗試，於是有了本文的誕生。</p><h3 id="本文目錄"><a href="#本文目錄" class="headerlink" title="本文目錄"></a>本文目錄</h3><ol><li><a href="#%E7%B7%A3%E8%B5%B7">緣起</a></li><li><a href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85">本文主旨與目標讀者</a></li><li><a href="#Why-Ruff%EF%BC%9F">Why Ruff？</a></li><li><a href="#%E6%9C%AC%E6%96%87%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC">本文範例程式碼</a></li><li><a href="#Ruff-%E4%BB%8B%E7%B4%B9%E7%AF%87">Ruff 介紹篇</a></li><li><a href="#Linter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Flake8-%E8%88%87-isort-%E7%AD%89%E7%AD%89">Linter 部分：取代 Flake8 與 isort 等等</a></li><li><a href="#Formatter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Black">Formatter 部分：取代 Black</a></li><li><a href="#%E5%96%AE%E3%80%81%E9%9B%99%E5%BC%95%E8%99%9F%E8%AD%B0%E9%A1%8C">單、雙引號議題</a></li><li><a href="#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87">Ruff 設定篇</a></li><li><a href="#pyproject-toml-%E8%A8%AD%E5%AE%9A">pyproject.toml 設定</a></li><li><a href="##Ruff-VS-Code-%E5%A5%97%E4%BB%B6%E8%A8%AD%E5%AE%9A">Ruff VS Code 套件設定</a></li><li><a href="#pre-commit-%E8%A8%AD%E5%AE%9A">pre-commit 設定</a></li><li><a href="#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87%E5%B0%8F%E7%B5%90">Ruff 設定篇小結</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1">工作上我還未採用 Ruff 的理由</a></li><li><a href="#%E7%B5%90%E8%AA%9E%EF%BC%9ATime-to-Ruff">結語：Time to Ruff</a></li></ol><span id="more"></span><hr><h2 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h2><p>工作上，我們團隊使用的 linter、formatter 分別是常見的 Flake8、isort、yapf。這在以往的文章有多次提及。</p><p>隨著 Ruff 的聲量與能見度日漸提高，作為一個 <a href="https://blog.kyomind.tw/tags/Code-Formatting/">Code Formatting</a> 愛好者，我自然也是躍躍欲試——最好是能夠直接應用到工作開發上！</p><p>因為團隊還不大（含我共 3 個後端開發者），所以改用 Ruff 是完全有可能的。</p><p>不過經過一番研究與考慮，我還是暫時推遲了工作上對 Ruff 的採用（只是把 formatter 從 yapf 換成 Black），原因會在<a href="#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1">文末說明</a>。</p><p>但是！我還是很推薦，<strong>從現在就開始使用 Ruff 作為你「個人開發」的預設 linter 甚至 formatter</strong>。而 Ruff 究竟有哪些吸引人之處？且容我娓娓道來。</p><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>我在〈<a href="https://blog.kyomind.tw/pre-commit/">Python 開發：pre-commit 設定 Git Hooks 教學</a>〉曾提過：</p><blockquote><p>考慮到「pre-commit」這個主題已經有數篇文章珠玉在前，我下筆前都已拜讀完。<strong>本文的論述重心會盡可能與這些文章錯開，或乾脆直接引用，以降低不必要的重複感。</strong></p></blockquote><p>而 Ruff 也是如此，推薦你先讀過這篇〈<a href="https://myapollo.com.tw/blog/python-linter-ruff/">新世代的 Python Linter - Ruff</a>〉，然後再繼續閱讀本文，將有助於獲得<strong>更全面的理解</strong>。</p><p>接下來對 Ruff 的介紹，會有不同的側重與著墨，與更多的設定細節。</p><h3 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h3><p>本文主要分為三大部分：</p><ol><li>前言。</li><li>Ruff 介紹篇。</li><li>Ruff 設定篇。</li></ol><p>一開始不免俗地先講述我研究與使用 Ruff 的動機與理由，接著介紹 Ruff 的主要功能——linter 與 formatter。這也是它的最大賣點。</p><p>而「設定篇」著重的，則是在初步了解 Ruff 之後，如果真要採用它，我們還需要處理好哪些環節，才能在開發中流暢地使用它。</p><p>畢竟，<strong>開發工具的設定與整合</strong>，可算是本站文章的一大類型。☺️</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文的目標讀者有三：</p><ol><li>Python 開發中還沒有認真用過 linter、formatter 作為規範工具，想要開始導入，並希望用 Ruff 一次解決的人。</li><li>長期使用「<strong>Flake8 + isort + Black</strong>」這套 Python 開發經典組合，對 Ruff 有高度興趣，想要試試看的人。</li><li>Code Formatting in Python 愛好者。</li></ol><p>這篇文章是寫給「已經用 Python 開發一段時間」的人，而非 Python 初學者。</p><p>不過話說回來，如果初學者一開始就肯使用 Ruff 好好規範自己所寫的 Python code，不正是一個絕佳的開端嗎？😎</p><hr><h2 id="Why-Ruff？"><a href="#Why-Ruff？" class="headerlink" title="Why Ruff？"></a>Why Ruff？</h2><p>什麼是 Ruff，一句話說就是：</p><blockquote><p>An extremely fast Python linter and code formatter, written in Rust.</p></blockquote><p>而我認為採用 Ruff 主要基於下面兩大理由。</p><h3 id="一、快，就是快"><a href="#一、快，就是快" class="headerlink" title="一、快，就是快"></a>一、快，就是快</h3><p>下圖來自 <a href="https://github.com/astral-sh/ruff">Ruff 的 GitHub 首頁</a>，很好表達了為何要採用 Ruff——因為快。</p><p><img src="https://i.imgur.com/rjPXQg4.png"></p><p>用 Rust 寫的，快，自然不在話下。</p><p>而「極致的快」在很多時候會大幅改變你做事的方式——不過這對於大型專案可能才更有感。</p><p>對於中、小型專案，我覺得以下第二個理由更加重要。</p><h3 id="二、All-in-One：整合眾多套件"><a href="#二、All-in-One：整合眾多套件" class="headerlink" title="二、All-in-One：整合眾多套件"></a>二、All-in-One：整合眾多套件</h3><p>不止是速度，Ruff 的「整合」能力也不可小覷。</p><p>按照官方文件，有了 Ruff 後，以下的工具都不必再安裝了：</p><ul><li><a href="https://pypi.org/project/flake8/">Flake8</a> 和一堆 Flake8 外掛</li><li><a href="https://github.com/psf/black">Black</a></li><li><a href="https://pypi.org/project/isort/">isort</a></li><li><a href="https://pypi.org/project/pydocstyle/">pydocstyle</a></li><li><a href="https://pypi.org/project/pyupgrade/">pyupgrade</a></li><li><a href="https://pypi.org/project/autoflake/">autoflake</a></li><li>還有更多！</li></ul><p>想想是不是有一點「<a href="https://blog.kyomind.tw/pyproject-toml/#pyproject-toml-%E4%BB%8B%E7%B4%B9">pyproject.toml</a>」企圖統一天下，整合眾多工具設定檔的味道呢？</p><p>上述這些工具，尤其是最常用的 Flake8、isort、Black，如果現在只需要用一個工具就能實現，而且還更快、更好。</p><p>那我們何樂而不為？</p><hr><h2 id="本文範例程式碼"><a href="#本文範例程式碼" class="headerlink" title="本文範例程式碼"></a>本文範例程式碼</h2><p>本文中所提到的 Ruff 設定具體內容，包括 pyproject、VS Code、pre-commit 部分，都會加到 <a href="https://github.com/kyomind/Django-Tutorial">Django-Tutorial</a> 這個專案中。</p><p>它是我「<a href="https://blog.kyomind.tw/tags/Django-Tutorial/">Django Tutorial</a>」系列文章的範例程式碼，恰好也適合作為其它教學文章的實際素材展示。</p><p><code>git clone</code>本專案後，可以直接<code>git checkout</code>到<code>02-ruff</code>分支。這個分支所在的 commit，就是本文的具體設定內容與改動。</p><p>你也可以直接在 GitHub 上查看 <a href="https://github.com/kyomind/Django-Tutorial/commit/42a5a678ba5fbcc38f4463f593fad024636941ec">commit 內容</a>。</p><hr><p>前言結束，接下來我們進入正題。首先是對 Ruff 的整體介紹。</p><h2 id="Ruff-介紹篇"><a href="#Ruff-介紹篇" class="headerlink" title="Ruff 介紹篇"></a>Ruff 介紹篇</h2><p>Ruff 是一個 Python linter + formatter，雖然大部分人可能只使用它的 linter 部分，因為 formatter 還處於 beta 階段。</p><p>Ruff formatter 是一個相對獨立的功能，在開源後才開始建構。你完全可以只用 Ruff 的 linter，而依舊使用 Black 或 yapf 來格式化程式碼。</p><p>不過，即使只看 Ruff 的 linter 部分，它也並不是一個「單純的 linter」而已。因為它的實際行為超過了<strong>靜態分析</strong>（static analysis）。</p><p>所以，想要全面了解 Ruff，我們需要具體知曉：它究竟能夠做到哪些事、取代哪些工具。</p><h2 id="Linter-部分：取代-Flake8-與-isort-等等"><a href="#Linter-部分：取代-Flake8-與-isort-等等" class="headerlink" title="Linter 部分：取代 Flake8 與 isort 等等"></a>Linter 部分：取代 Flake8 與 isort 等等</h2><p>Ruff 的核心部分就是它的 linter，這點無庸置疑。</p><p>而 Flake8 作為 Python 開發中最流行的 linter，自然是 Ruff 首要取代的目標。所以 Ruff 連錯誤代碼都盡可能與 Flake8 一致，也是考慮到遷移的成本。</p><h3 id="Autofix-功能"><a href="#Autofix-功能" class="headerlink" title="Autofix 功能"></a>Autofix 功能</h3><p>不僅如此，Ruff 還能取代一眾「<strong>帶有 formatter 功能的 linter</strong>」，isort 就是其中的代表。而常見的 <a href="https://github.com/asottile/pyupgrade">pyupgrade</a> 也是。</p><p>這就有趣了，從這點可知，即使你沒有使用 Ruff 的 formatter 功能，它的 linter 部分還是<strong>帶有一定的 format 能力</strong>——其實就是 <a href="https://docs.astral.sh/ruff/linter/#fixes">autofix</a>。</p><p>這個特性<strong>真的很方便</strong>，但也帶來了一定的複雜。</p><p>方便的是，你可以只安裝 Ruff linter，就<strong>獲得多種 linter 附帶的 format 行為</strong>。而複雜則在於：設定上的細節也比一般 linter 更多。</p><h3 id="簡易版-formatter"><a href="#簡易版-formatter" class="headerlink" title="簡易版 formatter"></a>簡易版 formatter</h3><p>我原本以為 Ruff（不考慮<code>ruff-format</code>部分）只是一個比較快的靜態分析工具，顯然事實並非如此。</p><p>總之，我們只要記得：<strong>Ruff linter 有著簡易 format（autofix）能力</strong>——它是個簡易版的 formatter。</p><p>這和 Flake8 只做單純的靜態分析不同，Ruff linter 在檢查過程中，<strong>能夠直接對程式碼進行修改</strong>。當然，如果你不喜歡，這功能是可以關閉的。</p><hr><h2 id="Formatter-部分：取代-Black"><a href="#Formatter-部分：取代-Black" class="headerlink" title="Formatter 部分：取代 Black"></a>Formatter 部分：取代 Black</h2><p>我相信從 Ruff 的開源之初，就已經想過要成為一個 All-in-One 工具。畢竟 Rust 這麼快，只做 linter 未免太可惜了！</p><p>和 linter 不同，formatter 具有<strong>強烈的排它性</strong>。不同的 formatter 之間，<strong>沒有相容可言</strong>。不像 linter 還可以疊加使用——如果你不嫌煩XD。</p><p>如果寫一個全新的 formatter，就必須要有足夠的理由，讓開發者願意放棄當前方案，採用你的新工具——這很不容易。</p><p>比較可行的做法，是<strong>相容並取代</strong>市場上現有的 formatter。</p><p>既然要選一個，那當然是選 <a href="https://github.com/psf/black">Black</a>——目前最流行的 Python formatter。</p><blockquote><p>Black Formatter 相關文章：</p><ul><li><a href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/">《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</a></li><li><a href="https://blog.kyomind.tw/flake8-and-black/">VS Code：Python Flake8 與 Black Formatter 擴充套件快速上手</a></li></ul></blockquote><h3 id="和-Black-的相容性"><a href="#和-Black-的相容性" class="headerlink" title="和 Black 的相容性"></a>和 Black 的相容性</h3><p>因此，和對待 Flake8 一樣，Ruff formatter 必須與 Black 格式化後的結果，有<strong>高度的相容</strong>（一致）。否則你換了它的 formatter，卻帶來一堆格式化結果改動，絕對會造成遷移負擔與採用意願的下降。</p><p>按照官方文件中「<a href="https://docs.astral.sh/ruff/formatter/#black-compatibility">Black compatibility</a> 」這段可知：</p><blockquote><p>Specifically, the formatter is intended to emit near-identical output when run over Black-formatted code. When run over extensive Black-formatted projects like Django and Zulip, <strong>&gt; 99.9% of lines are formatted identically</strong>. When migrating an existing project from Black to Ruff, you should expect to see a few differences on the margins, <strong>but the vast majority of your code should be unchanged.</strong></p></blockquote><p>兩者的相容性（一致性）高達 99.9% 以上，基本可以放心遷移。</p><p>附帶一提，如果你是從 yapf 遷移到 Black，就能夠明顯感受到格式化風格差異所帶來的困擾——程式碼變動的地方太多了！</p><p>這種情況最好還是<strong>獨立一個分支或 commit，一次就把所有格式化差異都處理掉。</strong>而不要直接繼續開發，讓開發中的程式碼、檔案隨著開發進度被新 formatter 自動格式化，因為這會很影響 code review——格式化變動和開發變動混雜。</p><h3 id="還處於-Beta-階段"><a href="#還處於-Beta-階段" class="headerlink" title="還處於 Beta 階段"></a>還處於 Beta 階段</h3><blockquote><p>The Ruff formatter is available as a <a href="https://astral.sh/blog/the-ruff-formatter">production-ready Beta</a> as of Ruff v0.1.2.</p></blockquote><p>引言中的「<a href="https://astral.sh/blog/the-ruff-formatter">production-ready Beta</a>」超連結，指向 Ruff Formatter 的官方介紹文章與發展現況總結。</p><p>所謂的 beta 並不是還有很多 bug，更像是「設計與方向上」還沒有完全底定——比如下面要討論的「單、雙引號」議題。所以才會在前面加上「production-ready」。</p><p>如果你想要在個人的生產環境中使用，我相信是沒什麼問題。畢竟 <a href="https://github.com/tiangolo/fastapi/pull/10517">FastAPI 專案已經直接使用了</a>！</p><p>不過如果是公司專案，我還是會選擇觀望，不急於一時。</p><h2 id="單、雙引號議題"><a href="#單、雙引號議題" class="headerlink" title="單、雙引號議題"></a>單、雙引號議題</h2><p>Python 允許開發者自由選擇要在程式碼中使用單引號或雙引號。</p><p>只有在比如 docstring 這種<strong>連續使用 3 個引號</strong>的場景——即<code>&quot;&quot;&quot; &lt;內容&gt; &quot;&quot;&quot;</code>——時，慣例上要求使用雙引號。見 <a href="https://peps.python.org/pep-0257/#what-is-a-docstring">PEP 257</a>：</p><blockquote><p>For consistency, always use <code>&quot;&quot;&quot;triple double quotes&quot;&quot;&quot;</code> around docstrings.</p></blockquote><p>如果你對 Black 有一些了解，應該會知道，早期 Black 是<strong>完全不管</strong>你習慣用單引號還是雙引號，<strong>它一律把你的 Python 程式碼格式化為雙引號！</strong></p><p>這小小的硬性規則帶來了<strong>巨大的反彈</strong>，畢竟 Python 開發者中想必有不少人和我一樣，是「單引號」的支持者。</p><p>最後，Black 開發團隊也不得不妥協（這是 Black 少數的妥協，因為該工具本身就是以「不妥協」為賣點、slogan🤣），加入了<code>skip-string-normalization</code>選項。</p><h3 id="Ruff-Formatter-發展中"><a href="#Ruff-Formatter-發展中" class="headerlink" title="Ruff Formatter 發展中"></a>Ruff Formatter 發展中</h3><p>而 Ruff linter 作為 Black 的替代方案，也會遇到相同的「困境」。不同於 Black，目前 Ruff linter 提供的是<code>quote-style</code>這個選項：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quote-style = <span class="string">&quot;single&quot;</span></span><br></pre></td></tr></table></figure><p>即使你選了 single，在上述的慣例部分，Ruff 還是會格式化為雙引號，不用擔心。</p><p>至於要不要像 Black 加上<code>skip-string-normalization</code>，目前似乎還沒有定論。</p><p>整體而言，這個議題仍然在持續中，有興趣可以關注這個 <a href="https://github.com/astral-sh/ruff/issues/7615">GitHub Issue 討論串</a>。</p><p>這裡只是提醒你，採用 Ruff formatter 會有「單、雙引號」議題（而且和 Black 的處理方式不完全相同）。</p><p>至少對我而言，這非常重要。</p><hr><p>接下來，我們要進入 Ruff 的「<strong>設定篇</strong>」。</p><h2 id="Ruff-設定篇"><a href="#Ruff-設定篇" class="headerlink" title="Ruff 設定篇"></a>Ruff 設定篇</h2><p>當要採用一個新的 linter、formatter 時（尤其站在團隊開發考量），以下這三個部分的支援成熟度，是我一定會慎重考慮的。</p><h3 id="設定檔（pyproject-toml-支援）"><a href="#設定檔（pyproject-toml-支援）" class="headerlink" title="設定檔（pyproject.toml 支援）"></a>設定檔（pyproject.toml 支援）</h3><p>不用說，複雜的工具都一定有自己的設定檔，讓你可以客製化一些需求。如果能支援 pyproject.toml 則會更受到我的青睞。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pyproject-toml/">Python 開發：pyproject.toml 介紹 + 使用教學</a></p></blockquote><h3 id="VS-Code-套件支援"><a href="#VS-Code-套件支援" class="headerlink" title="VS Code 套件支援"></a>VS Code 套件支援</h3><p>它能讓你在寫程式的同時，就能夠看到 linter 發出的警告，而不必等到 commit 之際才被 pre-commit 擋下來。</p><p>相較於 linter，<strong>formatter 更需要有自己的 VS Code 套件</strong>。讓你能直接在 VS Code 中進行格式化，而不用透過 CLI 指令或等到 pre-commit 時才自動修正。</p><p>而且，雖然你可以只用 Ruff 的 linter 功能，但因為有「autofix」存在，本質上它也是一個<strong>簡易（附帶）的格式化器</strong>，所以最好有 VS Code 整合。</p><h3 id="pre-commit-支援"><a href="#pre-commit-支援" class="headerlink" title="pre-commit 支援"></a>pre-commit 支援</h3><p>pre-commit 是團隊協作中一道重要的關卡，我在「<a href="https://blog.kyomind.tw/pre-commit/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E4%BD%BF%E7%94%A8-pre-commit%EF%BC%9F">為什麼要使用 pre-commit？</a>」中已有相當的闡述。</p><p>對於一個開發工具，我們主要關心的是：「它是否提供 pre-commit hook？」</p><hr><p>以上 3 點，Ruff 都有完整支援。下面就來一一解說。</p><h2 id="pyproject-toml-設定"><a href="#pyproject-toml-設定" class="headerlink" title="pyproject.toml 設定"></a>pyproject.toml 設定</h2><p>Ruff 總共支援三種設定檔：<code>pyproject.toml</code>、<code>ruff.toml</code>、<code>.ruff.toml</code>。</p><p>如果設定不算多，那我一律推薦放<code>pyproject.toml</code>。反之如果有大量的客製，那獨立一個設定檔可能是比較好的選擇。</p><p>如果不知道怎麼開始，參考<a href="https://docs.astral.sh/ruff/configuration/">文件</a>是最快上手的方式。文件中的範例內容同時有著註解式的解說。</p><p><strong>不過大部分時候，我們只需要設定一些基本的項目</strong>。比如以下是我目前的設定，包含了 linter 與 formatter 部分：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff]</span></span><br><span class="line"><span class="attr">line-length</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">select</span> = [<span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;UP&quot;</span>]</span><br><span class="line"><span class="attr">target-version</span> = <span class="string">&quot;py310&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.format]</span></span><br><span class="line"><span class="attr">quote-style</span> = <span class="string">&quot;single&quot;</span></span><br></pre></td></tr></table></figure><h3 id="設定解說"><a href="#設定解說" class="headerlink" title="設定解說"></a>設定解說</h3><p>首先，因為在<code>pyproject.toml</code>中，所以設定的 key 定是<code>[tool.xxx]</code>格式。</p><p>Linter 部分，一些基本的設定比如<code>line-length</code>和 Flake8 類似。其中<code>select</code>和沒有列出的<code>ignore</code>相對重要。</p><p>Ruff 預設只會顯示 <code>E</code> 和 <code>F</code> 系列的錯誤訊息（而 Flake8 還有 <code>W</code> 系列）。想要增加或排除特定部分的錯誤訊息警示（包含 autofix），就得透過上述兩個欄位調整。比如：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff.lint]</span></span><br><span class="line"><span class="comment"># 1. Enable flake8-bugbear (`B`) rules, in addition to the defaults.</span></span><br><span class="line"><span class="attr">select</span> = [<span class="string">&quot;E4&quot;</span>, <span class="string">&quot;E7&quot;</span>, <span class="string">&quot;E9&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Avoid enforcing line-length violations (`E501`)</span></span><br><span class="line"><span class="attr">ignore</span> = [<span class="string">&quot;E501&quot;</span>]</span><br></pre></td></tr></table></figure><p>在我的設定中，<code>select</code>加上了<code>I</code>和<code>UP</code>。分別代表了 isort 和 pyupgrade。一旦你開啟了它們，Ruff 就會提示相關錯誤，並在有錯誤時自動修正。（autofix 預設為開啟）</p><p>因為開啟了<code>UP</code>，所以我必須設定<code>target-version</code>（這裡為<code>py310</code>），意味著 Ruff 會將程式碼中<strong>舊的寫法</strong>自動轉換（autofix）為 Python 3.10 的寫法。</p><p>總之，可設定的項目非常豐富。</p><hr><h2 id="Ruff-VS-Code-套件設定"><a href="#Ruff-VS-Code-套件設定" class="headerlink" title="Ruff VS Code 套件設定"></a>Ruff VS Code 套件設定</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=charliermarsh.ruff">Ruff 的 VS Code 套件</a>在 2022 年 12 月首次發表。</p><p>說真的，如果一個全新的 linter 或 formatter 沒有相關的 VS Code 套件，我絕不會考慮使用。</p><p>套件的重要性前面有提過，在此再次闡述：</p><ul><li>Linter：在 IDE 中有直接的提示，不必等到 commit 才發現錯誤。</li><li>Formatter：直接執行格式化（尤其配合「<strong>存檔時格式化</strong>」），不需透過指令。</li></ul><p>絕大部分情況下，linter 提示的錯誤都會直接被 formatter 自動修正，感覺上沒有開啟 linter 提示似乎也無妨？</p><p>但是，兩者在少數時候會有<strong>不同的行為</strong>，所以我認為 linter 的提示仍是必要的。</p><p>當然，另一方面也因為我已習慣看 linter 提示👀——沒有會很不自在！</p><h3 id="安裝與設定-Ruff-套件"><a href="#安裝與設定-Ruff-套件" class="headerlink" title="安裝與設定 Ruff 套件"></a>安裝與設定 Ruff 套件</h3><p>套件安裝後就可以直接使用，如果你的專案中已有專屬的 Ruff 設定檔，我覺得<strong>不需要再特別設定</strong> VS Code Ruff 套件部分。</p><p>不過還是提供我的設定：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ruff.lint.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;--line-length=100&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.organizeImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.fixAll&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ruff.showNotifications&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onError&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="建議設定-Python-行為"><a href="#建議設定-Python-行為" class="headerlink" title="建議設定 Python 行為"></a>建議設定 Python 行為</h3><p>Ruff 套件我覺得不設定也沒關係，有設定檔就夠了。</p><p>除非你不想要為每個專案一一建立 Ruff 設定檔，那就還是得弄一下（會套用到每一個專案）。同時也要考慮不同專案間的設定衝突問題——使用者全局設定 vs 專案設定。</p><p>相對的，VS Code 的 Python 部分則建議一定要設定。</p><p>這部分的具體內容，Ruff 套件首頁也有完整說明。我們直接看最完整的版本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;[python]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;source.organizeImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;charliermarsh.ruff&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>效果：</p><ol><li><code>editor.formatOnSave</code>：存檔時自動格式化（對所有 formatter 都有效）。</li><li><code>source.fixAll</code>：存檔時自動 fix。（類似 pre-commit 時，hook 的自動修正）</li><li><code>source.organizeImports</code>：存檔時自動排序 imports。</li></ol><p>我想上述這些 Python 設定才是 Ruff 在 VS Code 中流暢使用的重點。</p><h3 id="不同專案間切換"><a href="#不同專案間切換" class="headerlink" title="不同專案間切換"></a>不同專案間切換</h3><p>還有一個小細節，就是專案之間的切換問題。</p><p>因為不一定每個專案都用 Ruff。比如我，只在個人專案使用 Ruff，但工作上還沒有。或是相反的情況。</p><p>此時記得要把可能發生衝突的 VS Code 套件（主要是 linter 和 isort）在「工作區」範圍內停用！做法如下圖。不然 linter 部分很可能一起運作，產生意料之外的結果。</p><p><img src="https://i.imgur.com/lknGhsJ.png"></p><p>Formatter 部分，因為每個專案只能選定一種格式化器，比較沒有衝突問題。</p><hr><h2 id="pre-commit-設定"><a href="#pre-commit-設定" class="headerlink" title="pre-commit 設定"></a>pre-commit 設定</h2><p>pre-commit 設定相對單純，更細部的行為，hook 會自動讀取設定檔中的內容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/astral-sh/ruff-pre-commit</span></span><br><span class="line">  <span class="attr">rev:</span> <span class="string">v0.1.4</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--fix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff-format</span></span><br></pre></td></tr></table></figure><p>這裡只要注意版本和 hook 的 id 即可。</p><hr><h2 id="Ruff-設定篇小結"><a href="#Ruff-設定篇小結" class="headerlink" title="Ruff 設定篇小結"></a>Ruff 設定篇小結</h2><p>Ruff 的設定真的滿多樣且可以很複雜——儘管它的預設值已能滿足大多數人。</p><p>如果你不清楚究竟有哪些項目可以調整，又想了解更多。除了研究官方文件、Github 首頁的 README 外，去看看那些<a href="https://github.com/astral-sh/ruff?tab=readme-ov-file#whos-using-ruff">已經採用了 Ruff  的開源專案</a>的設定檔，也是很好的學習！</p><p>比如，我就習慣參考 <a href="https://github.com/tiangolo/fastapi/blob/master/pyproject.toml#L125">FastAPI 的 Ruff 設定</a>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff]</span></span><br><span class="line"><span class="attr">select</span> = [</span><br><span class="line">    <span class="string">&quot;E&quot;</span>,  <span class="comment"># pycodestyle errors</span></span><br><span class="line">    <span class="string">&quot;W&quot;</span>,  <span class="comment"># pycodestyle warnings</span></span><br><span class="line">    <span class="string">&quot;F&quot;</span>,  <span class="comment"># pyflakes</span></span><br><span class="line">    <span class="string">&quot;I&quot;</span>,  <span class="comment"># isort</span></span><br><span class="line">    <span class="string">&quot;C&quot;</span>,  <span class="comment"># flake8-comprehensions</span></span><br><span class="line">    <span class="string">&quot;B&quot;</span>,  <span class="comment"># flake8-bugbear</span></span><br><span class="line">    <span class="string">&quot;UP&quot;</span>,  <span class="comment"># pyupgrade</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="attr">ignore</span> = [</span><br><span class="line">    <span class="string">&quot;E501&quot;</span>,  <span class="comment"># line too long, handled by black</span></span><br><span class="line">    <span class="string">&quot;B008&quot;</span>,  <span class="comment"># do not perform function calls in argument defaults</span></span><br><span class="line">    <span class="string">&quot;C901&quot;</span>,  <span class="comment"># too complex</span></span><br><span class="line">    <span class="string">&quot;W191&quot;</span>,  <span class="comment"># indentation contains tabs</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.isort]</span></span><br><span class="line"><span class="attr">known-third-party</span> = [<span class="string">&quot;fastapi&quot;</span>, <span class="string">&quot;pydantic&quot;</span>, <span class="string">&quot;starlette&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.ruff.pyupgrade]</span></span><br><span class="line"><span class="comment"># Preserve types, even if a file imports `from __future__ import annotations`.</span></span><br><span class="line"><span class="attr">keep-runtime-typing</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>而且 FastAPI 真的很貼心，還加了註解！</p><hr><h2 id="工作上我還未採用-Ruff-的理由"><a href="#工作上我還未採用-Ruff-的理由" class="headerlink" title="工作上我還未採用 Ruff 的理由"></a>工作上我還未採用 Ruff 的理由</h2><p>結語之前，講講我在一番研究後，仍未建議團隊在此刻就採用 Ruff 的理由。</p><p>放到最後不是為了賣關子，而是看到這裡，你應該比較能夠理解其中的顧慮。</p><p>主要有三個。</p><h3 id="一、設定相對複雜"><a href="#一、設定相對複雜" class="headerlink" title="一、設定相對複雜"></a>一、設定相對複雜</h3><p>首先我覺得 Ruff 的設定太多樣了，畢竟它一口氣整合了這麼多的工具。</p><p>而且要同時考慮 pyproject.toml、VS Code、pre-commit 的整合，加上各種 linter 在設定上的開關，想想有點頭痛。</p><p>這會帶來一定的認知負擔，同事可能會覺得「搞這些真的有必要嗎？」——其實我也這麼想🤣</p><h3 id="二、需求不足"><a href="#二、需求不足" class="headerlink" title="二、需求不足"></a>二、需求不足</h3><p>我們目前的專案最多只能算中型，用「Flake8 + isort + Black Formatter」經典組合已能運作良好。改用 Ruff，可能看不出太大差別。</p><p>如果看不出差別，設定又要重新調整、學習，難免讓人卻步。</p><h3 id="三、讓子彈再飛一會兒"><a href="#三、讓子彈再飛一會兒" class="headerlink" title="三、讓子彈再飛一會兒"></a>三、讓子彈再飛一會兒</h3><p>說起來，前兩個理由並不算什麼重大阻礙，只是也沒有明顯的動力。</p><p>我打算等 Ruff formatter 的「beta」字樣拿掉後，直接「一換三」一次到位。</p><p>所以，不妨讓子彈再飛一會兒。</p><hr><h2 id="結語：Time-to-Ruff"><a href="#結語：Time-to-Ruff" class="headerlink" title="結語：Time to Ruff"></a>結語：Time to Ruff</h2><p>Ruff 現階段對我的重要性，顯然還遠不如 <a href="https://blog.kyomind.tw/python-poetry/">Poetry 套件管理器</a>。但這樣的工具依舊讓人興奮且充滿期待。</p><p>我並不認為目前的 Python 開發一定要用上 Ruff，但值得你嘗試一下。</p><p>如果你也是一個 Code Formatting 愛好者，那麼 Ruff 絕對是一個值得你花時間研究的工具。</p><p>更重要的是，由 Rust 所引發的 Python 生態革命，現在才剛剛開始。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/klPlw0x.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/astral-sh/ruff&quot;&gt;Ruff&lt;/a&gt; 從去年（2022）6 月正式開源起算，已過去一年半，知道此工具的開發者也愈來愈多。雖然在去年就聽過它，但我卻一直沒有任何行動。&lt;/p&gt;
&lt;p&gt;隨著前陣子 &lt;a href=&quot;https://github.com/astral-sh/ruff/releases/tag/v0.1.0&quot;&gt;v0.1.0&lt;/a&gt; 的發布（先別覺得這版本號怎麼乍看像早期測試版本🤣，畢竟前一版可是 v0.0.292），我覺得時機已到，所以進行了一番研究、嘗試，於是有了本文的誕生。&lt;/p&gt;
&lt;h3 id=&quot;本文目錄&quot;&gt;&lt;a href=&quot;#本文目錄&quot; class=&quot;headerlink&quot; title=&quot;本文目錄&quot;&gt;&lt;/a&gt;本文目錄&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B7%A3%E8%B5%B7&quot;&gt;緣起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E4%B8%BB%E6%97%A8%E8%88%87%E7%9B%AE%E6%A8%99%E8%AE%80%E8%80%85&quot;&gt;本文主旨與目標讀者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Why-Ruff%EF%BC%9F&quot;&gt;Why Ruff？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AC%E6%96%87%E7%AF%84%E4%BE%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC&quot;&gt;本文範例程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E4%BB%8B%E7%B4%B9%E7%AF%87&quot;&gt;Ruff 介紹篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Linter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Flake8-%E8%88%87-isort-%E7%AD%89%E7%AD%89&quot;&gt;Linter 部分：取代 Flake8 與 isort 等等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Formatter-%E9%83%A8%E5%88%86%EF%BC%9A%E5%8F%96%E4%BB%A3-Black&quot;&gt;Formatter 部分：取代 Black&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%96%AE%E3%80%81%E9%9B%99%E5%BC%95%E8%99%9F%E8%AD%B0%E9%A1%8C&quot;&gt;單、雙引號議題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87&quot;&gt;Ruff 設定篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pyproject-toml-%E8%A8%AD%E5%AE%9A&quot;&gt;pyproject.toml 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;##Ruff-VS-Code-%E5%A5%97%E4%BB%B6%E8%A8%AD%E5%AE%9A&quot;&gt;Ruff VS Code 套件設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pre-commit-%E8%A8%AD%E5%AE%9A&quot;&gt;pre-commit 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Ruff-%E8%A8%AD%E5%AE%9A%E7%AF%87%E5%B0%8F%E7%B5%90&quot;&gt;Ruff 設定篇小結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B7%A5%E4%BD%9C%E4%B8%8A%E6%88%91%E9%82%84%E6%9C%AA%E6%8E%A1%E7%94%A8-Ruff-%E7%9A%84%E7%90%86%E7%94%B1&quot;&gt;工作上我還未採用 Ruff 的理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%B5%90%E8%AA%9E%EF%BC%9ATime-to-Ruff&quot;&gt;結語：Time to Ruff&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    <content src="https://i.imgur.com/klPlw0x.jpg" type="image"/>
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="長文" scheme="https://blog.kyomind.tw/tags/%E9%95%B7%E6%96%87/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="Flake8" scheme="https://blog.kyomind.tw/tags/Flake8/"/>
    
    <category term="isort" scheme="https://blog.kyomind.tw/tags/isort/"/>
    
    <category term="Code Formatting" scheme="https://blog.kyomind.tw/tags/Code-Formatting/"/>
    
    <category term="Black Formatter" scheme="https://blog.kyomind.tw/tags/Black-Formatter/"/>
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="pre-commit" scheme="https://blog.kyomind.tw/tags/pre-commit/"/>
    
    <category term="Ruff" scheme="https://blog.kyomind.tw/tags/Ruff/"/>
    
  </entry>
  
  <entry>
    <title>24，收回「發文計畫」</title>
    <link href="https://blog.kyomind.tw/weekly-review-24/"/>
    <id>https://blog.kyomind.tw/weekly-review-24/</id>
    <published>2023-11-03T18:22:04.000Z</published>
    <updated>2024-01-02T02:45:59.835Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/mmEzb21.png"></p><p>你現在看網站的選單，已經沒有「發文計畫」了。</p><p>至於那是什麼，可以參考上一期〈<a href="https://blog.kyomind.tw/weekly-review-23/">23，Blog 新增「發文計畫」與我的思路</a>〉。</p><p>這篇就來解釋，為什麼它失敗了，與我的一點想法。</p><span id="more"></span><hr><h2 id="結束的理由"><a href="#結束的理由" class="headerlink" title="結束的理由"></a>結束的理由</h2><p>先簡單回顧一下，發文計畫的兩大初衷：</p><ol><li>可預見性。</li><li>公開承諾。</li></ol><p>從這一個多月的實施結果來看，上述這兩件事情，基本都搞砸了。</p><h3 id="可預見但不可信"><a href="#可預見但不可信" class="headerlink" title="可預見但不可信"></a>可預見但不可信</h3><p>首先是可預見，這確實有一定的效果。畢竟我把接下來的要寫的東西，都先公開其中。</p><p>但是，很多文章（尤其是較長的內容）的發文日期，卻是一延再延，如此一來，即使可預見，也沒有太大的參考價值。</p><h3 id="無法兌現的承諾"><a href="#無法兌現的承諾" class="headerlink" title="無法兌現的承諾"></a>無法兌現的承諾</h3><p>既然文章發布日可以一延再延，那公開承諾就沒有了原來想像的拘束力（至少在心理上沒有足夠的拘束力）。</p><p>如此一來，想透過公開承諾培養一定紀律的期待，也就落了空。</p><h2 id="收穫與反省"><a href="#收穫與反省" class="headerlink" title="收穫與反省"></a>收穫與反省</h2><p>其實，並不是所有的文章都是一延再延。</p><h3 id="意料之外的收穫"><a href="#意料之外的收穫" class="headerlink" title="意料之外的收穫"></a>意料之外的收穫</h3><p>有一部分文章，反而因為有了這份「發文行事曆」，而事先完成了！這實在超乎了我的預料，可謂意外的驚喜。</p><blockquote><p>這是我少數能感受到「計畫」強大威力的時刻。</p></blockquote><p>不過，即使已經完稿，我通常還是會等到上面寫的發文日期才正式公開。</p><p>這是好的部分。</p><h3 id="問題反省"><a href="#問題反省" class="headerlink" title="問題反省"></a>問題反省</h3><p>但是，那些真正「困難」的文章（主要是技術相關的長篇文章），我卻還是一拖再拖，直接架空了這個行事曆。</p><p>我也真正了解到，除非我有辦法真正降低這些主題的寫作門檻，或許找到其它更有效的創作手段。</p><p>不然面對這些棘手的主題，常常就是一逃再逃。</p><p>本來我是這麼說的：</p><blockquote><p>公開承諾會<strong>強化其中的痛苦</strong>，讓我對這樣的拖延感到壓力。</p></blockquote><p>確實如此，但從結果看來，這樣的壓力，還是不足以讓我按時完成！</p><hr><p>既然事與願違，索性還是撤掉了。</p><p>此外，網站的選單部分我一向是寸土寸金，捨不得增加太多雜訊。</p><p>既然發文計畫無法達到當初的期待，又佔據了選單列表，我還是選擇拿掉。不再公開。</p><h2 id="行事曆是好東西"><a href="#行事曆是好東西" class="headerlink" title="行事曆是好東西"></a>行事曆是好東西</h2><p>儘管如此，我發現「發文行事曆」確實是很棒的規劃工具，尤其是可以「拖曳」這個特性，令人愛不釋手。</p><p>一直把日期後延，對讀者很不好意思，所以我只能「關門」。但如果只有我自己的話，行事曆仍不失為稱手好用的發文管理利器！</p><p>這和「僅把待發表文章列在清單中」的感覺，截然不同。推薦你也試試。</p><hr><h2 id="總結與重新思考"><a href="#總結與重新思考" class="headerlink" title="總結與重新思考"></a>總結與重新思考</h2><p>整體而言，我目前的寫作還是略嫌發散了，主要受到三股勢力的牽引：</p><ol><li><strong>有流量的內容</strong>：主要就是筆記軟體類的文章。當然，我也確實熱衷於此。</li><li><strong>我感興趣的內容</strong>：通常是個人價值觀的闡述。</li><li><strong>我認為自己可以寫好，也值得好好寫的內容</strong>：程式類文章。</li></ol><p>上述三者雖然不算涇渭分明，但仍有一定的排它性。</p><p>然而時間就這麼多，我必須有所取捨。而現在的我，還做得不夠好。</p><blockquote><p><strong>講白了就是太貪心！</strong></p></blockquote><p>所以我應該會<strong>減少發文量</strong>。把主要精力集中在<strong>中長篇內容</strong>，尤其是那些我常常想要逃避的主題。</p><p>這類文章往往需要很大的心力來創作，但也是真正具有「<a href="https://blog.kyomind.tw/a-mind-for-blogs/#%E4%BA%8C%E3%80%81%E5%8F%96%E6%8D%A8%E4%BB%A5%E7%AA%81%E9%A1%AF">自我代表性</a>」的作品。</p><p>至於發文頻率，則不再強求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mmEzb21.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;你現在看網站的選單，已經沒有「發文計畫」了。&lt;/p&gt;
&lt;p&gt;至於那是什麼，可以參考上一期〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-23/&quot;&gt;23，Blog 新增「發文計畫」與我的思路&lt;/a&gt;〉。&lt;/p&gt;
&lt;p&gt;這篇就來解釋，為什麼它失敗了，與我的一點想法。&lt;/p&gt;</summary>
    
    
    <content src="https://i.imgur.com/mmEzb21.png" type="image"/>
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="寫作" scheme="https://blog.kyomind.tw/tags/%E5%AF%AB%E4%BD%9C/"/>
    
  </entry>
  
</feed>
