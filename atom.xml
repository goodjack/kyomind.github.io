<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code and Me</title>
  <icon>https://blog.kyomind.tw/leaf.svg</icon>
  <subtitle>我的程式與學習心得</subtitle>
  <link href="https://blog.kyomind.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.kyomind.tw/"/>
  <updated>2023-08-18T17:37:27.832Z</updated>
  <id>https://blog.kyomind.tw/</id>
  
  <author>
    <name>kyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Apple Studio Display 適合你嗎？——我的心得與選購指南</title>
    <link href="https://blog.kyomind.tw/apple-studio-display/"/>
    <id>https://blog.kyomind.tw/apple-studio-display/</id>
    <published>2023-08-16T16:06:24.000Z</published>
    <updated>2023-08-18T17:37:27.832Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/H6W14Kj.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p><a href="https://www.apple.com/tw/shop/buy-mac/apple-studio-display">Apple Studio Display</a> 無疑是今年內，我所有新購入的<a href="https://blog.kyomind.tw/weekly-review-16/#%E4%BD%95%E8%AC%82%E5%83%B9%E5%80%BC%E8%A7%80%E5%B1%A4%E7%B4%9A%E7%9A%84%E3%80%8C%E5%99%A8%E7%89%A9%E3%80%8D%EF%BC%9F">器物</a>之中，<strong>最值得的選擇</strong>，且沒有之一。</p><p>但它不一定適合你，也可能不適合多數人。</p><blockquote><p>相關文章：</p><ul><li><a href="https://blog.kyomind.tw/mac-mini/">M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南</a></li><li><a href="https://blog.kyomind.tw/weekly-review-16/">16，我的「價值觀層級」器物清單</a></li></ul></blockquote><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>作為一個使用它近半年的真實用戶，我撰寫本文的目標，就是為了協助你判斷：<strong>是不是真的值得為自己購買一台 Studio Display。</strong></p><p>你也可以當作這是一篇 <strong>Studio Display 開箱文</strong>。</p><p>我們會提到它的優點——我最喜歡的部分。不過，作為一台昂貴的螢幕，在購入之前，你可能更關心「它究竟適不適合自己、值不值得？」</p><p>就像我在〈<a href="https://blog.kyomind.tw/weekly-review-13/">13，我買了 Apple Studio Display 與系列心得寫作計畫</a>〉說的：</p><blockquote><p>那些你<strong>不喜歡</strong>或<strong>可能無法接受</strong>的環節，才是做決定時最重要的考量點——<strong>那些「不」才是關鍵</strong>。</p></blockquote><span id="more"></span><h2 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h2><p>Studio Display 是 Apple 公司專為 Mac 推出的專業顯示器。</p><p>雖然 Windows 電腦也可以連接並使用 Studio Display，但存在一些限制，而且可能還有其它意料之外的問題。</p><p>所以，<strong>本文是寫給 Mac 用戶的選購指南。</strong></p><p>Windows 用戶如果真心想買，建議先參考下列兩篇文章：</p><ul><li><a href="https://www.techbang.com/posts/95066-using-the-apple-studio-display-display-on-a-windows-pc-is">網友實戰在 PC上使用蘋果Studio Display顯示器：不但功能半殘，而且接線可能會把你搞瘋</a></li><li><a href="https://applefans.today/2022-03-how-to-use-apple-studio-display-with-windows-pc/">如何在 Windows 上使用 Apple Studio Display?</a></li></ul><h2 id="兩部影片推薦"><a href="#兩部影片推薦" class="headerlink" title="兩部影片推薦"></a>兩部影片推薦</h2><p>一般的文章，參考材料肯定是放在文末，甚至直接省略。</p><p>但是像「顯示器開箱、評論」這樣的內容，我們從直觀上想像，無疑透過「<strong>影片</strong>」是最適合的，畢竟是它顯示器嘛！——我們想要看顏色、聽聲音。</p><p>因此，我在購入 Studio Display 之前，也不可免地看了大量評測影片。</p><p>但我覺得「少則得，多則惑」，大部分影片講的不夠深入，或者面向的受眾群體更廣，參考價值相對有限。</p><p>我推薦以下這兩部 Studio Display 評測影片，對我頗有幫助。而且我覺得看完文本加上這些影片，已經很足夠：</p><ul><li><a href="https://youtu.be/kdMIw9R7XrQ">最後，我還是怒刷！Apple Studio Display 開箱 &amp; 三個月真實使用心得：蘋果終究是蘋果，連螢幕也有最強生態圈體驗</a></li><li><a href="https://youtu.be/ai7Qc3hV1Xw">「黑貓」Apple Studio Display 開箱 + 評測 + 連接PC</a></li></ul><hr><p>正文開始，我們先講它的優點，再論選購前注意事項，最後給出我對 Studio Display 的總體評價。</p><h2 id="我最喜歡-Studio-Display-的部分"><a href="#我最喜歡-Studio-Display-的部分" class="headerlink" title="我最喜歡 Studio Display 的部分"></a>我最喜歡 Studio Display 的部分</h2><p>以下這幾點是我個人最喜歡 Studio Display 的地方。大部分與主流觀點相同，而最後一項則是我個人的偏好。</p><p>關於優秀的畫質，這對 Studio Display 無疑是基本，且無法用簡單文字呈現，直接參考上述影片即可。以下講述<strong>顏色之外</strong>的細節。</p><h3 id="一、出色的揚聲器"><a href="#一、出色的揚聲器" class="headerlink" title="一、出色的揚聲器"></a>一、出色的揚聲器</h3><p>誰也沒想到，一台螢幕竟然在揚聲器（喇叭）部分引發了熱烈的討論。</p><p>原因無它，如果 Studio Display 的揚聲器音質是 100 分，那其餘「螢幕附帶」的揚聲器，應該沒有一款可以得到 50 分。</p><p>和很多人一樣，買了這台螢幕後，我就把桌上型 2.0 喇叭（兩件式喇叭）丟掉了。電腦桌面空出了原先喇叭與線材佔用的空間，讓人感覺無比清爽！</p><p>無論是音質還是省下的空間，都出乎了我的意料，對此大大加分！</p><p>Studio Display 揚聲器的音質大概可以比美台幣 1500-3000 價位的桌上型 2.0 喇叭。對我而言，已然足夠。</p><p>除此之外，螢幕內建的麥克風和前鏡頭也都有一定水準，對非專業人士而言，堪稱綽綽有餘。</p><h3 id="二、5K-與-4K"><a href="#二、5K-與-4K" class="headerlink" title="二、5K 與 4K"></a>二、<strong>5K 與 4K</strong></h3><p>Studio Display 5K 解析度的 1474 萬總像素量， 比一般常見 27吋 4K 的 829 萬的像素量，<strong>足足多了 77.7%。</strong></p><p>用 PPI 比較，則是 218（5K）VS 163（4K）——差距不可謂不小。而 Studio Display  的 218 PPI，顯然是比照 Macbook 的 PPI 標準。</p><p>不過，使用 27 吋螢幕的視線距離，肯定大於使用筆電型電腦，所以對 PPI 的要求或許不需要達到 Macbook 等級。</p><p>但可以想見，兩者的<strong>細膩度</strong>，在視覺上仍會有一定落差，從文字的「毛邊」就能體現。對於常盯著程式碼與文字稿的我，依舊會很在意。</p><p>所以，5K 解析度對我而言，有其價值與必要性。</p><h3 id="三、抗反射鍍膜"><a href="#三、抗反射鍍膜" class="headerlink" title="三、抗反射鍍膜"></a>三、抗反射鍍膜</h3><p>Macbook 或非平價版 iPad 的用戶，對 Apple 這項科技肯定不陌生。</p><p>不僅保留了鏡面螢幕在觀看時的<strong>通透感</strong>（如下圖），又大幅降低了一般鏡面螢幕的最大問題——反光。</p><p>下圖截取自<a href="https://youtu.be/yiRIfoEqGxw">這部影片</a>，比較<strong>鏡面版</strong>（右，有抗反射鍍膜）和 <strong>Nano-texture 版</strong>（可以類比於一般常見的霧面螢幕，只是 Nano-texture 更高級）的視覺差距。</p><p>擁有抗反射鍍膜的 Studio Display 鏡面版，其視覺效果，無疑是肉眼可見的好。</p><p><img src="https://i.imgur.com/KE1nUaD.png" alt="來源：鍾文澤 YouTube"><span class="cap">來源：鍾文澤 YouTube</span></p><p>這也是為什麼我<strong>非買 Studio Display 不可</strong>的另一大理由。畢竟市面上絕大部分的螢幕都是<strong>霧面</strong>，即使畫質再好，實際顯示效果也會<strong>大打折扣</strong>。</p><p>附帶一提，如影片中所言，除非你<strong>很清楚自身需求</strong>，否則不建議買 Nano-texture 版，而上圖就是理由。</p><h3 id="四、4-邊等寬的螢幕邊框"><a href="#四、4-邊等寬的螢幕邊框" class="headerlink" title="四、4 邊等寬的螢幕邊框"></a>四、4 邊等寬的螢幕邊框</h3><p>這屬於我個人偏好，我非常喜歡 Studio Display 的 4 邊等寬設計。可能有人嫌它還不夠窄（相較於 <a href="https://www.apple.com/tw/pro-display-xdr/">Pro Display XDR</a>），但我覺得很可以了。</p><p>與之相對的，我非常不喜歡各式「下巴型」設計——下邊框很寬，而其餘 3 邊很窄。比如 LG 的<a href="https://www.lg.com/tw/monitors/lg-27up850n-w">很多機型</a>都是如此。</p><p>這類「<strong>不對稱</strong>」的設計，其審美讓我難以苟同。</p><hr><h2 id="購買前的注意事項"><a href="#購買前的注意事項" class="headerlink" title="購買前的注意事項"></a>購買前的注意事項</h2><p>前面關於 Studio Display 的優點，你可能未必有感或並不在意。不過以下的注意事項，則是作為消費者的我們，不得不事先考慮的環節。部分取自我實際使用經驗。</p><h3 id="一、固定支架的高度太低"><a href="#一、固定支架的高度太低" class="headerlink" title="一、固定支架的高度太低"></a>一、固定支架的高度太低</h3><p>Studio Display 有「<strong>固定</strong>」和「<strong>可調整高度</strong>」兩種支架——後者要多付 12000。</p><p>對大部分人來說這應該有點難以接受，畢竟我們買一般螢幕時，螢幕底座本來就可以伸縮並調整高低，如今我竟然要多花 12000 才能辦到，豈有此理？</p><p>確實！而且我相信正常人不會想花這個錢——那問題就來了。</p><p>固定支架的<strong>高度有限</strong>，我在買之前就不禁懷疑：「這高度真的夠嗎？」</p><p>仔細看了很多影片（有些影片評的是「可升降」版本，這部分沒有參考價值），並沒有哪一部對此有特別著墨。</p><p>想想我還是不放心，最後選擇了 VESA 版，再另外買了<a href="https://www.dell.com/zh-tw/shop/dell-%E5%96%AE%E4%B8%80%E9%A1%AF%E7%A4%BA%E5%99%A8%E8%87%82%E6%9E%B6-msa20/apd/482-bbdj/%E9%A1%AF%E7%A4%BA%E5%99%A8%E5%92%8C%E9%A1%AF%E7%A4%BA%E5%99%A8%E9%85%8D%E4%BB%B6">螢幕支架</a>。</p><p>事實證明，買 VESA 版是對的！至少就我而言，固定支架的高度是遠遠不夠的。不過你不一定真的需要買 VESA 版，但可能要考慮是否具備下列兩項條件之一：</p><ol><li>偏高的桌子。</li><li>螢幕增高架。</li></ol><h3 id="二、VSEA-或支架版？"><a href="#二、VSEA-或支架版？" class="headerlink" title="二、VSEA 或支架版？"></a>二、VSEA 或支架版？</h3><p>VESA 版和其餘兩種支架只能三選一，所以這一步得謹慎，我們繼續此話題。</p><p>絕大部分的螢幕根本沒有這個問題，因為現代螢幕都是底座拆掉就是一個標準的 VESA 接口槽，而 Studio Display 的底座卻無法拆卸，需要你在選購時就決定好。</p><p>這樣的設計著實令人討厭。</p><p>對於已經有獨立螢幕支架的人來說，或許不是太大的問題，直接買 VESA 版即可。不過這裡還有一個考量點，就是萬一要賣掉螢幕，VESA 版可能比較不好賣。</p><p>我自己的思路則是：不考慮轉手問題（應該不會賣掉），但我也不想用螢幕增高架，因為高度固定，萬一使用後的高度看不習慣，又得換一個架子。</p><p>所以我選擇獨立支架 + VESA 版。而從結果看來——我很滿意。</p><h3 id="三、Windows-用戶不建議購買"><a href="#三、Windows-用戶不建議購買" class="headerlink" title="三、Windows 用戶不建議購買"></a>三、Windows 用戶不建議購買</h3><p>如前所述，Studio Display 是為 Mac 開發的螢幕，Windows 電腦可用但問題較多。</p><p>即使這些問題都能一一克服，花這麼多錢卻無法享受完整版的功能，難免讓人心理不平衡。所以我不建議購買。</p><p>當然，如果你真的很喜歡它的畫質（與音質），則另當別論。</p><h3 id="四、Intel-Mac-用戶也要三思"><a href="#四、Intel-Mac-用戶也要三思" class="headerlink" title="四、Intel Mac 用戶也要三思"></a>四、Intel Mac 用戶也要三思</h3><p>即使是 Mac，如果 CPU 是 Intel 版，而且沒有獨立顯卡，只有內顯——尤其是早期的內顯，我強烈建議不要買。</p><p>我自己的 <a href="https://blog.kyomind.tw/weekly-review-09/#%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%8F%B0-Macbook%EF%BC%9AMacbook-Air-2020-Intel-%E7%89%88">2020 Intel 版 Macbook Air</a>，接上這台螢幕，基本上<strong>跑太不動</strong>，可見 5K 解析度對於顯示晶片還是有一定要求。（也可能是硬體不夠相容）</p><p>而 Intel CPU 早期的內顯，只能說是雞肋，有跟沒有差不多！</p><p>所以，如果手上只有 Intel CPU 版的 Mac，可能不一定能夠稱心如意。</p><p>如果是 M 系列晶片，則絕對沒問題。</p><h3 id="五、RAM-消耗問題"><a href="#五、RAM-消耗問題" class="headerlink" title="五、RAM 消耗問題"></a>五、RAM 消耗問題</h3><p>這是一個極冷門議題，不過還是提一下。對 RAM 只有 8 GB 的 Mac 會有一點影響。</p><p>那就是 WindowServer 這個專門處理螢幕圖形顯示的程序，佔用的記憶體會明顯增加。這是當然的！因為它現在要處理 5K 像素。</p><p>增加的幅度是可觀的，就我自己而言，13 吋的 Macbook 螢幕大概只佔用 500 MB，而外接 Studio Display 則佔用了 1.8 GB。當然這跟你開了多少程式、視窗也有關。</p><p>RAM 消耗的增加，對於 RAM 只有 8 GB 的 Mac，虛擬記憶體（SWAP）的使用率一定會跟著增加。這多少會加速消耗 SSD 的壽命。</p><p>不過因為 SSD 很難真的用到壞掉，所以也無傷大雅。</p><h3 id="六、要不要購買-AppleCare-？"><a href="#六、要不要購買-AppleCare-？" class="headerlink" title="六、要不要購買 AppleCare+？"></a>六、要不要購買 AppleCare+？</h3><p>像 Mac mini、Studio Display 這種「使用場景比較固定」的機器，AppleCare+ 的費用相對低廉，畢竟出保的機率也比較低。</p><p>但 Studio Display 的 AppleCare+ 還是要價 4290！怎麼也稱不上便宜。買不買依舊是一個大問題。</p><p>我最後還是買了。我的考量是，萬一螢幕真的有問題要送修，AppleCare+ 提供到府收送服務，對我比較省事。</p><p>對於沒有車的人而言，這是一個重要的考量——當然你也可以叫計程車😎</p><hr><h2 id="結語：事前功課麻煩，但值得"><a href="#結語：事前功課麻煩，但值得" class="headerlink" title="結語：事前功課麻煩，但值得"></a>結語：事前功課麻煩，但值得</h2><p>為了買這台 Studio Display，我花費了不少心思。好在從結果來看，一切是值得的。</p><p>其實，不想做功課也無妨，畢竟從 Apple 官網購買的產品都有 14 天的鑑賞期，即使完全沒做功課，也可以在使用後覺得不適合時斷然退貨。</p><p>但退貨對我來說（心理上）更麻煩！所以我寧願在事前花時間。</p><p>如果你問我給 Studio Display 的使用滿意度打幾分，我會說 100 分。縱然它真的不便宜，但它的整體表現，完全值得這個價錢，甚至可以說沒有缺點（對我而言）。</p><p>更重要的是，相比也是今年購入的 M2 Pro Mac mini，即使少了 Mac mini，我仍有其他  Macbook 可供選擇。</p><p>而 Studio Display 就這一台了！我完全想不到在同樣的價格下，有其它螢幕選項可以作為「相同滿足感」的替代選項——真的沒有。</p><p>所以在我心中，Studio Display 的地位高於 Mac mini，這也是為什麼它能得到 100 分的根本原因。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/H6W14Kj.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.apple.com/tw/shop/buy-mac/apple-studio-display&quot;&gt;Apple Studio Display&lt;/a&gt; 無疑是今年內，我所有新購入的&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-16/#%E4%BD%95%E8%AC%82%E5%83%B9%E5%80%BC%E8%A7%80%E5%B1%A4%E7%B4%9A%E7%9A%84%E3%80%8C%E5%99%A8%E7%89%A9%E3%80%8D%EF%BC%9F&quot;&gt;器物&lt;/a&gt;之中，&lt;strong&gt;最值得的選擇&lt;/strong&gt;，且沒有之一。&lt;/p&gt;
&lt;p&gt;但它不一定適合你，也可能不適合多數人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/mac-mini/&quot;&gt;M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-16/&quot;&gt;16，我的「價值觀層級」器物清單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本文主旨&quot;&gt;&lt;a href=&quot;#本文主旨&quot; class=&quot;headerlink&quot; title=&quot;本文主旨&quot;&gt;&lt;/a&gt;本文主旨&lt;/h2&gt;&lt;p&gt;作為一個使用它近半年的真實用戶，我撰寫本文的目標，就是為了協助你判斷：&lt;strong&gt;是不是真的值得為自己購買一台 Studio Display。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你也可以當作這是一篇 &lt;strong&gt;Studio Display 開箱文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我們會提到它的優點——我最喜歡的部分。不過，作為一台昂貴的螢幕，在購入之前，你可能更關心「它究竟適不適合自己、值不值得？」&lt;/p&gt;
&lt;p&gt;就像我在〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-13/&quot;&gt;13，我買了 Apple Studio Display 與系列心得寫作計畫&lt;/a&gt;〉說的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那些你&lt;strong&gt;不喜歡&lt;/strong&gt;或&lt;strong&gt;可能無法接受&lt;/strong&gt;的環節，才是做決定時最重要的考量點——&lt;strong&gt;那些「不」才是關鍵&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="Studio Display" scheme="https://blog.kyomind.tw/tags/Studio-Display/"/>
    
    <category term="開箱評論" scheme="https://blog.kyomind.tw/tags/%E9%96%8B%E7%AE%B1%E8%A9%95%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>《Python 功力提升的樂趣》筆記（一）Black、命名、壞味道</title>
    <link href="https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/"/>
    <id>https://blog.kyomind.tw/beyond-the-basic-stuff-with-python-01/</id>
    <published>2023-08-05T06:03:13.000Z</published>
    <updated>2023-08-16T14:17:57.398Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/tS78Ke0.png" alt="Python 功力提升的樂趣"><span class="cap">Python 功力提升的樂趣</span></p><p>這是《<a href="https://www.tenlong.com.tw/products/9789865027711">Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務</a>》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。</p><h2 id="系列緣起"><a href="#系列緣起" class="headerlink" title="系列緣起"></a>系列緣起</h2><p>我會用數篇文章，把本書的重點一一勾勒出來。之所以願意這麼做，主要有兩個原因。</p><h3 id="要真正落實-Clean-Code，著實不易"><a href="#要真正落實-Clean-Code，著實不易" class="headerlink" title="要真正落實 Clean Code，著實不易"></a>要真正落實 Clean Code，著實不易</h3><p>雖然任何一種程式語言都能夠寫出堪稱簡潔的程式碼，但 Python 可能是最接近「自然語言」的那個，從這個角度看，Python 的 Clean Code 或許是最美的。</p><p>但因為 Python 的自由度，往往實際上的程式碼品質都不是那麼理想——你甚至希望它不要那麼自由。</p><h3 id="我認為這本書被低估了"><a href="#我認為這本書被低估了" class="headerlink" title="我認為這本書被低估了"></a>我認為這本書被低估了</h3><p>意思是它似乎不那麼有名。</p><p>當然，講 Clean Code Python 的書也不只這本，但我認為本書是<strong>最適合起手</strong>的一本。儘管它面向的是 Python 新鮮人，但不得不承認，即使已經寫了一、兩年 Python 的開發者，對於書中建議的落實，往往都還有所不足。</p><p>儘管 Python 是自由的，但 Clean Code 卻<strong>沒有那麼自由</strong>——我們需要這本書，而且要好好實踐它。</p><span id="more"></span><h2 id="只講重點"><a href="#只講重點" class="headerlink" title="只講重點"></a>只講重點</h2><p>雖然是偏筆記的形式，但我也不想重複那些基本知識，所以只講重點，視需要給予書中的細節。</p><p>重要的是，我們「知道」有這件事。這是一種「嗅覺」，你也可以說，是對於「程式碼壞味道」的嗅覺。</p><p>儘管在不久的將來，我們產出的程式碼，可能有相當部分是 AI 幫我們寫的，但那依舊不妨礙我們對於 Clean Code 的追求——畢竟你還是要審視 AI 的產出，並適時修正與完善。</p><hr><p>本文整理書中第 3-5 章重點，前 2 章我覺得重要性普通就略過了。</p><h2 id="第-3-章：使用-Black-進行程式碼格式化"><a href="#第-3-章：使用-Black-進行程式碼格式化" class="headerlink" title="第 3 章：使用 Black 進行程式碼格式化"></a>第 3 章：使用 Black 進行程式碼格式化</h2><p>Formatter——格式化器——想必大家都很熟悉了，我也有不少文章提過（雖然主要講 yapf），有興趣可以查看「<a href="https://blog.kyomind.tw/tags/Code-Formatting/">Code Formatting</a>」這個標籤。</p><p>提 formatter 肯定要提 <a href="https://peps.python.org/pep-0008/">PEP 8</a>，畢竟所有的 Python formatter 都是以 PEP 8 為基礎，再加上一些慣例或額外規則。</p><p>所以這章有一定的篇幅與範例都是在講 PEP 8，這裡只提一個我覺得比較容易被忽略（但我認為重要）的點——垂直間距（空行）。</p><p>至於要用哪個格式化器，本書推薦 Black。我認為 yapf 也不錯。</p><h3 id="垂直間距"><a href="#垂直間距" class="headerlink" title="垂直間距"></a>垂直間距</h3><p>這名稱好學術，講白了就是程式碼之間的「空行」。</p><blockquote><p>空行是一種藝術。</p></blockquote><p>就跟文章的分段一樣，程式碼的空行太多會流於鬆散，而太少則過度緊迫。如何拿捏，需要你對<strong>美感與程式可讀性</strong>有幾分「<strong>直覺</strong>」才行。</p><p>所幸，PEP 8 有基本規則：</p><ol><li>函式之間：2 行空行。</li><li>類別之間：2 行空行。</li><li>類別的方法之間：1 行空行。</li></ol><p>這 3 種空行，格式化器能幫你自動完成。另外，空 3 行或在上述情境「以外」的地方空 2 行，都是不允許的😷</p><p>格式化器會一併修正（linter 也會提醒），不會讓你自由發揮。</p><p>這麼說來，真正難的，還是<strong>什麼時候要空 1 行</strong>。我想這就是<strong>空行藝術</strong>的所在了。</p><h3 id="Why-Black？"><a href="#Why-Black？" class="headerlink" title="Why Black？"></a>Why Black？</h3><p>本書推薦 Black 的理由，就跟許多大型 Python 開源專案採用 Black 的理由一樣——因為它的<strong>規則最硬</strong>，大家只能乖乖遵守：</p><blockquote><p>如果您正在與其他人一起進行某個程式專案，只要使用 Black 工具就能立即解決所有關於格式化程式碼的許多爭論與協調。</p></blockquote><p>真的，只要協作的人愈多，我們對程式碼「<strong>一致性</strong>」的需求就愈高，<strong>優先權</strong>甚至高過了典型的<strong>慣例與規則</strong>。比如 Google 要求內部 Python 專案中的程式碼縮排為 2 個空格而不是常見的 4 個。</p><p>2 空格的縮排既不符合 PEP 8，也並非常見慣例，是基於團隊與專案的<strong>一致性要求</strong>。</p><p>而一致性的本質就是——<strong>這沒得商量</strong>。</p><p>沒得商量，就沒必要爭執，而且誰也不能怪誰，因為這是 Black 規定的！</p><p>不過，如同我之前的文章介紹，大多數時候我還是會變更下列兩個 Black 預設值：</p><ol><li>單行字元上限。</li><li>停用強制雙引號。</li></ol><p>最後附上這段我相當認同的引述：</p><blockquote><p>Python 的語法在風格樣式上<strong>更有彈性</strong>。如果您編寫的程式別人看不到，那怎麼樣寫都可以，但是軟體開發工作大都是<strong>共同協作</strong>的，無論與其他人一起在專案上工作，或是請經驗豐富的開發專家來審查您完成的程式，<strong>把程式碼格式化為大家公認的風格樣式是很重要的。</strong></p></blockquote><p>可不是嗎？</p><hr><h2 id="第-4-章：選用易懂的命名"><a href="#第-4-章：選用易懂的命名" class="headerlink" title="第 4 章：選用易懂的命名"></a>第 4 章：選用易懂的命名</h2><p>命名之難，是因為你總是要用很心才能命出好名字。而且情境千變萬化，命名有原則，卻沒有太多捷徑。</p><p>檢查風格樣式，機器可以代勞，但命名就不行了——那是以前！</p><p>現在有了 AI，只要你願意讓它看看你的程式碼，要求它「請幫我找出不恰當的命名」並接受它的建言，我相信肯定很有幫助。</p><p>雖然我們通常不想面對批評，哪怕是來自 AI 的批評。我懂，這是人之常情。包括我自己，也會覺得有點難受。</p><h3 id="兩種不佳的命名模式"><a href="#兩種不佳的命名模式" class="headerlink" title="兩種不佳的命名模式"></a>兩種不佳的命名模式</h3><p><strong>一、prefix，命名的前綴</strong></p><p>為類別中的屬性命名，重複類別名稱作為前綴，比如在 Cat 類別中，屬性 weight 又命名為 cat_weight。這樣做是冗餘的。</p><p>先別說你不會XD，很多時候人都是健忘的。尤其當這個類別是 ORM 中的 Model 時，特別容易！</p><p>而且冗餘的前綴不一定只發生在類別，有時模組中的變數命名，也會再度重複模組名稱作為前綴。</p><p><strong>二、在名稱中以「循序數字」當作後綴</strong></p><p>比如<code>payment1</code>、<code>payment2</code>、<code>payment3</code>。</p><p>我真的很討厭！因為這樣的命名<strong>缺乏表意性</strong>。</p><p>有時候我會在 pytest 的 fixtrue 看到同事這樣寫，我會建議改成比較「<strong>能表現個體特質</strong>」的命名。</p><p>比如<code>payment1</code>改成<code>payment_with_credit_card</code>、<code>payment2</code>改成<code>invalid_payment</code>等等。除非它們之間真的沒有任何區別（通常都有區別，但懶得一一想名字），就只是需要複數個同類型的物件</p><h3 id="不要使用內建名稱"><a href="#不要使用內建名稱" class="headerlink" title="不要使用內建名稱"></a>不要使用內建名稱</h3><p>意即不要使用 Python 的<a href="https://zh.wikipedia.org/zh-tw/%E4%BF%9D%E7%95%99%E5%AD%97">保留字</a>。理由可想而知，因為它會覆蓋原來的內建物件，造成程式的錯誤與混亂。</p><p>那真的需要怎麼辦？一個常見的做法是加上<code>_</code>作為<strong>後綴</strong>。比如<code>type_</code>。</p><h3 id="史上最糟的變數名稱——data"><a href="#史上最糟的變數名稱——data" class="headerlink" title="史上最糟的變數名稱——data"></a>史上最糟的變數名稱——data</h3><p>不瞞您說，<strong>萬事萬物都是資料。</strong></p><p>在實務中，遇到把變數命名為 data 的情況還真不算罕見，往往讓人看得一頭霧水。</p><p>書中的這段話說得非常好（我稍重組了一下原句）：</p><blockquote><p>將變數命名為 data，就像把你的狗命名為 Dog。</p></blockquote><p>簡言之，執意將變數命名為 data，需要非常堅實的理由——通常不存在這樣的理由。</p><hr><h2 id="第-5-章：找出程式碼的異味"><a href="#第-5-章：找出程式碼的異味" class="headerlink" title="第 5 章：找出程式碼的異味"></a>第 5 章：找出程式碼的異味</h2><p>程式碼異味（<a href="https://zh.wikipedia.org/zh-tw/%E4%BB%A3%E7%A0%81%E5%BC%82%E5%91%B3">code smell</a>）指的就是程式中看起來「不對勁」，且有可能在後續引發問題的地方。</p><p>如果可以，我們當然要盡可能避免異味，至少要給予一定關注才行。</p><p>實務上，我會在覺得有明顯異味的地方留下<code>XXX</code>註解，闡述異味的理由，並留意後續發展。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XXX PATCH 做的事情太多了，很容易發生狀態殘留問題</span></span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">&#x27;PATCH&#x27;</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>畢竟異味不一定都會造成問題，也不是所有的異味都要被修正（因為太多了），甚至隨著後續開發，原本看起來的異味可能隨之消散或減緩——但這屬於少見的情況。大部分都是愈來愈糟，不然怎麼會有「<strong>技術債</strong>」這個詞呢？</p><p>書中所舉的異味種類很多，也都很經典，值一一細讀。不過限於篇幅，我只舉其中幾個我認為比較有代表性的異味。</p><h3 id="一、重複的程式碼"><a href="#一、重複的程式碼" class="headerlink" title="一、重複的程式碼"></a>一、重複的程式碼</h3><p>重複程式碼肯定不是一個錯誤（error），卻很可能造成後續維護上的困擾。典型的困境就是改一個地方結果多處也要跟著一起改時，我稱之為程式碼的「<strong>同步</strong>」問題。</p><blockquote><p>需要手動同步，就是壞味道。</p></blockquote><p>通常我們會將這部分抽取出來，讓程式只需要改動一處，就能在所有引用處生效。</p><p>不過，書中也說了，重複一、兩次通常沒有關係；而重複三、四次時，就要好好考慮了是否重構或刪除。</p><p>而且有些時候，重複反而是比較簡潔的做法——無腦但直觀，可讀性最高。</p><p>確實，單憑形式上的「是否重複」來判斷要不要修改程式碼，往往是不足夠的。還要看<strong>使用的場景</strong>。比如前面說的那種會發生同步問題的重複，哪怕只有一次，我也會特地抽出來。</p><p>顯然，這需要一些經驗，與一次又一次的思考。</p><h3 id="二、魔術數字"><a href="#二、魔術數字" class="headerlink" title="二、魔術數字"></a>二、魔術數字</h3><p>有些數字我們很容易知曉其含意，比如 3.14，而有些則否。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expiration = time.time() + <span class="number">604800</span></span><br></pre></td></tr></table></figure><p>這 604800 究竟代表什麼？我們肯定需要停下來思考，可能需要花一些時間才能想出來。這樣的寫法顯然太不直觀。</p><p>重點是，<strong>你縱使猜得到，也無法 100% 確定</strong>。</p><p>一種改進方式是加上註解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expiration = time.time() + <span class="number">604800</span>  <span class="comment"># 一星期後失效</span></span><br></pre></td></tr></table></figure><p>原來 604800 代表的是一週的秒數！</p><p>這樣寫好很多，但書中建議我們採取更經典的做法——使用<strong>常數</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECONDS_PER_MINUTE = <span class="number">60</span></span><br><span class="line">SECONDS_PER_HOUR = <span class="number">60</span> * SECONDS_PER_MINUTE</span><br><span class="line">SECONDS_PER_DAY = <span class="number">24</span> * SECONDS_PER_HOUR</span><br><span class="line">SECONDS_PER_WEEK = <span class="number">7</span> * SECONDS_PER_DAY</span><br><span class="line"></span><br><span class="line">expiration = time.time() + SECONDS_PER_WEEK  <span class="comment"># 一星期後失效</span></span><br></pre></td></tr></table></figure><p>常數是在程式中被使用的<strong>固定值</strong>，通常是<strong>不能被改變</strong>的。在使用常數時，我們應該使用<strong>有描述性的命名</strong>，這樣有助於提高程式的可讀性和可維護性。</p><p>常數 + 有描述性的命名，就是應對魔術數字的絕佳手段。</p><p>比如 <a href="https://www.django-rest-framework.org/">Django REST Framework</a>（DRF）中的<code>status</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> JsonResponse(context, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure><p>除了 200，常見的還有：</p><ul><li><code>status.HTTP_400_BAD_REQUEST</code></li><li><code>status.HTTP_404_NOT_FOUND</code></li></ul><p>我們當然可以直接寫<code>status=200</code>、<code>400</code>、<code>404</code>，看起來也很直觀，但對於那些我們<strong>沒那麼熟悉</strong>的 HTTP 狀態碼，比如 509，則又需要陷入停頓與思考。</p><p>而使用常數的話，則所有成員都會更加一視同仁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status.HTTP_509_BANDWIDTH_LIMIT_EXCEEDED</span><br></pre></td></tr></table></figure><h3 id="三、雙層生成式"><a href="#三、雙層生成式" class="headerlink" title="三、雙層生成式"></a>三、雙層生成式</h3><p>書中的例子是，你想把一個二維 list「攤平」成一維，於是寫了<strong>雙層串列生成式</strong>（List <a href="https://steam.oxxostudio.tw/category/python/basic/comprehension.html">Comprehension</a>）進行處理，像這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nested_list = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat_list = [num <span class="keyword">for</span> sub_list <span class="keyword">in</span> nested_list <span class="keyword">for</span> num <span class="keyword">in</span> sub_list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat_list</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>這樣的寫法雖然簡短，但<strong>可讀性極差</strong>。哪怕是 Python 老手，也很難一眼就看出來這個生成式到底在做什麼。</p><p>作者建議用雙層的 for 迴圈改寫，以增加可讀性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nested_list = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat_list = []</span><br><span class="line"><span class="keyword">for</span> sub_list <span class="keyword">in</span> nested_list:</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> sub_list:</span><br><span class="line">        flat_list.append(num)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat_list</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>確實，但說真的，可以的話，也盡量不要使用雙層迴圈。</p><p>其中的原因，容我直接引用<a href="https://www.facebook.com/kyomind/posts/pfbid02KKKWxAjUxGWVep39bUDUyopBPrJcWj6Wv7tMU5wuZqF9AknA8cQT88zJQUNMS7sl">臉書舊貼文</a>：</p><blockquote><p>程式碼裡有：一層迴圈是壞味道，兩層迴圈是罪惡，三層迴圈是罪大惡極<br>　<br>因為這些都是程式中的「手工藝」，乏缺架構思維，除了當下用起來很「方便」，日後更可能是難以維護，畢竟正常人無法一眼就看出第二、三層迴圈到底在做什麼（仔細看也一樣啦！）<br>　<br>此乃典型的技術債，而且是很廉價的那種</p></blockquote><p>雙重迴圈有時是不得已——總會有這樣的時候，但我們仍必須<strong>視之為罪惡</strong>。</p><h2 id="程式碼異味的迷思"><a href="#程式碼異味的迷思" class="headerlink" title="程式碼異味的迷思"></a>程式碼異味的迷思</h2><p>這是第 5 章的最後一節，但我覺得特別精彩，值得獨立拿出來講。</p><p>書中所謂「程式碼異味的迷思」，指的是<strong>作者不認為那是異味</strong>，但常常會被視為異味的情況。</p><p>書中列舉了 5 個迷思（作者<strong>不認同</strong>的命題），分別如下：</p><ol><li>迷思：函式末尾應該只有一個 return</li><li>迷思：函式中最多應該只有一個 try 陳述句</li><li>迷思：旗標（flag）引數是不好的</li><li>迷思：全域變數是不好的</li><li>迷思：注釋是不需要的</li></ol><p>有些你可能也不覺得是迷思，沒關係，這裡我只打算討論第 5 個。</p><h2 id="註解是不需要的？"><a href="#註解是不需要的？" class="headerlink" title="註解是不需要的？"></a>註解是不需要的？</h2><p>我們可能聽過類似「好的程式碼應該透過優秀的命名與明確的意圖來自我表達、好的程式不需要註解」等等論述。</p><p>這堪稱是一種理想，乍聽也有幾分道理，但事實又如何呢？</p><p>在我看來，不寫任何註解或 <a href="https://en.wikipedia.org/wiki/Docstring">docstring</a>，卻期待程式非常好讀，幾乎是不可能的！</p><p>註解或 docstring 使用自然語言，表達能力與彈性<strong>遠遠超過</strong>受限於「用詞精簡且著重於功能面」的程式碼。</p><p>我在「<a href="https://blog.kyomind.tw/good-vscode-extensions/#Python-docstring-%E4%B9%8B%E6%88%91%E8%A6%8B">Python docstring 之我見</a>」也表述過類似的看法：</p><blockquote><p>在我看來，無論程式寫得如何簡潔易讀，對一些比較複雜的函式或類別而言，<strong>docstring 終究是不可少的</strong>。因為文字的<strong>詮釋能力</strong>和程式碼相比，<strong>絕不在同一個層次</strong>，相信這也是為何 docstring 會有屬於自己的獨立 PEP 加以規範的理由。</p></blockquote><blockquote><p>不知道你怎麼看？我相信，寫好 docstring，是簡潔程式碼<strong>不可或缺的一環</strong>，更是優秀軟體工程師的必備條件——我對此深信不疑。</p></blockquote><h3 id="註解與-docstring-的價值"><a href="#註解與-docstring-的價值" class="headerlink" title="註解與 docstring 的價值"></a>註解與 docstring 的價值</h3><p><strong>有些事很重要</strong>，開發者在維護與修改程式時<strong>必須知道</strong>，這些事往往難以直接藉由程式碼透露出來，<strong>比如函式的「使用方式」與「注意事項」</strong>，這時註解就派上用場了。</p><p>退萬步言，複雜的程式光要看懂就很不容易。而良好的註解與 docstring <strong>可以大幅縮短閱讀理解的時間</strong>，你的隊友一定會感謝你。</p><p>尤其在團隊開發時，<strong>註解與 docstring 是溝通的重要媒介</strong>，有時甚至是<strong>唯一</strong>的媒介。</p><p>當然我們也不得不承認，很多註解都寫得很爛！但這不是註解的錯，而是寫的人還不夠熟練或深思。而且寫好註解也真的很難，需要大量的練習。</p><p>顯然作者也是這麼認為的：</p><blockquote><p>要寫出簡潔有效的注釋並不容易，注釋就像程式碼一樣，需要重寫和多次修調才會更好。</p></blockquote><h3 id="寫好註解是同理心的表現"><a href="#寫好註解是同理心的表現" class="headerlink" title="寫好註解是同理心的表現"></a>寫好註解是同理心的表現</h3><p>就像我在〈<a href="https://blog.kyomind.tw/weekly-review-18/">18，論軟體工程師常見的「路徑依賴」問題（上）</a>〉中所闡述的：</p><blockquote><p>寫程式若只顧自己，終究難登大雅之堂。這些程式碼看起來就像是<strong>一個人的自言自語</strong>（只要自己有完成任務就好）——<strong>它並沒有在溝通</strong>。</p></blockquote><p>程式碼是溝通，而註解更是。它是同理心中「<strong>換位思考</strong>」的具體表現。</p><p>而且，把註解寫好，自己也會是受益者。因為我們不可能總是記得程式的所有細節，哪怕是自己寫的程式。</p><p>優秀的註解和 docstring，讓人讀程式時心曠神怡，維護的壓力也小得多。我相信任何開發者都希望自己接手的是這樣的程式碼。</p><p>在團隊協作中，這是一種任何人都會喜愛的溫柔。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tS78Ke0.png&quot; alt=&quot;Python 功力提升的樂趣&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是《&lt;a href=&quot;https://www.tenlong.com.tw/products/9789865027711&quot;&gt;Python 功力提升的樂趣：寫出乾淨程式碼的最佳實務&lt;/a&gt;》筆記的第 1 篇，你可以把它當作是一則重點整理，加上我個人的開發經驗與心得。&lt;/p&gt;
&lt;h2 id=&quot;系列緣起&quot;&gt;&lt;a href=&quot;#系列緣起&quot; class=&quot;headerlink&quot; title=&quot;系列緣起&quot;&gt;&lt;/a&gt;系列緣起&lt;/h2&gt;&lt;p&gt;我會用數篇文章，把本書的重點一一勾勒出來。之所以願意這麼做，主要有兩個原因。&lt;/p&gt;
&lt;h3 id=&quot;要真正落實-Clean-Code，著實不易&quot;&gt;&lt;a href=&quot;#要真正落實-Clean-Code，著實不易&quot; class=&quot;headerlink&quot; title=&quot;要真正落實 Clean Code，著實不易&quot;&gt;&lt;/a&gt;要真正落實 Clean Code，著實不易&lt;/h3&gt;&lt;p&gt;雖然任何一種程式語言都能夠寫出堪稱簡潔的程式碼，但 Python 可能是最接近「自然語言」的那個，從這個角度看，Python 的 Clean Code 或許是最美的。&lt;/p&gt;
&lt;p&gt;但因為 Python 的自由度，往往實際上的程式碼品質都不是那麼理想——你甚至希望它不要那麼自由。&lt;/p&gt;
&lt;h3 id=&quot;我認為這本書被低估了&quot;&gt;&lt;a href=&quot;#我認為這本書被低估了&quot; class=&quot;headerlink&quot; title=&quot;我認為這本書被低估了&quot;&gt;&lt;/a&gt;我認為這本書被低估了&lt;/h3&gt;&lt;p&gt;意思是它似乎不那麼有名。&lt;/p&gt;
&lt;p&gt;當然，講 Clean Code Python 的書也不只這本，但我認為本書是&lt;strong&gt;最適合起手&lt;/strong&gt;的一本。儘管它面向的是 Python 新鮮人，但不得不承認，即使已經寫了一、兩年 Python 的開發者，對於書中建議的落實，往往都還有所不足。&lt;/p&gt;
&lt;p&gt;儘管 Python 是自由的，但 Clean Code 卻&lt;strong&gt;沒有那麼自由&lt;/strong&gt;——我們需要這本書，而且要好好實踐它。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="書" scheme="https://blog.kyomind.tw/tags/%E6%9B%B8/"/>
    
    <category term="Clean Code" scheme="https://blog.kyomind.tw/tags/Clean-Code/"/>
    
    <category term="Black Formatter" scheme="https://blog.kyomind.tw/tags/Black-Formatter/"/>
    
    <category term="筆記" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="閱讀心得" scheme="https://blog.kyomind.tw/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>20，更新部落格「關於我」至 2.0</title>
    <link href="https://blog.kyomind.tw/weekly-review-20/"/>
    <id>https://blog.kyomind.tw/weekly-review-20/</id>
    <published>2023-07-29T17:27:31.000Z</published>
    <updated>2023-08-02T09:03:17.466Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>從〈<a href="https://blog.kyomind.tw/weekly-review-05/">05，終於寫了「關於我」頁面</a>〉至今，已經近 8 個月。這次「<a href="https://blog.kyomind.tw/about/">關於我</a>」終於迎來 2.0 版更新。</p><p>1.0 版的「關於我」，尚有參考借鑑其他作者共 3 篇自介的影子，到了 2.0，應該已經不太容易發現這些痕跡。</p><p>這也符合<strong>創作的本質</strong>——從風格模仿到慢慢演化出自己的偏好。</p><p>本篇會講述本次更新的<strong>重點思路</strong>，可以視為有關這次更新的「導讀」與補充。</p><span id="more"></span><h2 id="更新概要"><a href="#更新概要" class="headerlink" title="更新概要"></a>更新概要</h2><p>整體而言，這次新增了有關「<a href="https://en.wikipedia.org/wiki/Cal_Newport">Cal Newport</a>」的一整段內容（往後的文章中，他的名字將更常出現），以及<strong>對舊有內容的刪減與補充</strong>。</p><p>我刪掉了關於「記錄控」一節，這並不是說我不記錄了，而是我認為這部分的代表性和其它部分相比，還略有不足。</p><p>加上自介篇幅不宜過長，新增了一段，只好也刪掉一段。</p><p>此外，幾乎每一個段落都進行了字句調整，還補上了幅篇不多但<strong>極具個人價值觀色彩</strong>的表述。比如：</p><blockquote><p><strong>我相信，人不是機器，不需要知曉一切，更不需要一個「完美」的筆記系統。</strong></p></blockquote><p>這段除了呼應到新增的 Cal Newport 相關內容，也代表了我看待這些筆記工具的基本態度。</p><hr><h2 id="Cal-Newport-段落"><a href="#Cal-Newport-段落" class="headerlink" title="Cal Newport 段落"></a>Cal Newport 段落</h2><p>Cal Newport 在台灣被翻譯出版了 4 本書，其中最著名的無疑是《<a href="https://www.books.com.tw/products/0010906940">Deep Work 深度工作力：淺薄時代，個人成功的關鍵能力</a>》。</p><p>我都買了也看了，最有共鳴的一本，當然屬已經為其寫過數篇文章的《深度數位大掃除》，Weekly Review 上一期就是在探討書中的「數位斷捨離」。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-19/">19，AI 時代的生存指南（二）數位斷捨離</a></p></blockquote><p>但，必須承認，除了《深度數位大掃除》與數位斷捨離，我相當認同也實踐了一番外。他的《深度工作力》和《深度職場力》，我乍看感覺都和現實世界有好一段距離。</p><p>換句話說，我並不相信大多數人真的能實踐——因為這些理論看起來很不容易。</p><h2 id="深度工作的極限想像"><a href="#深度工作的極限想像" class="headerlink" title="深度工作的極限想像"></a>深度工作的極限想像</h2><p>Cal Newport 在其著名且廣為流傳的文章〈<a href="https://calnewport.com/fixed-schedule-productivity-how-i-accomplish-a-large-amount-of-work-in-a-small-number-of-work-hours/">Fixed-Schedule Productivity: How I Accomplish a Large Amount of Work in a Small Number of Work Hours</a>〉中，闡述了他如何在一週工作約 40 小時的「限制」內，完成許多重要的事。</p><p>文章中提到了他的一週實際工作時間如下：</p><ul><li>工作日早上 9 點到下午 5 點</li><li>星期日早上</li></ul><p>除上述時段外，他就不碰工作，而是做自己想做的事。這聽起來<strong>很不可思議</strong>，但他的確做到了。</p><p>至少在時間上，他並沒有「做更多」，但「產能」卻相當可觀。</p><p>合理推測，一般人如果要完成相同的工作量，可能需要 50、60 小時，甚至更久——<strong>這也是為何這篇文章的迴響驚人。</strong></p><p>但我認為，一般人看到這樣的內容，最強烈的感受可能不是深深佩服或想要立即效仿，而是覺得<strong>壓力很大</strong>！因為「<strong>密度</strong>」太高了。</p><p>意思是，這套模式對實踐者的「<strong>紀律與決心、面對變化的決策與彈性拿捏</strong>」等等，<strong>要求極高</strong>——我還不如老老實實加班或延長工作時間，為什麼非得在 40 小時內做完？</p><h2 id="我的折衷"><a href="#我的折衷" class="headerlink" title="我的折衷"></a>我的折衷</h2><p>然而就像更新中說的：</p><blockquote><p>直到最近接觸了他的 Podcast《<a href="https://podcasts.apple.com/us/podcast/deep-questions-with-cal-newport/id1515786216">Deep Questions with Cal Newport</a>》，有機會從書籍以外的各種角度，更深入了解他的想法。</p></blockquote><p>附帶一提，我不是真的聽了這些 Podcast，而是靠 <a href="https://goodsnooze.gumroad.com/l/macwhisper">MacWhisper</a> 語音轉文字，並使用 ChatGPT Code Interpreter 整理、Logseq 筆記。</p><p>原本我覺得「深度工作」是一個曲高和寡的理論，現在稍為改觀了——我想要實現這種可能。</p><p>儘管我認為要達到 Cal Newport 這樣的水準依舊難如登天，但我願意相信這些理論是可行的，哪怕是像我一樣的凡人。</p><p>我大概無法只用 40 小時就做到這麼多事，但我可以試著用 25 小時做出原本自己要花 30、40 小時才能達到的價值。</p><p>在我看來，這已經相當了不起。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;從〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-05/&quot;&gt;05，終於寫了「關於我」頁面&lt;/a&gt;〉至今，已經近 8 個月。這次「&lt;a href=&quot;https://blog.kyomind.tw/about/&quot;&gt;關於我&lt;/a&gt;」終於迎來 2.0 版更新。&lt;/p&gt;
&lt;p&gt;1.0 版的「關於我」，尚有參考借鑑其他作者共 3 篇自介的影子，到了 2.0，應該已經不太容易發現這些痕跡。&lt;/p&gt;
&lt;p&gt;這也符合&lt;strong&gt;創作的本質&lt;/strong&gt;——從風格模仿到慢慢演化出自己的偏好。&lt;/p&gt;
&lt;p&gt;本篇會講述本次更新的&lt;strong&gt;重點思路&lt;/strong&gt;，可以視為有關這次更新的「導讀」與補充。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
    <category term="Deep Work" scheme="https://blog.kyomind.tw/tags/Deep-Work/"/>
    
  </entry>
  
  <entry>
    <title>Evernote 最佳替代方案——筆記軟體 Bear 2 升級心得</title>
    <link href="https://blog.kyomind.tw/bear/"/>
    <id>https://blog.kyomind.tw/bear/</id>
    <published>2023-07-16T20:12:36.000Z</published>
    <updated>2023-07-29T16:36:15.119Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/CkddA67.png" alt="bear.app"><span class="cap">bear.app</span></p><p>在〈<a href="https://blog.kyomind.tw/simple-notion/">使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？</a>〉一文中，我曾提到：</p><blockquote><p>如果你正在尋找一款和 Evernote 界面相似、使用邏輯相仿，且<strong>符合現代潮流</strong>的 app，那麼我誠摯推薦自己也有在用的 <a href="https://bear.app/">Bear</a>。（可惜它只限 macOS 與 iOS 平台）</p></blockquote><p>Bear（中文名稱：<strong>熊掌記</strong>）、Notion、Logseq 這三者，都是我目前<strong>持續使用中</strong>的筆記軟體，雖然在使用量上，它們呈現一個<strong>非常不均勻</strong>的分布：</p><ul><li>Logseq：80%</li><li>Notion：15%</li><li>Bear：5%</li></ul><p>對，你沒看錯，Bear 的使用量只佔我全部筆記的 5% 而已。</p><p>儘管如此，我依舊是一個忠實的 Bear 付費用戶。原因無他，因為無論是 Notion 還是 Logseq，它們都太「<strong>重</strong>」了！</p><span id="more"></span><h2 id="簡易型筆記軟體"><a href="#簡易型筆記軟體" class="headerlink" title="簡易型筆記軟體"></a>簡易型筆記軟體</h2><p>當我只想儲存一些<strong>簡單內容</strong>，比如常用資訊（地址、帳號、手機）；或完全不想歸類的獨立筆記，比如臉書文章摘要。此時，<strong>我需要更簡單、輕量的筆記工具</strong>。</p><p>而這些筆記、內容的特色是：</p><ul><li>當我需要它們的時候，我要能<strong>快速獲取</strong>！</li><li>我不想為它們進行有系統的組織與架構，只求<strong>大概整理、排序</strong>。</li></ul><p>因此，我不願動用 Notion、Logseq 這兩把「牛刀」，徒增心理上的負擔。</p><p>我相信，這樣的「簡單需求」始終存在，所以我還是需要第三個筆記軟體。</p><h2 id="Bear-2"><a href="#Bear-2" class="headerlink" title="Bear 2"></a>Bear 2</h2><p>要說 macOS 上的簡易型筆記軟體，很多人會先想到 <a href="https://apps.apple.com/us/app/notes/id1110145109">Apple Notes</a>。</p><p>畢竟對 Mac 用戶而言，它不止免費，而且還不需要額外安裝，同時也完全符合訴求。</p><p><a href="https://bear.app/">Bear</a> 則是另一個有力選項，以流暢的操作手感與簡潔優雅的使用者介面聞名。和多數筆記軟體相同，它可以免費使用，然後付費解鎖額外功能。</p><p>3 年前，我<a href="https://blog.kyomind.tw/weekly-review-09/#%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%8F%B0-Macbook%EF%BC%9AMacbook-Air-2020-Intel-%E7%89%88">剛換新的 Macbook</a>。不同以往，我沒有再透過 <a href="https://zh.wikipedia.org/zh-tw/%E5%90%AF%E5%8A%A8%E8%BD%AC%E6%8D%A2">Boot Camp</a> 灌 Windows，而是開始試著使用 macOS。也是從那時才正式上手 Bear。</p><p>就在本月，Bear 迎來了許多人等待數年之久的重大更新——<a href="https://blog.bear.app/2023/07/bear-2-is-here/">Bear 2</a>。</p><p>這篇，我們就來聊聊，Bear 2 帶給我的感受。</p><hr><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>文章首先會講一下我對 Bear 這個筆記工具的整體看法，以及為何它是 Evernote 的優秀替代方案。</p><p>其次是介紹這次 Bear 2 總計 20-30 項更新中，我個人比較有感的 4 項。最後給出一個簡要的結論。</p><p>值得一提的是，因為 Bear 只是我的「第三」筆記軟體，所以我對它的要求與第一筆記軟體——Logseq——有<strong>很大的不同</strong>！</p><p>換句話說，就是一個<strong>輕度用戶</strong>會有的需求。原則上只要「<strong>方便</strong>」就好，不求功能強大或面面俱到。</p><h3 id="目標讀者"><a href="#目標讀者" class="headerlink" title="目標讀者"></a>目標讀者</h3><p>本文目標讀者有三。但無論如何，你得先是一個 macOS 或 iOS 用戶才行🥹</p><ol><li>屬於這波 <a href="https://www.bnext.com.tw/article/72698/evernote-join-bending-spoons">Evernote 逃難潮</a>，正在考慮下一個筆記軟體的人。</li><li>已嘗試過 <a href="https://www.notion.so/">Notion</a>、<a href="https://obsidian.md/">Obsidian</a>、<a href="https://logseq.com/">Logseq</a>、<a href="https://heptabase.com/">Heptabase</a> 等筆記軟體，<strong>覺得這些東西實在太複雜</strong>的人——它們確實都很複雜😷</li><li>不想用 Apple Notes 的人。</li></ol><hr><h2 id="不用-Apple-Notes-的理由"><a href="#不用-Apple-Notes-的理由" class="headerlink" title="不用 Apple Notes 的理由"></a>不用 Apple Notes 的理由</h2><p>可能有讀者好奇，既然前面都說 Apple Notes「不止免費，也符合訴求」，那為什麼我不用 Apple Notes 呢？</p><p>我可以想到<strong>兩個理由</strong>，而且它們<strong>對我已經足夠充分</strong>。</p><h3 id="一、Apple-Notes-對-Markdown-的支援不足"><a href="#一、Apple-Notes-對-Markdown-的支援不足" class="headerlink" title="一、Apple Notes 對 Markdown 的支援不足"></a>一、Apple Notes 對 Markdown 的支援不足</h3><p>不足？恩…其實就是沒什麼支援啦！</p><p>別誤會，我個人並不愛寫「<strong>純 Markdown</strong>」，否則我應該會是 <a href="https://hackmd.io/">HackMD</a> 或 <a href="https://ulysses.app/">Ulysses</a> 的支持者——顯然我不是。</p><p>且我在〈<a href="https://blog.kyomind.tw/my-markdown-writing-flow/#%E4%B8%8D%E6%84%9B-Markdown%EF%BC%8C%E5%8F%AA%E6%84%9B%E7%B7%A8%E8%BC%AF%E5%99%A8%E7%9A%84%E6%88%91">Notion + VS Code：我的 Markdown 寫作工作流</a>〉中已表明：我還是更偏好編輯器一些。</p><p>但是！<strong>文件本身最好還是要支援 Markdown</strong>，因為這樣才能<strong>輕鬆跨平台</strong>。</p><p>這也是為什麼我可以在 Notion 上寫文章草稿，然後直接<strong>複製貼上</strong>，就能在 VS Code 中繼續編輯，然後發表。</p><h3 id="二、文字排版的選項太少"><a href="#二、文字排版的選項太少" class="headerlink" title="二、文字排版的選項太少"></a>二、文字排版的選項太少</h3><p>對我而言，這是 Apple Notes <strong>最大的缺點</strong>，也是我不用它的<strong>根本理由</strong>。</p><p>事實上，很多筆記軟體都有這個問題。而我「<strong>只會選擇</strong>」允許我控制<strong>字體大小、字型、行高</strong>（三者缺一不可）的筆記工具。</p><ul><li><strong>Notion</strong>：字體只能選「大或小」，而且字型是固定的，十分陽春。<ul><li>但因為有<strong>網頁版</strong>，我能透過 <a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne">stylus</a> 等瀏覽器外掛，直接重設 CSS 樣式，進而改變字體、字型、行高。</li><li>所以我在電腦上只使用 Notion 的網頁版，不考慮 macOS 版本。</li><li>而手機版，偶爾會用來查看筆記，但不會用來寫筆記，所以影響不大。</li></ul></li><li><strong>Logseq</strong>：沒有網頁版，但因為有<code>custom.css</code>設定檔，<strong>排版可以完全自訂</strong>。</li><li><strong>Bear</strong>：沒有網頁版，也沒有設定檔。但它的字型、字體大小、行高，<strong>全部都可以調整！</strong>🎉</li></ul><p><strong>中文排版</strong>是個大議題，會相當程度影響使用者體驗——<strong>至少很影響我的體驗</strong>。</p><p>有興趣可參考這篇〈<a href="https://medium.com/deerlight/medium-6a42f494254">留在 Medium 及暫不自架站</a>〉對「中英文排版差異」的討論：</p><blockquote><p>中文字體的結構統一卻容易缺少節奏感，它需要更多的考量，在編排文字時需要對文字的結構適當的調整，增加文字的節奏，感營造舒適的編排。</p></blockquote><blockquote><p>若需要同時兼顧中英文字體的呈現，不僅是在介面上下手，而是對不同語系的字體樣式都必須要設定得很詳細。</p></blockquote><p>我完全認同。</p><hr><h2 id="為什麼說-Bear-是-Evernote-最佳替代？"><a href="#為什麼說-Bear-是-Evernote-最佳替代？" class="headerlink" title="為什麼說 Bear 是 Evernote 最佳替代？"></a>為什麼說 Bear 是 Evernote 最佳替代？</h2><p>當然是因為它們的「<strong>頁面格局</strong>」和使用方式都相對類似，如圖：</p><p><img src="https://i.imgur.com/5vlTatc.png" alt="Bear 2 使用者介面"><span class="cap">Bear 2 使用者介面</span></p><p>兩者從左至右都是：分類選單、分類文章摘要、本文——只是 Bear 美得多☺️</p><p>不得不承認，這種排版無疑是<strong>最簡潔有力的排版</strong>，使用上非常直觀，對任何人都能輕鬆上手。難怪 Apple Notes 也採用了這個呈現方式。</p><h3 id="標籤-VS-記事本"><a href="#標籤-VS-記事本" class="headerlink" title="標籤 VS 記事本"></a>標籤 VS 記事本</h3><p>真要說不同的話，早期的 Evernote 採用的是很傳統的分類資料夾，稱為「<strong>記事本</strong>」，而且只限一層。加上堆疊，也不過兩層。</p><p>就像我在〈<a href="https://medium.com/code-and-me/why-evernote-7cd2abbfbafd">心得 |《曼無止盡》第40期：Evernote 的重生之路</a>〉一文說的：</p><blockquote><ul><li>只允許「記事本堆疊&gt;記事本&gt;記事」最多共 3 個層級的目錄結構，不像 Notion 或 WorkFlowy 可以無限層級</li><li>承上，層級很少，所以你無法進行太複雜的「專案架構」規劃，只能以簡單分類的方式來歸納記事而已，這顯然不太符合時代潮流</li></ul></blockquote><p>相對的，Bear 則是用「標籤」來形成分類，彈性更大，而且支援無限層級。</p><p>但老實說，<strong>現在的我已不覺得「層級少」是個問題</strong>，我目前的 Notion 或 Logseq 中，往往也<strong>只用兩個層級</strong>而已。</p><blockquote><p>為什麼？</p></blockquote><h3 id="過度分類-x3D-自找麻煩"><a href="#過度分類-x3D-自找麻煩" class="headerlink" title="過度分類 &#x3D; 自找麻煩"></a>過度分類 &#x3D; 自找麻煩</h3><p>因為「多層級」是一種<strong>由上而下</strong>，有著強烈「<strong>中心化精神</strong>」的筆記方式，就像<a href="https://online.visual-paradigm.com/tw/diagrams/templates/organization-chart/organizing-big-pile-of-projects/">傳統的大型組識</a>一樣。它的優點是層次井然、有條理，缺點則是笨重、缺乏彈性。</p><p>「<strong>笨重、缺乏彈性</strong>」在這裡的意思是：你常常得對任意一則筆記<strong>進行詳細的分類</strong>，才能確定它們所在的知識體系——我認為這是在<strong>自找麻煩</strong>。</p><p>而我也自找麻煩了好多年😅，所以才不禁在「<a href="https://blog.kyomind.tw/logseq/#%E4%BA%8C%E3%80%81%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%AD%86%E8%A8%98">二、去中心化筆記</a>」中感嘆道：</p><blockquote><p>分類是一件<strong>令人頭痛的事</strong>，尤其在你還無法摸清楚當前事物該如何分類之際，感覺自己正事（筆記本身）都還沒做，就已深陷在「<strong>架構上的束縛</strong>」。</p></blockquote><p>尤其一個概念往往是<strong>多維的</strong>，複雜的分類容易帶來<strong>管理上的混亂</strong>，而且還會讓你<strong>分心</strong>，因為你得時常思考「<strong>這個筆記應該放在哪裡？</strong>」</p><p>太累了。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/logseq/">Logseq 心得：一顆冉冉升起的「卡片筆記」新星</a></p></blockquote><p>後來 Evernote 也加入了<a href="https://www.playpcesor.com/2016/03/evernote-3-1.html">層級標籤功能</a>，兩者的區別就更小了。真要說的話，主要差異還是產品給人的感覺，尤其是<strong>整體感</strong>與<strong>美感</strong>。</p><p>Evernote 畢竟是 2008 年的產物，受限於時空與古老的軟體架構，而且還要跨平台。它落後於時代，我覺得情有可原。</p><p>但就讓它安息吧。</p><hr><p>好，簡單的比較結束，我們來看看這次 Bear 2 更新對我來說有哪些亮點。所有的更新項目請參考<a href="https://blog.bear.app/2023/07/bear-2-is-here/">網頁</a>，這裡只提其中一部分。</p><h2 id="一、隱藏-Markdown-符號"><a href="#一、隱藏-Markdown-符號" class="headerlink" title="一、隱藏 Markdown 符號"></a>一、隱藏 Markdown 符號</h2><p><img src="https://i.imgur.com/sjJb6cX.png"></p><p>這是一段沒有隱藏 Markdown 符號的 Bear 文本，說真的看起來就是有點煩。而且以前沒有開關，它一定會顯示。</p><p>我相信不是每個人都討厭這樣的設計，因為它的好處是<strong>文本的長度會完全固定</strong>，不會因為 Markdown 符號的顯示、隱藏而有區別。</p><p>但缺點當然就是——略嫌妨礙閱讀。</p><p>現在總算有開關了，讓使用者可以自由選擇。</p><h2 id="二、可調整圖片大小"><a href="#二、可調整圖片大小" class="headerlink" title="二、可調整圖片大小"></a>二、可調整圖片大小</h2><p><img src="https://i.imgur.com/TNj2LeB.png"></p><p>這個真的很重要！</p><p>雖然這功能 Notion、Logseq 都有，但呈現上各有優劣。</p><p>Logseq 的最爛，調整鈕一樣是在右下角，但沒那麼好操作。而且調完後，前後的文本不會跟著移動，需要重新讀取區塊才行。差評！</p><p>Notion 就好多了，使用圖片左右兩側的判定區來調整大小。</p><p>Bear 也很不錯！調整鈕做得很美，拉起來也很順。和 Logseq 相同，圖片都會靠左，而 Notion 則是置中。我個人偏好靠左，與文字一致。</p><h2 id="三、超連結編輯器"><a href="#三、超連結編輯器" class="headerlink" title="三、超連結編輯器"></a>三、超連結編輯器</h2><p><img src="https://i.imgur.com/8yPlckm.png"></p><p>在 Markdown 文件中要編輯超連結，真的不太方便，所以很多支援 Markdown 的軟體會有類似上圖的超連結編輯器，比如 Notion 就有。</p><p>我覺得 Bear 貼心之處在於，每個超連結的末端都加了「<strong>鉛筆</strong>」圖示，按下去即可直接編輯，確實方便。</p><p>相較之下，Notion 則需要游標在連結上<strong>短暫停留</strong>，我感覺稍為麻煩一點。</p><p>但 Bear 的不足則是無法直接取消超連結，只能透過清空下面的連結內容來達成，這就太不直觀了。</p><h2 id="四、還不錯的摺疊功能"><a href="#四、還不錯的摺疊功能" class="headerlink" title="四、還不錯的摺疊功能"></a>四、還不錯的摺疊功能</h2><p><img src="https://i.imgur.com/SFdsEJJ.png"></p><p>相當於 Notion 中的 Toggle，<del>但要透過呼叫選單才能操作，有點不便</del>。</p><p>效果是把整個標題的內容都收納起來，收納後會呈現上面那個 H3 標題樣式。摺疊功能在「<a href="https://blog.kyomind.tw/silver-bullets/#%E4%BA%8C%E3%80%81%E6%94%B6%E5%90%88">清單式筆記</a>」幾乎是必備元素，已經相當成熟。</p><p>經<a href="https://github.com/kyomind/blog-reply/issues/17#issuecomment-1642026218">網友補充</a>，摺疊功能可以透過快捷鍵「<code>⌘ + &#39;</code>」操作，那就很方便了！</p><p>如此一來，這個摺疊功能將<strong>明顯超越 Notion 的 Toggle</strong>，因為 Notion 的 Toggle 是<strong>獨立元素</strong>，不可以和一般版本的標題、清單混用。</p><p>而 Bear 的摺疊功能，則是<strong>直接融入</strong>標題、清單中，使用上更為簡潔、自然。</p><h2 id="五、其它更新項目簡評"><a href="#五、其它更新項目簡評" class="headerlink" title="五、其它更新項目簡評"></a>五、其它更新項目簡評</h2><p>其餘比較值得一提的更新：</p><ul><li><strong>Table of Contents</strong>：不是在文本中，是在<strong>資訊欄的第二分頁</strong>，可以快速跳轉同頁內容，對長文本比較有用。</li><li><strong>表格</strong>：偶爾需要，而且用起來比 Notion 的順手。</li><li><strong>自訂字型</strong>：雖然我覺得這是現代筆記工具的<strong>基本</strong>，但很多軟體都沒有！</li><li><strong>反向連結</strong>：類似 Notion 會把<strong>連結到這個筆記</strong>的相關筆記清單列在頁面開頭，而 Bear 則是放在<strong>資訊欄的第三分頁</strong>。查看起來不方便，我覺得不實用。</li></ul><p>附帶一提，在 Bear 筆記頁中輸入<code>[[</code>然後空一格，會出現頁面搜尋清單，可以讓你輕鬆建立<strong>正向連結</strong>。（也就是把其餘筆記連結到當前頁面）</p><hr><h2 id="結語：對需求保持清醒"><a href="#結語：對需求保持清醒" class="headerlink" title="結語：對需求保持清醒"></a>結語：對需求保持清醒</h2><p>Bear 2 力求在維持簡潔的基礎上，盡可能加入一些常用的便捷功能。</p><p>在這個筆記軟體的戰國時代，「功能的<strong>多樣化</strong>與<strong>複雜化</strong>」幾乎是現代筆記軟體都會遇到的<strong>兩難困境</strong>，猶如一場軍備競賽：</p><ul><li>別人有的功能你沒有，難免會<strong>流失一些客群</strong>。</li><li>但如果你有樣學樣，不斷增加新功能，又可能<strong>讓使用者感到負擔</strong>。</li></ul><p>這種情況下還要繼續貫徹簡潔精神，我認為很不容易。所以我依舊欣賞 Bear，因為它有一定的——被嫌棄的勇氣。</p><p>當然，某些功能的更新也讓我覺得，它感受到一定的壓力，不得不加入。</p><p><strong>如何保持清醒，對目標用戶需求有一定清晰認知</strong>，是開發方需要不斷思考的問題。</p><p>而對身為使用者的我們而言，恐怕也是如此。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CkddA67.png&quot; alt=&quot;bear.app&quot;&gt;&lt;/p&gt;
&lt;p&gt;在〈&lt;a href=&quot;https://blog.kyomind.tw/simple-notion/&quot;&gt;使用 Notion 滿 3 年，為何我仍「不推薦」用它來管理你的人生？&lt;/a&gt;〉一文中，我曾提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你正在尋找一款和 Evernote 界面相似、使用邏輯相仿，且&lt;strong&gt;符合現代潮流&lt;/strong&gt;的 app，那麼我誠摯推薦自己也有在用的 &lt;a href=&quot;https://bear.app/&quot;&gt;Bear&lt;/a&gt;。（可惜它只限 macOS 與 iOS 平台）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bear（中文名稱：&lt;strong&gt;熊掌記&lt;/strong&gt;）、Notion、Logseq 這三者，都是我目前&lt;strong&gt;持續使用中&lt;/strong&gt;的筆記軟體，雖然在使用量上，它們呈現一個&lt;strong&gt;非常不均勻&lt;/strong&gt;的分布：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logseq：80%&lt;/li&gt;
&lt;li&gt;Notion：15%&lt;/li&gt;
&lt;li&gt;Bear：5%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;對，你沒看錯，Bear 的使用量只佔我全部筆記的 5% 而已。&lt;/p&gt;
&lt;p&gt;儘管如此，我依舊是一個忠實的 Bear 付費用戶。原因無他，因為無論是 Notion 還是 Logseq，它們都太「&lt;strong&gt;重&lt;/strong&gt;」了！&lt;/p&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Logseq" scheme="https://blog.kyomind.tw/tags/Logseq/"/>
    
    <category term="筆記軟體" scheme="https://blog.kyomind.tw/tags/%E7%AD%86%E8%A8%98%E8%BB%9F%E9%AB%94/"/>
    
    <category term="個人知識管理" scheme="https://blog.kyomind.tw/tags/%E5%80%8B%E4%BA%BA%E7%9F%A5%E8%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="Notion" scheme="https://blog.kyomind.tw/tags/Notion/"/>
    
    <category term="Bear" scheme="https://blog.kyomind.tw/tags/Bear/"/>
    
    <category term="Evernote" scheme="https://blog.kyomind.tw/tags/Evernote/"/>
    
  </entry>
  
  <entry>
    <title>淺談我對蘋果 M 系列晶片的看法——超新星爆發</title>
    <link href="https://blog.kyomind.tw/apple-silicon/"/>
    <id>https://blog.kyomind.tw/apple-silicon/</id>
    <published>2023-07-02T09:23:58.000Z</published>
    <updated>2023-08-10T08:47:09.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/fGGona2.jpg" alt="apple.com"><span class="cap">apple.com</span></p><p>昨天寫了這篇〈<a href="https://blog.kyomind.tw/mac-mini/">M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南</a>〉後，我發現，我對蘋果 M 系列晶片的讚揚，還遠遠沒有寫夠！</p><p>因此，我續寫了這篇，補充我對 M 系列晶片的看法——解釋為什麼我對它的評價如此之高，甚至接近「信仰」的程度。</p><p>這不僅僅因為它的高效能、低功耗，更重要的是，它讓我深刻理解到：原來（處理器）<strong>世界真的能夠被顛覆</strong>！</p><p>而要充分表達其中的「感動」，還得從採用 Intel 處理器時代的 Mac 說起。</p><span id="more"></span><hr><h2 id="從-Core-系列開始擠牙膏的-Intel"><a href="#從-Core-系列開始擠牙膏的-Intel" class="headerlink" title="從 Core 系列開始擠牙膏的 Intel"></a>從 Core 系列開始擠牙膏的 Intel</h2><p>Apple Mac 早期用的是 IBM <a href="https://zh.wikipedia.org/zh-tw/PowerPC">PowerPC</a> 架構的處理器，但因為效能不足，於 2005 年宣布轉向使用 Intel 處理器。</p><p>Intel 從 2006 的 <a href="https://zh.wikipedia.org/zh-tw/%E9%85%B7%E7%9D%BF#Core%E5%BE%AE%E6%9E%B6%E6%A7%8B%EF%BC%8864%E4%BD%8D%E5%85%83%EF%BC%89">Core</a> 架構開始，與競爭對手 AMD 漸漸拉開了技術差距，造就了其長達 10 年的獨大地位。</p><p>同時也開啟了 Intel 長達 10 年的「<a href="https://youtu.be/4bhHPeCZu0w">擠牙膏之旅</a>」——fuxk。</p><p>直到 2017 年，AMD 推出了全新的 <a href="https://zh.wikipedia.org/zh-tw/AMD_Ryzen">Ryzen</a> 處理器，重新點燃戰火，才正式打破了 Intel 的絕對優勢地位。</p><h2 id="處理器發展的黑暗時代"><a href="#處理器發展的黑暗時代" class="headerlink" title="處理器發展的黑暗時代"></a>處理器發展的黑暗時代</h2><p>維基百科是這麼描述中古黑暗時期：</p><blockquote><p><strong>歐洲黑暗時代</strong>（<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E8%AF%AD">英語</a>：<strong>Dark Ages</strong> 或 <strong>Dark Age</strong>）在編史工作上是指在<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E6%AC%A7">西歐</a>歷史上，從<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD">西羅馬帝國</a>的滅亡到<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E8%89%BA%E5%A4%8D%E5%85%B4">文藝復興</a>開始，一段文化層次下降或者社會崩潰的時期。 在 19 世紀，隨著對<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%B8%96%E7%BA%AA">中世紀</a>更多的了解，整個時代都被描述成「黑暗」的說法受到了挑戰。</p></blockquote><p>如文中所言，中世紀這段時期，是否真的該稱為「黑暗」時代，容有不同看法。</p><p>然而，Intel 獨大的這 10 年，它的壟斷地位對個人電腦發展的影響，就是一片黑暗！</p><p>從 Core 1 代到 7 代，每次更新的效能提升幅度，從前期的 10-15%，到後期甚至降到了 10% 以下，真是充分利用了自身的優勢，令人火大。</p><hr><h2 id="終於有「誠意」的-8-代"><a href="#終於有「誠意」的-8-代" class="headerlink" title="終於有「誠意」的 8 代"></a>終於有「誠意」的 8 代</h2><p>再看維基百科對第 8 代 Core——<a href="https://zh.wikipedia.org/zh-tw/Coffee_Lake">Coffee Lake</a>——的評價：</p><blockquote><p>Coffee Lake 標誌著個人電腦中處理器核心數的一次大升級，<strong>而上一次這樣的升級還是十年前的 Core 2 Duo</strong>。這次的升級主要是因為 AMD 的 Ryzen 系列處理器。</p></blockquote><p>平心而論，8 代 Core 的效能提升絕對是有目共睹的——早該如此了好嗎？</p><p>和前代 Kaby Lake 相比，效能幾乎翻倍！因為筆電處理器的核心數量，從雙核升級到了 4 核，所以確實很有感。</p><p>導致我曾一度以為，擁有 4 核心處理器的 Macbook，應該接近「完全體」了。因此，在 2020 年，我換了<a href="https://blog.kyomind.tw/weekly-review-09/#%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%8F%B0-Macbook%EF%BC%9AMacbook-Air-2020-Intel-%E7%89%88">新的 Macbook Air</a>。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/weekly-review-09/">09，我的 Macbook 之旅 + 新的野心</a></p></blockquote><p>雖然這台 Mac 配備了 Intel 更新的<a href="https://www.intel.com.tw/content/www/tw/zh/products/sku/196589/intel-core-i51030ng7-processor-6m-cache-up-to-3-50-ghz/specifications.html">第 10 代 CPU</a>，但因為屬於<strong>超低功耗系列</strong>，整體效能尚不及採用第 8 代 CPU——<a href="https://www.intel.com.tw/content/www/tw/zh/products/sku/135935/intel-core-i58259u-processor-6m-cache-up-to-3-80-ghz/specifications.html">i5-8259U</a>——的 13 吋 Macbook Pro。</p><p>但考慮它 <a href="https://browser.geekbench.com/processors/intel-core-i5-1030ng7">Geekbench 多核跑分</a>也有 [i5-8259U 跑分</p><p>然而事實是：這台 Mac 的效能<strong>明顯達不到我的要求——它離「完全體」還很遠！</strong></p><hr><h2 id="超新星爆發：Apple-Silicon-M1-降臨"><a href="#超新星爆發：Apple-Silicon-M1-降臨" class="headerlink" title="超新星爆發：Apple Silicon M1 降臨"></a>超新星爆發：Apple Silicon M1 降臨</h2><p>所謂<a href="https://zh.wikipedia.org/zh-tw/%E8%B6%85%E6%96%B0%E6%98%9F">超新星爆發</a>，實際上是大質量恆星生命週期的<strong>終點</strong>，而不是開始或誕生的象徵。</p><p>但因為爆發產生的亮度極高，能量巨大，當我們談論新事物或新概念時，有時我們會用「超新星爆發」來形容它們帶來的顯著變革和影響。</p><p>這種比喻意味著該新事物的出現，伴隨極大的能量和劇烈的變動，<strong>且很可能改變現有的狀態和平衡。</strong></p><p>2020 年底，專為 Mac 設計的 Apple Silicon 晶片正式發表，它的名字叫 <a href="https://zh.wikipedia.org/zh-tw/Apple_M1">M1</a>。</p><p>和我原有的 Macbook Air 相比，它的效能是誇張的 3 倍，而續航力竟然也是 3 倍——<strong>不可思議</strong>。這顯然超越了我們對「進化」的理解——這是「<strong>超新星爆發</strong>」。</p><hr><h2 id="小結：Way-to-Go"><a href="#小結：Way-to-Go" class="headerlink" title="小結：Way to Go"></a>小結：Way to Go</h2><p>革命不可能常常發生，在 M1 帶給我們如此深刻的印象之後，後續的 M2 自然很難複製同樣的衝擊。</p><p>但對我來說，配備 M 系列晶片的 Mac，已經可以稱為「<strong>完全體</strong>」。</p><p>意即，這台機器要用上十年、八年，我相信完全不是問題。這是舊 Intel 時代處理器，所無法帶給我的想望。</p><p>這也是為什麼我願意為 M2 Pro Mac mini 加購那麼多「不一定必要」的升級——因為我對它的<strong>長期價值</strong>，有著相當的信心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fGGona2.jpg&quot; alt=&quot;apple.com&quot;&gt;&lt;/p&gt;
&lt;p&gt;昨天寫了這篇〈&lt;a href=&quot;https://blog.kyomind.tw/mac-mini/&quot;&gt;M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南&lt;/a&gt;〉後，我發現，我對蘋果 M 系列晶片的讚揚，還遠遠沒有寫夠！&lt;/p&gt;
&lt;p&gt;因此，我續寫了這篇，補充我對 M 系列晶片的看法——解釋為什麼我對它的評價如此之高，甚至接近「信仰」的程度。&lt;/p&gt;
&lt;p&gt;這不僅僅因為它的高效能、低功耗，更重要的是，它讓我深刻理解到：原來（處理器）&lt;strong&gt;世界真的能夠被顛覆&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;而要充分表達其中的「感動」，還得從採用 Intel 處理器時代的 Mac 說起。&lt;/p&gt;</summary>
    
    
    
    <category term="隨筆雜談" scheme="https://blog.kyomind.tw/categories/%E9%9A%A8%E7%AD%86%E9%9B%9C%E8%AB%87/"/>
    
    
    <category term="Apple Silicon" scheme="https://blog.kyomind.tw/tags/Apple-Silicon/"/>
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="短篇" scheme="https://blog.kyomind.tw/tags/%E7%9F%AD%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>M2 Pro 版 Mac mini：寫程式最佳選擇！我的心得與選購指南</title>
    <link href="https://blog.kyomind.tw/mac-mini/"/>
    <id>https://blog.kyomind.tw/mac-mini/</id>
    <published>2023-07-01T13:12:39.000Z</published>
    <updated>2023-08-16T16:32:05.982Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/h8Mebn5.jpg" alt="Cassiopeia A 超新星殘骸，直徑約 10 光年"><span class="cap">Cassiopeia A 超新星殘骸，直徑約 10 光年</span></p><p>今年 4 月，我入手了 M2 Pro 版的 <a href="https://www.apple.com/tw/mac-mini/">Mac mini</a>，至今已使用了快 3 個月。隨著配備 M2 Max 的 <a href="https://www.apple.com/tw/mac-studio/">Mac Studio</a> 發表，我認為是時候分享一下我的心得和選購指南——雖然這只是一個粗略的指南。</p><blockquote><p>相關文章：<a href="/apple-studio-display/">Apple Studio Display 適合你嗎？——我的心得與選購指南</a></p></blockquote><h2 id="本文主旨與目標讀者"><a href="#本文主旨與目標讀者" class="headerlink" title="本文主旨與目標讀者"></a>本文主旨與目標讀者</h2><p>本文主要寫給那些<strong>「想買 Mac mini 但還有所遲疑的人」</strong>作為參考，我不會特別鼓吹要買哪一款，這是一篇「平靜」的心得。</p><p>此外，這篇文章是以<strong>我的核心需求</strong>——<a href="/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/">軟體開發</a>——為出發點，對同為軟體工程師的讀者而言，可能更具參考價值。</p><span id="more"></span><h2 id="我的-Mac-mini-規格"><a href="#我的-Mac-mini-規格" class="headerlink" title="我的 Mac mini 規格"></a>我的 Mac mini 規格</h2><p>先講規格，如開頭所言，這是一台 M2 Pro 版的 Mac mini，並做了一些升級：</p><ul><li>升級 CPU 晶片：10C&#x2F;16C（CPU 和 GPU 核心數）升級為 12C&#x2F;19C。</li><li>升級 32 GB RAM。</li><li>升級 1 TB SSD。</li><li>升級 10 Gigabit 乙太網卡。</li></ul><p>總計 69900 元，但我<strong>並不推薦</strong>這樣的配置，文末會推薦我認為 <strong>CP 值較高</strong>的選項。</p><hr><h2 id="為什麼-Mac-mini-才是我寫程式最佳選擇？"><a href="#為什麼-Mac-mini-才是我寫程式最佳選擇？" class="headerlink" title="為什麼 Mac mini 才是我寫程式最佳選擇？"></a>為什麼 Mac mini 才是我寫程式最佳選擇？</h2><p>對於大部分工程師來說，14 或 16 吋的 Macbook Pro 應該是首選。即使在家中使用，也可以透過外接大螢幕來提供更好的工作體驗。</p><p>確實如此，我以前也是這樣想的。</p><p>直到〈<a href="https://blog.kyomind.tw/weekly-review-09/">09，我的 Macbook 之旅 + 新的野心</a>〉，重新思考了自己的需求後，<strong>我發現我真正需要的，是 Mac mini——也許你也是。</strong></p><p>我主要的考慮有三：</p><ol><li>我很少把筆電帶出門使用，雖然是遠端工作但我從不去咖啡廳，所以機動性需求非常小。</li><li>即使真的要帶筆電出門，我也不想帶 14 吋甚至 16 吋的 Macbook Pro——它們都太重也太厚了。</li><li>家中使用，外接<a href="https://blog.kyomind.tw/weekly-review-13/">大螢幕</a>後，筆電<strong>只剩下主機功能</strong>，繼續放在桌上<strong>顯得很佔空間</strong>，不符合我的簡潔美學。很多人會把它立起來或當小螢幕使用，但我不喜歡。</li></ol><p>由此可知，在絕大部分時候，Mac mini 才是我的首選。</p><h2 id="新-Mac-都有的-SSD-降速問題"><a href="#新-Mac-都有的-SSD-降速問題" class="headerlink" title="新 Mac 都有的 SSD 降速問題"></a>新 Mac 都有的 SSD 降速問題</h2><p>現在要買 M2 晶片的 Mac，無論桌機還是筆電，我們都不得不接受一個現實：只要是該系列的「<strong>最低規格</strong>」，那 SSD 就一定是<strong>單晶片</strong>——這意味著<strong>速度較慢</strong>，而且還<strong>慢上不少</strong>。</p><p>哪怕是 M2 Pro 入門起跳的 512 GB SSD，一樣有這個問題，著實令人不快。因為通常最低階的規格，對多數人而言，就是 CP 值最高的選擇。</p><p>而蘋果想必也深知這一點，讓你陷入兩難，真的很討厭！</p><blockquote><p>蘋果你贏了。</p></blockquote><h2 id="為什麼我選擇-M2-Pro？"><a href="#為什麼我選擇-M2-Pro？" class="headerlink" title="為什麼我選擇 M2 Pro？"></a>為什麼我選擇 M2 Pro？</h2><p>作為一個靠電腦吃飯的軟體工程師，我買電腦比較沒那麼重視 CP 值。所以原本一直都把目光放向 Max 而非 Pro。</p><p>原因也非常直接簡單：「因為它叫 Max，作為一個工程師，我應該要 Max！」，即使我明白 Max 和 Pro 在 CPU 效能上是相同的。</p><p>不過在做了更多功課後，我還是得承認，如果用不到 Max 多出來的 GPU 核心，那買 Max 的機型就完完全全是一種浪費。</p><p>而現實中的我，連 Pro 版 GPU 核心都用不太到🐸</p><hr><h2 id="Mac-mini-的選購考量"><a href="#Mac-mini-的選購考量" class="headerlink" title="Mac mini 的選購考量"></a>Mac mini 的選購考量</h2><p>好，捨棄 Max！這是好事，因為 Mac mini 也沒有 Max 版本。如果我堅持要 Max，就只能購買 Mac Studio。</p><p>但我才不想買「體積龐大（相對於 mini😷）」的 Studio！我想這也是促成我堅定選擇 M2 Pro 的<strong>另一大考量</strong>——mini 最多只有 Pro，而我要 mini。</p><p>但問題又來了，如果要買 mini，是要買 M2 版還是 M2 Pro 版呢？</p><blockquote><p>平心而論，我覺得都可以。</p></blockquote><p>這不是開玩笑，因為 M2（或說 M1 及以後）的 Mac，相較於以前的 Intel CPU，效能實在強太多了，而且功耗也低得多。</p><p>以至於我不禁感到，選購 M2 或 M2 Pro，也許只是一個「心情」議題——我真心這麼認為。意即，好一點的規格，很多時候只是為了心安而已。</p><h2 id="M2-和-M2-Pro-差異"><a href="#M2-和-M2-Pro-差異" class="headerlink" title="M2 和 M2 Pro 差異"></a>M2 和 M2 Pro 差異</h2><p>不過話又說回來，哪怕只是為了心安，我們也得先知道 M2 和 M2 Pro 有什麼差異。</p><p>兩者的差異可參考這個影片〈<a href="https://www.youtube.com/watch?v=szBpbSMhe_s">The TRUTH about New Mac Mini after 1 Month - M2 vs M2 Pro!</a>〉，有著相當完整的比較。</p><p>對我而言，大概有這幾個主要差別：</p><ol><li>相較於 M2，Pro 是更強的 CPU 與 GPU。提升幅度依不同場景，約落在 40-80% 之間。</li><li>M2 Pro 的記憶體上限是 32 GB，而 M2 則是 24 GB。對於需要大量記憶體的人，這是一個重要考量。</li><li>M2 Pro 的記憶體頻寬從 100 GB 提升至 200 GB。這個好評！</li><li>SSD 的速度也有差別（而且差滿多的XD），可參考下圖：</li></ol><p><img src="https://i.imgur.com/bSiCE1t.png" alt="來源：Max Tech"><span class="cap">來源：Max Tech</span></p><p>雖然 SSD 速度上差很多，但實際感受上，可能沒有多大差異。</p><p>我的看法是，除非你能「榨乾」GPU，比如全職影像工作者，否則 M2 或 M2 Pro 的「<strong>體感差異</strong>」終究是有限的。</p><p>而且退萬步言，哪怕是 M2，要剪輯多軌 4K 影片，也是沒問題的。</p><p><strong>真正需要嚴肅考慮的，或許是 RAM 的大小！</strong>因為在某些單次就要載入大檔案的情境（比如載入機器學習資料集），RAM 的不足真的會讓效率大幅下降。</p><p>除了上述兩種情況，其它時候，兩者大同小異。所以我才說，這是一個心情議題。</p><hr><h2 id="Mac-mini-與-Mac-Studio-的選購考量"><a href="#Mac-mini-與-Mac-Studio-的選購考量" class="headerlink" title="Mac mini 與 Mac Studio 的選購考量"></a>Mac mini 與 Mac Studio 的選購考量</h2><p>最近 M2 Max 版的 <a href="https://www.apple.com/tw/shop/buy-mac/mac-studio">Mac Studio</a> 發表了，這會一定程度影響「<strong>高階 Mac mini</strong>」的<strong>選購合理性</strong>，值得一提。</p><p>怎麼說？講白了就是，如果你選了 M2 Pro 版的 Mac mini，而且像我一樣，對它進行了若干升級，那它的 CP 值很可能就會<strong>明顯不如</strong> M2 Max 的 Mac Studio。</p><p>以我的 Mac mini 為例，足足升級了 4 個項目，而 Mac Studio 只要升級 SSD，規格上就幾乎就完勝。差別如下：</p><ol><li>升級後，Mac Studio 僅貴了 1000 左右（69900 VS 70999）。</li><li>Mac Studio 的 GPU 從 mini 的 19 核變成 30 核！</li><li>Mac Studio 機體正面多了兩個 USB-C 埠和讀卡機——對某些人可謂愛不釋手。</li><li>Mac Studio 的記憶體頻寬從每秒 200 GB 提升到 400 GB。</li></ol><p>其它暫且不論，光多花 1000 元就足足多了 11 核心的 GPU，這道計算題……似乎不是太困難😎——想想 M2 Macbook Air 僅從 8 核 GPU 升到 10 核，就要 3000 元。</p><p>總之，如果你想買「<strong>升級版</strong>」M2 Pro Mac mini，不妨先看一下 Mac Studio <strong>是否更符合自己的需求</strong>，再決定也不遲。</p><h2 id="我依舊選擇-Mac-mini"><a href="#我依舊選擇-Mac-mini" class="headerlink" title="我依舊選擇 Mac mini"></a>我依舊選擇 Mac mini</h2><p>說了這麼多，主要是為讀者——也就是螢幕前的你——考慮。若此時此刻，讓我再重新選擇，我還是會選 Mac mini，而且一樣會升級。</p><p>現在我們已經知道，這樣的升級，相較於直接購買 Mac Studio，多少是不太划算的，那我<strong>鍾情於 Mac mini 的理由</strong>又是如何呢？主要有三：</p><ol><li>Mac Studio 的體積太大了！足足有 3 台 Mac mini 這麼大，我不能接受XD。</li><li>Mac Studio 多出來的 GPU 效能，我用不太到，畢竟連 M2 Pro 的 GPU 對我都屬效能過剩。<ol><li>附帶一提，我升級 M2 Pro 的 CPU 晶片，主要是為了 <strong>CPU 部分的提升</strong>——大概 20%，對一些<strong>計算密集</strong>的任務仍有大用。</li><li>比如我很常用 <a href="https://goodsnooze.gumroad.com/l/macwhisper">MacWhisper</a> 將聲音轉成文字，<a href="https://github.com/openai/whisper/pull/382">受限於模型</a>，目前在 macOS 上只能靠 CPU 運算，快個 20% 總是好的。</li></ol></li><li>值得欣慰的是，根據<a href="https://youtu.be/fkhkm1wQS18">這則影片</a>的測試，Mac Studio 採用的新一批 SSD，在跑分上甚至還略遜於 mini，如圖（僅供參考）：</li></ol><p><img src="https://i.imgur.com/745De6H.png" alt="來源：Max Tech"><span class="cap">來源：Max Tech</span></p><p>Mac Studio 是一台強大的性能怪獸，只是我目前還用不上。有朝一日，會再考慮。</p><hr><h2 id="選購建議"><a href="#選購建議" class="headerlink" title="選購建議"></a>選購建議</h2><p>身為一個軟體工程師，在選購「吃飯工具」時，我不會太在乎 CP 值，所以加了一些讓自己「<strong>心情更好</strong>」的升級，儘管我知道這些升級<strong>對於實際體驗的影響有限</strong>。</p><p>這樣的心態很像散文〈<a href="https://medium.com/code-and-me/%E7%AC%AC%E4%B9%9D%E5%91%B3-453d14626ed7">第九味</a>〉中的那句話：「喫是為己，穿是為人。」</p><blockquote><p><strong>但我並不推薦你這麼做。</strong></p></blockquote><h3 id="Mac-選購建議"><a href="#Mac-選購建議" class="headerlink" title="Mac 選購建議"></a>Mac 選購建議</h3><p>如前所述，在蘋果的精心設計下，<strong>通常系列的入門款，就是 CP 值最高的選擇</strong>。因此，如果你是 Mac 新手且只有文書需求，我推薦入門款的 M2 Mac mini。</p><p>如果你也是軟體工程師，則 M2 Pro 無疑是<strong>更加均衡的選擇</strong>。而入門款的 M2 Pro Mac mini，恰恰是<strong>效能與價格競爭力兼具</strong>的不敗選項。</p><p>如果你影像工作者，且需要<strong>非常強大的 GPU 運算力</strong>，那麼從 Mac Studio 開始考慮，或許會比較快。</p><h3 id="Macbook-選購建議"><a href="#Macbook-選購建議" class="headerlink" title="Macbook 選購建議"></a>Macbook 選購建議</h3><p>2020 舊款、2022 新款的 Macbook Air 我都有，M1 Pro 的 Macbook Pro 也曾短暫入手過，說說我對它們的看法。</p><p>如果<strong>只能擁有一台 Macbook</strong>，我會毫不猶豫地選擇 <strong>M2 Macbook Air</strong>。因為它的外觀設計幾乎完美符合我對於輕薄筆電的想像——圓潤的邊角及線條，太美了。</p><p>但如果是推薦身邊的人買，我八成還是會選舊款 M1 Macbook Air，因為它的價格更加親民、性能足夠好。不到 3 萬就能擁有這樣一台機器，<strong>這是以前所無法想像的。</strong></p><p>至於 Macbook Pro，顯然更適合<strong>對效能有要求</strong>，並希望透過一台 Macbook，一次滿足在家與外出使用的人。</p><p>附帶一提，<strong>盡量避免在 14 吋的 Macbook Pro 上選用 Max 版的 CPU</strong>，因為它的<strong>散熱能力相對有限</strong>。在持續高負載下，CPU 容易因過熱而降頻，造成<strong>性能瓶頸</strong>。</p><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>整體而言，我對於手上這台 Mac mini 可謂<strong>相當滿意</strong>。它以極低功耗提供了十分優秀的效能和穩定性，充分滿足了我在工作、學習上的需求。</p><p>我不得不佩服蘋果 M 系列晶片之強大，猶如<strong>超新星爆發</strong>。而你，也值得擁有。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/apple-silicon/">淺談我對蘋果 M 系列晶片的看法——超新星爆發</a></p></blockquote><p>在我看來，要說 Mac 有什麼<strong>致命缺點</strong>，大概就是<strong>升級真的好貴！</strong>而且<strong>無法自行升級</strong>。但這也是蘋果一貫的作風，我只能眼睜睜看著自己的錢包被掏空🥹</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/h8Mebn5.jpg&quot; alt=&quot;Cassiopeia A 超新星殘骸，直徑約 10 光年&quot;&gt;&lt;/p&gt;
&lt;p&gt;今年 4 月，我入手了 M2 Pro 版的 &lt;a href=&quot;https://www.apple.com/tw/mac-mini/&quot;&gt;Mac mini&lt;/a&gt;，至今已使用了快 3 個月。隨著配備 M2 Max 的 &lt;a href=&quot;https://www.apple.com/tw/mac-studio/&quot;&gt;Mac Studio&lt;/a&gt; 發表，我認為是時候分享一下我的心得和選購指南——雖然這只是一個粗略的指南。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;/apple-studio-display/&quot;&gt;Apple Studio Display 適合你嗎？——我的心得與選購指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本文主旨與目標讀者&quot;&gt;&lt;a href=&quot;#本文主旨與目標讀者&quot; class=&quot;headerlink&quot; title=&quot;本文主旨與目標讀者&quot;&gt;&lt;/a&gt;本文主旨與目標讀者&lt;/h2&gt;&lt;p&gt;本文主要寫給那些&lt;strong&gt;「想買 Mac mini 但還有所遲疑的人」&lt;/strong&gt;作為參考，我不會特別鼓吹要買哪一款，這是一篇「平靜」的心得。&lt;/p&gt;
&lt;p&gt;此外，這篇文章是以&lt;strong&gt;我的核心需求&lt;/strong&gt;——&lt;a href=&quot;/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/&quot;&gt;軟體開發&lt;/a&gt;——為出發點，對同為軟體工程師的讀者而言，可能更具參考價值。&lt;/p&gt;</summary>
    
    
    
    <category term="心得" scheme="https://blog.kyomind.tw/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Mac" scheme="https://blog.kyomind.tw/tags/Mac/"/>
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
    <category term="開箱評論" scheme="https://blog.kyomind.tw/tags/%E9%96%8B%E7%AE%B1%E8%A9%95%E8%AB%96/"/>
    
  </entry>
  
  <entry>
    <title>Django ORM：一對一、一對多外鍵教學（上）前言與關聯設定</title>
    <link href="https://blog.kyomind.tw/django-models/"/>
    <id>https://blog.kyomind.tw/django-models/</id>
    <published>2023-06-24T17:31:49.000Z</published>
    <updated>2023-08-19T01:30:54.557Z</updated>
    
    <content type="html"><![CDATA[<!-- ![by Léo Alexandre](https://i.imgur.com/yK0Us6a.jpg) --><p><img src="https://i.imgur.com/TBQKYrC.png"></p><p>工作上使用 Django 近 2 年，卻很少發表關於 Django 主題的文章，是時候該來補一補了。</p><p>那就從 Django ORM 開始吧！因為 ORM（<a href="https://docs.djangoproject.com/en/4.2/topics/db/models/">Django Models</a>）可以說是無論你怎麼使用 Django（全端或前後端分離），都不得不學的核心部分。</p><p>怎麼說？我們先來看看，在「<strong>前後端分離</strong>」的開發趨勢下，Django 的三大核心——MTV——的重要性有哪些變動。</p><span id="more"></span><h2 id="前後端分離下的-Django-MTV"><a href="#前後端分離下的-Django-MTV" class="headerlink" title="前後端分離下的 Django MTV"></a>前後端分離下的 Django MTV</h2><p>在 Django 中，MTV 指的是「<strong>Model-Template-View</strong>」架構模式。類似於 <a href="https://zh.wikipedia.org/zh-tw/MVC">MVC</a>，這是 Django 框架的核心設計模式，用於組織和分離應用程式的不同部分。</p><ul><li><strong>Model（模型）：</strong> 模型負責處理與資料庫相關的操作，它是定義數據結構、資料表和資料庫查詢的地方。</li><li><strong>Template（模板）：</strong> 模板用於前端。它是一個包含 HTML、CSS 和一些額外標記語言（例如 Django 的模板語言）的文件，用於定義網頁的外觀和內容。</li><li><strong>View（視圖）：</strong> 視圖是應用程式處理邏輯的地方。它接收來自前端的 HTTP 請求，並根據需要調用相應的模型和模板來生成回應。</li></ul><h3 id="前後端分離對三大元件的重要性影響"><a href="#前後端分離對三大元件的重要性影響" class="headerlink" title="前後端分離對三大元件的重要性影響"></a>前後端分離對三大元件的重要性影響</h3><p>假設你是一個前後端分離下的 Django 工程師，那通常是負責<strong>後端的 API 開發</strong>。</p><p>首先，顯然 Template 不需要了，因為這是前端的範疇，而 View 呢？相當程度會被 <a href="https://www.django-rest-framework.org/">Django REST framework</a>（以下皆簡稱為 DRF）所取代。說「取代」不太正確，應該說「升級」。</p><p>帶來的影響是 View 中相當部分操作細節與學習重點會遷移到 DRF 本身，而非 Django 提供的原生功能。</p><p>比如<code>request.data</code>，重新封裝了 Django 中的<code>request.POST</code>和<code>request.FILES</code>兩個屬性，類似的情況還有<code>APIView</code>或<code>@api_view</code>等等。</p><p>既然 Template 被前端取代，而 View 的功能則被 DRF 重新封裝。可想而知，三大元件中重要性<strong>唯一不變</strong>的，就是 Model——Django ORM。</p><p>可見，作為一個 Django 開發者，學好 ORM 是絕對不虧的！</p><h2 id="有助於學習-FastAPI"><a href="#有助於學習-FastAPI" class="headerlink" title="有助於學習 FastAPI"></a>有助於學習 FastAPI</h2><p>如果這樣還不夠，我再給你一個學好 Django ORM 的理由。（加分項）</p><p>現在火紅的 <a href="https://github.com/tiangolo/fastapi">FastAPI</a>，本身並沒有包括 ORM 功能，所以需要你另外選擇 ORM 套件。常見的選項有 <a href="https://github.com/sqlalchemy/sqlalchemy">SQLAlchemy</a>、<a href="https://github.com/tortoise/tortoise-orm">Tortoise ORM</a>。</p><p><strong>而 Tortoise ORM 正是</strong><a href="https://github.com/tortoise/tortoise-orm#introduction">受到 Django ORM 的啟發</a>，所以學好 Django ORM 之後，學習 Tortoise ORM 會更容易上手：</p><blockquote><p>Tortoise ORM is an easy-to-use asyncio ORM (Object Relational Mapper) <strong>inspired by Django</strong>.</p></blockquote><blockquote><p><strong>Tortoise ORM was built with relations in mind and admiration for the excellent and popular Django ORM.</strong> It’s engraved in its design that you are working not with just tables, you work with relational data.</p></blockquote><p>附帶一提，我個人不太喜歡 SQLAlchemy，因為它的語法相對複雜，還有那過時的官方文件網站排版（這點和 DRF 很像XD）。所以推薦 Tortoise ORM。</p><hr><h2 id="範例程式碼專案介紹"><a href="#範例程式碼專案介紹" class="headerlink" title="範例程式碼專案介紹"></a>範例程式碼專案介紹</h2><p>如前所述，我打算寫一系列的 Django 教學文章，有範例程式碼，會更方便讀者學習、參考。於是我建了一個 GitHub Repo 名為「<a href="https://github.com/kyomind/kyo-django-tutorial">kyo-django-tutorial</a>」，把文章中使用的程式碼同步更新於此。</p><p>這是一個典型的 Django 專案，而且有著完整的 Python 環境設定，各種細節都和我個人開發一致，有 Poetry、pre-commit 與基本的 linter、formatter 設定等，方便你重現環境並跟著操作。</p><p>以下是簡單的介紹。</p><h3 id="專案環境介紹"><a href="#專案環境介紹" class="headerlink" title="專案環境介紹"></a>專案環境介紹</h3><p>支援 Poetry，方便重建專案所需的 Python 虛擬環境。但你也可以不使用它，我有另外準備<code>requirements.txt</code>供<code>pip</code>安裝。</p><p>pre-commit 完全可選，基本上用不到，除非你有打算變更程式碼的內容。只要不使用指令<code>pre-commit install</code>，它相當於不存在。但如果你想用的話，整個<code>.pre-commit-config.yaml</code>設定檔都寫好了。</p><p>隨著文章更新，未來還會支援 Docker，敬請期待。</p><h3 id="工具版本說明"><a href="#工具版本說明" class="headerlink" title="工具版本說明"></a>工具版本說明</h3><p>Django 版本為 4.2 LTS，對 Python 的版本有一定要求，不能太舊，要 3.8 以上。</p><p>Python 版本使用 3.10.11，建議至少使用 3.8.1，雖然剛剛說 Django 只要求 3.8，但因為 Flake8 版本是 6.0.0，要求 Python 至少要 3.8.1 XD。建議直接還是安裝 3.10 或更新的版本。</p><hr><p>基本的介紹就到這裡，我們趕緊進入本篇的重點。</p><h2 id="本文重點：Django-ORM-外鍵關聯設定"><a href="#本文重點：Django-ORM-外鍵關聯設定" class="headerlink" title="本文重點：Django ORM 外鍵關聯設定"></a>本文重點：Django ORM 外鍵關聯設定</h2><p><a href="https://docs.djangoproject.com/en/4.2/topics/db/models/">Django Models</a>，也就是 database table 的 <a href="https://zh.wikipedia.org/zh-tw/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84">OOP</a> 型態，透過 ORM 來實現兩者的對應關係——從 table 到 Python class。</p><p>如果說 ORM 是 Django 的核心之一，而 ORM 的核心會是什麼呢？我相信其中一個答案，就是「<strong>外鍵關聯</strong>」（<strong>relationships</strong>）。若是少了關聯，資料表就像孤立的島嶼，根本無法真實模擬世界。</p><p>剛開始寫 Django ORM 時，疑問最多的就是外鍵關聯了！因為它不止重要，而且十分常用。外鍵關聯又分一對一、一對多（多對一）與多對多，我們會先著重在前兩者的介紹——因為它們最常遇到，方便你快速上手。</p><p><strong>本文為上篇，主要是系列前言與外鍵設定教學，查詢部分則留到下篇。</strong></p><h2 id="專案模型介紹"><a href="#專案模型介紹" class="headerlink" title="專案模型介紹"></a>專案模型介紹</h2><p>學習 Django 模型和外鍵關係的最佳方法，是透過具體的例子。在上述專案中，我準備了一個最常見的範例：<a href="https://github.com/kyomind/kyo-django-tutorial/blob/01-django-models/post/models.py">文章模型</a>。</p><p>選這個例子主要出於兩個原因：</p><ol><li>它很容易想像。</li><li>它同時包括了一對一、一對多、多對多等不同情境。</li></ol><p>模型對應的情境大致是這樣：你有一個個人的部落格網站，只有你可以發表文章，而讀者可以留言。</p><p>因為只有一個作者，也就是你，所以模型省略了作者的部分。這些設計都是為了方便介紹而已，不必對它們的真實性太過認真。</p><p>以下我們一一介紹這 3 個模型。</p><h3 id="Title：文章標題"><a href="#Title：文章標題" class="headerlink" title="Title：文章標題"></a>Title：文章標題</h3><p>通常標題只會是文章模型的一個欄位，很少獨立出來。我這樣設計是為了呈現一對一關係，而且這裡有分主、副標題，多少為獨立出來增加了一些合理性。</p><h3 id="Post：文章"><a href="#Post：文章" class="headerlink" title="Post：文章"></a>Post：文章</h3><p>最主要的模型，其餘兩個模型都和它有關。</p><p>與標題是一對一關係，直接有一個<code>title</code>外鍵欄位關聯到 Title 模型，另一個欄位則是<code>content</code>。</p><h3 id="Comment：留言"><a href="#Comment：留言" class="headerlink" title="Comment：留言"></a>Comment：留言</h3><p>用來說明對一多關係的模型，有一個外鍵欄位<code>post</code>關聯到 Post。對 Post 來說，則會產生一個「<strong>反向關聯</strong>（<a href="https://allwin-raju-12.medium.com/reverse-relationship-in-django-f016d34e2c68">reverse relationship</a>）」屬性，下面會詳細介紹。</p><p>三者的關係可以畫成簡單的<strong>實體關聯圖</strong>（Entity Relationship Diagram，簡稱 <strong>ERD</strong>），如下：</p><p><img src="https://i.imgur.com/5qO8q8E.png"></p><p>Django 會自動幫你在外鍵屬性名稱加上<code>_id</code>，轉換成 db 中 table 欄位的名稱，所以上面圖中的欄位名稱是<code>title_id</code>與<code>post_id</code>。</p><hr><h2 id="在-Model-中建立外鍵欄位"><a href="#在-Model-中建立外鍵欄位" class="headerlink" title="在 Model 中建立外鍵欄位"></a>在 Model 中建立外鍵欄位</h2><p>我們知道，ORM 所對應的 table 欄位，都是用 Python 類別中的類別屬性來定義與規範的。而 db 欄位的 schema 則對應 model 屬性的「參數」。</p><p>尤其是外鍵屬性，因為要建立關聯，使用的參數通常比較多，格式上也和一般欄位屬性有所差別。</p><p>無論如何，了解外鍵欄位常用的參數與其代表的意義，相當必要，這也是本篇的重心。</p><p>以下介紹一對一和一對多的外鍵關聯設定，讀者可適時參考深獲開發者好評的 <a href="https://docs.djangoproject.com/en/4.2/">Django 文件</a>，我們只就重點進行說明。</p><h2 id="一對一關係"><a href="#一對一關係" class="headerlink" title="一對一關係"></a>一對一關係</h2><p>參考<code>OneToOneField</code>的<a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#onetoonefield">文件</a>，有兩個必填的<strong>位置參數</strong>，即<code>to</code>和<code>on_delete</code>。</p><p>先看一下專案中存在一對一關係的兩個 model（為了網頁呈現，我縮減了單行字元上限與空行數、省略了無關部分，所以和原始碼有所不同）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Title</span>(models.Model):</span><br><span class="line">    main = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    subtitle = models.CharField(max_length=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><code>OneToOneField</code>即外鍵中的一對一關係欄位，第一個參數是<code>to</code>，為目標關聯的 model，有兩種格式：</p><ol><li>model class 本身。</li><li>字串。用於無法直接引用的情境，比如本例中的 title 欄位，Title 類別定義在 Post 之後。</li></ol><p>第二個參數是<code>on_delete</code>，用來定義「關聯物件被刪除時」當前物件該如何處理的行為。有多揰模式，最常用的不外乎<code>CASCADE</code>、<code>PROTECT</code>、<code>SET_NULL</code>這 3 種，其餘所有選項與行為定義，可以參考<a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.CASCADE">文件</a>。</p><p>除了<code>to</code>和<code>on_delete</code>兩個必要參數，剩下的都是 optional，不過還有一個參數也非常重要，那就是<code>related_name</code>。</p><h2 id="related-name-與反向關聯"><a href="#related-name-與反向關聯" class="headerlink" title="related_name 與反向關聯"></a>related_name 與反向關聯</h2><p><code>related_name</code>用於指定關聯<strong>目標 model</strong>（本例為 Title）的「反向關聯」<strong>屬性名稱</strong>。這個屬性對查詢很實用，所以<code>related_name</code>也是外鍵屬性中重要的參數之一。</p><p>我們從 model 角度來看外鍵建立後的效果，以及<code>related_name</code>所扮演的角色。</p><h3 id="Post-角度"><a href="#Post-角度" class="headerlink" title="Post 角度"></a>Post 角度</h3><p>Post 有一個屬性為<code>title</code>，也就是我們所建立的外鍵，這個屬性在 model 中是明示的，意味著它在 db table 中也會有對應的欄位——<code>title_id</code>。其中<code>_id</code>是 Django 幫你加的，你可以透過<code>class Meta</code>自行定義這個欄位的名稱。</p><p>事實上，建立關聯不一定只能指向目標 model 的「主鍵」，只要是 model 中的  unique 欄位都可以，可參考 <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey.to_field">to_field 文件</a>。</p><h3 id="Title-角度"><a href="#Title-角度" class="headerlink" title="Title 角度"></a>Title 角度</h3><p>一對一關係建立後，對 Title model 或它的實例而言，它得到了什麼？——反向關聯屬性。</p><p>這個屬性在 model 中沒有明示，你從 model 中看不出 Title 有什麼屬性可以指向 Post。但實際上 Title 確實有一個反向關聯屬性指向 Post。</p><p>這就是反向關聯的特性，它是「<strong>隱式</strong>」的，這個屬性確實存在。而<strong>反向關聯屬性的名稱就是前述</strong><code>related_name</code><strong>所定義的名稱</strong>，即<code>post</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> title = models.OneToOneField(</span><br><span class="line">     <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure><p>所以，Title 的所有實例，比如有一個實例叫<code>title_1</code>，一定會有一個<strong>反向關聯屬性</strong><code>post</code>，而它的返回值依不同情況有兩種可能：</p><ol><li><code>title_1</code>已經被關聯到某個 Post 實例比如<code>post_1</code>，那<code>title_1.post</code>的值就是該<code>post_1</code>實例。</li><li><code>RelatedObjectDoesNotExist</code>物件。當<strong>實例之間的關聯還不存在</strong>，試圖取得關聯實例將會出現這樣的錯誤。</li></ol><p>附帶一提，<code>RelatedObjectDoesNotExist</code>其實就是<code>ObjectDoesNotExist</code>的子類別。所以如果你想要捕捉它，直接使用常見的<code>ObjectDoesNotExist</code>即可。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    title_1.post</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><h3 id="反向關聯屬性"><a href="#反向關聯屬性" class="headerlink" title="反向關聯屬性"></a>反向關聯屬性</h3><p>上述<code>post</code>屬性並未在 model class 中明示（但物件有此屬性），資料表中也<strong>不存在相對應的欄位</strong>。它本質上只是一個「<strong>ORM 查詢捷徑</strong>」——但非常實用。</p><p>這種隱式的設計讓我們<strong>更容易識別</strong>在外鍵關係中，哪些屬性是<strong>正向關聯</strong>，哪些則是<strong>反向關聯</strong>。</p><p>反向關聯允許我們透過簡單的<strong>屬性呼叫</strong>，就能夠輕鬆地獲取相關資料，而不需要額外的操作和查詢語句。</p><hr><h2 id="一對多關係"><a href="#一對多關係" class="headerlink" title="一對多關係"></a>一對多關係</h2><blockquote><p>class <code>ForeignKey</code>(to, on_delete, **<strong>options</strong>) <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey">¶</a></p></blockquote><blockquote><p>A <strong>many-to-one</strong> relationship. <strong>Requires two positional arguments</strong>: the class to which the model is related and the <a href="https://docs.djangoproject.com/en/4.2/ref/models/fields/#django.db.models.ForeignKey.on_delete"><code>on_delete</code></a> option.</p></blockquote><p>我們在前述一對一關係費了很大的功夫將關聯的細節詳加說明，有了上述基礎，理解一對多關係也會容易得多。</p><p>Django 稱<code>ForeignKey</code>為「<strong>many-to-one</strong>」，即多對一關係，從 model 角度看，確實更合理。因為建立這個<code>ForeignKey</code>屬性的 model，必然屬於關係中的「<strong>多方</strong>」。所以是「多對一」。</p><p>不過無論一對多或多對一，主要區別是視角不同，都是同一種關係。下面我還是用「一對多」這個詞進行說明。</p><p>我選擇先講一對一是因為它相對單純，不需要一次理解太多事情。而一對多（或多對一），即 Django 中的 ForeignKey，則有更多參數和變化，但我們依舊只關注其中最重要的部分。</p><h3 id="專案程式碼說明"><a href="#專案程式碼說明" class="headerlink" title="專案程式碼說明"></a>專案程式碼說明</h3><p>毫無疑問，文章和它的留言是一對多關係，一篇文章可以有「0 到多個」留言，注意這個 0 還滿重要的！這也是它和一對一關係很不同的地方。</p><p>回到程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 留言</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br><span class="line">    content = models.TextField()</span><br></pre></td></tr></table></figure><p>我們可以看到，Comment 有一個欄位叫<code>post</code>，是一個<code>ForeignKey</code>。這個<code>ForeignKey</code>欄位，最常用的參數還是那 3 個，前 2 個前面已經有介紹，在此不贅。</p><p>第 3 個參數仍是<code>related_name</code>，但它的引數值<code>&#39;comments&#39;</code>看起來，和一對一的<code>related_name</code>在命名上有所不同——它是複數！</p><h2 id="related-name-在一對多關係中的重點"><a href="#related-name-在一對多關係中的重點" class="headerlink" title="related_name 在一對多關係中的重點"></a>related_name 在一對多關係中的重點</h2><p>前提已經提過，<code>related_name</code>實際上是為「反向關聯屬性」進行命名。</p><p><code>post</code>屬性的<code>related_name=&#39;comments&#39;</code>意味著，Post model 將得到一個名為「comments」反向關聯屬性。</p><p>一個 Post 實例，假設為<code>post_1</code>，可以透過<code>post_1.comments</code>取得所有和它關聯的 Comment 實例。可能有 1 個、多個，甚至沒有。</p><blockquote><p>這裡有一個細節是，<code>post_1.comments</code>只會先取得「<a href="https://docs.djangoproject.com/en/4.2/ref/models/relations/#django.db.models.fields.related.RelatedManager">關係管理器</a>」物件，再透過該物件取得「由 Comment 關聯實例組成的<code>QuerySet</code>」，比如：<code>post_1.comments.all()</code>。</p></blockquote><p>這和一對一關係中，你呼叫反向關聯屬性時，可能得到一個<strong>關聯實例</strong>或拋出<code>RelatedObjectDoesNotExist</code>有明顯不同。</p><h3 id="related-name-的預設名稱"><a href="#related-name-的預設名稱" class="headerlink" title="related_name 的預設名稱"></a>related_name 的預設名稱</h3><p>如果你在建立欄位時沒有給定<code>related_name</code>引數，那 Django 會自動給你預設名稱。</p><p>在一對一中，預設名稱為外鍵欄位所屬 Model 名稱的小寫。</p><p>參考 Post 的一對一外鍵程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Post</span>(models.Model):</span><br><span class="line">    title = models.OneToOneField(</span><br><span class="line">        <span class="string">&#x27;Title&#x27;</span>, on_delete=models.PROTECT, related_name=<span class="string">&#x27;post&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>related_name</code>的預設值就是 Post 的小寫——<code>post</code>。顯然我定義的其實就是預設值而已。一對一時，是否定義<code>related_name</code>影響不大，<strong>因為它的預設值往往就已足夠</strong>。</p><p>在一對多，預設名稱為外鍵欄位所屬 Model 名稱的小寫再加上<code>_set</code>後綴。你可能就未必喜歡這樣的命名了。</p><p>一樣看一下相關程式片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span>(models.Model):</span><br><span class="line">    post = models.ForeignKey(</span><br><span class="line">        Post, on_delete=models.CASCADE, related_name=<span class="string">&#x27;comments&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果沒有定義<code>related_name</code>，則被關聯的 Post 將獲得 Django 預設的反向關聯屬性名稱「<code>comment_set</code>」。</p><p>無論是自定義的<code>comments</code>或預設的<code>comment_set</code>，都表達它的內涵是一個「複數」，這是一對多的特色（多對多也是如此）。</p><h2 id="良好的-related-name-命名"><a href="#良好的-related-name-命名" class="headerlink" title="良好的 related_name 命名"></a>良好的 related_name 命名</h2><p>實務中，把這個<code>related_name</code>命名好還是很重要的，雖然大部分時候用單純的複數就可以搞定，就像上面的<code>comments</code>，但為了<strong>增進程式的可讀性</strong>，也有需要你花費巧思的時候。</p><p>比如，任何專案都需要有憑證才能被存取，而一個憑證可以讓多個專案共用，此時我們可能會這樣設計：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Project</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    certificate = models.ForeignKey(<span class="string">&#x27;Certificate&#x27;</span>,</span><br><span class="line">                                    on_delete=models.PROTECT,</span><br><span class="line">                                    related_name=<span class="string">&#x27;used_by_projects&#x27;</span>)</span><br></pre></td></tr></table></figure><p>這裡的 related_name 不再用死板板的<code>projects</code>來命名，因為當你透過<code>Certificate</code>物件要訪問「<strong>所有使用該憑證的專案</strong>」時，<code>certificate.used_by_projects</code>顯然會比<code>certificate.projects</code><strong>更具描述性</strong>——尤其在<code>Certificate</code>還有<strong>更多其它關聯</strong>的時候，太多<code>certificate.XXXs</code>容易讓人混淆。</p><p>簡言之，<code>used_by_projects</code>命名<strong>讓程式更可讀</strong>，讓你一看就知道這個<code>related_name</code>的意義與用途。</p><hr><h2 id="小結：關聯是-model-核心"><a href="#小結：關聯是-model-核心" class="headerlink" title="小結：關聯是 model 核心"></a>小結：關聯是 model 核心</h2><p>耗費了如此多的幅篇，詳細講述關聯設定，都是為了強調一個重點：關聯是 Django ORM 的核心之一。</p><p>通過關聯，我們能夠模擬真實世界中的關係，使資料表之間建立起有意義的連結。</p><p>了解一對一和一對多的關聯設定，以及反向關聯屬性的使用，我們能夠更好地應用 Django ORM，建構出高效且具有關聯性的資料模型。</p><p>而辛苦建立這些模型與關聯，就是為了能夠充分利用它們！</p><p>下篇文章將探討，如何有效對這些關聯模型進行查詢，輕鬆地從模型中檢索和篩選所需的資料。</p><p>請敬期待。</p>]]></content>
    
    
    <summary type="html">&lt;!-- ![by Léo Alexandre](https://i.imgur.com/yK0Us6a.jpg) --&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TBQKYrC.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;工作上使用 Django 近 2 年，卻很少發表關於 Django 主題的文章，是時候該來補一補了。&lt;/p&gt;
&lt;p&gt;那就從 Django ORM 開始吧！因為 ORM（&lt;a href=&quot;https://docs.djangoproject.com/en/4.2/topics/db/models/&quot;&gt;Django Models&lt;/a&gt;）可以說是無論你怎麼使用 Django（全端或前後端分離），都不得不學的核心部分。&lt;/p&gt;
&lt;p&gt;怎麼說？我們先來看看，在「&lt;strong&gt;前後端分離&lt;/strong&gt;」的開發趨勢下，Django 的三大核心——MTV——的重要性有哪些變動。&lt;/p&gt;</summary>
    
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/categories/Django/"/>
    
    
    <category term="Django" scheme="https://blog.kyomind.tw/tags/Django/"/>
    
    <category term="ORM" scheme="https://blog.kyomind.tw/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>19，AI 時代的生存指南（二）數位斷捨離</title>
    <link href="https://blog.kyomind.tw/weekly-review-19/"/>
    <id>https://blog.kyomind.tw/weekly-review-19/</id>
    <published>2023-06-10T11:27:31.000Z</published>
    <updated>2023-07-11T18:27:35.067Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>上一篇〈<a href="https://blog.kyomind.tw/weekly-review-17/">17，AI 時代的生存指南（一）我對 AI 工具的投入與觀望</a>〉並沒有真正進入「生存指南」這個核心主題，只能算是整個系列的前言。</p><p>為避免你忘記，我們再來回顧一下，前一篇所提出的，本系列的宗旨：</p><blockquote><p>我期望這系列和一般談論 AI 文章的一個核心差別是：<strong>它們主要用來「降低」AI 資訊焦慮，而非增加。</strong></p></blockquote><blockquote><p>更具體地說，這個系列是「<strong>我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄</strong>」，這樣才有趣。</p></blockquote><p>而本篇要探討的，就是這系列最核心的「生存手段」：數位斷捨離。</p><p>數位斷捨離（Digital Declutter）作家卡爾．紐波特（Cal Newport）在其著作《<a href="https://www.books.com.tw/products/0010843512">深度數位大掃除</a>》一書中所提出。</p><p>數位斷捨離是一種整理和簡化數位世界的方法，旨在<strong>減少干擾並提升專注力</strong>。通過過濾數位訊息和限制使用數位工具（尤其是社交平台），我們可以節省時間和精力，更好地專注於重要的事情。</p><p>這種方法有助於建立一個更有意義和平衡的數位生活。所以它不止是方法，也是一種「<strong>價值觀與實踐</strong>」。</p><p>概念理解上沒什麼困難，但實踐起來可遠遠不是如此。</p><span id="more"></span><h2 id="本文重點"><a href="#本文重點" class="headerlink" title="本文重點"></a>本文重點</h2><p>這篇文章不會有太多關於「數位斷捨離」的做法與細節討論。而是<strong>試圖推論與強調，它在 AI 時代的重要性，以及在現實世界中所面臨的困難。</strong></p><p>此外，我並非「<a href="https://zh.wikipedia.org/zh-tw/%E6%A5%B5%E7%B0%A1%E4%B8%BB%E7%BE%A9">極簡主義</a>」愛好者，而是屬於「<a href="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/">簡潔主義</a>」的信徒。雖然它們都有一個「簡」字，但後者更強調「<strong>過猶不及、適可而止</strong>」的精神——更重視「<strong>均衡</strong>」。</p><p>理解了上述前提後，讓我們進入正文。</p><hr><h2 id="我的兩篇《深度數位大掃除》心得"><a href="#我的兩篇《深度數位大掃除》心得" class="headerlink" title="我的兩篇《深度數位大掃除》心得"></a>我的兩篇《深度數位大掃除》心得</h2><p>早在 3 年前，還在 <a href="https://medium.com/">Medium</a> 平台創作時期，我就寫過關於《深度數位大掃除》一書的「實踐心得」，即<strong>個人版的數位斷捨離</strong>，前後總共 2 篇：</p><ol><li><a href="https://medium.com/code-and-me/my-digital-declutter-216d472f8251">每天都是一種練習：我的數位斷捨離</a></li><li><a href="https://medium.com/code-and-me/31%E5%A4%A9-%E6%88%91%E7%9A%84%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2%E5%BF%83%E5%BE%97-51289e99ff96">31天：我的數位斷捨離心得</a></li></ol><p>這是個有趣的嘗試，尤其讓我印象深刻的，是第二篇中的這段與這個規則：</p><ul><li><strong>在捷運或公車的「刷卡範圍」內，不得使用手機通話以外的功能</strong></li></ul><blockquote><p>簡單講就是不能滑手機，而且也不能聽音樂。</p></blockquote><blockquote><p>這是一條我無法明確告訴你為什麼值得這麼做，但實踐後仍然建議你嘗試看看的規則。</p></blockquote><blockquote><p>如果真的需要一個理由，或許可以說，在這個我們都自願或被迫保持「連線狀態」的智慧手機時代。在一個人坐捷運無聊難耐，讓你有充分的動機與理由拿出手機消磨（或善加利用）的時候，你卻沒有這麼做，這是沉默而自覺的戰鬥。</p></blockquote><blockquote><p>你靜靜地坐著或站著，看著周圍的人，沉浸在網路的世界裡。而至少在此刻，你選擇不要這麼做。</p></blockquote><p>真的，那幾個月，我上下班坐捷運時，就是這樣傻傻地看著別人滑手機，心癢難耐，甚至不禁想問：「為什麼要制定這種規則來為難自己？我得到了什麼？」</p><p>「我得到了什麼？」不是一個容易回答的問題——因為它的好處並非立竿見影。這也是為何「數位斷捨離」通常很難持續。</p><p>網路上你可以找到不少實踐心得，遵從書中的建議，貫徹為期 1 個月的數位斷捨離。但你很難找到持續超過 3 個月甚至半年的實踐心得，連我自己，最後也大概只堅持了 3 個月，就差不多「<strong>打回原形</strong>」了。</p><h2 id="數位斷捨離常常只是一場短暫的狂歡"><a href="#數位斷捨離常常只是一場短暫的狂歡" class="headerlink" title="數位斷捨離常常只是一場短暫的狂歡"></a>數位斷捨離常常只是一場短暫的狂歡</h2><p>用「<strong>狂歡</strong>」來形容<strong>充滿限制且帶有自律意味</strong>的數位斷捨離，可能有點詭異，卻也不失真實，為什麼？</p><p>因為它富含一種「我將擺脫數位工具成癮並重獲新生」的<strong>期待</strong>。和一般狂歡通常以大鳴大放的形式不同，這種期待蘊含了一股內持、蓄勢待發的力量。它暗潮湧動，使人從情感上，<strong>將其視為達成目標和恢復精神自由的萬靈藥</strong>。</p><p>因此，在實踐數位斷捨離的初期，雖然辛苦，但我們會暫時感到一陣<strong>自由和解脫</strong>。儘管這種過程伴隨著一定的自我限制，但也對於能夠重新獲得對自己時間和注意力的<strong>掌控感</strong>到興奮甚至滿足。</p><p>這類「狂歡」形式雖然不常見，但它真實地反映了我們對於解放自己的數位束縛的期待與渴望。</p><p>我承認這種感覺確實「很好」，但這樣的動機是<strong>不健康</strong>的，因為它和所有的狂歡一樣，都有一個<strong>「致命問題」——很難持續。</strong></p><h2 id="為什麼數位斷捨離很難超過-3-個月？"><a href="#為什麼數位斷捨離很難超過-3-個月？" class="headerlink" title="為什麼數位斷捨離很難超過 3 個月？"></a>為什麼數位斷捨離很難超過 3 個月？</h2><p>把數位斷捨離當成是一場狂歡、救贖，或所謂的「數位排毒」，往往註定要失敗。</p><p>試想，數位斷捨離所要對抗的，都是什麼樣的洪水猛獸？</p><p>沒錯，就是那些精心設計，讓你容易非常數位成癮的社交平台與內容平台，比如臉書、Instagram、YouTube、TikTok……等等。</p><p>最關鍵的是，獲取它們的門檻可謂低之又低，近在眼前，唾手可得。因此，社交平台和內容平台所提供的即時滿足感和快樂，往往讓人很難抗拒。</p><h3 id="長路漫漫的數位斷捨離"><a href="#長路漫漫的數位斷捨離" class="headerlink" title="長路漫漫的數位斷捨離"></a>長路漫漫的數位斷捨離</h3><p>相較之下，數位斷捨離就不那麼討喜。它要你自制、找尋替代活動（書中稱之為「<strong>優質的休閒活動</strong>」），還要反思數位工具你對的意義。</p><p>要求還真多。</p><p>前期，你確實可以藉由上述的「<strong>期待</strong>」來支持，但這樣的期待也是種<strong>有限資源</strong>。把數位斷捨離當作是一種「<strong>自我救贖</strong>」，確實可以成為堅持的動力——最多持續 1 個月。</p><p>1 個月以後，期待帶來的初始動力散去，我們就很容易陷入「<strong>我得到了什麼？</strong>」茫然。</p><h3 id="數位斷捨離的意義與價值"><a href="#數位斷捨離的意義與價值" class="headerlink" title="數位斷捨離的意義與價值"></a>數位斷捨離的意義與價值</h3><p>如果「我得到了什麼？」的答案，對你來說<strong>還不夠清晰</strong>，那麼<strong>放棄</strong>恐怕是<strong>遲早的事情</strong>，因為回到原點比茫然堅持，可要容易得太多。</p><p>然而，我更想<strong>強調</strong>：這個問題的答案，<strong>幾乎不可能一開始就很清晰</strong>。因為，數位斷捨離的意義，往往是需要你<strong>透過實踐</strong>才能<strong>慢慢體會</strong>的。</p><p>不止實踐，你還需要<strong>時間</strong>與<strong>自我理解</strong>。</p><p>所以我們可以看到，網路確實上有不少篇心得，講述自己如何實踐了為期 30 天的數位斷捨離，那感覺，是多麼地讓人神清氣爽、重獲新生。</p><p><strong>然後，就沒有然後了。</strong></p><hr><h2 id="我為何重拾數位斷捨離？"><a href="#我為何重拾數位斷捨離？" class="headerlink" title="我為何重拾數位斷捨離？"></a>我為何重拾數位斷捨離？</h2><p>說了那麼多，都是在唱衰數位斷捨離，難道真的沒救了嗎？</p><p>我想其中的奇妙之處正在於，本來我也覺得「算了，就這樣吧！要持續貫徹，需要長期的嘗試與不斷改善規則」。</p><p>對我來說這也不是不可能，作為曾經全職準備國考與軟體工程師轉職的人（就是待業時間很長的意思），有很多「建立個人長期制度」的經驗（包括很多失敗經驗），我知道怎麼做能更接近「<strong>可持續性</strong>」。</p><p>換言之，我對一件事情「能否持續」的<strong>敏感度</strong>，還是比較高的。</p><p>所以我才會猶豫不前，因為我知道這件事的難度。</p><h3 id="值得嗎？"><a href="#值得嗎？" class="headerlink" title="值得嗎？"></a>值得嗎？</h3><p>還是那個問題「值得嗎？」——這是個大哉問。</p><p>對我而言，以往是的答案是「<strong>我不確定</strong>」。而現在或許值得了，因為 AI 時代到來。</p><p>AI 帶給我的「<strong>資訊煩躁感（資訊焦慮）</strong>」，讓我感到「<strong>必須要做些什麼</strong>」應對。</p><p>這不是因為資訊量隨 AI 的爆發而再度遽增（我覺得這反而是相對無關緊要的部分），而是「<strong>做事的方法</strong>」因為 AI 而改變了。</p><p>所以，作為渺小的人類，對抗資訊焦慮的「<strong>防禦手段</strong>」也得跟著升級才行。那麼，什麼才是真正有效的手段？</p><p>思來想去，我最終的答案<strong>還是——數位斷捨離</strong>。</p><h2 id="內心的平靜"><a href="#內心的平靜" class="headerlink" title="內心的平靜"></a>內心的平靜</h2><p>說了那麼多，其實我們所求的，不過就是「<strong>內心的平靜</strong>」而已。</p><p>然而內心的平靜卻也是世上最易失又難得的珍貴體驗，我們只能一步一步靠近。</p><h3 id="目前的具體做法"><a href="#目前的具體做法" class="headerlink" title="目前的具體做法"></a>目前的具體做法</h3><p>一開始說不會講太多做法，但還是要提一下，才好想像我的數位斷捨離的具體內容。</p><p>目前我實踐中的數位斷捨離規則大致如下：</p><ol><li>每天早上 9 點到下午 6 點，不登入 Line 桌面版。</li><li>身體接觸床面時，存取手機不得超過一分鐘！（防止睡前滑手機行為）</li><li>半夜 1 點到早上 6 點，不聽任何多媒體的聲音。</li><li>河濱散步時，不存取、使用手機。（培養發散思維模式）</li><li>少用臉書。</li></ol><p>咦？怎麼沒有搭公車、捷運不能用手機那條？本來有的，但太難了，只好暫時捨棄🫡</p><p>規則的組成與細節，會一直變動，達到「有效且可持續」的部分，才會漸漸確定下來。</p><p>毫無疑問，這會是一個<strong>不算短的過程</strong>，1 個月是絕對不夠的。因為能堅持 1 個月的事，未必能堅持 3 個月。</p><hr><h2 id="結語：3-個月只是開端"><a href="#結語：3-個月只是開端" class="headerlink" title="結語：3 個月只是開端"></a>結語：3 個月只是開端</h2><p>1 個月也好，3 個月也罷，它們都只是漫長人生中的一小部分。僅僅在這麼短的時間內達成數位斷捨離，很難帶來本質上的改變。</p><p>數位斷捨離的目的不僅僅是在短期內達成某個特定的目標，而是<strong>要在局部，永久地建立有別於以往的生活方式。</strong></p><p>在開始之前，我們要先嚴肅地認知到：<strong>這真的很難</strong>——凡是改變都很難。</p><p>數位斷捨離是<strong>習慣的養成</strong>，從更高的角度看，更是一種「<strong>價值取捨</strong>」。</p><p>有些東西——哪怕是好東西——你必須<strong>捨棄</strong>，才能換得幾分<strong>心靈上的平靜</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一篇〈&lt;a href=&quot;https://blog.kyomind.tw/weekly-review-17/&quot;&gt;17，AI 時代的生存指南（一）我對 AI 工具的投入與觀望&lt;/a&gt;〉並沒有真正進入「生存指南」這個核心主題，只能算是整個系列的前言。&lt;/p&gt;
&lt;p&gt;為避免你忘記，我們再來回顧一下，前一篇所提出的，本系列的宗旨：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我期望這系列和一般談論 AI 文章的一個核心差別是：&lt;strong&gt;它們主要用來「降低」AI 資訊焦慮，而非增加。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;更具體地說，這個系列是「&lt;strong&gt;我為了降低自己對 AI 的資訊焦慮，付諸過的實踐與行動記錄&lt;/strong&gt;」，這樣才有趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而本篇要探討的，就是這系列最核心的「生存手段」：數位斷捨離。&lt;/p&gt;
&lt;p&gt;數位斷捨離（Digital Declutter）作家卡爾．紐波特（Cal Newport）在其著作《&lt;a href=&quot;https://www.books.com.tw/products/0010843512&quot;&gt;深度數位大掃除&lt;/a&gt;》一書中所提出。&lt;/p&gt;
&lt;p&gt;數位斷捨離是一種整理和簡化數位世界的方法，旨在&lt;strong&gt;減少干擾並提升專注力&lt;/strong&gt;。通過過濾數位訊息和限制使用數位工具（尤其是社交平台），我們可以節省時間和精力，更好地專注於重要的事情。&lt;/p&gt;
&lt;p&gt;這種方法有助於建立一個更有意義和平衡的數位生活。所以它不止是方法，也是一種「&lt;strong&gt;價值觀與實踐&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;概念理解上沒什麼困難，但實踐起來可遠遠不是如此。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="簡潔主義" scheme="https://blog.kyomind.tw/tags/%E7%B0%A1%E6%BD%94%E4%B8%BB%E7%BE%A9/"/>
    
    <category term="資訊焦慮" scheme="https://blog.kyomind.tw/tags/%E8%B3%87%E8%A8%8A%E7%84%A6%E6%85%AE/"/>
    
    <category term="數位斷捨離" scheme="https://blog.kyomind.tw/tags/%E6%95%B8%E4%BD%8D%E6%96%B7%E6%8D%A8%E9%9B%A2/"/>
    
    <category term="Cal Newport" scheme="https://blog.kyomind.tw/tags/Cal-Newport/"/>
    
  </entry>
  
  <entry>
    <title>Poetry + pyenv 實戰心得：常用指令與注意事項</title>
    <link href="https://blog.kyomind.tw/poetry-pyenv-practical-tips/"/>
    <id>https://blog.kyomind.tw/poetry-pyenv-practical-tips/</id>
    <published>2023-06-05T15:01:08.000Z</published>
    <updated>2023-06-22T05:39:39.761Z</updated>
    
    <content type="html"><![CDATA[<!-- ![from Pixabay](https://i.imgur.com/yODxmxJ.jpg) --><p><img src="https://i.imgur.com/npnmhFE.jpg" alt="from Pixabay"><span class="cap">from Pixabay</span></p><p>〈<a href="https://blog.kyomind.tw/python-poetry/">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a>〉發表至今，已過了 1 年多，這意味我也用了一年多的 Poetry。</p><p>感覺如何？——我覺得還不錯！可見不是三分鐘熱度而已。</p><p>對現在的我而言，Poetry 已成為專案開發不可或缺的元素。它不僅提供了更加便捷的專案套件管理和版本控制，同時，Poetry 支援 pyproject.toml 作為設定檔的特性，也使得我更容易使用其他也採用 pyproject.toml 的工具。</p><blockquote><p>相關文章：<a href="https://blog.kyomind.tw/pyproject-toml/">pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學</a></p></blockquote><h3 id="系列：Python-Poetry-三部曲"><a href="#系列：Python-Poetry-三部曲" class="headerlink" title="系列：Python Poetry 三部曲"></a>系列：Python Poetry 三部曲</h3><blockquote><ol><li><a href="https://blog.kyomind.tw/python-poetry/">再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南</a></li><li><strong>Poetry + pyenv 實戰心得：常用指令與注意事項</strong></li><li>終結 requirements.txt：Dockerfile 多階段建構 Poetry 虛擬環境（待發表）</li></ol></blockquote><span id="more"></span><hr><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>本文將補充系列第一篇中在「<a href="https://blog.kyomind.tw/python-poetry/#Poetry-%E5%B8%B8%E8%A6%8B%E4%BD%BF%E7%94%A8%E6%83%85%E5%A2%83%E8%88%87%E6%93%8D%E4%BD%9C-QA">情境使用</a>」方面的不足之處，尤其是針對 Poetry 和 pyenv 同時使用時可能出現的問題進行討論。這是第一篇所遺漏的內容。</p><p>透過本文，我希望能夠提供更全面、更實用的 Poetry 使用建議，讓讀者在使用 Poetry 和 pyenv 時能夠充分發揮它們的優勢，並減少不必要的困惑。</p><h3 id="以-poetry-demo-為例"><a href="#以-poetry-demo-為例" class="headerlink" title="以 poetry-demo 為例"></a>以 poetry-demo 為例</h3><p>poetry-demo 是本文作為例示的專案模版，但我們不會安裝太多套件，僅各取一個作為示範之用。</p><p>有一個簡單的具體實例，還是比抽象的描述容易理解得多。</p><p>我們會從一台全新的 Linux VM（Ubuntu 20.04）開始，先安裝 pyenv，再安裝 Poetry，然後再一起使用它們，建立 Python 專案與虛擬環境。</p><h3 id="使用的-Poetry-版本：1-5-1"><a href="#使用的-Poetry-版本：1-5-1" class="headerlink" title="使用的 Poetry 版本：1.5.1"></a>使用的 Poetry 版本：1.5.1</h3><p>Poetry 在 1.2 版後，對於部分指令進行有較大的改動與擴張，導致舊指令使用上不完全相容，這次會採用當前的最新版——<a href="https://github.com/python-poetry/poetry/releases/tag/1.5.1">1.5.1</a>——來進行示範。</p><h3 id="使用的-pyenv-版本：2-3-18"><a href="#使用的-pyenv-版本：2-3-18" class="headerlink" title="使用的 pyenv 版本：2.3.18"></a>使用的 pyenv 版本：2.3.18</h3><p>pyenv 在 v2.3.0 以後，已經<a href="https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv">大幅簡化了設定操作</a>，所以這裡也有必要強調一下使用的版本：<a href="https://github.com/pyenv/pyenv/releases/tag/v2.3.18">v2.3.18</a>。</p><p>相關文章也有就新版設定內容進行更新，可參考〈<a href="https://blog.kyomind.tw/ubuntu-pyenv/#%E8%A8%AD%E5%AE%9A-pyenv">Ubuntu 安裝使用 pyenv + pyenv-virtualenv</a>〉。</p><h2 id="安裝-Poetry、pyenv、Python-3-10"><a href="#安裝-Poetry、pyenv、Python-3-10" class="headerlink" title="安裝 Poetry、pyenv、Python 3.10"></a>安裝 Poetry、pyenv、Python 3.10</h2><p>請直接參考〈<a href="https://blog.kyomind.tw/linux-dev-setup/">Linux Python 開發環境設定：zsh、zinit、pyenv、poetry、docker</a>〉中的「<a href="https://blog.kyomind.tw/linux-dev-setup/#%E4%B8%89%E3%80%81%E8%A8%AD%E5%AE%9A-pyenv">三、設定 pyenv</a>」、「<a href="https://blog.kyomind.tw/linux-dev-setup/#%E5%9B%9B%E3%80%81%E8%A8%AD%E5%AE%9A-Poetry">四、設定 Poetry</a>」部分。</p><p>不只是安裝，還包括設定 PATH 等環節，這些步驟都是必要的。完成這些步驟後，我們就擁有了 Poetry 和 pyenv。</p><h3 id="透過-pyenv-安裝-Python-3-10-11"><a href="#透過-pyenv-安裝-Python-3-10-11" class="headerlink" title="透過 pyenv 安裝 Python 3.10.11"></a>透過 pyenv 安裝 Python 3.10.11</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.10.11</span><br></pre></td></tr></table></figure><p>pyenv 是為了方便我們管理多個 Python 版本，下面我們會探討不同專案分別使用多個 Python 版本時的 Poetry + pyenv 操作注意事項。</p><p>這裡至少要先有一個 Python 版本，才能順利安裝我們的專案，在此以 <a href="https://www.python.org/downloads/release/python-31011/">Python 3.10.11</a> 為例。</p><h2 id="Poetry-與-pyenv-的部分功能重疊"><a href="#Poetry-與-pyenv-的部分功能重疊" class="headerlink" title="Poetry 與 pyenv 的部分功能重疊"></a>Poetry 與 pyenv 的部分功能重疊</h2><p>安裝完後，是否要設定<code>pyenv local 3.10.11</code>或<code>pyenv global 3.10.11</code>，取決於你是否有「多專案且多種 Python 版本」需求。</p><p>如果只需要一種 Python 版本，那將其設定為<code>global</code>已足：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global 3.10.11</span><br></pre></td></tr></table></figure><p>如<a href="https://blog.kyomind.tw/linux-dev-setup/">前述文章</a>所言：</p><blockquote><p>因為 Poetry 自帶了虛擬環境管理功能，容易和 pyenv-virtualenv <strong>疊床架屋</strong>，徒增<strong>管理上的混淆</strong>，所以<strong>我現在一律只使用 Poetry + venv 來管理 Python 虛擬環境</strong>。</p></blockquote><p>即使在不同專案需要多版本 Python 情況下，pyenv-virtualenv 也不是必須。只要善用<code>pyenv local</code>和<code>poetry env use</code>兩大指令即可。</p><p>綜上所述，這也是為什麼我認為 Poetry 的教學<strong>應該涵蓋對 pyenv 的整合</strong>，因為在「虛擬環境管理」方面，兩者的功能有一定重疊。</p><hr><p>前置作業總算大功告成，我們開始建立 poetry-demo 吧！</p><h2 id="一、初始化-Poetry-專案"><a href="#一、初始化-Poetry-專案" class="headerlink" title="一、初始化 Poetry 專案"></a>一、初始化 Poetry 專案</h2><p>先確認一下當前的 Poetry 版本，使用<code>poetry --version</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry --version</span><br><span class="line">Poetry (version 1.4.2)</span><br></pre></td></tr></table></figure><p>我的 Poetry 是一段時間前安裝的 1.4.2，需要更新一下，以符合本文使用的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry self update</span><br><span class="line"></span><br><span class="line">Using version ^1.5.1 <span class="keyword">for</span> poetry</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (2.6s)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Package operations: 0 installs, 5 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Updating platformdirs (2.6.2 -&gt; 3.5.1)</span><br><span class="line">  • Updating poetry-core (1.5.2 -&gt; 1.6.1)</span><br><span class="line">  • Updating poetry-plugin-export (1.3.1 -&gt; 1.4.0)</span><br><span class="line">  • Updating virtualenv (20.21.1 -&gt; 20.23.0)</span><br><span class="line">  • Updating poetry (1.4.2 -&gt; 1.5.1)</span><br></pre></td></tr></table></figure><p>因為是使用全域安裝 Poetry，上面的套件更新訊息和專案的虛擬環境無關——畢竟我們根本都還沒有為專案建立專屬的 Python 虛擬環境！</p><p>也可以指定要升級的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry self update 1.5.1</span><br></pre></td></tr></table></figure><h3 id="使用poetry-init初始化專案"><a href="#使用poetry-init初始化專案" class="headerlink" title="使用poetry init初始化專案"></a>使用<code>poetry init</code>初始化專案</h3><p>確認完 Poetry 版本，開始建立專案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> poetry-demo</span><br><span class="line"><span class="built_in">cd</span> poetry-demo</span><br><span class="line">poetry init</span><br></pre></td></tr></table></figure><p><code>poetry init</code>會出現下列互動式訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">This <span class="built_in">command</span> will guide you through creating your pyproject.toml config.</span><br><span class="line"></span><br><span class="line">Package name [poetry-demo]:</span><br><span class="line">Version [0.1.0]:</span><br><span class="line">Description []:</span><br><span class="line">Author [kyo &lt;odinxp@gmail.com&gt;, n to skip]:</span><br><span class="line">License []:</span><br><span class="line">Compatible Python versions [^3.8]:</span><br><span class="line"></span><br><span class="line">Would you like to define your main dependencies interactively? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>] no</span><br><span class="line">Would you like to define your development dependencies interactively? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>] no</span><br><span class="line">Generated file</span><br><span class="line"></span><br><span class="line">[tool.poetry]</span><br><span class="line">name = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">description = <span class="string">&quot;&quot;</span></span><br><span class="line">authors = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line">readme = <span class="string">&quot;README.md&quot;</span></span><br><span class="line">packages = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line">build-backend = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br><span class="line"></span><br><span class="line">Do you confirm generation? (<span class="built_in">yes</span>/no) [<span class="built_in">yes</span>]</span><br></pre></td></tr></table></figure><p>中間的「Would you like to define your <strong>main&#x2F;development</strong> dependencies interactively?」兩個問句，我都回答「no」，最後一個則是「yes」。</p><p>初始化後的<code>pyproject.toml</code>內容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">readme</span> = <span class="string">&quot;README.md&quot;</span></span><br><span class="line"><span class="attr">packages</span> = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到其中有一行「<code>readme = &quot;README.md&quot;</code>」，此時專案必須有<code>README.md</code>，否則會找不到檔案。我都直接刪除該行，比較省事。</p><h3 id="使用poetry-new快速初始化"><a href="#使用poetry-new快速初始化" class="headerlink" title="使用poetry new快速初始化"></a>使用<code>poetry new</code>快速初始化</h3><p>要達到專案初始化的效果，你也可以直接用<code>poetry new poetry-demo</code>指令，更快速！不過它也會幫你做「更多事」，細節請參考<a href="https://python-poetry.org/docs/basic-usage/#project-setup">文件</a>。</p><h2 id="二、為專案建立-Python-虛擬環境"><a href="#二、為專案建立-Python-虛擬環境" class="headerlink" title="二、為專案建立 Python 虛擬環境"></a>二、為專案建立 Python 虛擬環境</h2><p>這裡是「重頭戲」之一，但做法上並不是那麼「直觀」，常常容易讓人混淆。僅使用 pyenv 的前提下，再安裝<code>pyenv-virtualenv</code>來建立虛擬環境，確實不難。</p><p>但現在有了 Poetry，兩者的搭配使用方式就很重要，這也是為什麼我一再強調，有了 Poetry，乾脆就不要再裝<code>pyenv-virtualenv</code>了。</p><h3 id="使用-Poetry-建立虛擬環境"><a href="#使用-Poetry-建立虛擬環境" class="headerlink" title="使用 Poetry 建立虛擬環境"></a>使用 Poetry 建立虛擬環境</h3><p>在第一篇文章中，雖然我提過<code>poetry shell</code>有時候可以替代<code>poetry env use</code>，作為快速建立虛擬環境的便捷手段。</p><p>但是，當你還沒有為專案建立虛擬環境，且作業系統中包含了不止一個 Python 版本時，建議就不要用<code>poetry shell</code>來建立虛擬環境——因為它很可能會選擇不是你要的 Python 版本。</p><p>儘管我們使用 pyenv 來管理 Python，但完整的 Linux 發行版往往都自帶了系統的 Python。比如我的 Ubuntu 就自帶了 3.8.x，這正是為何上面<code>pyproject.toml</code>會有一行「<code>python = &quot;^3.8&quot;</code>」而不是<code>^3.10</code>——因為 Poetry 偵測到的是系統預設的 Python，而不是 pyenv 的 Poetry。</p><p>換句話說，無論透過 pyenv 安裝了幾個 Python 版本，<strong>這些資訊對 Poetry 而言，仍可能是陌生的。</strong></p><p>為了讓 Poetry 在建立虛擬環境時，能確實使用<strong>你想要的 Python 版本</strong>，我們必須善用<code>poetry env use</code>指令才行。</p><h2 id="三、確定專案使用的-Python-版本"><a href="#三、確定專案使用的-Python-版本" class="headerlink" title="三、確定專案使用的 Python 版本"></a>三、確定專案使用的 Python 版本</h2><p>第一篇文章中也提到：</p><blockquote><p>我覺得學習 Poetry 的<strong>第一道關卡</strong>，就是它對於<strong>虛擬環境</strong>的管理。</p></blockquote><p>現在看來一點也沒錯！</p><h3 id="指定虛擬環境-Python-版本的標準做法"><a href="#指定虛擬環境-Python-版本的標準做法" class="headerlink" title="指定虛擬環境 Python 版本的標準做法"></a>指定虛擬環境 Python 版本的標準做法</h3><p>在使用 pyenv 的情況下，<a href="https://python-poetry.org/docs/managing-environments/">Poetry 官方文件</a>有補充一個讓你能「確定」虛擬環境會使用的 Python 版本的做法：</p><blockquote><p>If you use a tool like <strong><a href="https://github.com/pyenv/pyenv">pyenv</a></strong> to manage different Python versions, you can set the <strong>experimental</strong> <code>virtualenvs.prefer-active-python</code> option to <code>true</code>. Poetry will then try to find the current <code>python</code> of your shell.</p></blockquote><p>其中的「experimental」表示這是一個實驗性功能。所以我不偏好這個做法。</p><blockquote><p>For instance, if your project requires a newer Python than is available with your system, a standard workflow would be:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.9.8</span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.8  <span class="comment"># Activate Python 3.9 for the current project</span></span><br><span class="line">poetry install</span><br></pre></td></tr></table></figure><p>主要分成兩個步驟：</p><ol><li>將<code>virtualenvs.prefer-active-python</code>設為<code>true</code>。</li><li>使用 pyenv 的<code>pyenv local</code>指令。</li></ol><h3 id="我偏好的做法：poetry-env-use"><a href="#我偏好的做法：poetry-env-use" class="headerlink" title="我偏好的做法：poetry env use"></a>我偏好的做法：<code>poetry env use</code></h3><p>如果你只確定需要「<strong>一個</strong>」Python 版本，且已經將其設定為<code>global</code>，那麼前述的<code>virtualenvs.prefer-active-python</code>設定，或可省略。</p><p><code>poetry env use</code>有下列幾種用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use /full/path/to/python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use python</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use python3.7</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use 3.7</span><br></pre></td></tr></table></figure><p>後三者的<code>python</code>、<code>python3.7</code>或<code>3.7</code>，都和你的<code>PATH</code>有關。</p><p>換句話說，如果你在終端機打<code>python3.7</code>，有成功進入「<a href="https://learn.microsoft.com/zh-tw/visualstudio/python/python-interactive-repl-in-visual-studio?view=vs-2022">Python 互動式視窗</a>」，那就表示這個版本的 Python 確實存在<code>PATH</code>中。</p><h3 id="使用which指令確認-Python-版本是否存在PATH中"><a href="#使用which指令確認-Python-版本是否存在PATH中" class="headerlink" title="使用which指令確認 Python 版本是否存在PATH中"></a>使用<code>which</code>指令確認 Python 版本是否存在<code>PATH</code>中</h3><p>不想進入 REPL，只想確認 Python 版本是否存在<code>PATH</code>中，可以使用<code>which</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">which</span> python3.9</span><br><span class="line">/home/kyo/.pyenv/shims/python3.9</span><br><span class="line">❯ <span class="built_in">which</span> python3.10</span><br><span class="line">/home/kyo/.pyenv/shims/python3.10</span><br><span class="line">❯ <span class="built_in">which</span> python</span><br><span class="line">/home/kyo/.pyenv/shims/python</span><br></pre></td></tr></table></figure><p>聰明的你應該猜到了，我們只要確保 Python 版本已存在於<code>PATH</code>，透過<code>poetry env use &lt;指定的python版本&gt;</code>即可確定專案使用的 Python 版本。</p><p>不過，這個<code>&lt;指定的python版本&gt;</code>必須要先透過 pyenv 安裝好，<strong>而且你通常要將其設定為<code>global</code>或<code>local</code>，系統才找得到。</strong></p><h3 id="poetry-demo-操作"><a href="#poetry-demo-操作" class="headerlink" title="poetry-demo 操作"></a>poetry-demo 操作</h3><p>回到案例，這裡我們已經將 3.10.11 設為<code>global</code>。所以輸入<code>python3.10</code>指令時，會進入互動式視窗。</p><p>此時只要使用下列指令，基本上可以確定使用的 Python 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use 3.10.11</span><br></pre></td></tr></table></figure><p>因為已經有設定<code>global</code>，單純使用<code>poetry env use python</code>應該也是可以成功套用 3.10。但保險起見，使用指令時還是建議輸入<strong>完整的版本號</strong>，包括尾綴的<code>.11</code></p><h2 id="四、不同專案使用不同-Python-版本"><a href="#四、不同專案使用不同-Python-版本" class="headerlink" title="四、不同專案使用不同 Python 版本"></a>四、不同專案使用不同 Python 版本</h2><p>即使有「多專案多 Python 版本」需求，也未必要變更前述的<code>virtualenvs.prefer-active-python</code>設定。</p><p>透過<code>pyenv local</code>+<code>poetry env use</code>，可以為不同專案設定不同的 Python 版本。</p><p>假設你有 a、b、c 三個專案，分別要使用 Python 3.7.11、3.9.12、3.10.11，依照前段介紹，我們可以這麼做。</p><p>首先，<code>pyenv versions</code>確認這三個版本的 Python 都已經由 pyenv 安裝完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ pyenv versions</span><br><span class="line">  system</span><br><span class="line">  3.7.11</span><br><span class="line">  3.9.12</span><br><span class="line">* 3.10.11 (<span class="built_in">set</span> by /home/kyo/.pyenv/version)</span><br></pre></td></tr></table></figure><p>接下來就很簡單了，為各專案設定好<code>pyenv local</code>（好讓<code>PATH</code>可以成功找到對應的 Python 執行檔），然後再<code>poetry env use &lt;指定的python版本&gt;</code>。</p><p>假設 b 專案要使用 3.9.12，則做法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> b</span><br><span class="line">pyenv <span class="built_in">local</span> 3.9.12</span><br><span class="line">poetry <span class="built_in">env</span> use 3.9.12</span><br></pre></td></tr></table></figure><p>其餘專案以此類推。</p><h2 id="五、如何移除-Poetry-虛擬環境？"><a href="#五、如何移除-Poetry-虛擬環境？" class="headerlink" title="五、如何移除 Poetry 虛擬環境？"></a>五、如何移除 Poetry 虛擬環境？</h2><p>參考<a href="https://python-poetry.org/docs/managing-environments/#deleting-the-environments">文件</a>，標準做法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> remove /full/path/to/python</span><br><span class="line">poetry <span class="built_in">env</span> remove python3.7</span><br><span class="line">poetry <span class="built_in">env</span> remove 3.7</span><br><span class="line">poetry <span class="built_in">env</span> remove test-O3eWbxRl-py3.7</span><br></pre></td></tr></table></figure><p>然而，因為我們已經將<code>virtualenvs.in-project</code>改設為<code>true</code>，也就是直接在專案中建立名為<code>.venv</code>的虛擬環境。</p><p>上述的指令基本都沒有作用了。</p><blockquote><p>但我就真的需要砍掉重練啊！怎麼辦？</p></blockquote><h3 id="兩個方法"><a href="#兩個方法" class="headerlink" title="兩個方法"></a>兩個方法</h3><p>此時還有兩個簡單的方法可用。</p><p>方法一，就是直接砍掉<code>.venv</code>，簡單有效！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .venv</span><br></pre></td></tr></table></figure><p>方法二，我們依舊可以使用下列指令，優雅地移除它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry <span class="built_in">env</span> remove --all</span><br><span class="line">Deleted virtualenv: /home/kyo/poetry-demo/.venv</span><br></pre></td></tr></table></figure><hr><p>光專案初始化與虛擬環境管理就用掉了 5 個 h2 標題，可見其複雜。現在，我們進入第二部分——套件的安裝與管理。</p><h2 id="六、安裝套件至-main-dependencies"><a href="#六、安裝套件至-main-dependencies" class="headerlink" title="六、安裝套件至 main dependencies"></a>六、安裝套件至 main dependencies</h2><p>使用<code>poetry add</code>指令。</p><p>參考<a href="https://python-poetry.org/docs/cli/#add">文件</a>，可以發現<code>add</code>指令的用法還挺多元的！</p><p>我覺得對一般使用者而言，<code>poetry add</code>有兩個重點：</p><ol><li>了解<code>poetry add</code>的「多階段行為」。</li><li>了解<code>--group</code>參數用法。</li></ol><h3 id="重點一：poetry-add多階段行為"><a href="#重點一：poetry-add多階段行為" class="headerlink" title="重點一：poetry add多階段行為"></a>重點一：<code>poetry add</code>多階段行為</h3><p>如上篇文章所言，<code>poetry add</code>實際上會做 3 件事，依序為：</p><ol><li>更新<code>pyproject.toml</code>。</li><li>依照<code>pyproject.toml</code>的內容，更新<code>poetry.lock</code>。（相當於<code>poetry lock</code>）</li><li>依照<code>poetry.lock</code>的內容，更新虛擬環境。（相當於<code>poetry install</code>）</li></ol><blockquote><p>為什麼知道這個很重要？</p></blockquote><p>因為當你不是使用<code>poetry add</code>指令，而是直接修改<code>pyproject.toml</code>時，此時上述的第 2、3 步<strong>都不會自動執行</strong>。</p><p>但通常你手動修改 toml 檔最終都是為了變更虛擬環境，所以更新完<code>pyproject.toml</code>後，我們還要再使用<code>poetry lock</code>與<code>poetry install</code>指令才行！</p><p>對於不熟悉上述流程的初學者，很容易遺漏，並感到困惑。</p><h3 id="重點二：-group"><a href="#重點二：-group" class="headerlink" title="重點二：--group"></a>重點二：<code>--group</code></h3><p><strong>舊版</strong>（1.1）只有 main 和 dev 兩種依賴環境設定，<strong>新版</strong>（1.2）增加了<code>--group</code>參數，讓你可以除了 main 和 dev 外，還有能自訂多種 group，增加使用上的彈性。</p><p>比如可以命名不同的群組如下：</p><ul><li>test</li><li>dev</li><li>prod</li></ul><p>基本語法（後續還會提及）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add pytest --group <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>在新版（1.2）的<code>pyproject.toml</code>中會如此記載：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.group.test.dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;^6.0.0&quot;</span></span><br><span class="line"><span class="attr">pytest-mock</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>而舊版則是：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Poetry pre-1.2.x style, understood by Poetry 1.0–1.2</span></span><br><span class="line"><span class="section">[tool.poetry.dev-dependencies]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;^6.0.0&quot;</span></span><br><span class="line"><span class="attr">pytest-mock</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>兩者的<strong>差異</strong>，是版本過渡時要特別注意的。</p><p>雖然彈性變大，但我個人目前還是只有使用 main 和 dev 而已。</p><h3 id="poetry-demo-操作-1"><a href="#poetry-demo-操作-1" class="headerlink" title="poetry-demo 操作"></a>poetry-demo 操作</h3><p>至此，我們也安裝 Django 3.2.x 至 main dependencies 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">❯ poetry add django@^3.2</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (0.5s)</span><br><span class="line"></span><br><span class="line">Package operations: 5 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing typing-extensions (4.6.3)</span><br><span class="line">  • Installing asgiref (3.7.2)</span><br><span class="line">  • Installing pytz (2023.3)</span><br><span class="line">  • Installing sqlparse (0.4.4)</span><br><span class="line">  • Installing django (3.2.19)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br></pre></td></tr></table></figure><p>這個<code>@</code>符號（運算子）要怎麼用，請參考<a href="https://python-poetry.org/docs/dependency-specification/#using-the--operator">文件</a>。</p><h2 id="七、安裝套件至-dev-dependencies"><a href="#七、安裝套件至-dev-dependencies" class="headerlink" title="七、安裝套件至 dev dependencies"></a>七、安裝套件至 dev dependencies</h2><p>上篇文章中，我們已經探討過「<a href="https://blog.kyomind.tw/python-poetry/#%E6%96%B0%E5%A2%9E%E5%A5%97%E4%BB%B6%E8%87%B3-dev-dependencies">明確區分開發環境專用的套件</a>」的重要性。</p><p>舊版的指令是這樣的，以<code>black</code>為例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry add black --dev</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">poetry add black -D</span><br></pre></td></tr></table></figure><p>然而<code>--dev (-D)</code>在新版<a href="https://python-poetry.org/docs/cli/#options-4">已棄用</a>：</p><blockquote><p>• <code>--dev (-D)</code>: Add package as development dependency. (Deprecated, use <code>-G dev</code> instead)</p></blockquote><p>因為加入了 group 機制，新版的指令略有不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry add black --group dev</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">poetry add black -G dev</span><br></pre></td></tr></table></figure><p>講白了就是變囉嗦了一點。</p><p>此時的 toml 檔內容如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;poetry-demo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;kyo &lt;odinxp@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">packages</span> = [&#123;include = <span class="string">&quot;poetry_demo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.8&quot;</span></span><br><span class="line"><span class="attr">django</span> = <span class="string">&quot;^3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.group.dev.dependencies]</span></span><br><span class="line"><span class="attr">black</span> = <span class="string">&quot;^23.3.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">&quot;poetry-core&quot;</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure><h2 id="八、poetry-install-sync"><a href="#八、poetry-install-sync" class="headerlink" title="八、poetry install --sync"></a>八、<code>poetry install --sync</code></h2><p>不久前才發現，虛擬環境用久了，安裝的套件似乎和 lock 檔不完全一致！我一直以為兩者是一定同步的🐸，顯然不是。</p><p>參考<a href="https://python-poetry.org/docs/managing-dependencies/#synchronizing-dependencies">文件</a>，可用下列指令確保同步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry install --<span class="built_in">sync</span></span><br></pre></td></tr></table></figure><h2 id="九、Docker-環境中使用-Poetry"><a href="#九、Docker-環境中使用-Poetry" class="headerlink" title="九、Docker 環境中使用 Poetry"></a>九、Docker 環境中使用 Poetry</h2><p>前文中有<a href="https://blog.kyomind.tw/python-poetry/#%E4%BA%94%E3%80%81%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E4%B8%8D%E5%9C%A8-Docker-%E7%92%B0%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Poetry%EF%BC%9F">這麼一段</a>，闡述我不在 Docker 中使用 Poetry 的<strong>理由</strong>與<strong>替代方案</strong>：</p><blockquote><p>所幸 Poetry 依舊可以輸出<code>requirements.txt</code>，Docker 部署環境就繼續使用這個舊方案即可，而且 Poetry 本來主要就是用於「開發」時的套件管理，對部署差別不大。</p></blockquote><p>說是這樣說，但一年多用下來，我發現這個做法也<strong>不盡理想</strong>，它至少存在兩個問題：</p><ol><li>套件有變動時，常常會<strong>忘記匯出</strong><code>requirements.txt</code>：你可以說這是人的問題，但這個 export <code>requirements.txt</code>做法，就真的很容易讓人忘記。</li><li>由 Poetry 匯出的<code>requirements.txt</code>，不一定能透過 pip 正常安裝套件——兩者存在<strong>輕微的相容性問題</strong>。</li></ol><p>怎麼解？我在原文也已經補充了：</p><blockquote><p>使用 <strong><a href="https://docs.docker.com/build/building/multi-stage/">multi-stage builds</a></strong> 的 Dockerfile，可以在第一階段安裝 Poetry，第二階段再把 Poetry 捨棄，這樣就不會有多餘的耦合與依賴了。日後會專文介紹。</p></blockquote><p>對，所以系列的第三篇會把這部分補完。</p>]]></content>
    
    
    <summary type="html">&lt;!-- ![from Pixabay](https://i.imgur.com/yODxmxJ.jpg) --&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/npnmhFE.jpg&quot; alt=&quot;from Pixabay&quot;&gt;&lt;/p&gt;
&lt;p&gt;〈&lt;a href=&quot;https://blog.kyomind.tw/python-poetry/&quot;&gt;再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;〉發表至今，已過了 1 年多，這意味我也用了一年多的 Poetry。&lt;/p&gt;
&lt;p&gt;感覺如何？——我覺得還不錯！可見不是三分鐘熱度而已。&lt;/p&gt;
&lt;p&gt;對現在的我而言，Poetry 已成為專案開發不可或缺的元素。它不僅提供了更加便捷的專案套件管理和版本控制，同時，Poetry 支援 pyproject.toml 作為設定檔的特性，也使得我更容易使用其他也採用 pyproject.toml 的工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;a href=&quot;https://blog.kyomind.tw/pyproject-toml/&quot;&gt;pyproject.toml 介紹 + VS Code 整合 Black、yapf、isort 教學&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系列：Python-Poetry-三部曲&quot;&gt;&lt;a href=&quot;#系列：Python-Poetry-三部曲&quot; class=&quot;headerlink&quot; title=&quot;系列：Python Poetry 三部曲&quot;&gt;&lt;/a&gt;系列：Python Poetry 三部曲&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.kyomind.tw/python-poetry/&quot;&gt;再見了 pip！最佳 Python 套件管理器——Poetry 完全入門指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Poetry + pyenv 實戰心得：常用指令與注意事項&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;終結 requirements.txt：Dockerfile 多階段建構 Poetry 虛擬環境（待發表）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.kyomind.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="pyproject.toml" scheme="https://blog.kyomind.tw/tags/pyproject-toml/"/>
    
    <category term="Python" scheme="https://blog.kyomind.tw/tags/Python/"/>
    
    <category term="pyenv" scheme="https://blog.kyomind.tw/tags/pyenv/"/>
    
    <category term="Poetry" scheme="https://blog.kyomind.tw/tags/Poetry/"/>
    
    <category term="Docker" scheme="https://blog.kyomind.tw/tags/Docker/"/>
    
    <category term="pip" scheme="https://blog.kyomind.tw/tags/pip/"/>
    
    <category term="virtualenv" scheme="https://blog.kyomind.tw/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>18，論軟體工程師常見的「路徑依賴」問題（上）</title>
    <link href="https://blog.kyomind.tw/weekly-review-18/"/>
    <id>https://blog.kyomind.tw/weekly-review-18/</id>
    <published>2023-05-13T20:01:00.000Z</published>
    <updated>2023-05-23T09:29:13.218Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/sWgUbzT.png"></p><p>我常常覺得，軟體工程師可能是最能體現「<a href="https://zh.wikipedia.org/zh-tw/%E5%B7%A5%E5%85%B7%E8%A7%84%E5%BE%8B">當你手裡只有鎚子，看什麼都會像釘子</a>」的一群人😂</p><p>我們在工作中，有時會陷入一種被稱為「<a href="https://zh.wikipedia.org/zh-tw/%E8%B7%AF%E5%BE%84%E4%BE%9D%E8%B5%96">路徑依賴</a>」的困境。本文將探討「路徑依賴」在軟體工程師的工作與職涯發展中，所造成的各種影響和受困者會有的具體表現。</p><p>或許會讓你感到有點熟悉。</p><h2 id="前言：何謂路徑依賴？"><a href="#前言：何謂路徑依賴？" class="headerlink" title="前言：何謂路徑依賴？"></a>前言：何謂路徑依賴？</h2><p>「<strong>路徑依賴</strong>」是個社會科學的概念，用來描述一種現象，即一旦人們在某一方面選擇了特定的路徑或方式，他們就可能變得<strong>過度依賴這條路徑，並且可能難以改變。</strong></p><p>這種依賴性可能源於各種因素，包括習慣、成本、學習曲線等，並可能在多個層面上產生影響，包括個人的行為、團隊的運作，甚至是整個社會的結構和制度。</p><p>在這裡，我們將專注於討論「<strong>軟體工程師常見的路徑依賴</strong>」。以下的內容主要是基於我個人在工作上的觀察，可能會帶有一點偏見，但絕大部分都是基於事實。</p><span id="more"></span><h2 id="何謂軟體工程師的路徑依賴？"><a href="#何謂軟體工程師的路徑依賴？" class="headerlink" title="何謂軟體工程師的路徑依賴？"></a><strong>何謂軟體工程師的路徑依賴？</strong></h2><p>文章標題與開頭把「路徑依賴」稱為一種「<strong>困境</strong>」，這樣的說法可能<strong>有失公允</strong>。</p><p>事實上，在大部分情況下，遵循既定的路徑可以顯著提高效率、增加確定性，同時也是我們發展專業的基礎。</p><p>所以嚴格來說，本文要討論的，是軟體工程師在工作與職涯中，那些「<strong>造成不良影響</strong>」的路徑依賴。</p><p>這類依賴帶來了<strong>一系列問題</strong>，例如<strong>低效率產出、溝通不順暢，甚至限制了我們的視野</strong>。因此，對於軟體工程師來說，了解這些路徑依賴的存在，確實有其必要。</p><p>接下來，我將從我自己以及我曾接觸和共事過的軟體工程師身上，舉出四個常見的路徑依賴觀察實例。</p><p>而且它們會是「<strong>層層遞進</strong>」的關係，從底層的工作細節，到上層的個人職涯選擇，我們無不受到「<strong>軟體工程師</strong>」這個角色的影響（或說「<strong>限制</strong>」）。</p><p>不過礙於篇幅，我們這期<strong>只先講前兩個</strong>。</p><hr><h2 id="一、程式註解的路徑依賴"><a href="#一、程式註解的路徑依賴" class="headerlink" title="一、程式註解的路徑依賴"></a>一、程式註解的路徑依賴</h2><p>首先，讓我們以「程式註解」為例，看看軟體工程師在<strong>為程式碼寫註解</strong>時，如何表現出「<strong>不良的路徑依賴</strong>」。</p><p>所謂的「<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%BB%E8%A7%A3_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">程式註解</a>」，指的是在程式碼中<strong>以特定格式或符號添加的文字或說明</strong>，用於解釋程式碼的功能、邏輯或用途。</p><p>程式註解是為了提供給開發人員或其他讀者（通常是一起開發的工程師）更容易理解和閱讀本段程式碼的<strong>附加資訊</strong>。它們<strong>不會影響程式的執行</strong>，但對於增進開發上的溝通與協作效率，有著重要地位，尤其是程式中<strong>特別複雜</strong>的部分。</p><p>註解通常使用<strong>自然語言</strong>（例如英文、中文）撰寫，而且要力求<strong>好讀、好理解</strong>。</p><h3 id="「程式晶晶體」註解"><a href="#「程式晶晶體」註解" class="headerlink" title="「程式晶晶體」註解"></a>「程式晶晶體」註解</h3><blockquote><p><a href="https://zh.wikipedia.org/zh-tw/%E6%99%B6%E6%99%B6%E9%AB%94">晶晶體</a>是一種流行於臺灣以中文為基底，夾雜英語不成句的單字或片語的表達方式。</p></blockquote><p>某些人在撰寫註解時，容易過度依賴程式碼的「<strong>實作細節</strong>」表達（比如<code>用 excutemany 大量插入資料至 User Table</code>、<code>以 bulk_create 批次建立 obj</code>），而非使用<strong>簡潔清晰的自然語言</strong>（比如<code>將用戶資料存入資料庫</code>、<code>一次性建立大量用戶資料</code>）。</p><p>在中文夾雜大量的程式碼片語，堪稱「<strong>程式晶晶體</strong>」，語意不清、主詞不明，常常讓人無法一望即知。</p><p>其實也有完全用自然語言書寫的註解，但你讀起來並不覺得那是「<strong>通順</strong>」的句子，比較像 10 歲小學生寫的作文。</p><p>為什麼會這樣？因為開發者普遍「<strong>比較擅長</strong>」寫程式，而非文字表達。所以乾脆用寫程式的思路來寫註解——毫無疑問，這樣真的比較輕鬆。</p><p>這種在思考與陳述上，<strong>嚴重依賴程式碼邏輯</strong>的敘事方式，常常導致註解<strong>難以理解</strong>、重複程式碼的內容（即<strong>冗餘的註解</strong>），甚至可能<strong>產生混淆</strong>。</p><h3 id="從他人角度自我審視：為什麼作者都需要好的編輯？"><a href="#從他人角度自我審視：為什麼作者都需要好的編輯？" class="headerlink" title="從他人角度自我審視：為什麼作者都需要好的編輯？"></a>從他人角度自我審視：為什麼作者都需要好的編輯？</h3><p>你可能會認為：「只要提醒對方注意一下，問題就解決了吧？自己的文字是否易懂，應該很容易看得出來吧！」可惜，事實往往不是如此。</p><p>對於開發程式的「當事人」而言，即使註解中夾雜了大量不必要的程式細節，自己也常常會<strong>深陷其中，難以察覺</strong>，甚至覺得看起來<strong>很合理</strong>！——這就是為什麼作者都需要好的編輯，因為<strong>自身的盲點是很難完全發現並避免的</strong>。</p><p>少部分工程師甚至會覺得「我的程式能跑且執行結果正確」就算稱職了。至於註解有沒有寫、寫得好不好，不能算是評價我工作品質的範圍與指標。</p><p>這想法不能說毫無道理，只不過，寫程式若只顧自己，終究難登大雅之堂。這些程式碼看起來就像是<strong>一個人的自言自語</strong>（只要自己有完成任務就好）——<strong>它並沒有在溝通</strong>。</p><h3 id="註解只是冰山一角"><a href="#註解只是冰山一角" class="headerlink" title="註解只是冰山一角"></a>註解只是冰山一角</h3><p>本段以「程式註解」為例，試圖說明工程師在「撰寫易讀程式碼」的路上常見的路徑依賴（可以說是一種協作上的「阻礙」）。</p><p>然而，這種「<strong>缺乏溝通意識</strong>」所帶來的影響，不僅存在於註解中，<strong>也往往貫穿整個程式寫作過程</strong>。</p><p>這種心態的影響實際上<strong>遠遠超越了程式碼的範疇</strong>，接下來，我們將繼續探討這種心態在「<strong>工作表達方式</strong>」上所展現的路徑依賴特徵。</p><h2 id="二、工作表達方式上的路徑依賴"><a href="#二、工作表達方式上的路徑依賴" class="headerlink" title="二、工作表達方式上的路徑依賴"></a>二、工作表達方式上的路徑依賴</h2><p>看完第一個路徑依賴，我想你已經能猜到，這第二個會是什麼模樣了。</p><p>很多軟體 PM 在會議中常常會覺得，聽不太懂工程師在說些什麼。而我想說的是，你的感覺是對的！其實我也聽不懂。</p><p>既然寫註解、<a href="https://en.wikipedia.org/wiki/Docstring">docstring</a> 這種應該要用「簡潔清晰的自然語言」表達的場合，都容易<strong>藉由程式邏輯與實作細節含混帶過</strong>。那麼軟體工程師在會議中的表達，自然也會受到此「<strong>慣性</strong>」影響。</p><p>以我個人的經驗，工程師在描述自己工作上的要解決的問題、解決方式、可能的方向、已完成的任務等等，非常容易陷入類似的路徑依賴。</p><p>其結果就跟前面提到的程式註解一樣，你不會覺得對方是在講「人話」，而像是一種對技術方案、程式邏輯的「<strong>輪廓描述</strong>」。</p><p>至於所要解決的問題、背後的痛點究竟是什麼？選擇的依據為何？常常會直接予以忽略——因為他們滿腦子都是技術思維。</p><p>導致重點還沒說清楚，相關細節卻講了一堆，本末倒置。</p><h3 id="請說人話"><a href="#請說人話" class="headerlink" title="請說人話"></a>請說人話</h3><p>前面提到，不好的程式註解，就像一個人的自言自語。而這樣的表達方式，又何嘗不是如此？導致我們常常需要提醒對方「等等！我想要先知道的是……」</p><p>不過平心而論，良好的溝通、表達，對任何人都不容易，都需要一定的練習。</p><p>換句話說，要把一件事情講好，絕對需要先構思、自我反芻、察覺他人容易產生的疑問，並且<strong>以他人的角度去思考</strong>，才能真正做到「<strong>說人話</strong>」。</p><p>只不過軟體工程師基於職業上的特性，在感到<strong>表達困難</strong>的當下，<strong>容易反射性地躲回自己熟悉的技術與專業領域，以求得一定的自適與安全感。</strong></p><p>這無疑會讓沒有技術背景的人，感到困惑和隔閡。</p><hr><h2 id="小結：讀者意識的欠缺"><a href="#小結：讀者意識的欠缺" class="headerlink" title="小結：讀者意識的欠缺"></a>小結：讀者意識的欠缺</h2><p>講完前兩項，本篇要收尾了，我們作個小結。</p><p>前兩個路徑依賴凸顯的都是當事人對於「<strong>他人很可能會不理解</strong>」這個意識的強烈欠缺，以至於常常用一種旁人看來近乎「<strong>自言自語</strong>」的方式在表達自我。</p><p>如果是一個作者，那就是「<strong>讀者意識不足</strong>」——寫出來的文章<strong>只有自己看得懂</strong>。</p><blockquote><p>所謂的「<strong>讀者意識</strong>」，指的是作者在寫作時預見到讀者的理解困難，並通過語言表達和組織結構來幫助讀者，使讀者更容易理解的能力。</p></blockquote><p>我很想說「本文只是指出少數軟體工程師在工作上……」，但你我都知道（這裡的「你我」指的是工程師群體），說「少」恐怕是騙人的。</p><p>「<strong>讀者意識的欠缺</strong>」在軟體工程師中確實是一個<strong>普遍存在的問題</strong>。有時候，我們可能過於專注於自己的程式碼和技術細節，而忽略了將這些複雜的概念和思維以易於理解的方式傳達給他人。</p><p>我也不敢說自己已經完全擺脫了上述的困境，在「讓自己與自己的工作產出容易被他人理解」這個面向上，我們還可以不斷努力，一直努力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sWgUbzT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我常常覺得，軟體工程師可能是最能體現「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%B7%A5%E5%85%B7%E8%A7%84%E5%BE%8B&quot;&gt;當你手裡只有鎚子，看什麼都會像釘子&lt;/a&gt;」的一群人😂&lt;/p&gt;
&lt;p&gt;我們在工作中，有時會陷入一種被稱為「&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E8%B7%AF%E5%BE%84%E4%BE%9D%E8%B5%96&quot;&gt;路徑依賴&lt;/a&gt;」的困境。本文將探討「路徑依賴」在軟體工程師的工作與職涯發展中，所造成的各種影響和受困者會有的具體表現。&lt;/p&gt;
&lt;p&gt;或許會讓你感到有點熟悉。&lt;/p&gt;
&lt;h2 id=&quot;前言：何謂路徑依賴？&quot;&gt;&lt;a href=&quot;#前言：何謂路徑依賴？&quot; class=&quot;headerlink&quot; title=&quot;前言：何謂路徑依賴？&quot;&gt;&lt;/a&gt;前言：何謂路徑依賴？&lt;/h2&gt;&lt;p&gt;「&lt;strong&gt;路徑依賴&lt;/strong&gt;」是個社會科學的概念，用來描述一種現象，即一旦人們在某一方面選擇了特定的路徑或方式，他們就可能變得&lt;strong&gt;過度依賴這條路徑，並且可能難以改變。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這種依賴性可能源於各種因素，包括習慣、成本、學習曲線等，並可能在多個層面上產生影響，包括個人的行為、團隊的運作，甚至是整個社會的結構和制度。&lt;/p&gt;
&lt;p&gt;在這裡，我們將專注於討論「&lt;strong&gt;軟體工程師常見的路徑依賴&lt;/strong&gt;」。以下的內容主要是基於我個人在工作上的觀察，可能會帶有一點偏見，但絕大部分都是基於事實。&lt;/p&gt;</summary>
    
    
    
    <category term="Weekly Review" scheme="https://blog.kyomind.tw/categories/Weekly-Review/"/>
    
    
    <category term="軟體工程師" scheme="https://blog.kyomind.tw/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB/"/>
    
  </entry>
  
</feed>
